#!/usr/bin/env python3
"""
Example 19: GitHub Actions Integration (CI/CD)
===============================================

AUDIENCE: DevOps engineers, teams implementing AI-powered CI/CD
VALUE: Shows how to integrate Amplifier into automated workflows
PATTERN: CI/CD automation, code review bots, PR analysis

What this demonstrates:
  - Running Amplifier in GitHub Actions workflows
  - Automated code review and analysis
  - PR comment generation
  - Test failure analysis
  - Release note generation

When you'd use this:
  - Automated code review on PRs
  - Security scanning with AI insights
  - Test failure root cause analysis
  - Automated documentation generation
  - Release management automation
"""

import asyncio
import os
from pathlib import Path
from typing import Any

from amplifier_core import AmplifierSession
from amplifier_foundation import load_bundle

# ============================================================================
# GitHub Actions Helpers
# ============================================================================


def is_github_actions() -> bool:
    """Check if running in GitHub Actions environment."""
    return os.getenv("GITHUB_ACTIONS") == "true"


def get_github_context() -> dict[str, Any]:
    """Get GitHub Actions context information."""
    return {
        "repository": os.getenv("GITHUB_REPOSITORY", "unknown/unknown"),
        "ref": os.getenv("GITHUB_REF", "unknown"),
        "sha": os.getenv("GITHUB_SHA", "unknown"),
        "actor": os.getenv("GITHUB_ACTOR", "unknown"),
        "workflow": os.getenv("GITHUB_WORKFLOW", "unknown"),
        "run_id": os.getenv("GITHUB_RUN_ID", "unknown"),
        "event_name": os.getenv("GITHUB_EVENT_NAME", "unknown"),
    }


def set_output(name: str, value: str):
    """Set GitHub Actions output variable."""
    if is_github_actions():
        print(f"::set-output name={name}::{value}")
    else:
        print(f"OUTPUT: {name}={value}")


def post_pr_comment(comment: str):
    """
    Post comment to PR (simulated).

    In real implementation, use GitHub API or gh CLI.
    """
    if is_github_actions():
        # Write to file that workflow can pick up
        with open("pr_comment.txt", "w") as f:
            f.write(comment)
        print("::notice::PR comment written to pr_comment.txt")
    else:
        print("\n" + "=" * 80)
        print("üìù PR COMMENT")
        print("=" * 80)
        print(comment)


def fail_if_critical_issues(issues: list[dict[str, Any]]):
    """Fail the workflow if critical issues found."""
    critical = [i for i in issues if i.get("severity") == "critical"]
    if critical:
        print(f"::error::Found {len(critical)} critical issues")
        if not is_github_actions():
            print("\n‚ùå CRITICAL ISSUES FOUND - workflow would fail")


# ============================================================================
# CI/CD Workflows
# ============================================================================


async def workflow_code_review():
    """
    Workflow: Automated code review on PR.

    Analyzes changed files and provides feedback.
    """
    print("\n" + "=" * 80)
    print("üîç WORKFLOW: Automated Code Review")
    print("=" * 80)

    # Get GitHub context
    context = get_github_context()
    print(f"\nRepository: {context['repository']}")
    print(f"Event: {context['event_name']}")
    print(f"SHA: {context['sha'][:8]}")

    # Simulate getting PR diff
    pr_files = [
        "src/api/users.py",
        "src/api/auth.py",
        "tests/test_users.py",
    ]

    print(f"\nFiles changed: {len(pr_files)}")
    for f in pr_files:
        print(f"  - {f}")

    # Load Amplifier
    foundation_path = Path(__file__).parent.parent
    foundation = await load_bundle(str(foundation_path))
    mount_plan = foundation.to_mount_plan()

    session = AmplifierSession(config=mount_plan)
    await session.initialize()

    # Generate code review
    prompt = f"""Perform a code review on the following changed files:

Files: {", ".join(pr_files)}

Please review for:
1. Security vulnerabilities
2. Code quality and best practices
3. Test coverage
4. Performance issues
5. Documentation completeness

Provide feedback in this format:
- File: [filename]
- Issue: [description]
- Severity: [critical/high/medium/low]
- Suggestion: [how to fix]

Be concise but thorough."""

    print("\n‚è≥ Generating code review...")

    try:
        review = await session.execute(prompt)

        # Post as PR comment
        comment = f"""## ü§ñ AI Code Review

{review}

---
*Generated by Amplifier in CI/CD workflow*
*Commit: {context["sha"][:8]}*
"""
        post_pr_comment(comment)

        # Set outputs for workflow
        set_output("review_completed", "true")
        set_output("review_length", str(len(review)))

        print("\n‚úÖ Code review completed")

    finally:
        await session.cleanup()


async def workflow_test_failure_analysis():
    """
    Workflow: Analyze test failures and provide insights.

    Helps developers understand why tests failed.
    """
    print("\n" + "=" * 80)
    print("üß™ WORKFLOW: Test Failure Analysis")
    print("=" * 80)

    # Simulate test failure output
    test_failure = """
    FAILED tests/test_users.py::test_create_user - AssertionError:
    Expected user.email to be 'test@example.com' but got None

    Traceback:
      File "tests/test_users.py", line 45, in test_create_user
        assert user.email == 'test@example.com'
    """

    print("\nTest failure detected:")
    print(test_failure)

    # Load Amplifier
    foundation_path = Path(__file__).parent.parent
    foundation = await load_bundle(str(foundation_path))
    mount_plan = foundation.to_mount_plan()

    session = AmplifierSession(config=mount_plan)
    await session.initialize()

    prompt = f"""Analyze this test failure and provide insights:

{test_failure}

Please provide:
1. Root cause analysis
2. Likely code issues that could cause this
3. Suggested fixes
4. Related tests that might also fail

Be specific and actionable."""

    print("\n‚è≥ Analyzing test failure...")

    try:
        analysis = await session.execute(prompt)

        # Post as workflow annotation
        comment = f"""## üî¨ Test Failure Analysis

{analysis}

---
*AI-powered analysis by Amplifier*
"""
        post_pr_comment(comment)

        print("\n‚úÖ Analysis completed")

    finally:
        await session.cleanup()


async def workflow_release_notes():
    """
    Workflow: Generate release notes from commits.

    Creates human-readable release notes from git history.
    """
    print("\n" + "=" * 80)
    print("üìã WORKFLOW: Release Notes Generation")
    print("=" * 80)

    # Simulate commit messages
    commits = [
        "feat: Add user authentication with JWT",
        "fix: Resolve memory leak in session manager",
        "docs: Update API documentation",
        "perf: Optimize database queries for user lookup",
        "test: Add integration tests for auth flow",
    ]

    print(f"\nCommits since last release: {len(commits)}")
    for commit in commits:
        print(f"  - {commit}")

    # Load Amplifier
    foundation_path = Path(__file__).parent.parent
    foundation = await load_bundle(str(foundation_path))
    mount_plan = foundation.to_mount_plan()

    session = AmplifierSession(config=mount_plan)
    await session.initialize()

    prompt = f"""Generate professional release notes from these commits:

{chr(10).join(commits)}

Format as:
## Features
- [user-facing features]

## Bug Fixes
- [user-facing fixes]

## Performance
- [performance improvements]

## Documentation
- [doc updates]

Make it clear, concise, and user-focused."""

    print("\n‚è≥ Generating release notes...")

    try:
        notes = await session.execute(prompt)

        # Save to file for release
        with open("RELEASE_NOTES.md", "w") as f:
            f.write(f"# Release Notes\n\n{notes}\n")

        print("\n‚úÖ Release notes generated")
        print("\n" + "=" * 80)
        print(notes[:500] + "..." if len(notes) > 500 else notes)

        set_output("release_notes_generated", "true")

    finally:
        await session.cleanup()


async def workflow_security_scan():
    """
    Workflow: AI-powered security scanning.

    Analyzes code for security vulnerabilities with AI insights.
    """
    print("\n" + "=" * 80)
    print("üîí WORKFLOW: Security Scanning")
    print("=" * 80)

    # Simulate code snippet
    code_snippet = """
def login(username, password):
    query = f"SELECT * FROM users WHERE username='{username}' AND password='{password}'"
    user = db.execute(query)
    return user
"""

    print("\nScanning code for security issues...")
    print(code_snippet)

    # Load Amplifier
    foundation_path = Path(__file__).parent.parent
    foundation = await load_bundle(str(foundation_path))
    mount_plan = foundation.to_mount_plan()

    session = AmplifierSession(config=mount_plan)
    await session.initialize()

    prompt = f"""Perform a security audit of this code:

{code_snippet}

Identify:
1. Security vulnerabilities (SQL injection, XSS, etc.)
2. Severity level (critical/high/medium/low)
3. Exploit scenarios
4. Recommended fixes with code examples

Be thorough and specific."""

    print("\n‚è≥ Running security scan...")

    try:
        scan_results = await session.execute(prompt)

        # Check for critical issues
        issues = [{"severity": "critical", "type": "SQL Injection"}]  # Simulated

        fail_if_critical_issues(issues)

        # Post results
        comment = f"""## üîí Security Scan Results

{scan_results}

---
*Automated security scan by Amplifier*
"""
        post_pr_comment(comment)

        print("\n‚úÖ Security scan completed")

    finally:
        await session.cleanup()


# ============================================================================
# GitHub Actions Workflow YAML Generator
# ============================================================================


def generate_workflow_yaml():
    """Generate example GitHub Actions workflow YAML."""
    yaml_content = """
name: AI Code Review

on:
  pull_request:
    types: [opened, synchronize]

jobs:
  ai-review:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: |
          pip install amplifier-core amplifier-foundation

      - name: Run AI code review
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
        run: |
          python examples/19_github_actions_ci.py --workflow=code-review

      - name: Post PR comment
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const comment = fs.readFileSync('pr_comment.txt', 'utf8');
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });

  security-scan:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: |
          pip install amplifier-core amplifier-foundation

      - name: Run security scan
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
        run: |
          python examples/19_github_actions_ci.py --workflow=security-scan
"""

    print("\n" + "=" * 80)
    print("üìÑ EXAMPLE GITHUB ACTIONS WORKFLOW")
    print("=" * 80)
    print("\nSave this as .github/workflows/ai-review.yml:")
    print("=" * 80)
    print(yaml_content)

    # Save to file
    output_file = "github_actions_workflow.yml"
    with open(output_file, "w") as f:
        f.write(yaml_content)

    print(f"\nüíæ Workflow saved to: {output_file}")


# ============================================================================
# Interactive Menu
# ============================================================================


async def main():
    """Run interactive demo menu."""
    print("\n" + "=" * 80)
    print("üîÑ GitHub Actions Integration (CI/CD)")
    print("=" * 80)
    print("\nVALUE: Integrate AI-powered automation into your CI/CD pipeline")
    print("AUDIENCE: DevOps engineers, development teams")
    print("\nWhat this demonstrates:")
    print("  - Automated code review on PRs")
    print("  - Test failure analysis")
    print("  - Release note generation")
    print("  - Security scanning")

    workflows = [
        ("Code Review (PR analysis)", workflow_code_review),
        ("Test Failure Analysis", workflow_test_failure_analysis),
        ("Release Notes Generation", workflow_release_notes),
        ("Security Scanning", workflow_security_scan),
    ]

    print("\n" + "=" * 80)
    print("Choose a workflow to simulate:")
    print("=" * 80)
    for i, (name, _) in enumerate(workflows, 1):
        print(f"  {i}. {name}")
    print("  5. Generate GitHub Actions YAML")
    print("  q. Quit")
    print("-" * 80)

    choice = input("\nYour choice: ").strip().lower()

    if choice == "q":
        print("\nüëã Goodbye!")
        return

    if choice == "5":
        generate_workflow_yaml()
        return

    try:
        idx = int(choice) - 1
        if 0 <= idx < len(workflows):
            _, workflow_func = workflows[idx]
            await workflow_func()
        else:
            print("\n‚ùå Invalid choice")
    except ValueError:
        print("\n‚ùå Invalid choice")

    print("\n" + "=" * 80)
    print("üí° KEY TAKEAWAYS")
    print("=" * 80)
    print("""
1. **Automated Intelligence**: AI-powered insights in your CI/CD pipeline
2. **Developer Experience**: Faster feedback, better context for issues
3. **Quality Gates**: AI helps maintain code quality automatically
4. **Cost-Effective**: Run only when needed (PR events, test failures)

**Implementation tips:**
- Use caching to speed up CI runs
- Set appropriate timeouts
- Store API keys in GitHub Secrets
- Use workflow outputs to chain jobs
- Add conditional logic (run only on certain files)

**Common CI/CD patterns:**
- PR review: Run on pull_request events
- Security scan: Run on main branch commits
- Release notes: Run on tag creation
- Test analysis: Run on test failures
- Documentation: Run on docs/ changes

**GitHub Actions workflow structure:**
```yaml
name: AI Workflow
on: [pull_request]
jobs:
  ai-task:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Run AI task
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
        run: python your_script.py
```
""")


if __name__ == "__main__":
    asyncio.run(main())
