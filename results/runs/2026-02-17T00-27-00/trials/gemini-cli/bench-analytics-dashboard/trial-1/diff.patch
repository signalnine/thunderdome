diff --git a/.gemini-output.json b/.gemini-output.json
new file mode 100644
index 0000000..e69de29
diff --git a/.thunderdome-stderr.log b/.thunderdome-stderr.log
new file mode 100644
index 0000000..73e63a5
--- /dev/null
+++ b/.thunderdome-stderr.log
@@ -0,0 +1,36 @@
+YOLO mode is enabled. All tool calls will be automatically approved.
+Loaded cached credentials.
+YOLO mode is enabled. All tool calls will be automatically approved.
+Hook registry initialized with 0 hook entries
+Attempt 1 failed: You have exhausted your capacity on this model. Your quota will reset after 1s.. Retrying after 1078.155674ms...
+Attempt 1 failed: You have exhausted your capacity on this model. Your quota will reset after 2s.. Retrying after 2117.2456620000003ms...
+Attempt 1 failed: You have exhausted your capacity on this model. Your quota will reset after 2s.. Retrying after 2766.402105ms...
+Attempt 1 failed: You have exhausted your capacity on this model. Your quota will reset after 2s.. Retrying after 2020.2920940000001ms...
+Attempt 2 failed: You have exhausted your capacity on this model. Your quota will reset after 2s.. Retrying after 2885.5032920000003ms...
+Attempt 3 failed: You have exhausted your capacity on this model.. Max attempts reached
+Error when talking to Gemini API Full report available at: /tmp/gemini-client-error-Turn.run-sendMessageStream-2026-02-17T00-27-40-160Z.json RetryableQuotaError: You have exhausted your capacity on this model.
+    at classifyGoogleError (file:///usr/local/lib/node_modules/@google/gemini-cli/node_modules/@google/gemini-cli-core/dist/src/utils/googleQuotaErrors.js:211:28)
+    at retryWithBackoff (file:///usr/local/lib/node_modules/@google/gemini-cli/node_modules/@google/gemini-cli-core/dist/src/utils/retry.js:131:37)
+    at process.processTicksAndRejections (node:internal/process/task_queues:95:5)
+    at async GeminiChat.makeApiCallAndProcessStream (file:///usr/local/lib/node_modules/@google/gemini-cli/node_modules/@google/gemini-cli-core/dist/src/core/geminiChat.js:431:32)
+    at async GeminiChat.streamWithRetries (file:///usr/local/lib/node_modules/@google/gemini-cli/node_modules/@google/gemini-cli-core/dist/src/core/geminiChat.js:263:40)
+    at async Turn.run (file:///usr/local/lib/node_modules/@google/gemini-cli/node_modules/@google/gemini-cli-core/dist/src/core/turn.js:66:30)
+    at async GeminiClient.processTurn (file:///usr/local/lib/node_modules/@google/gemini-cli/node_modules/@google/gemini-cli-core/dist/src/core/client.js:459:26)
+    at async GeminiClient.sendMessageStream (file:///usr/local/lib/node_modules/@google/gemini-cli/node_modules/@google/gemini-cli-core/dist/src/core/client.js:559:20)
+    at async file:///usr/local/lib/node_modules/@google/gemini-cli/dist/src/nonInteractiveCli.js:193:34
+    at async main (file:///usr/local/lib/node_modules/@google/gemini-cli/dist/src/gemini.js:492:9) {
+  cause: {
+    code: 429,
+    message: 'You have exhausted your capacity on this model.',
+    details: [ [Object], [Object] ]
+  },
+  retryDelayMs: 10000
+}
+{
+  "session_id": "d9320c1b-970c-45a0-8059-18fed4c6c354",
+  "error": {
+    "type": "Error",
+    "message": "[object Object]",
+    "code": 1
+  }
+}
\ No newline at end of file
diff --git a/src/db.ts b/src/db.ts
new file mode 100644
index 0000000..2a5e1eb
--- /dev/null
+++ b/src/db.ts
@@ -0,0 +1,15 @@
+import Database from 'better-sqlite3';
+import { readFileSync } from 'fs';
+import { join } from 'path';
+
+const db = new Database('analytics.db');
+
+// Enable foreign keys
+db.pragma('foreign_keys = ON');
+
+export function initDb() {
+  const schema = readFileSync(join(process.cwd(), 'schema.sql'), 'utf8');
+  db.exec(schema);
+}
+
+export default db;
diff --git a/src/middleware/auth.ts b/src/middleware/auth.ts
new file mode 100644
index 0000000..c82bc0a
--- /dev/null
+++ b/src/middleware/auth.ts
@@ -0,0 +1,38 @@
+import { Request, Response, NextFunction } from 'express';
+import jwt from 'jsonwebtoken';
+
+export const JWT_SECRET = process.env.JWT_SECRET || 'your-secret-key';
+
+export interface AuthRequest extends Request {
+  user?: {
+    id: string;
+    email: string;
+    tenant_id: string;
+    role: string;
+  };
+}
+
+export const authenticate = (req: AuthRequest, res: Response, next: NextFunction) => {
+  const authHeader = req.headers.authorization;
+  if (!authHeader || !authHeader.startsWith('Bearer ')) {
+    return res.status(401).json({ error: 'Unauthorized' });
+  }
+
+  const token = authHeader.split(' ')[1];
+  try {
+    const decoded = jwt.verify(token, JWT_SECRET) as any;
+    req.user = decoded;
+    next();
+  } catch (err) {
+    return res.status(401).json({ error: 'Unauthorized' });
+  }
+};
+
+export const authorize = (roles: string[]) => {
+  return (req: AuthRequest, res: Response, next: NextFunction) => {
+    if (!req.user || !roles.includes(req.user.role)) {
+      return res.status(403).json({ error: 'Forbidden' });
+    }
+    next();
+  };
+};
diff --git a/src/routes/auth.ts b/src/routes/auth.ts
new file mode 100644
index 0000000..8f9cbd2
--- /dev/null
+++ b/src/routes/auth.ts
@@ -0,0 +1,81 @@
+import { Router, Response } from 'express';
+import { v4 as uuidv4 } from 'uuid';
+import jwt from 'jsonwebtoken';
+import crypto from 'crypto';
+import db from '../db.js';
+import { JWT_SECRET, AuthRequest, authenticate, authorize } from '../middleware/auth.js';
+
+const router = Router();
+
+function hashPassword(password: string) {
+  return crypto.scryptSync(password, 'salt', 64).toString('hex');
+}
+
+router.post('/register', (req, res) => {
+  const { email, password, tenant_id, role } = req.body;
+  if (!email || !password) {
+    return res.status(400).json({ error: 'Email and password required' });
+  }
+
+  const id = uuidv4();
+  const tenantId = tenant_id || uuidv4();
+  const userRole = role || 'admin'; // Default to admin for first user of tenant maybe? Requirement says "different roles"
+  const passwordHash = hashPassword(password);
+
+  try {
+    const stmt = db.prepare('INSERT INTO users (id, email, password_hash, tenant_id, role) VALUES (?, ?, ?, ?, ?)');
+    stmt.run(id, email, passwordHash, tenantId, userRole);
+    res.status(201).json({ id, email, tenant_id: tenantId, role: userRole });
+  } catch (err: any) {
+    if (err.code === 'SQLITE_CONSTRAINT_UNIQUE') {
+      return res.status(400).json({ error: 'Email already exists' });
+    }
+    res.status(500).json({ error: 'Internal server error' });
+  }
+});
+
+router.post('/login', (req, res) => {
+  const { email, password } = req.body;
+  if (!email || !password) {
+    return res.status(400).json({ error: 'Email and password required' });
+  }
+
+  const user = db.prepare('SELECT * FROM users WHERE email = ?').get(email) as any;
+  if (!user || user.password_hash !== hashPassword(password)) {
+    return res.status(401).json({ error: 'Invalid credentials' });
+  }
+
+  const token = jwt.sign(
+    { id: user.id, email: user.email, tenant_id: user.tenant_id, role: user.role },
+    JWT_SECRET,
+    { expiresIn: '24h' }
+  );
+
+  res.json({ token });
+});
+
+router.get('/me', authenticate, (req: AuthRequest, res: Response) => {
+  res.json(req.user);
+});
+
+router.patch('/users/:id/role', authenticate, authorize(['admin']), (req: AuthRequest, res: Response) => {
+  const { id } = req.params;
+  const { role } = req.body;
+
+  if (!['admin', 'editor', 'viewer'].includes(role)) {
+    return res.status(400).json({ error: 'Invalid role' });
+  }
+
+  try {
+    const stmt = db.prepare('UPDATE users SET role = ? WHERE id = ? AND tenant_id = ?');
+    const result = stmt.run(role, id, req.user!.tenant_id);
+    if (result.changes === 0) {
+      return res.status(404).json({ error: 'User not found in your tenant' });
+    }
+    res.json({ message: 'Role updated successfully' });
+  } catch (err) {
+    res.status(500).json({ error: 'Internal server error' });
+  }
+});
+
+export default router;
