diff --git a/.thunderdome-metrics.json b/.thunderdome-metrics.json
new file mode 100644
index 0000000..f0761b3
--- /dev/null
+++ b/.thunderdome-metrics.json
@@ -0,0 +1,11 @@
+{
+  "input_tokens": 0,
+  "output_tokens": 0,
+  "cache_read_tokens": 0,
+  "cache_creation_tokens": 0,
+  "turns": 0,
+  "tools_used": [],
+  "duration_ms": 0,
+  "total_cost_usd": 0,
+  "note": "interactive-mode-metrics-approximate"
+}
\ No newline at end of file
diff --git a/package-lock.json b/package-lock.json
index 16cc798..53f6fc4 100644
--- a/package-lock.json
+++ b/package-lock.json
@@ -22,12 +22,84 @@
         "@types/uuid": "^10.0.0",
         "@typescript-eslint/eslint-plugin": "^7.0.0",
         "@typescript-eslint/parser": "^7.0.0",
+        "@vitest/coverage-v8": "^2.0.0",
         "eslint": "^8.56.0",
         "supertest": "^7.0.0",
         "typescript": "^5.4.0",
         "vitest": "^2.0.0"
       }
     },
+    "node_modules/@ampproject/remapping": {
+      "version": "2.3.0",
+      "resolved": "https://registry.npmjs.org/@ampproject/remapping/-/remapping-2.3.0.tgz",
+      "integrity": "sha512-30iZtAPgz+LTIYoeivqYo853f02jBYSd5uGnGpkFV0M3xOt9aN73erkgYAmZU43x4VfqcnLxW9Kpg3R5LC4YYw==",
+      "dev": true,
+      "license": "Apache-2.0",
+      "dependencies": {
+        "@jridgewell/gen-mapping": "^0.3.5",
+        "@jridgewell/trace-mapping": "^0.3.24"
+      },
+      "engines": {
+        "node": ">=6.0.0"
+      }
+    },
+    "node_modules/@babel/helper-string-parser": {
+      "version": "7.27.1",
+      "resolved": "https://registry.npmjs.org/@babel/helper-string-parser/-/helper-string-parser-7.27.1.tgz",
+      "integrity": "sha512-qMlSxKbpRlAridDExk92nSobyDdpPijUq2DW6oDnUqd0iOGxmQjyqhMIihI9+zv4LPyZdRje2cavWPbCbWm3eA==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=6.9.0"
+      }
+    },
+    "node_modules/@babel/helper-validator-identifier": {
+      "version": "7.28.5",
+      "resolved": "https://registry.npmjs.org/@babel/helper-validator-identifier/-/helper-validator-identifier-7.28.5.tgz",
+      "integrity": "sha512-qSs4ifwzKJSV39ucNjsvc6WVHs6b7S03sOh2OcHF9UHfVPqWWALUsNUVzhSBiItjRZoLHx7nIarVjqKVusUZ1Q==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=6.9.0"
+      }
+    },
+    "node_modules/@babel/parser": {
+      "version": "7.29.0",
+      "resolved": "https://registry.npmjs.org/@babel/parser/-/parser-7.29.0.tgz",
+      "integrity": "sha512-IyDgFV5GeDUVX4YdF/3CPULtVGSXXMLh1xVIgdCgxApktqnQV0r7/8Nqthg+8YLGaAtdyIlo2qIdZrbCv4+7ww==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@babel/types": "^7.29.0"
+      },
+      "bin": {
+        "parser": "bin/babel-parser.js"
+      },
+      "engines": {
+        "node": ">=6.0.0"
+      }
+    },
+    "node_modules/@babel/types": {
+      "version": "7.29.0",
+      "resolved": "https://registry.npmjs.org/@babel/types/-/types-7.29.0.tgz",
+      "integrity": "sha512-LwdZHpScM4Qz8Xw2iKSzS+cfglZzJGvofQICy7W7v4caru4EaAmyUuO6BGrbyQ2mYV11W0U8j5mBhd14dd3B0A==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@babel/helper-string-parser": "^7.27.1",
+        "@babel/helper-validator-identifier": "^7.28.5"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      }
+    },
+    "node_modules/@bcoe/v8-coverage": {
+      "version": "0.2.3",
+      "resolved": "https://registry.npmjs.org/@bcoe/v8-coverage/-/v8-coverage-0.2.3.tgz",
+      "integrity": "sha512-0hYQ8SB4Db5zvZB4axdMHGwEaQjkZzFjQiN9LVYvIFB2nSUHW9tYpxWriPrWDASIxiaXax83REcLxuSdnGPZtw==",
+      "dev": true,
+      "license": "MIT"
+    },
     "node_modules/@esbuild/aix-ppc64": {
       "version": "0.21.5",
       "resolved": "https://registry.npmjs.org/@esbuild/aix-ppc64/-/aix-ppc64-0.21.5.tgz",
@@ -568,6 +640,84 @@
       "dev": true,
       "license": "BSD-3-Clause"
     },
+    "node_modules/@isaacs/cliui": {
+      "version": "8.0.2",
+      "resolved": "https://registry.npmjs.org/@isaacs/cliui/-/cliui-8.0.2.tgz",
+      "integrity": "sha512-O8jcjabXaleOG9DQ0+ARXWZBTfnP4WNAqzuiJK7ll44AmxGKv/J2M4TPjxjY3znBCfvBXFzucm1twdyFybFqEA==",
+      "dev": true,
+      "license": "ISC",
+      "dependencies": {
+        "string-width": "^5.1.2",
+        "string-width-cjs": "npm:string-width@^4.2.0",
+        "strip-ansi": "^7.0.1",
+        "strip-ansi-cjs": "npm:strip-ansi@^6.0.1",
+        "wrap-ansi": "^8.1.0",
+        "wrap-ansi-cjs": "npm:wrap-ansi@^7.0.0"
+      },
+      "engines": {
+        "node": ">=12"
+      }
+    },
+    "node_modules/@isaacs/cliui/node_modules/ansi-regex": {
+      "version": "6.2.2",
+      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-6.2.2.tgz",
+      "integrity": "sha512-Bq3SmSpyFHaWjPk8If9yc6svM8c56dB5BAtW4Qbw5jHTwwXXcTLoRMkpDJp6VL0XzlWaCHTXrkFURMYmD0sLqg==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/ansi-regex?sponsor=1"
+      }
+    },
+    "node_modules/@isaacs/cliui/node_modules/strip-ansi": {
+      "version": "7.1.2",
+      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-7.1.2.tgz",
+      "integrity": "sha512-gmBGslpoQJtgnMAvOVqGZpEz9dyoKTCzy2nfz/n8aIFhN/jCE/rCmcxabB6jOOHV+0WNnylOxaxBQPSvcWklhA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "ansi-regex": "^6.0.1"
+      },
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/strip-ansi?sponsor=1"
+      }
+    },
+    "node_modules/@istanbuljs/schema": {
+      "version": "0.1.3",
+      "resolved": "https://registry.npmjs.org/@istanbuljs/schema/-/schema-0.1.3.tgz",
+      "integrity": "sha512-ZXRY4jNvVgSVQ8DL3LTcakaAtXwTVUxE81hslsyD2AtoXW/wVob10HkOJ1X/pAlcI7D+2YoZKg5do8G/w6RYgA==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/@jridgewell/gen-mapping": {
+      "version": "0.3.13",
+      "resolved": "https://registry.npmjs.org/@jridgewell/gen-mapping/-/gen-mapping-0.3.13.tgz",
+      "integrity": "sha512-2kkt/7niJ6MgEPxF0bYdQ6etZaA+fQvDcLKckhy1yIQOzaoKjBBjSj63/aLVjYE3qhRt5dvM+uUyfCg6UKCBbA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@jridgewell/sourcemap-codec": "^1.5.0",
+        "@jridgewell/trace-mapping": "^0.3.24"
+      }
+    },
+    "node_modules/@jridgewell/resolve-uri": {
+      "version": "3.1.2",
+      "resolved": "https://registry.npmjs.org/@jridgewell/resolve-uri/-/resolve-uri-3.1.2.tgz",
+      "integrity": "sha512-bRISgCIjP20/tbWSPWMEi54QVPRZExkuD9lJL+UIxUKtwVJA8wW1Trb1jMs1RFXo1CBTNZ/5hpC9QvmKWdopKw==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=6.0.0"
+      }
+    },
     "node_modules/@jridgewell/sourcemap-codec": {
       "version": "1.5.5",
       "resolved": "https://registry.npmjs.org/@jridgewell/sourcemap-codec/-/sourcemap-codec-1.5.5.tgz",
@@ -575,6 +725,17 @@
       "dev": true,
       "license": "MIT"
     },
+    "node_modules/@jridgewell/trace-mapping": {
+      "version": "0.3.31",
+      "resolved": "https://registry.npmjs.org/@jridgewell/trace-mapping/-/trace-mapping-0.3.31.tgz",
+      "integrity": "sha512-zzNR+SdQSDJzc8joaeP8QQoCQr8NuYx2dIIytl1QeBEZHJ9uW6hebsrYgbz8hJwUQao3TWCMtmfV8Nu1twOLAw==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@jridgewell/resolve-uri": "^3.1.0",
+        "@jridgewell/sourcemap-codec": "^1.4.14"
+      }
+    },
     "node_modules/@noble/hashes": {
       "version": "1.8.0",
       "resolved": "https://registry.npmjs.org/@noble/hashes/-/hashes-1.8.0.tgz",
@@ -636,6 +797,17 @@
         "@noble/hashes": "^1.1.5"
       }
     },
+    "node_modules/@pkgjs/parseargs": {
+      "version": "0.11.0",
+      "resolved": "https://registry.npmjs.org/@pkgjs/parseargs/-/parseargs-0.11.0.tgz",
+      "integrity": "sha512-+1VkjdD0QBLPodGrJUeqarH8VAIvQODIbwh9XpP5Syisf7YoQgsJKPNFoqqLQlu+VQ/tVSshMR6loPMn8U+dPg==",
+      "dev": true,
+      "license": "MIT",
+      "optional": true,
+      "engines": {
+        "node": ">=14"
+      }
+    },
     "node_modules/@rollup/rollup-android-arm-eabi": {
       "version": "4.57.1",
       "resolved": "https://registry.npmjs.org/@rollup/rollup-android-arm-eabi/-/rollup-android-arm-eabi-4.57.1.tgz",
@@ -1102,7 +1274,6 @@
       "integrity": "sha512-m0jEgYlYz+mDJZ2+F4v8D1AyQb+QzsNqRuI7xg1VQX/KlKS0qT9r1Mo16yo5F/MtifXFgaofIFsdFMox2SxIbQ==",
       "dev": true,
       "license": "MIT",
-      "peer": true,
       "dependencies": {
         "undici-types": "~7.16.0"
       }
@@ -1225,7 +1396,6 @@
       "integrity": "sha512-4Z+L8I2OqhZV8qA132M4wNL30ypZGYOQVBfMgxDH/K5UX0PNqTu1c6za9ST5r9+tavvHiTWmBnKzpCJ/GlVFtg==",
       "dev": true,
       "license": "BSD-2-Clause",
-      "peer": true,
       "dependencies": {
         "@typescript-eslint/scope-manager": "7.18.0",
         "@typescript-eslint/types": "7.18.0",
@@ -1386,6 +1556,39 @@
       "dev": true,
       "license": "ISC"
     },
+    "node_modules/@vitest/coverage-v8": {
+      "version": "2.1.9",
+      "resolved": "https://registry.npmjs.org/@vitest/coverage-v8/-/coverage-v8-2.1.9.tgz",
+      "integrity": "sha512-Z2cOr0ksM00MpEfyVE8KXIYPEcBFxdbLSs56L8PO0QQMxt/6bDj45uQfxoc96v05KW3clk7vvgP0qfDit9DmfQ==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@ampproject/remapping": "^2.3.0",
+        "@bcoe/v8-coverage": "^0.2.3",
+        "debug": "^4.3.7",
+        "istanbul-lib-coverage": "^3.2.2",
+        "istanbul-lib-report": "^3.0.1",
+        "istanbul-lib-source-maps": "^5.0.6",
+        "istanbul-reports": "^3.1.7",
+        "magic-string": "^0.30.12",
+        "magicast": "^0.3.5",
+        "std-env": "^3.8.0",
+        "test-exclude": "^7.0.1",
+        "tinyrainbow": "^1.2.0"
+      },
+      "funding": {
+        "url": "https://opencollective.com/vitest"
+      },
+      "peerDependencies": {
+        "@vitest/browser": "2.1.9",
+        "vitest": "2.1.9"
+      },
+      "peerDependenciesMeta": {
+        "@vitest/browser": {
+          "optional": true
+        }
+      }
+    },
     "node_modules/@vitest/expect": {
       "version": "2.1.9",
       "resolved": "https://registry.npmjs.org/@vitest/expect/-/expect-2.1.9.tgz",
@@ -1518,7 +1721,6 @@
       "integrity": "sha512-NZyJarBfL7nWwIq+FDL6Zp/yHEhePMNnnJ0y3qfieCrmNvYct8uvtiV41UvlSe6apAfk0fY1FbWx+NwfmpvtTg==",
       "dev": true,
       "license": "MIT",
-      "peer": true,
       "bin": {
         "acorn": "bin/acorn"
       },
@@ -2140,6 +2342,13 @@
         "node": ">= 0.4"
       }
     },
+    "node_modules/eastasianwidth": {
+      "version": "0.2.0",
+      "resolved": "https://registry.npmjs.org/eastasianwidth/-/eastasianwidth-0.2.0.tgz",
+      "integrity": "sha512-I88TYZWc9XiYHRQ4/3c5rjjfgkjhLyW2luGIheGERbNQ6OY7yTybanSpDXZa8y7VUP9YmDcYa+eyq4ca7iLqWA==",
+      "dev": true,
+      "license": "MIT"
+    },
     "node_modules/ecdsa-sig-formatter": {
       "version": "1.0.11",
       "resolved": "https://registry.npmjs.org/ecdsa-sig-formatter/-/ecdsa-sig-formatter-1.0.11.tgz",
@@ -2155,6 +2364,13 @@
       "integrity": "sha512-WMwm9LhRUo+WUaRN+vRuETqG89IgZphVSNkdFgeb6sS/E4OrDIN7t48CAewSHXc6C8lefD8KKfr5vY61brQlow==",
       "license": "MIT"
     },
+    "node_modules/emoji-regex": {
+      "version": "9.2.2",
+      "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-9.2.2.tgz",
+      "integrity": "sha512-L18DaJsXSUk2+42pv8mLs5jJT2hqFkFE4j21wOmgbUqsZ2hL72NsUU785g9RXgo3s0ZNgVl42TiHp3ZtOv/Vyg==",
+      "dev": true,
+      "license": "MIT"
+    },
     "node_modules/encodeurl": {
       "version": "2.0.0",
       "resolved": "https://registry.npmjs.org/encodeurl/-/encodeurl-2.0.0.tgz",
@@ -2291,7 +2507,6 @@
       "deprecated": "This version is no longer supported. Please see https://eslint.org/version-support for other options.",
       "dev": true,
       "license": "MIT",
-      "peer": true,
       "dependencies": {
         "@eslint-community/eslint-utils": "^4.2.0",
         "@eslint-community/regexpp": "^4.6.1",
@@ -2731,6 +2946,23 @@
       "dev": true,
       "license": "ISC"
     },
+    "node_modules/foreground-child": {
+      "version": "3.3.1",
+      "resolved": "https://registry.npmjs.org/foreground-child/-/foreground-child-3.3.1.tgz",
+      "integrity": "sha512-gIXjKqtFuWEgzFRJA9WCQeSJLZDjgJUOMCMzxtvFq/37KojM1BFGufqsCy0r4qSQmYLsZYMeyRqzIWOMup03sw==",
+      "dev": true,
+      "license": "ISC",
+      "dependencies": {
+        "cross-spawn": "^7.0.6",
+        "signal-exit": "^4.0.1"
+      },
+      "engines": {
+        "node": ">=14"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/isaacs"
+      }
+    },
     "node_modules/form-data": {
       "version": "4.0.5",
       "resolved": "https://registry.npmjs.org/form-data/-/form-data-4.0.5.tgz",
@@ -3029,6 +3261,13 @@
         "node": ">= 0.4"
       }
     },
+    "node_modules/html-escaper": {
+      "version": "2.0.2",
+      "resolved": "https://registry.npmjs.org/html-escaper/-/html-escaper-2.0.2.tgz",
+      "integrity": "sha512-H2iMtd0I4Mt5eYiapRdIDjp+XzelXQ0tFE4JS7YFwFevXXMmOp9myNrUvCg0D6ws8iqkRPBfKHgbwig1SmlLfg==",
+      "dev": true,
+      "license": "MIT"
+    },
     "node_modules/http-errors": {
       "version": "2.0.1",
       "resolved": "https://registry.npmjs.org/http-errors/-/http-errors-2.0.1.tgz",
@@ -3161,6 +3400,16 @@
         "node": ">=0.10.0"
       }
     },
+    "node_modules/is-fullwidth-code-point": {
+      "version": "3.0.0",
+      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/is-fullwidth-code-point-3.0.0.tgz",
+      "integrity": "sha512-zymm5+u+sCsSWyD9qNaejV3DFvhCKclKdizYaJUuHA83RLjb7nSuGnddCHGv0hk+KY7BMAlsWeK4Ueg6EV6XQg==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=8"
+      }
+    },
     "node_modules/is-glob": {
       "version": "4.0.3",
       "resolved": "https://registry.npmjs.org/is-glob/-/is-glob-4.0.3.tgz",
@@ -3201,6 +3450,76 @@
       "dev": true,
       "license": "ISC"
     },
+    "node_modules/istanbul-lib-coverage": {
+      "version": "3.2.2",
+      "resolved": "https://registry.npmjs.org/istanbul-lib-coverage/-/istanbul-lib-coverage-3.2.2.tgz",
+      "integrity": "sha512-O8dpsF+r0WV/8MNRKfnmrtCWhuKjxrq2w+jpzBL5UZKTi2LeVWnWOmWRxFlesJONmc+wLAGvKQZEOanko0LFTg==",
+      "dev": true,
+      "license": "BSD-3-Clause",
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/istanbul-lib-report": {
+      "version": "3.0.1",
+      "resolved": "https://registry.npmjs.org/istanbul-lib-report/-/istanbul-lib-report-3.0.1.tgz",
+      "integrity": "sha512-GCfE1mtsHGOELCU8e/Z7YWzpmybrx/+dSTfLrvY8qRmaY6zXTKWn6WQIjaAFw069icm6GVMNkgu0NzI4iPZUNw==",
+      "dev": true,
+      "license": "BSD-3-Clause",
+      "dependencies": {
+        "istanbul-lib-coverage": "^3.0.0",
+        "make-dir": "^4.0.0",
+        "supports-color": "^7.1.0"
+      },
+      "engines": {
+        "node": ">=10"
+      }
+    },
+    "node_modules/istanbul-lib-source-maps": {
+      "version": "5.0.6",
+      "resolved": "https://registry.npmjs.org/istanbul-lib-source-maps/-/istanbul-lib-source-maps-5.0.6.tgz",
+      "integrity": "sha512-yg2d+Em4KizZC5niWhQaIomgf5WlL4vOOjZ5xGCmF8SnPE/mDWWXgvRExdcpCgh9lLRRa1/fSYp2ymmbJ1pI+A==",
+      "dev": true,
+      "license": "BSD-3-Clause",
+      "dependencies": {
+        "@jridgewell/trace-mapping": "^0.3.23",
+        "debug": "^4.1.1",
+        "istanbul-lib-coverage": "^3.0.0"
+      },
+      "engines": {
+        "node": ">=10"
+      }
+    },
+    "node_modules/istanbul-reports": {
+      "version": "3.2.0",
+      "resolved": "https://registry.npmjs.org/istanbul-reports/-/istanbul-reports-3.2.0.tgz",
+      "integrity": "sha512-HGYWWS/ehqTV3xN10i23tkPkpH46MLCIMFNCaaKNavAXTF1RkqxawEPtnjnGZ6XKSInBKkiOA5BKS+aZiY3AvA==",
+      "dev": true,
+      "license": "BSD-3-Clause",
+      "dependencies": {
+        "html-escaper": "^2.0.0",
+        "istanbul-lib-report": "^3.0.0"
+      },
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/jackspeak": {
+      "version": "3.4.3",
+      "resolved": "https://registry.npmjs.org/jackspeak/-/jackspeak-3.4.3.tgz",
+      "integrity": "sha512-OGlZQpz2yfahA/Rd1Y8Cd9SIEsqvXkLVoSw/cgwhnhFMDbsQFeZYoJJ7bIZBS9BcamUW96asq/npPWugM+RQBw==",
+      "dev": true,
+      "license": "BlueOak-1.0.0",
+      "dependencies": {
+        "@isaacs/cliui": "^8.0.2"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/isaacs"
+      },
+      "optionalDependencies": {
+        "@pkgjs/parseargs": "^0.11.0"
+      }
+    },
     "node_modules/js-yaml": {
       "version": "4.1.1",
       "resolved": "https://registry.npmjs.org/js-yaml/-/js-yaml-4.1.1.tgz",
@@ -3374,6 +3693,13 @@
       "dev": true,
       "license": "MIT"
     },
+    "node_modules/lru-cache": {
+      "version": "10.4.3",
+      "resolved": "https://registry.npmjs.org/lru-cache/-/lru-cache-10.4.3.tgz",
+      "integrity": "sha512-JNAzZcXrCt42VGLuYz0zfAzDfAvJWW6AfYlDBQyDV5DClI2m5sAmK+OIO7s59XfsRsWHp02jAJrRadPRGTt6SQ==",
+      "dev": true,
+      "license": "ISC"
+    },
     "node_modules/magic-string": {
       "version": "0.30.21",
       "resolved": "https://registry.npmjs.org/magic-string/-/magic-string-0.30.21.tgz",
@@ -3384,6 +3710,34 @@
         "@jridgewell/sourcemap-codec": "^1.5.5"
       }
     },
+    "node_modules/magicast": {
+      "version": "0.3.5",
+      "resolved": "https://registry.npmjs.org/magicast/-/magicast-0.3.5.tgz",
+      "integrity": "sha512-L0WhttDl+2BOsybvEOLK7fW3UA0OQ0IQ2d6Zl2x/a6vVRs3bAY0ECOSHHeL5jD+SbOpOCUEi0y1DgHEn9Qn1AQ==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@babel/parser": "^7.25.4",
+        "@babel/types": "^7.25.4",
+        "source-map-js": "^1.2.0"
+      }
+    },
+    "node_modules/make-dir": {
+      "version": "4.0.0",
+      "resolved": "https://registry.npmjs.org/make-dir/-/make-dir-4.0.0.tgz",
+      "integrity": "sha512-hXdUTZYIVOt1Ex//jAQi+wTZZpUpwBj/0QsOzqegb3rGMMeJiSEu5xLHnYfBrRV4RH2+OCSOO95Is/7x1WJ4bw==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "semver": "^7.5.3"
+      },
+      "engines": {
+        "node": ">=10"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/sindresorhus"
+      }
+    },
     "node_modules/math-intrinsics": {
       "version": "1.1.0",
       "resolved": "https://registry.npmjs.org/math-intrinsics/-/math-intrinsics-1.1.0.tgz",
@@ -3514,6 +3868,16 @@
         "url": "https://github.com/sponsors/ljharb"
       }
     },
+    "node_modules/minipass": {
+      "version": "7.1.2",
+      "resolved": "https://registry.npmjs.org/minipass/-/minipass-7.1.2.tgz",
+      "integrity": "sha512-qOOzS1cBTWYF4BH8fVePDBOO9iptMnGUEZwNc/cMWnTV2nVLZ7VoNWEPHkYczZA0pdoA7dl6e7FL659nX9S2aw==",
+      "dev": true,
+      "license": "ISC",
+      "engines": {
+        "node": ">=16 || 14 >=14.17"
+      }
+    },
     "node_modules/mkdirp-classic": {
       "version": "0.5.3",
       "resolved": "https://registry.npmjs.org/mkdirp-classic/-/mkdirp-classic-0.5.3.tgz",
@@ -3662,6 +4026,13 @@
         "url": "https://github.com/sponsors/sindresorhus"
       }
     },
+    "node_modules/package-json-from-dist": {
+      "version": "1.0.1",
+      "resolved": "https://registry.npmjs.org/package-json-from-dist/-/package-json-from-dist-1.0.1.tgz",
+      "integrity": "sha512-UEZIS3/by4OC8vL3P2dTXRETpebLI2NiI5vIrjaD/5UtrkFX/tNbwjTSRAGC/+7CAo2pIcBaRgWmcBBHcsaCIw==",
+      "dev": true,
+      "license": "BlueOak-1.0.0"
+    },
     "node_modules/parent-module": {
       "version": "1.0.1",
       "resolved": "https://registry.npmjs.org/parent-module/-/parent-module-1.0.1.tgz",
@@ -3714,6 +4085,23 @@
         "node": ">=8"
       }
     },
+    "node_modules/path-scurry": {
+      "version": "1.11.1",
+      "resolved": "https://registry.npmjs.org/path-scurry/-/path-scurry-1.11.1.tgz",
+      "integrity": "sha512-Xa4Nw17FS9ApQFJ9umLiJS4orGjm7ZzwUrwamcGQuHSzDyth9boKDaycYdDcZDuqYATXw4HFXgaqWTctW/v1HA==",
+      "dev": true,
+      "license": "BlueOak-1.0.0",
+      "dependencies": {
+        "lru-cache": "^10.2.0",
+        "minipass": "^5.0.0 || ^6.0.2 || ^7.0.0"
+      },
+      "engines": {
+        "node": ">=16 || 14 >=14.18"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/isaacs"
+      }
+    },
     "node_modules/path-to-regexp": {
       "version": "0.1.12",
       "resolved": "https://registry.npmjs.org/path-to-regexp/-/path-to-regexp-0.1.12.tgz",
@@ -4270,6 +4658,19 @@
       "dev": true,
       "license": "ISC"
     },
+    "node_modules/signal-exit": {
+      "version": "4.1.0",
+      "resolved": "https://registry.npmjs.org/signal-exit/-/signal-exit-4.1.0.tgz",
+      "integrity": "sha512-bzyZ1e88w9O1iNJbKnOlvYTrWPDl46O1bG0D3XInv+9tkPrxrN8jUUTiFlDkkmKWgn1M6CfIA13SuGqOa9Korw==",
+      "dev": true,
+      "license": "ISC",
+      "engines": {
+        "node": ">=14"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/isaacs"
+      }
+    },
     "node_modules/simple-concat": {
       "version": "1.0.1",
       "resolved": "https://registry.npmjs.org/simple-concat/-/simple-concat-1.0.1.tgz",
@@ -4367,6 +4768,76 @@
         "safe-buffer": "~5.2.0"
       }
     },
+    "node_modules/string-width": {
+      "version": "5.1.2",
+      "resolved": "https://registry.npmjs.org/string-width/-/string-width-5.1.2.tgz",
+      "integrity": "sha512-HnLOCR3vjcY8beoNLtcjZ5/nxn2afmME6lhrDrebokqMap+XbeW8n9TXpPDOqdGK5qcI3oT0GKTW6wC7EMiVqA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "eastasianwidth": "^0.2.0",
+        "emoji-regex": "^9.2.2",
+        "strip-ansi": "^7.0.1"
+      },
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/sindresorhus"
+      }
+    },
+    "node_modules/string-width-cjs": {
+      "name": "string-width",
+      "version": "4.2.3",
+      "resolved": "https://registry.npmjs.org/string-width/-/string-width-4.2.3.tgz",
+      "integrity": "sha512-wKyQRQpjJ0sIp62ErSZdGsjMJWsap5oRNihHhu6G7JVO/9jIB6UyevL+tXuOqrng8j/cxKTWyWUwvSTriiZz/g==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "emoji-regex": "^8.0.0",
+        "is-fullwidth-code-point": "^3.0.0",
+        "strip-ansi": "^6.0.1"
+      },
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/string-width-cjs/node_modules/emoji-regex": {
+      "version": "8.0.0",
+      "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-8.0.0.tgz",
+      "integrity": "sha512-MSjYzcWNOA0ewAHpz0MxpYFvwg6yjy1NG3xteoqz644VCo/RPgnr1/GGt+ic3iJTzQ8Eu3TdM14SawnVUmGE6A==",
+      "dev": true,
+      "license": "MIT"
+    },
+    "node_modules/string-width/node_modules/ansi-regex": {
+      "version": "6.2.2",
+      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-6.2.2.tgz",
+      "integrity": "sha512-Bq3SmSpyFHaWjPk8If9yc6svM8c56dB5BAtW4Qbw5jHTwwXXcTLoRMkpDJp6VL0XzlWaCHTXrkFURMYmD0sLqg==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/ansi-regex?sponsor=1"
+      }
+    },
+    "node_modules/string-width/node_modules/strip-ansi": {
+      "version": "7.1.2",
+      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-7.1.2.tgz",
+      "integrity": "sha512-gmBGslpoQJtgnMAvOVqGZpEz9dyoKTCzy2nfz/n8aIFhN/jCE/rCmcxabB6jOOHV+0WNnylOxaxBQPSvcWklhA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "ansi-regex": "^6.0.1"
+      },
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/strip-ansi?sponsor=1"
+      }
+    },
     "node_modules/strip-ansi": {
       "version": "6.0.1",
       "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-6.0.1.tgz",
@@ -4380,6 +4851,20 @@
         "node": ">=8"
       }
     },
+    "node_modules/strip-ansi-cjs": {
+      "name": "strip-ansi",
+      "version": "6.0.1",
+      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-6.0.1.tgz",
+      "integrity": "sha512-Y38VPSHcqkFrCpFnQ9vuSXmquuv5oXOKpGeT6aGrr3o3Gc9AlVa6JBfUSOCnbxGGZF+/0ooI7KrPuUSztUdU5A==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "ansi-regex": "^5.0.1"
+      },
+      "engines": {
+        "node": ">=8"
+      }
+    },
     "node_modules/strip-json-comments": {
       "version": "3.1.1",
       "resolved": "https://registry.npmjs.org/strip-json-comments/-/strip-json-comments-3.1.1.tgz",
@@ -4493,6 +4978,43 @@
         "node": ">=6"
       }
     },
+    "node_modules/test-exclude": {
+      "version": "7.0.1",
+      "resolved": "https://registry.npmjs.org/test-exclude/-/test-exclude-7.0.1.tgz",
+      "integrity": "sha512-pFYqmTw68LXVjeWJMST4+borgQP2AyMNbg1BpZh9LbyhUeNkeaPF9gzfPGUAnSMV3qPYdWUwDIjjCLiSDOl7vg==",
+      "dev": true,
+      "license": "ISC",
+      "dependencies": {
+        "@istanbuljs/schema": "^0.1.2",
+        "glob": "^10.4.1",
+        "minimatch": "^9.0.4"
+      },
+      "engines": {
+        "node": ">=18"
+      }
+    },
+    "node_modules/test-exclude/node_modules/glob": {
+      "version": "10.5.0",
+      "resolved": "https://registry.npmjs.org/glob/-/glob-10.5.0.tgz",
+      "integrity": "sha512-DfXN8DfhJ7NH3Oe7cFmu3NCu1wKbkReJ8TorzSAFbSKrlNaQSKfIzqYqVY8zlbs2NLBbWpRiU52GX2PbaBVNkg==",
+      "deprecated": "Old versions of glob are not supported, and contain widely publicized security vulnerabilities, which have been fixed in the current version. Please update. Support for old versions may be purchased (at exorbitant rates) by contacting i@izs.me",
+      "dev": true,
+      "license": "ISC",
+      "dependencies": {
+        "foreground-child": "^3.1.0",
+        "jackspeak": "^3.1.2",
+        "minimatch": "^9.0.4",
+        "minipass": "^7.1.2",
+        "package-json-from-dist": "^1.0.0",
+        "path-scurry": "^1.11.1"
+      },
+      "bin": {
+        "glob": "dist/esm/bin.mjs"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/isaacs"
+      }
+    },
     "node_modules/text-table": {
       "version": "0.2.0",
       "resolved": "https://registry.npmjs.org/text-table/-/text-table-0.2.0.tgz",
@@ -4636,7 +5158,6 @@
       "integrity": "sha512-jl1vZzPDinLr9eUt3J/t7V6FgNEw9QjvBPdysz9KfQDD41fQrC2Y4vKQdiaUpFT4bXlb1RHhLpp8wtm6M5TgSw==",
       "dev": true,
       "license": "Apache-2.0",
-      "peer": true,
       "bin": {
         "tsc": "bin/tsc",
         "tsserver": "bin/tsserver"
@@ -4900,6 +5421,107 @@
         "node": ">=0.10.0"
       }
     },
+    "node_modules/wrap-ansi": {
+      "version": "8.1.0",
+      "resolved": "https://registry.npmjs.org/wrap-ansi/-/wrap-ansi-8.1.0.tgz",
+      "integrity": "sha512-si7QWI6zUMq56bESFvagtmzMdGOtoxfR+Sez11Mobfc7tm+VkUckk9bW2UeffTGVUbOksxmSw0AA2gs8g71NCQ==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "ansi-styles": "^6.1.0",
+        "string-width": "^5.0.1",
+        "strip-ansi": "^7.0.1"
+      },
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/wrap-ansi?sponsor=1"
+      }
+    },
+    "node_modules/wrap-ansi-cjs": {
+      "name": "wrap-ansi",
+      "version": "7.0.0",
+      "resolved": "https://registry.npmjs.org/wrap-ansi/-/wrap-ansi-7.0.0.tgz",
+      "integrity": "sha512-YVGIj2kamLSTxw6NsZjoBxfSwsn0ycdesmc4p+Q21c5zPuZ1pl+NfxVdxPtdHvmNVOQ6XSYG4AUtyt/Fi7D16Q==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "ansi-styles": "^4.0.0",
+        "string-width": "^4.1.0",
+        "strip-ansi": "^6.0.0"
+      },
+      "engines": {
+        "node": ">=10"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/wrap-ansi?sponsor=1"
+      }
+    },
+    "node_modules/wrap-ansi-cjs/node_modules/emoji-regex": {
+      "version": "8.0.0",
+      "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-8.0.0.tgz",
+      "integrity": "sha512-MSjYzcWNOA0ewAHpz0MxpYFvwg6yjy1NG3xteoqz644VCo/RPgnr1/GGt+ic3iJTzQ8Eu3TdM14SawnVUmGE6A==",
+      "dev": true,
+      "license": "MIT"
+    },
+    "node_modules/wrap-ansi-cjs/node_modules/string-width": {
+      "version": "4.2.3",
+      "resolved": "https://registry.npmjs.org/string-width/-/string-width-4.2.3.tgz",
+      "integrity": "sha512-wKyQRQpjJ0sIp62ErSZdGsjMJWsap5oRNihHhu6G7JVO/9jIB6UyevL+tXuOqrng8j/cxKTWyWUwvSTriiZz/g==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "emoji-regex": "^8.0.0",
+        "is-fullwidth-code-point": "^3.0.0",
+        "strip-ansi": "^6.0.1"
+      },
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/wrap-ansi/node_modules/ansi-regex": {
+      "version": "6.2.2",
+      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-6.2.2.tgz",
+      "integrity": "sha512-Bq3SmSpyFHaWjPk8If9yc6svM8c56dB5BAtW4Qbw5jHTwwXXcTLoRMkpDJp6VL0XzlWaCHTXrkFURMYmD0sLqg==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/ansi-regex?sponsor=1"
+      }
+    },
+    "node_modules/wrap-ansi/node_modules/ansi-styles": {
+      "version": "6.2.3",
+      "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-6.2.3.tgz",
+      "integrity": "sha512-4Dj6M28JB+oAH8kFkTLUo+a2jwOFkuqb3yucU0CANcRRUbxS0cP0nZYCGjcc3BNXwRIsUVmDGgzawme7zvJHvg==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/ansi-styles?sponsor=1"
+      }
+    },
+    "node_modules/wrap-ansi/node_modules/strip-ansi": {
+      "version": "7.1.2",
+      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-7.1.2.tgz",
+      "integrity": "sha512-gmBGslpoQJtgnMAvOVqGZpEz9dyoKTCzy2nfz/n8aIFhN/jCE/rCmcxabB6jOOHV+0WNnylOxaxBQPSvcWklhA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "ansi-regex": "^6.0.1"
+      },
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/strip-ansi?sponsor=1"
+      }
+    },
     "node_modules/wrappy": {
       "version": "1.0.2",
       "resolved": "https://registry.npmjs.org/wrappy/-/wrappy-1.0.2.tgz",
diff --git a/src/app.test.ts b/src/app.test.ts
new file mode 100644
index 0000000..627df1d
--- /dev/null
+++ b/src/app.test.ts
@@ -0,0 +1,450 @@
+import { describe, it, expect, beforeEach } from "vitest";
+import request from "supertest";
+import { createApp } from "./app.js";
+import type { Express } from "express";
+
+describe("Analytics Dashboard API", () => {
+  let app: Express;
+
+  beforeEach(() => {
+    app = createApp();
+  });
+
+  describe("Health check", () => {
+    it("returns ok", async () => {
+      const res = await request(app).get("/health");
+      expect(res.status).toBe(200);
+      expect(res.body.status).toBe("ok");
+    });
+  });
+
+  describe("User Management", () => {
+    it("registers a new user", async () => {
+      const res = await request(app).post("/api/users/register").send({
+        email: "test@example.com",
+        password: "password123",
+        tenantId: "tenant-1",
+      });
+      expect(res.status).toBe(201);
+      expect(res.body.user.email).toBe("test@example.com");
+      expect(res.body.user.tenantId).toBe("tenant-1");
+      expect(res.body.user.role).toBe("viewer");
+      expect(res.body.token).toBeDefined();
+    });
+
+    it("rejects duplicate email registration", async () => {
+      await request(app).post("/api/users/register").send({
+        email: "test@example.com",
+        password: "password123",
+        tenantId: "tenant-1",
+      });
+      const res = await request(app).post("/api/users/register").send({
+        email: "test@example.com",
+        password: "password456",
+        tenantId: "tenant-1",
+      });
+      expect(res.status).toBe(409);
+    });
+
+    it("logs in with valid credentials", async () => {
+      await request(app).post("/api/users/register").send({
+        email: "test@example.com",
+        password: "password123",
+        tenantId: "tenant-1",
+      });
+      const res = await request(app).post("/api/users/login").send({
+        email: "test@example.com",
+        password: "password123",
+      });
+      expect(res.status).toBe(200);
+      expect(res.body.token).toBeDefined();
+    });
+
+    it("rejects invalid credentials", async () => {
+      await request(app).post("/api/users/register").send({
+        email: "test@example.com",
+        password: "password123",
+        tenantId: "tenant-1",
+      });
+      const res = await request(app).post("/api/users/login").send({
+        email: "test@example.com",
+        password: "wrongpassword",
+      });
+      expect(res.status).toBe(401);
+    });
+
+    it("gets user profile with auth", async () => {
+      const reg = await request(app).post("/api/users/register").send({
+        email: "test@example.com",
+        password: "password123",
+        tenantId: "tenant-1",
+      });
+      const res = await request(app)
+        .get("/api/users/profile")
+        .set("Authorization", `Bearer ${reg.body.token}`);
+      expect(res.status).toBe(200);
+      expect(res.body.email).toBe("test@example.com");
+    });
+
+    it("rejects unauthenticated profile request", async () => {
+      const res = await request(app).get("/api/users/profile");
+      expect(res.status).toBe(401);
+    });
+
+    it("admin can change user role", async () => {
+      const admin = await request(app).post("/api/users/register").send({
+        email: "admin@example.com",
+        password: "password123",
+        tenantId: "tenant-1",
+        role: "admin",
+      });
+      const user = await request(app).post("/api/users/register").send({
+        email: "user@example.com",
+        password: "password123",
+        tenantId: "tenant-1",
+      });
+      const res = await request(app)
+        .put(`/api/users/${user.body.user.id}/role`)
+        .set("Authorization", `Bearer ${admin.body.token}`)
+        .send({ role: "editor" });
+      expect(res.status).toBe(200);
+      expect(res.body.role).toBe("editor");
+    });
+
+    it("non-admin cannot change roles", async () => {
+      const viewer = await request(app).post("/api/users/register").send({
+        email: "viewer@example.com",
+        password: "password123",
+        tenantId: "tenant-1",
+      });
+      const user = await request(app).post("/api/users/register").send({
+        email: "user@example.com",
+        password: "password123",
+        tenantId: "tenant-1",
+      });
+      const res = await request(app)
+        .put(`/api/users/${user.body.user.id}/role`)
+        .set("Authorization", `Bearer ${viewer.body.token}`)
+        .send({ role: "editor" });
+      expect(res.status).toBe(403);
+    });
+  });
+
+  describe("Event Ingestion", () => {
+    let token: string;
+
+    beforeEach(async () => {
+      const reg = await request(app).post("/api/users/register").send({
+        email: "test@example.com",
+        password: "password123",
+        tenantId: "tenant-1",
+      });
+      token = reg.body.token;
+    });
+
+    it("ingests a single event", async () => {
+      const res = await request(app)
+        .post("/api/events")
+        .set("Authorization", `Bearer ${token}`)
+        .send({ name: "page_view", properties: { url: "/home" } });
+      expect(res.status).toBe(201);
+      expect(res.body.name).toBe("page_view");
+      expect(res.body.id).toBeDefined();
+    });
+
+    it("ingests batch events", async () => {
+      const res = await request(app)
+        .post("/api/events/batch")
+        .set("Authorization", `Bearer ${token}`)
+        .send({
+          events: [
+            { name: "page_view", properties: { url: "/home" } },
+            { name: "click", properties: { button: "signup" } },
+            { name: "page_view", properties: { url: "/about" } },
+          ],
+        });
+      expect(res.status).toBe(201);
+      expect(res.body.inserted).toBe(3);
+    });
+
+    it("rejects unauthenticated event ingestion", async () => {
+      const res = await request(app)
+        .post("/api/events")
+        .send({ name: "page_view" });
+      expect(res.status).toBe(401);
+    });
+  });
+
+  describe("Query Engine", () => {
+    let token: string;
+
+    beforeEach(async () => {
+      const reg = await request(app).post("/api/users/register").send({
+        email: "test@example.com",
+        password: "password123",
+        tenantId: "tenant-1",
+      });
+      token = reg.body.token;
+
+      // Insert test events
+      await request(app)
+        .post("/api/events/batch")
+        .set("Authorization", `Bearer ${token}`)
+        .send({
+          events: [
+            { name: "page_view", properties: { url: "/home" }, timestamp: "2024-01-01T10:00:00Z" },
+            { name: "page_view", properties: { url: "/about" }, timestamp: "2024-01-01T14:00:00Z" },
+            { name: "page_view", properties: { url: "/home" }, timestamp: "2024-01-02T10:00:00Z" },
+            { name: "click", properties: { button: "signup" }, timestamp: "2024-01-01T11:00:00Z" },
+          ],
+        });
+    });
+
+    it("counts events", async () => {
+      const res = await request(app)
+        .post("/api/query/count")
+        .set("Authorization", `Bearer ${token}`)
+        .send({ eventName: "page_view" });
+      expect(res.status).toBe(200);
+      expect(res.body.count).toBe(3);
+    });
+
+    it("counts events with date filter", async () => {
+      const res = await request(app)
+        .post("/api/query/count")
+        .set("Authorization", `Bearer ${token}`)
+        .send({
+          eventName: "page_view",
+          startDate: "2024-01-01T00:00:00Z",
+          endDate: "2024-01-01T23:59:59Z",
+        });
+      expect(res.status).toBe(200);
+      expect(res.body.count).toBe(2);
+    });
+
+    it("returns timeseries data", async () => {
+      const res = await request(app)
+        .post("/api/query/timeseries")
+        .set("Authorization", `Bearer ${token}`)
+        .send({ eventName: "page_view", interval: "day" });
+      expect(res.status).toBe(200);
+      expect(res.body.timeseries.length).toBe(2);
+    });
+
+    it("returns breakdown data", async () => {
+      const res = await request(app)
+        .post("/api/query/breakdown")
+        .set("Authorization", `Bearer ${token}`)
+        .send({ eventName: "page_view", property: "url" });
+      expect(res.status).toBe(200);
+      expect(res.body.breakdown.length).toBe(2);
+      expect(res.body.breakdown[0].count).toBe(2); // /home has 2 views
+    });
+
+    it("enforces tenant isolation in queries", async () => {
+      // Create another user in a different tenant
+      const reg2 = await request(app).post("/api/users/register").send({
+        email: "other@example.com",
+        password: "password123",
+        tenantId: "tenant-2",
+      });
+      const token2 = reg2.body.token;
+
+      const res = await request(app)
+        .post("/api/query/count")
+        .set("Authorization", `Bearer ${token2}`)
+        .send({});
+      expect(res.status).toBe(200);
+      expect(res.body.count).toBe(0); // tenant-2 has no events
+    });
+  });
+
+  describe("Dashboard Configuration", () => {
+    let token: string;
+
+    beforeEach(async () => {
+      const reg = await request(app).post("/api/users/register").send({
+        email: "test@example.com",
+        password: "password123",
+        tenantId: "tenant-1",
+      });
+      token = reg.body.token;
+    });
+
+    it("creates a dashboard", async () => {
+      const res = await request(app)
+        .post("/api/dashboards")
+        .set("Authorization", `Bearer ${token}`)
+        .send({ name: "My Dashboard", config: { theme: "dark" } });
+      expect(res.status).toBe(201);
+      expect(res.body.name).toBe("My Dashboard");
+      expect(res.body.config.theme).toBe("dark");
+    });
+
+    it("lists dashboards", async () => {
+      await request(app)
+        .post("/api/dashboards")
+        .set("Authorization", `Bearer ${token}`)
+        .send({ name: "Dashboard 1" });
+      await request(app)
+        .post("/api/dashboards")
+        .set("Authorization", `Bearer ${token}`)
+        .send({ name: "Dashboard 2" });
+
+      const res = await request(app)
+        .get("/api/dashboards")
+        .set("Authorization", `Bearer ${token}`);
+      expect(res.status).toBe(200);
+      expect(res.body.dashboards.length).toBe(2);
+    });
+
+    it("gets a single dashboard", async () => {
+      const created = await request(app)
+        .post("/api/dashboards")
+        .set("Authorization", `Bearer ${token}`)
+        .send({ name: "My Dashboard" });
+
+      const res = await request(app)
+        .get(`/api/dashboards/${created.body.id}`)
+        .set("Authorization", `Bearer ${token}`);
+      expect(res.status).toBe(200);
+      expect(res.body.name).toBe("My Dashboard");
+      expect(res.body.widgets).toBeDefined();
+    });
+
+    it("updates a dashboard", async () => {
+      const created = await request(app)
+        .post("/api/dashboards")
+        .set("Authorization", `Bearer ${token}`)
+        .send({ name: "Old Name" });
+
+      const res = await request(app)
+        .put(`/api/dashboards/${created.body.id}`)
+        .set("Authorization", `Bearer ${token}`)
+        .send({ name: "New Name" });
+      expect(res.status).toBe(200);
+      expect(res.body.name).toBe("New Name");
+    });
+
+    it("deletes a dashboard", async () => {
+      const created = await request(app)
+        .post("/api/dashboards")
+        .set("Authorization", `Bearer ${token}`)
+        .send({ name: "To Delete" });
+
+      const res = await request(app)
+        .delete(`/api/dashboards/${created.body.id}`)
+        .set("Authorization", `Bearer ${token}`);
+      expect(res.status).toBe(204);
+
+      const check = await request(app)
+        .get(`/api/dashboards/${created.body.id}`)
+        .set("Authorization", `Bearer ${token}`);
+      expect(check.status).toBe(404);
+    });
+
+    it("enforces tenant isolation for dashboards", async () => {
+      const created = await request(app)
+        .post("/api/dashboards")
+        .set("Authorization", `Bearer ${token}`)
+        .send({ name: "Tenant 1 Dashboard" });
+
+      const reg2 = await request(app).post("/api/users/register").send({
+        email: "other@example.com",
+        password: "password123",
+        tenantId: "tenant-2",
+      });
+
+      const res = await request(app)
+        .get(`/api/dashboards/${created.body.id}`)
+        .set("Authorization", `Bearer ${reg2.body.token}`);
+      expect(res.status).toBe(404);
+    });
+  });
+
+  describe("Data Export", () => {
+    let token: string;
+
+    beforeEach(async () => {
+      const reg = await request(app).post("/api/users/register").send({
+        email: "test@example.com",
+        password: "password123",
+        tenantId: "tenant-1",
+      });
+      token = reg.body.token;
+
+      await request(app)
+        .post("/api/events/batch")
+        .set("Authorization", `Bearer ${token}`)
+        .send({
+          events: [
+            { name: "page_view", properties: { url: "/home" } },
+            { name: "click", properties: { button: "signup" } },
+          ],
+        });
+    });
+
+    it("exports events as JSON", async () => {
+      const res = await request(app)
+        .get("/api/export/events/json")
+        .set("Authorization", `Bearer ${token}`);
+      expect(res.status).toBe(200);
+      expect(res.body.events.length).toBe(2);
+      expect(res.headers["content-disposition"]).toContain("events.json");
+    });
+
+    it("exports events as CSV", async () => {
+      const res = await request(app)
+        .get("/api/export/events/csv")
+        .set("Authorization", `Bearer ${token}`);
+      expect(res.status).toBe(200);
+      expect(res.headers["content-type"]).toContain("text/csv");
+      expect(res.text).toContain("id,name,properties");
+    });
+
+    it("exports dashboard as JSON", async () => {
+      const dash = await request(app)
+        .post("/api/dashboards")
+        .set("Authorization", `Bearer ${token}`)
+        .send({ name: "Export Test" });
+
+      const res = await request(app)
+        .get(`/api/export/dashboards/${dash.body.id}/json`)
+        .set("Authorization", `Bearer ${token}`);
+      expect(res.status).toBe(200);
+      expect(res.body.dashboard.name).toBe("Export Test");
+    });
+
+    it("exports dashboard as CSV", async () => {
+      const dash = await request(app)
+        .post("/api/dashboards")
+        .set("Authorization", `Bearer ${token}`)
+        .send({ name: "Export Test" });
+
+      const res = await request(app)
+        .get(`/api/export/dashboards/${dash.body.id}/csv`)
+        .set("Authorization", `Bearer ${token}`);
+      expect(res.status).toBe(200);
+      expect(res.headers["content-type"]).toContain("text/csv");
+    });
+
+    it("enforces tenant isolation on export", async () => {
+      const reg2 = await request(app).post("/api/users/register").send({
+        email: "other@example.com",
+        password: "password123",
+        tenantId: "tenant-2",
+      });
+
+      const res = await request(app)
+        .get("/api/export/events/json")
+        .set("Authorization", `Bearer ${reg2.body.token}`);
+      expect(res.status).toBe(200);
+      expect(res.body.events.length).toBe(0);
+    });
+
+    it("rejects unauthenticated export", async () => {
+      const res = await request(app).get("/api/export/events/json");
+      expect(res.status).toBe(401);
+    });
+  });
+});
diff --git a/src/app.ts b/src/app.ts
new file mode 100644
index 0000000..c5033fa
--- /dev/null
+++ b/src/app.ts
@@ -0,0 +1,26 @@
+import express from "express";
+import { createDatabase } from "./db.js";
+import { createUserRoutes } from "./routes/users.js";
+import { createEventRoutes } from "./routes/events.js";
+import { createQueryRoutes } from "./routes/query.js";
+import { createDashboardRoutes } from "./routes/dashboards.js";
+import { createExportRoutes } from "./routes/export.js";
+
+export function createApp(dbPath?: string) {
+  const app = express();
+  const db = createDatabase(dbPath);
+
+  app.use(express.json());
+
+  app.get("/health", (_req, res) => {
+    res.json({ status: "ok" });
+  });
+
+  app.use("/api/users", createUserRoutes(db));
+  app.use("/api/events", createEventRoutes(db));
+  app.use("/api/query", createQueryRoutes(db));
+  app.use("/api/dashboards", createDashboardRoutes(db));
+  app.use("/api/export", createExportRoutes(db));
+
+  return app;
+}
diff --git a/src/auth.ts b/src/auth.ts
new file mode 100644
index 0000000..55eb43d
--- /dev/null
+++ b/src/auth.ts
@@ -0,0 +1,65 @@
+import { Request, Response, NextFunction } from "express";
+import jwt from "jsonwebtoken";
+import crypto from "crypto";
+
+const JWT_SECRET = process.env.JWT_SECRET || "analytics-dashboard-secret-key";
+
+export interface JwtPayload {
+  userId: string;
+  email: string;
+  tenantId: string;
+  role: string;
+}
+
+declare module "express-serve-static-core" {
+  interface Request {
+    user?: JwtPayload;
+  }
+}
+
+export function hashPassword(password: string): string {
+  const salt = crypto.randomBytes(16).toString("hex");
+  const hash = crypto.scryptSync(password, salt, 64).toString("hex");
+  return `${salt}:${hash}`;
+}
+
+export function verifyPassword(password: string, stored: string): boolean {
+  const [salt, hash] = stored.split(":");
+  const computed = crypto.scryptSync(password, salt, 64).toString("hex");
+  return hash === computed;
+}
+
+export function generateToken(payload: JwtPayload): string {
+  return jwt.sign(payload, JWT_SECRET, { expiresIn: "24h" });
+}
+
+export function authenticate(req: Request, res: Response, next: NextFunction): void {
+  const authHeader = req.headers.authorization;
+  if (!authHeader || !authHeader.startsWith("Bearer ")) {
+    res.status(401).json({ error: "Authentication required" });
+    return;
+  }
+
+  const token = authHeader.slice(7);
+  try {
+    const decoded = jwt.verify(token, JWT_SECRET) as JwtPayload;
+    req.user = decoded;
+    next();
+  } catch {
+    res.status(401).json({ error: "Invalid or expired token" });
+  }
+}
+
+export function requireRole(...roles: string[]) {
+  return (req: Request, res: Response, next: NextFunction): void => {
+    if (!req.user) {
+      res.status(401).json({ error: "Authentication required" });
+      return;
+    }
+    if (!roles.includes(req.user.role)) {
+      res.status(403).json({ error: "Insufficient permissions" });
+      return;
+    }
+    next();
+  };
+}
diff --git a/src/db.ts b/src/db.ts
new file mode 100644
index 0000000..7cc9c51
--- /dev/null
+++ b/src/db.ts
@@ -0,0 +1,15 @@
+import Database from "better-sqlite3";
+import { readFileSync } from "fs";
+import { join } from "path";
+
+export function createDatabase(dbPath: string = ":memory:"): Database.Database {
+  const db = new Database(dbPath);
+  db.pragma("journal_mode = WAL");
+  db.pragma("foreign_keys = ON");
+
+  const schemaPath = join(__dirname, "..", "schema.sql");
+  const schema = readFileSync(schemaPath, "utf-8");
+  db.exec(schema);
+
+  return db;
+}
diff --git a/src/index.ts b/src/index.ts
new file mode 100644
index 0000000..229beff
--- /dev/null
+++ b/src/index.ts
@@ -0,0 +1,2 @@
+export { createApp } from "./app.js";
+
diff --git a/src/routes/dashboards.ts b/src/routes/dashboards.ts
new file mode 100644
index 0000000..2b4ba65
--- /dev/null
+++ b/src/routes/dashboards.ts
@@ -0,0 +1,212 @@
+import { Router, Request, Response } from "express";
+import Database from "better-sqlite3";
+import { v4 as uuidv4 } from "uuid";
+import { authenticate } from "../auth.js";
+
+export function createDashboardRoutes(db: Database.Database): Router {
+  const router = Router();
+
+  // Create dashboard
+  router.post("/", authenticate, (req: Request, res: Response): void => {
+    const { name, config } = req.body;
+
+    if (!name) {
+      res.status(400).json({ error: "Dashboard name is required" });
+      return;
+    }
+
+    const id = uuidv4();
+    const tenantId = req.user!.tenantId;
+    const ownerId = req.user!.userId;
+    const dashConfig = JSON.stringify(config || {});
+
+    db.prepare(
+      "INSERT INTO dashboards (id, tenant_id, name, owner_id, config) VALUES (?, ?, ?, ?, ?)"
+    ).run(id, tenantId, name, ownerId, dashConfig);
+
+    res.status(201).json({
+      id,
+      name,
+      tenantId,
+      ownerId,
+      config: config || {},
+    });
+  });
+
+  // List dashboards for tenant
+  router.get("/", authenticate, (req: Request, res: Response): void => {
+    const tenantId = req.user!.tenantId;
+
+    const dashboards = db
+      .prepare(
+        "SELECT id, tenant_id, name, owner_id, config, created_at, updated_at FROM dashboards WHERE tenant_id = ?"
+      )
+      .all(tenantId) as Array<{
+      id: string;
+      tenant_id: string;
+      name: string;
+      owner_id: string;
+      config: string;
+      created_at: string;
+      updated_at: string;
+    }>;
+
+    res.json({
+      dashboards: dashboards.map((d) => ({
+        id: d.id,
+        name: d.name,
+        tenantId: d.tenant_id,
+        ownerId: d.owner_id,
+        config: JSON.parse(d.config),
+        createdAt: d.created_at,
+        updatedAt: d.updated_at,
+      })),
+    });
+  });
+
+  // Get single dashboard
+  router.get("/:id", authenticate, (req: Request, res: Response): void => {
+    const tenantId = req.user!.tenantId;
+    const { id } = req.params;
+
+    const dashboard = db
+      .prepare(
+        "SELECT id, tenant_id, name, owner_id, config, created_at, updated_at FROM dashboards WHERE id = ? AND tenant_id = ?"
+      )
+      .get(id, tenantId) as
+      | {
+          id: string;
+          tenant_id: string;
+          name: string;
+          owner_id: string;
+          config: string;
+          created_at: string;
+          updated_at: string;
+        }
+      | undefined;
+
+    if (!dashboard) {
+      res.status(404).json({ error: "Dashboard not found" });
+      return;
+    }
+
+    const widgets = db
+      .prepare(
+        "SELECT id, type, config, position_x, position_y, width, height FROM widgets WHERE dashboard_id = ?"
+      )
+      .all(id) as Array<{
+      id: string;
+      type: string;
+      config: string;
+      position_x: number;
+      position_y: number;
+      width: number;
+      height: number;
+    }>;
+
+    res.json({
+      id: dashboard.id,
+      name: dashboard.name,
+      tenantId: dashboard.tenant_id,
+      ownerId: dashboard.owner_id,
+      config: JSON.parse(dashboard.config),
+      createdAt: dashboard.created_at,
+      updatedAt: dashboard.updated_at,
+      widgets: widgets.map((w) => ({
+        id: w.id,
+        type: w.type,
+        config: JSON.parse(w.config),
+        positionX: w.position_x,
+        positionY: w.position_y,
+        width: w.width,
+        height: w.height,
+      })),
+    });
+  });
+
+  // Update dashboard
+  router.put("/:id", authenticate, (req: Request, res: Response): void => {
+    const tenantId = req.user!.tenantId;
+    const { id } = req.params;
+    const { name, config } = req.body;
+
+    const existing = db
+      .prepare("SELECT id FROM dashboards WHERE id = ? AND tenant_id = ?")
+      .get(id, tenantId);
+
+    if (!existing) {
+      res.status(404).json({ error: "Dashboard not found" });
+      return;
+    }
+
+    const updates: string[] = [];
+    const params: unknown[] = [];
+
+    if (name !== undefined) {
+      updates.push("name = ?");
+      params.push(name);
+    }
+
+    if (config !== undefined) {
+      updates.push("config = ?");
+      params.push(JSON.stringify(config));
+    }
+
+    if (updates.length === 0) {
+      res.status(400).json({ error: "No fields to update" });
+      return;
+    }
+
+    updates.push("updated_at = datetime('now')");
+    params.push(id, tenantId);
+
+    db.prepare(
+      `UPDATE dashboards SET ${updates.join(", ")} WHERE id = ? AND tenant_id = ?`
+    ).run(...params);
+
+    const updated = db
+      .prepare(
+        "SELECT id, tenant_id, name, owner_id, config, created_at, updated_at FROM dashboards WHERE id = ?"
+      )
+      .get(id) as {
+      id: string;
+      tenant_id: string;
+      name: string;
+      owner_id: string;
+      config: string;
+      created_at: string;
+      updated_at: string;
+    };
+
+    res.json({
+      id: updated.id,
+      name: updated.name,
+      tenantId: updated.tenant_id,
+      ownerId: updated.owner_id,
+      config: JSON.parse(updated.config),
+      createdAt: updated.created_at,
+      updatedAt: updated.updated_at,
+    });
+  });
+
+  // Delete dashboard
+  router.delete("/:id", authenticate, (req: Request, res: Response): void => {
+    const tenantId = req.user!.tenantId;
+    const { id } = req.params;
+
+    const existing = db
+      .prepare("SELECT id FROM dashboards WHERE id = ? AND tenant_id = ?")
+      .get(id, tenantId);
+
+    if (!existing) {
+      res.status(404).json({ error: "Dashboard not found" });
+      return;
+    }
+
+    db.prepare("DELETE FROM dashboards WHERE id = ? AND tenant_id = ?").run(id, tenantId);
+
+    res.status(204).send();
+  });
+
+  return router;
+}
diff --git a/src/routes/events.ts b/src/routes/events.ts
new file mode 100644
index 0000000..6280761
--- /dev/null
+++ b/src/routes/events.ts
@@ -0,0 +1,68 @@
+import { Router, Request, Response } from "express";
+import Database from "better-sqlite3";
+import { v4 as uuidv4 } from "uuid";
+import { authenticate } from "../auth.js";
+
+export function createEventRoutes(db: Database.Database): Router {
+  const router = Router();
+
+  // Ingest single event
+  router.post("/", authenticate, (req: Request, res: Response): void => {
+    const { name, properties, timestamp, sessionId } = req.body;
+
+    if (!name) {
+      res.status(400).json({ error: "Event name is required" });
+      return;
+    }
+
+    const id = uuidv4();
+    const tenantId = req.user!.tenantId;
+    const userId = req.user!.userId;
+    const eventTimestamp = timestamp || new Date().toISOString();
+    const eventProperties = JSON.stringify(properties || {});
+
+    db.prepare(
+      "INSERT INTO events (id, tenant_id, name, properties, timestamp, user_id, session_id) VALUES (?, ?, ?, ?, ?, ?, ?)"
+    ).run(id, tenantId, name, eventProperties, eventTimestamp, userId, sessionId || null);
+
+    res.status(201).json({ id, name, tenantId, timestamp: eventTimestamp });
+  });
+
+  // Batch ingest events
+  router.post("/batch", authenticate, (req: Request, res: Response): void => {
+    const { events } = req.body;
+
+    if (!Array.isArray(events) || events.length === 0) {
+      res.status(400).json({ error: "events array is required and must not be empty" });
+      return;
+    }
+
+    const tenantId = req.user!.tenantId;
+    const userId = req.user!.userId;
+
+    const insert = db.prepare(
+      "INSERT INTO events (id, tenant_id, name, properties, timestamp, user_id, session_id) VALUES (?, ?, ?, ?, ?, ?, ?)"
+    );
+
+    const results: Array<{ id: string; name: string }> = [];
+
+    const insertMany = db.transaction(
+      (items: Array<{ name: string; properties?: Record<string, unknown>; timestamp?: string; sessionId?: string }>) => {
+        for (const event of items) {
+          if (!event.name) continue;
+          const id = uuidv4();
+          const eventTimestamp = event.timestamp || new Date().toISOString();
+          const eventProperties = JSON.stringify(event.properties || {});
+          insert.run(id, tenantId, event.name, eventProperties, eventTimestamp, userId, event.sessionId || null);
+          results.push({ id, name: event.name });
+        }
+      }
+    );
+
+    insertMany(events);
+
+    res.status(201).json({ inserted: results.length, events: results });
+  });
+
+  return router;
+}
diff --git a/src/routes/export.ts b/src/routes/export.ts
new file mode 100644
index 0000000..1357d5a
--- /dev/null
+++ b/src/routes/export.ts
@@ -0,0 +1,198 @@
+import { Router, Request, Response } from "express";
+import Database from "better-sqlite3";
+import { authenticate } from "../auth.js";
+
+function eventsToCsv(
+  events: Array<{ id: string; name: string; properties: string; timestamp: string; user_id: string | null; session_id: string | null }>
+): string {
+  const header = "id,name,properties,timestamp,user_id,session_id";
+  const rows = events.map((e) => {
+    const props = e.properties.replace(/"/g, '""');
+    return `${e.id},${e.name},"${props}",${e.timestamp},${e.user_id || ""},${e.session_id || ""}`;
+  });
+  return [header, ...rows].join("\n");
+}
+
+export function createExportRoutes(db: Database.Database): Router {
+  const router = Router();
+
+  // Export events as JSON
+  router.get("/events/json", authenticate, (req: Request, res: Response): void => {
+    const tenantId = req.user!.tenantId;
+    const { eventName, startDate, endDate } = req.query;
+
+    let sql = "SELECT id, name, properties, timestamp, user_id, session_id FROM events WHERE tenant_id = ?";
+    const params: unknown[] = [tenantId];
+
+    if (eventName) {
+      sql += " AND name = ?";
+      params.push(eventName);
+    }
+
+    if (startDate) {
+      sql += " AND timestamp >= ?";
+      params.push(startDate);
+    }
+
+    if (endDate) {
+      sql += " AND timestamp <= ?";
+      params.push(endDate);
+    }
+
+    sql += " ORDER BY timestamp DESC";
+
+    const events = db.prepare(sql).all(...params) as Array<{
+      id: string;
+      name: string;
+      properties: string;
+      timestamp: string;
+      user_id: string | null;
+      session_id: string | null;
+    }>;
+
+    const formatted = events.map((e) => ({
+      id: e.id,
+      name: e.name,
+      properties: JSON.parse(e.properties),
+      timestamp: e.timestamp,
+      userId: e.user_id,
+      sessionId: e.session_id,
+    }));
+
+    res.setHeader("Content-Type", "application/json");
+    res.setHeader("Content-Disposition", "attachment; filename=events.json");
+    res.json({ events: formatted });
+  });
+
+  // Export events as CSV
+  router.get("/events/csv", authenticate, (req: Request, res: Response): void => {
+    const tenantId = req.user!.tenantId;
+    const { eventName, startDate, endDate } = req.query;
+
+    let sql = "SELECT id, name, properties, timestamp, user_id, session_id FROM events WHERE tenant_id = ?";
+    const params: unknown[] = [tenantId];
+
+    if (eventName) {
+      sql += " AND name = ?";
+      params.push(eventName);
+    }
+
+    if (startDate) {
+      sql += " AND timestamp >= ?";
+      params.push(startDate);
+    }
+
+    if (endDate) {
+      sql += " AND timestamp <= ?";
+      params.push(endDate);
+    }
+
+    sql += " ORDER BY timestamp DESC";
+
+    const events = db.prepare(sql).all(...params) as Array<{
+      id: string;
+      name: string;
+      properties: string;
+      timestamp: string;
+      user_id: string | null;
+      session_id: string | null;
+    }>;
+
+    res.setHeader("Content-Type", "text/csv");
+    res.setHeader("Content-Disposition", "attachment; filename=events.csv");
+    res.send(eventsToCsv(events));
+  });
+
+  // Export dashboard data as JSON
+  router.get("/dashboards/:id/json", authenticate, (req: Request, res: Response): void => {
+    const tenantId = req.user!.tenantId;
+    const { id } = req.params;
+
+    const dashboard = db
+      .prepare(
+        "SELECT id, tenant_id, name, owner_id, config, created_at, updated_at FROM dashboards WHERE id = ? AND tenant_id = ?"
+      )
+      .get(id, tenantId) as
+      | { id: string; tenant_id: string; name: string; owner_id: string; config: string; created_at: string; updated_at: string }
+      | undefined;
+
+    if (!dashboard) {
+      res.status(404).json({ error: "Dashboard not found" });
+      return;
+    }
+
+    const widgets = db
+      .prepare("SELECT id, type, config, position_x, position_y, width, height FROM widgets WHERE dashboard_id = ?")
+      .all(id) as Array<{
+      id: string;
+      type: string;
+      config: string;
+      position_x: number;
+      position_y: number;
+      width: number;
+      height: number;
+    }>;
+
+    res.setHeader("Content-Type", "application/json");
+    res.setHeader("Content-Disposition", `attachment; filename=dashboard-${id}.json`);
+    res.json({
+      dashboard: {
+        id: dashboard.id,
+        name: dashboard.name,
+        tenantId: dashboard.tenant_id,
+        ownerId: dashboard.owner_id,
+        config: JSON.parse(dashboard.config),
+        createdAt: dashboard.created_at,
+        updatedAt: dashboard.updated_at,
+        widgets: widgets.map((w) => ({
+          id: w.id,
+          type: w.type,
+          config: JSON.parse(w.config),
+          positionX: w.position_x,
+          positionY: w.position_y,
+          width: w.width,
+          height: w.height,
+        })),
+      },
+    });
+  });
+
+  // Export dashboard data as CSV
+  router.get("/dashboards/:id/csv", authenticate, (req: Request, res: Response): void => {
+    const tenantId = req.user!.tenantId;
+    const { id } = req.params;
+
+    const dashboard = db
+      .prepare("SELECT id, name FROM dashboards WHERE id = ? AND tenant_id = ?")
+      .get(id, tenantId) as { id: string; name: string } | undefined;
+
+    if (!dashboard) {
+      res.status(404).json({ error: "Dashboard not found" });
+      return;
+    }
+
+    const widgets = db
+      .prepare("SELECT id, type, config, position_x, position_y, width, height FROM widgets WHERE dashboard_id = ?")
+      .all(id) as Array<{
+      id: string;
+      type: string;
+      config: string;
+      position_x: number;
+      position_y: number;
+      width: number;
+      height: number;
+    }>;
+
+    const header = "widget_id,type,config,position_x,position_y,width,height";
+    const rows = widgets.map((w) => {
+      const config = w.config.replace(/"/g, '""');
+      return `${w.id},${w.type},"${config}",${w.position_x},${w.position_y},${w.width},${w.height}`;
+    });
+
+    res.setHeader("Content-Type", "text/csv");
+    res.setHeader("Content-Disposition", `attachment; filename=dashboard-${id}.csv`);
+    res.send([header, ...rows].join("\n"));
+  });
+
+  return router;
+}
diff --git a/src/routes/query.ts b/src/routes/query.ts
new file mode 100644
index 0000000..b8f9b4c
--- /dev/null
+++ b/src/routes/query.ts
@@ -0,0 +1,121 @@
+import { Router, Request, Response } from "express";
+import Database from "better-sqlite3";
+import { authenticate } from "../auth.js";
+
+export function createQueryRoutes(db: Database.Database): Router {
+  const router = Router();
+
+  // Count events
+  router.post("/count", authenticate, (req: Request, res: Response): void => {
+    const tenantId = req.user!.tenantId;
+    const { eventName, startDate, endDate, filters } = req.body;
+
+    let sql = "SELECT COUNT(*) as count FROM events WHERE tenant_id = ?";
+    const params: unknown[] = [tenantId];
+
+    if (eventName) {
+      sql += " AND name = ?";
+      params.push(eventName);
+    }
+
+    if (startDate) {
+      sql += " AND timestamp >= ?";
+      params.push(startDate);
+    }
+
+    if (endDate) {
+      sql += " AND timestamp <= ?";
+      params.push(endDate);
+    }
+
+    if (filters && typeof filters === "object") {
+      for (const [key, value] of Object.entries(filters)) {
+        sql += " AND json_extract(properties, ?) = ?";
+        params.push(`$.${key}`, value);
+      }
+    }
+
+    const result = db.prepare(sql).get(...params) as { count: number };
+    res.json({ count: result.count });
+  });
+
+  // Timeseries query
+  router.post("/timeseries", authenticate, (req: Request, res: Response): void => {
+    const tenantId = req.user!.tenantId;
+    const { eventName, startDate, endDate, interval, filters } = req.body;
+
+    if (!eventName) {
+      res.status(400).json({ error: "eventName is required" });
+      return;
+    }
+
+    const bucket = interval === "hour"
+      ? "strftime('%Y-%m-%dT%H:00:00', timestamp)"
+      : interval === "month"
+        ? "strftime('%Y-%m-01', timestamp)"
+        : "strftime('%Y-%m-%d', timestamp)";
+
+    let sql = `SELECT ${bucket} as period, COUNT(*) as count FROM events WHERE tenant_id = ? AND name = ?`;
+    const params: unknown[] = [tenantId, eventName];
+
+    if (startDate) {
+      sql += " AND timestamp >= ?";
+      params.push(startDate);
+    }
+
+    if (endDate) {
+      sql += " AND timestamp <= ?";
+      params.push(endDate);
+    }
+
+    if (filters && typeof filters === "object") {
+      for (const [key, value] of Object.entries(filters)) {
+        sql += " AND json_extract(properties, ?) = ?";
+        params.push(`$.${key}`, value);
+      }
+    }
+
+    sql += ` GROUP BY period ORDER BY period ASC`;
+
+    const results = db.prepare(sql).all(...params) as Array<{ period: string; count: number }>;
+    res.json({ timeseries: results });
+  });
+
+  // Breakdown query
+  router.post("/breakdown", authenticate, (req: Request, res: Response): void => {
+    const tenantId = req.user!.tenantId;
+    const { eventName, property, startDate, endDate, filters } = req.body;
+
+    if (!eventName || !property) {
+      res.status(400).json({ error: "eventName and property are required" });
+      return;
+    }
+
+    let sql = `SELECT json_extract(properties, ?) as value, COUNT(*) as count FROM events WHERE tenant_id = ? AND name = ?`;
+    const params: unknown[] = [`$.${property}`, tenantId, eventName];
+
+    if (startDate) {
+      sql += " AND timestamp >= ?";
+      params.push(startDate);
+    }
+
+    if (endDate) {
+      sql += " AND timestamp <= ?";
+      params.push(endDate);
+    }
+
+    if (filters && typeof filters === "object") {
+      for (const [key, value] of Object.entries(filters)) {
+        sql += " AND json_extract(properties, ?) = ?";
+        params.push(`$.${key}`, value);
+      }
+    }
+
+    sql += " GROUP BY value ORDER BY count DESC";
+
+    const results = db.prepare(sql).all(...params) as Array<{ value: string; count: number }>;
+    res.json({ breakdown: results });
+  });
+
+  return router;
+}
diff --git a/src/routes/users.ts b/src/routes/users.ts
new file mode 100644
index 0000000..e74e1b0
--- /dev/null
+++ b/src/routes/users.ts
@@ -0,0 +1,136 @@
+import { Router, Request, Response } from "express";
+import Database from "better-sqlite3";
+import { v4 as uuidv4 } from "uuid";
+import {
+  hashPassword,
+  verifyPassword,
+  generateToken,
+  authenticate,
+  requireRole,
+} from "../auth.js";
+
+export function createUserRoutes(db: Database.Database): Router {
+  const router = Router();
+
+  // Register
+  router.post("/register", (req: Request, res: Response): void => {
+    const { email, password, tenantId, role } = req.body;
+
+    if (!email || !password || !tenantId) {
+      res.status(400).json({ error: "email, password, and tenantId are required" });
+      return;
+    }
+
+    const existing = db.prepare("SELECT id FROM users WHERE email = ?").get(email);
+    if (existing) {
+      res.status(409).json({ error: "Email already registered" });
+      return;
+    }
+
+    const id = uuidv4();
+    const passwordHash = hashPassword(password);
+    const userRole = role && ["admin", "editor", "viewer"].includes(role) ? role : "viewer";
+
+    db.prepare(
+      "INSERT INTO users (id, email, password_hash, tenant_id, role) VALUES (?, ?, ?, ?, ?)"
+    ).run(id, email, passwordHash, tenantId, userRole);
+
+    const token = generateToken({ userId: id, email, tenantId, role: userRole });
+
+    res.status(201).json({
+      user: { id, email, tenantId, role: userRole },
+      token,
+    });
+  });
+
+  // Login
+  router.post("/login", (req: Request, res: Response): void => {
+    const { email, password } = req.body;
+
+    if (!email || !password) {
+      res.status(400).json({ error: "email and password are required" });
+      return;
+    }
+
+    const user = db
+      .prepare("SELECT id, email, password_hash, tenant_id, role FROM users WHERE email = ?")
+      .get(email) as
+      | { id: string; email: string; password_hash: string; tenant_id: string; role: string }
+      | undefined;
+
+    if (!user || !verifyPassword(password, user.password_hash)) {
+      res.status(401).json({ error: "Invalid email or password" });
+      return;
+    }
+
+    const token = generateToken({
+      userId: user.id,
+      email: user.email,
+      tenantId: user.tenant_id,
+      role: user.role,
+    });
+
+    res.json({
+      user: { id: user.id, email: user.email, tenantId: user.tenant_id, role: user.role },
+      token,
+    });
+  });
+
+  // Get profile
+  router.get("/profile", authenticate, (req: Request, res: Response): void => {
+    const user = db
+      .prepare("SELECT id, email, tenant_id, role, created_at FROM users WHERE id = ?")
+      .get(req.user!.userId) as
+      | { id: string; email: string; tenant_id: string; role: string; created_at: string }
+      | undefined;
+
+    if (!user) {
+      res.status(404).json({ error: "User not found" });
+      return;
+    }
+
+    res.json({
+      id: user.id,
+      email: user.email,
+      tenantId: user.tenant_id,
+      role: user.role,
+      createdAt: user.created_at,
+    });
+  });
+
+  // Update user role (admin only)
+  router.put(
+    "/:userId/role",
+    authenticate,
+    requireRole("admin"),
+    (req: Request, res: Response): void => {
+      const { userId } = req.params;
+      const { role } = req.body;
+
+      if (!role || !["admin", "editor", "viewer"].includes(role)) {
+        res.status(400).json({ error: "Valid role is required (admin, editor, viewer)" });
+        return;
+      }
+
+      const target = db
+        .prepare("SELECT id, tenant_id FROM users WHERE id = ?")
+        .get(userId) as { id: string; tenant_id: string } | undefined;
+
+      if (!target) {
+        res.status(404).json({ error: "User not found" });
+        return;
+      }
+
+      if (target.tenant_id !== req.user!.tenantId) {
+        res.status(403).json({ error: "Cannot modify users in other tenants" });
+        return;
+      }
+
+      db.prepare("UPDATE users SET role = ? WHERE id = ?").run(role, userId);
+
+      res.json({ id: userId, role });
+    }
+  );
+
+  return router;
+}
