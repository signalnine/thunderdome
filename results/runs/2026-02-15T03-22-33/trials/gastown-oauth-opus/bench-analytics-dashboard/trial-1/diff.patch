diff --git a/.thunderdome-metrics.json b/.thunderdome-metrics.json
new file mode 100644
index 0000000..b4e7794
--- /dev/null
+++ b/.thunderdome-metrics.json
@@ -0,0 +1,158 @@
+{
+  "input_tokens": 411,
+  "output_tokens": 63558,
+  "cache_read_tokens": 4947797,
+  "cache_creation_tokens": 184845,
+  "turns": 221,
+  "tools_used": [
+    "Read",
+    "Bash",
+    "TodoWrite",
+    "Write",
+    "Edit",
+    "Glob",
+    "Grep"
+  ],
+  "duration_ms": 649000,
+  "total_cost_usd": 5.307,
+  "gastown_meta": {
+    "strategy": "parallel",
+    "polecat_count": 4,
+    "roles": {
+      "mayor": {
+        "input_tokens": 3,
+        "output_tokens": 1208,
+        "cache_read_tokens": 7687,
+        "cache_creation_tokens": 1156,
+        "turns": 1,
+        "tools_used": [],
+        "duration_ms": 21924,
+        "total_cost_usd": 0.04128350000000001
+      },
+      "polecat-0": {
+        "input_tokens": 33,
+        "output_tokens": 10417,
+        "cache_read_tokens": 778324,
+        "cache_creation_tokens": 20334,
+        "turns": 38,
+        "tools_used": [
+          "Read",
+          "Bash",
+          "TodoWrite",
+          "Write",
+          "Edit"
+        ],
+        "duration_ms": 165401,
+        "total_cost_usd": 0.7900305000000002
+      },
+      "polecat-1": {
+        "input_tokens": 30,
+        "output_tokens": 8997,
+        "cache_read_tokens": 653067,
+        "cache_creation_tokens": 16212,
+        "turns": 38,
+        "tools_used": [
+          "Read",
+          "Glob",
+          "Bash",
+          "TodoWrite",
+          "Write"
+        ],
+        "duration_ms": 160086,
+        "total_cost_usd": 0.6694274999999998
+      },
+      "polecat-2": {
+        "input_tokens": 34,
+        "output_tokens": 14850,
+        "cache_read_tokens": 863581,
+        "cache_creation_tokens": 23173,
+        "turns": 39,
+        "tools_used": [
+          "Read",
+          "Glob",
+          "Bash",
+          "TodoWrite",
+          "Write"
+        ],
+        "duration_ms": 231599,
+        "total_cost_usd": 0.96975575
+      },
+      "polecat-3": {
+        "input_tokens": 31,
+        "output_tokens": 9519,
+        "cache_read_tokens": 687633,
+        "cache_creation_tokens": 16976,
+        "turns": 36,
+        "tools_used": [
+          "Read",
+          "Glob",
+          "Bash",
+          "TodoWrite",
+          "Write"
+        ],
+        "duration_ms": 183074,
+        "total_cost_usd": 0.7046545000000002
+      },
+      "refinery-fixup": {
+        "input_tokens": 259,
+        "output_tokens": 8520,
+        "cache_read_tokens": 1573847,
+        "cache_creation_tokens": 38520,
+        "turns": 51,
+        "tools_used": [
+          "Bash",
+          "Read",
+          "Edit",
+          "Glob"
+        ],
+        "duration_ms": 223757,
+        "total_cost_usd": 1.2543895
+      },
+      "refinery-merge-1": {
+        "input_tokens": 7,
+        "output_tokens": 1547,
+        "cache_read_tokens": 110659,
+        "cache_creation_tokens": 14743,
+        "turns": 6,
+        "tools_used": [
+          "Read",
+          "Glob",
+          "TodoWrite",
+          "Write"
+        ],
+        "duration_ms": 28784,
+        "total_cost_usd": 0.18712025
+      },
+      "refinery-merge-2": {
+        "input_tokens": 7,
+        "output_tokens": 4919,
+        "cache_read_tokens": 143918,
+        "cache_creation_tokens": 34449,
+        "turns": 6,
+        "tools_used": [
+          "TodoWrite",
+          "Read",
+          "Write"
+        ],
+        "duration_ms": 62798,
+        "total_cost_usd": 0.41111725
+      },
+      "refinery-merge-3": {
+        "input_tokens": 7,
+        "output_tokens": 3581,
+        "cache_read_tokens": 129081,
+        "cache_creation_tokens": 19282,
+        "turns": 6,
+        "tools_used": [
+          "Read",
+          "Glob",
+          "Write",
+          "Grep",
+          "Bash"
+        ],
+        "duration_ms": 56288,
+        "total_cost_usd": 0.2789020000000001
+      }
+    }
+  }
+}
\ No newline at end of file
diff --git a/analytics.db b/analytics.db
new file mode 100644
index 0000000..b3b6531
Binary files /dev/null and b/analytics.db differ
diff --git a/package-lock.json b/package-lock.json
index 16cc798..53f6fc4 100644
--- a/package-lock.json
+++ b/package-lock.json
@@ -22,12 +22,84 @@
         "@types/uuid": "^10.0.0",
         "@typescript-eslint/eslint-plugin": "^7.0.0",
         "@typescript-eslint/parser": "^7.0.0",
+        "@vitest/coverage-v8": "^2.0.0",
         "eslint": "^8.56.0",
         "supertest": "^7.0.0",
         "typescript": "^5.4.0",
         "vitest": "^2.0.0"
       }
     },
+    "node_modules/@ampproject/remapping": {
+      "version": "2.3.0",
+      "resolved": "https://registry.npmjs.org/@ampproject/remapping/-/remapping-2.3.0.tgz",
+      "integrity": "sha512-30iZtAPgz+LTIYoeivqYo853f02jBYSd5uGnGpkFV0M3xOt9aN73erkgYAmZU43x4VfqcnLxW9Kpg3R5LC4YYw==",
+      "dev": true,
+      "license": "Apache-2.0",
+      "dependencies": {
+        "@jridgewell/gen-mapping": "^0.3.5",
+        "@jridgewell/trace-mapping": "^0.3.24"
+      },
+      "engines": {
+        "node": ">=6.0.0"
+      }
+    },
+    "node_modules/@babel/helper-string-parser": {
+      "version": "7.27.1",
+      "resolved": "https://registry.npmjs.org/@babel/helper-string-parser/-/helper-string-parser-7.27.1.tgz",
+      "integrity": "sha512-qMlSxKbpRlAridDExk92nSobyDdpPijUq2DW6oDnUqd0iOGxmQjyqhMIihI9+zv4LPyZdRje2cavWPbCbWm3eA==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=6.9.0"
+      }
+    },
+    "node_modules/@babel/helper-validator-identifier": {
+      "version": "7.28.5",
+      "resolved": "https://registry.npmjs.org/@babel/helper-validator-identifier/-/helper-validator-identifier-7.28.5.tgz",
+      "integrity": "sha512-qSs4ifwzKJSV39ucNjsvc6WVHs6b7S03sOh2OcHF9UHfVPqWWALUsNUVzhSBiItjRZoLHx7nIarVjqKVusUZ1Q==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=6.9.0"
+      }
+    },
+    "node_modules/@babel/parser": {
+      "version": "7.29.0",
+      "resolved": "https://registry.npmjs.org/@babel/parser/-/parser-7.29.0.tgz",
+      "integrity": "sha512-IyDgFV5GeDUVX4YdF/3CPULtVGSXXMLh1xVIgdCgxApktqnQV0r7/8Nqthg+8YLGaAtdyIlo2qIdZrbCv4+7ww==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@babel/types": "^7.29.0"
+      },
+      "bin": {
+        "parser": "bin/babel-parser.js"
+      },
+      "engines": {
+        "node": ">=6.0.0"
+      }
+    },
+    "node_modules/@babel/types": {
+      "version": "7.29.0",
+      "resolved": "https://registry.npmjs.org/@babel/types/-/types-7.29.0.tgz",
+      "integrity": "sha512-LwdZHpScM4Qz8Xw2iKSzS+cfglZzJGvofQICy7W7v4caru4EaAmyUuO6BGrbyQ2mYV11W0U8j5mBhd14dd3B0A==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@babel/helper-string-parser": "^7.27.1",
+        "@babel/helper-validator-identifier": "^7.28.5"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      }
+    },
+    "node_modules/@bcoe/v8-coverage": {
+      "version": "0.2.3",
+      "resolved": "https://registry.npmjs.org/@bcoe/v8-coverage/-/v8-coverage-0.2.3.tgz",
+      "integrity": "sha512-0hYQ8SB4Db5zvZB4axdMHGwEaQjkZzFjQiN9LVYvIFB2nSUHW9tYpxWriPrWDASIxiaXax83REcLxuSdnGPZtw==",
+      "dev": true,
+      "license": "MIT"
+    },
     "node_modules/@esbuild/aix-ppc64": {
       "version": "0.21.5",
       "resolved": "https://registry.npmjs.org/@esbuild/aix-ppc64/-/aix-ppc64-0.21.5.tgz",
@@ -568,6 +640,84 @@
       "dev": true,
       "license": "BSD-3-Clause"
     },
+    "node_modules/@isaacs/cliui": {
+      "version": "8.0.2",
+      "resolved": "https://registry.npmjs.org/@isaacs/cliui/-/cliui-8.0.2.tgz",
+      "integrity": "sha512-O8jcjabXaleOG9DQ0+ARXWZBTfnP4WNAqzuiJK7ll44AmxGKv/J2M4TPjxjY3znBCfvBXFzucm1twdyFybFqEA==",
+      "dev": true,
+      "license": "ISC",
+      "dependencies": {
+        "string-width": "^5.1.2",
+        "string-width-cjs": "npm:string-width@^4.2.0",
+        "strip-ansi": "^7.0.1",
+        "strip-ansi-cjs": "npm:strip-ansi@^6.0.1",
+        "wrap-ansi": "^8.1.0",
+        "wrap-ansi-cjs": "npm:wrap-ansi@^7.0.0"
+      },
+      "engines": {
+        "node": ">=12"
+      }
+    },
+    "node_modules/@isaacs/cliui/node_modules/ansi-regex": {
+      "version": "6.2.2",
+      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-6.2.2.tgz",
+      "integrity": "sha512-Bq3SmSpyFHaWjPk8If9yc6svM8c56dB5BAtW4Qbw5jHTwwXXcTLoRMkpDJp6VL0XzlWaCHTXrkFURMYmD0sLqg==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/ansi-regex?sponsor=1"
+      }
+    },
+    "node_modules/@isaacs/cliui/node_modules/strip-ansi": {
+      "version": "7.1.2",
+      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-7.1.2.tgz",
+      "integrity": "sha512-gmBGslpoQJtgnMAvOVqGZpEz9dyoKTCzy2nfz/n8aIFhN/jCE/rCmcxabB6jOOHV+0WNnylOxaxBQPSvcWklhA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "ansi-regex": "^6.0.1"
+      },
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/strip-ansi?sponsor=1"
+      }
+    },
+    "node_modules/@istanbuljs/schema": {
+      "version": "0.1.3",
+      "resolved": "https://registry.npmjs.org/@istanbuljs/schema/-/schema-0.1.3.tgz",
+      "integrity": "sha512-ZXRY4jNvVgSVQ8DL3LTcakaAtXwTVUxE81hslsyD2AtoXW/wVob10HkOJ1X/pAlcI7D+2YoZKg5do8G/w6RYgA==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/@jridgewell/gen-mapping": {
+      "version": "0.3.13",
+      "resolved": "https://registry.npmjs.org/@jridgewell/gen-mapping/-/gen-mapping-0.3.13.tgz",
+      "integrity": "sha512-2kkt/7niJ6MgEPxF0bYdQ6etZaA+fQvDcLKckhy1yIQOzaoKjBBjSj63/aLVjYE3qhRt5dvM+uUyfCg6UKCBbA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@jridgewell/sourcemap-codec": "^1.5.0",
+        "@jridgewell/trace-mapping": "^0.3.24"
+      }
+    },
+    "node_modules/@jridgewell/resolve-uri": {
+      "version": "3.1.2",
+      "resolved": "https://registry.npmjs.org/@jridgewell/resolve-uri/-/resolve-uri-3.1.2.tgz",
+      "integrity": "sha512-bRISgCIjP20/tbWSPWMEi54QVPRZExkuD9lJL+UIxUKtwVJA8wW1Trb1jMs1RFXo1CBTNZ/5hpC9QvmKWdopKw==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=6.0.0"
+      }
+    },
     "node_modules/@jridgewell/sourcemap-codec": {
       "version": "1.5.5",
       "resolved": "https://registry.npmjs.org/@jridgewell/sourcemap-codec/-/sourcemap-codec-1.5.5.tgz",
@@ -575,6 +725,17 @@
       "dev": true,
       "license": "MIT"
     },
+    "node_modules/@jridgewell/trace-mapping": {
+      "version": "0.3.31",
+      "resolved": "https://registry.npmjs.org/@jridgewell/trace-mapping/-/trace-mapping-0.3.31.tgz",
+      "integrity": "sha512-zzNR+SdQSDJzc8joaeP8QQoCQr8NuYx2dIIytl1QeBEZHJ9uW6hebsrYgbz8hJwUQao3TWCMtmfV8Nu1twOLAw==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@jridgewell/resolve-uri": "^3.1.0",
+        "@jridgewell/sourcemap-codec": "^1.4.14"
+      }
+    },
     "node_modules/@noble/hashes": {
       "version": "1.8.0",
       "resolved": "https://registry.npmjs.org/@noble/hashes/-/hashes-1.8.0.tgz",
@@ -636,6 +797,17 @@
         "@noble/hashes": "^1.1.5"
       }
     },
+    "node_modules/@pkgjs/parseargs": {
+      "version": "0.11.0",
+      "resolved": "https://registry.npmjs.org/@pkgjs/parseargs/-/parseargs-0.11.0.tgz",
+      "integrity": "sha512-+1VkjdD0QBLPodGrJUeqarH8VAIvQODIbwh9XpP5Syisf7YoQgsJKPNFoqqLQlu+VQ/tVSshMR6loPMn8U+dPg==",
+      "dev": true,
+      "license": "MIT",
+      "optional": true,
+      "engines": {
+        "node": ">=14"
+      }
+    },
     "node_modules/@rollup/rollup-android-arm-eabi": {
       "version": "4.57.1",
       "resolved": "https://registry.npmjs.org/@rollup/rollup-android-arm-eabi/-/rollup-android-arm-eabi-4.57.1.tgz",
@@ -1102,7 +1274,6 @@
       "integrity": "sha512-m0jEgYlYz+mDJZ2+F4v8D1AyQb+QzsNqRuI7xg1VQX/KlKS0qT9r1Mo16yo5F/MtifXFgaofIFsdFMox2SxIbQ==",
       "dev": true,
       "license": "MIT",
-      "peer": true,
       "dependencies": {
         "undici-types": "~7.16.0"
       }
@@ -1225,7 +1396,6 @@
       "integrity": "sha512-4Z+L8I2OqhZV8qA132M4wNL30ypZGYOQVBfMgxDH/K5UX0PNqTu1c6za9ST5r9+tavvHiTWmBnKzpCJ/GlVFtg==",
       "dev": true,
       "license": "BSD-2-Clause",
-      "peer": true,
       "dependencies": {
         "@typescript-eslint/scope-manager": "7.18.0",
         "@typescript-eslint/types": "7.18.0",
@@ -1386,6 +1556,39 @@
       "dev": true,
       "license": "ISC"
     },
+    "node_modules/@vitest/coverage-v8": {
+      "version": "2.1.9",
+      "resolved": "https://registry.npmjs.org/@vitest/coverage-v8/-/coverage-v8-2.1.9.tgz",
+      "integrity": "sha512-Z2cOr0ksM00MpEfyVE8KXIYPEcBFxdbLSs56L8PO0QQMxt/6bDj45uQfxoc96v05KW3clk7vvgP0qfDit9DmfQ==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@ampproject/remapping": "^2.3.0",
+        "@bcoe/v8-coverage": "^0.2.3",
+        "debug": "^4.3.7",
+        "istanbul-lib-coverage": "^3.2.2",
+        "istanbul-lib-report": "^3.0.1",
+        "istanbul-lib-source-maps": "^5.0.6",
+        "istanbul-reports": "^3.1.7",
+        "magic-string": "^0.30.12",
+        "magicast": "^0.3.5",
+        "std-env": "^3.8.0",
+        "test-exclude": "^7.0.1",
+        "tinyrainbow": "^1.2.0"
+      },
+      "funding": {
+        "url": "https://opencollective.com/vitest"
+      },
+      "peerDependencies": {
+        "@vitest/browser": "2.1.9",
+        "vitest": "2.1.9"
+      },
+      "peerDependenciesMeta": {
+        "@vitest/browser": {
+          "optional": true
+        }
+      }
+    },
     "node_modules/@vitest/expect": {
       "version": "2.1.9",
       "resolved": "https://registry.npmjs.org/@vitest/expect/-/expect-2.1.9.tgz",
@@ -1518,7 +1721,6 @@
       "integrity": "sha512-NZyJarBfL7nWwIq+FDL6Zp/yHEhePMNnnJ0y3qfieCrmNvYct8uvtiV41UvlSe6apAfk0fY1FbWx+NwfmpvtTg==",
       "dev": true,
       "license": "MIT",
-      "peer": true,
       "bin": {
         "acorn": "bin/acorn"
       },
@@ -2140,6 +2342,13 @@
         "node": ">= 0.4"
       }
     },
+    "node_modules/eastasianwidth": {
+      "version": "0.2.0",
+      "resolved": "https://registry.npmjs.org/eastasianwidth/-/eastasianwidth-0.2.0.tgz",
+      "integrity": "sha512-I88TYZWc9XiYHRQ4/3c5rjjfgkjhLyW2luGIheGERbNQ6OY7yTybanSpDXZa8y7VUP9YmDcYa+eyq4ca7iLqWA==",
+      "dev": true,
+      "license": "MIT"
+    },
     "node_modules/ecdsa-sig-formatter": {
       "version": "1.0.11",
       "resolved": "https://registry.npmjs.org/ecdsa-sig-formatter/-/ecdsa-sig-formatter-1.0.11.tgz",
@@ -2155,6 +2364,13 @@
       "integrity": "sha512-WMwm9LhRUo+WUaRN+vRuETqG89IgZphVSNkdFgeb6sS/E4OrDIN7t48CAewSHXc6C8lefD8KKfr5vY61brQlow==",
       "license": "MIT"
     },
+    "node_modules/emoji-regex": {
+      "version": "9.2.2",
+      "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-9.2.2.tgz",
+      "integrity": "sha512-L18DaJsXSUk2+42pv8mLs5jJT2hqFkFE4j21wOmgbUqsZ2hL72NsUU785g9RXgo3s0ZNgVl42TiHp3ZtOv/Vyg==",
+      "dev": true,
+      "license": "MIT"
+    },
     "node_modules/encodeurl": {
       "version": "2.0.0",
       "resolved": "https://registry.npmjs.org/encodeurl/-/encodeurl-2.0.0.tgz",
@@ -2291,7 +2507,6 @@
       "deprecated": "This version is no longer supported. Please see https://eslint.org/version-support for other options.",
       "dev": true,
       "license": "MIT",
-      "peer": true,
       "dependencies": {
         "@eslint-community/eslint-utils": "^4.2.0",
         "@eslint-community/regexpp": "^4.6.1",
@@ -2731,6 +2946,23 @@
       "dev": true,
       "license": "ISC"
     },
+    "node_modules/foreground-child": {
+      "version": "3.3.1",
+      "resolved": "https://registry.npmjs.org/foreground-child/-/foreground-child-3.3.1.tgz",
+      "integrity": "sha512-gIXjKqtFuWEgzFRJA9WCQeSJLZDjgJUOMCMzxtvFq/37KojM1BFGufqsCy0r4qSQmYLsZYMeyRqzIWOMup03sw==",
+      "dev": true,
+      "license": "ISC",
+      "dependencies": {
+        "cross-spawn": "^7.0.6",
+        "signal-exit": "^4.0.1"
+      },
+      "engines": {
+        "node": ">=14"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/isaacs"
+      }
+    },
     "node_modules/form-data": {
       "version": "4.0.5",
       "resolved": "https://registry.npmjs.org/form-data/-/form-data-4.0.5.tgz",
@@ -3029,6 +3261,13 @@
         "node": ">= 0.4"
       }
     },
+    "node_modules/html-escaper": {
+      "version": "2.0.2",
+      "resolved": "https://registry.npmjs.org/html-escaper/-/html-escaper-2.0.2.tgz",
+      "integrity": "sha512-H2iMtd0I4Mt5eYiapRdIDjp+XzelXQ0tFE4JS7YFwFevXXMmOp9myNrUvCg0D6ws8iqkRPBfKHgbwig1SmlLfg==",
+      "dev": true,
+      "license": "MIT"
+    },
     "node_modules/http-errors": {
       "version": "2.0.1",
       "resolved": "https://registry.npmjs.org/http-errors/-/http-errors-2.0.1.tgz",
@@ -3161,6 +3400,16 @@
         "node": ">=0.10.0"
       }
     },
+    "node_modules/is-fullwidth-code-point": {
+      "version": "3.0.0",
+      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/is-fullwidth-code-point-3.0.0.tgz",
+      "integrity": "sha512-zymm5+u+sCsSWyD9qNaejV3DFvhCKclKdizYaJUuHA83RLjb7nSuGnddCHGv0hk+KY7BMAlsWeK4Ueg6EV6XQg==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=8"
+      }
+    },
     "node_modules/is-glob": {
       "version": "4.0.3",
       "resolved": "https://registry.npmjs.org/is-glob/-/is-glob-4.0.3.tgz",
@@ -3201,6 +3450,76 @@
       "dev": true,
       "license": "ISC"
     },
+    "node_modules/istanbul-lib-coverage": {
+      "version": "3.2.2",
+      "resolved": "https://registry.npmjs.org/istanbul-lib-coverage/-/istanbul-lib-coverage-3.2.2.tgz",
+      "integrity": "sha512-O8dpsF+r0WV/8MNRKfnmrtCWhuKjxrq2w+jpzBL5UZKTi2LeVWnWOmWRxFlesJONmc+wLAGvKQZEOanko0LFTg==",
+      "dev": true,
+      "license": "BSD-3-Clause",
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/istanbul-lib-report": {
+      "version": "3.0.1",
+      "resolved": "https://registry.npmjs.org/istanbul-lib-report/-/istanbul-lib-report-3.0.1.tgz",
+      "integrity": "sha512-GCfE1mtsHGOELCU8e/Z7YWzpmybrx/+dSTfLrvY8qRmaY6zXTKWn6WQIjaAFw069icm6GVMNkgu0NzI4iPZUNw==",
+      "dev": true,
+      "license": "BSD-3-Clause",
+      "dependencies": {
+        "istanbul-lib-coverage": "^3.0.0",
+        "make-dir": "^4.0.0",
+        "supports-color": "^7.1.0"
+      },
+      "engines": {
+        "node": ">=10"
+      }
+    },
+    "node_modules/istanbul-lib-source-maps": {
+      "version": "5.0.6",
+      "resolved": "https://registry.npmjs.org/istanbul-lib-source-maps/-/istanbul-lib-source-maps-5.0.6.tgz",
+      "integrity": "sha512-yg2d+Em4KizZC5niWhQaIomgf5WlL4vOOjZ5xGCmF8SnPE/mDWWXgvRExdcpCgh9lLRRa1/fSYp2ymmbJ1pI+A==",
+      "dev": true,
+      "license": "BSD-3-Clause",
+      "dependencies": {
+        "@jridgewell/trace-mapping": "^0.3.23",
+        "debug": "^4.1.1",
+        "istanbul-lib-coverage": "^3.0.0"
+      },
+      "engines": {
+        "node": ">=10"
+      }
+    },
+    "node_modules/istanbul-reports": {
+      "version": "3.2.0",
+      "resolved": "https://registry.npmjs.org/istanbul-reports/-/istanbul-reports-3.2.0.tgz",
+      "integrity": "sha512-HGYWWS/ehqTV3xN10i23tkPkpH46MLCIMFNCaaKNavAXTF1RkqxawEPtnjnGZ6XKSInBKkiOA5BKS+aZiY3AvA==",
+      "dev": true,
+      "license": "BSD-3-Clause",
+      "dependencies": {
+        "html-escaper": "^2.0.0",
+        "istanbul-lib-report": "^3.0.0"
+      },
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/jackspeak": {
+      "version": "3.4.3",
+      "resolved": "https://registry.npmjs.org/jackspeak/-/jackspeak-3.4.3.tgz",
+      "integrity": "sha512-OGlZQpz2yfahA/Rd1Y8Cd9SIEsqvXkLVoSw/cgwhnhFMDbsQFeZYoJJ7bIZBS9BcamUW96asq/npPWugM+RQBw==",
+      "dev": true,
+      "license": "BlueOak-1.0.0",
+      "dependencies": {
+        "@isaacs/cliui": "^8.0.2"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/isaacs"
+      },
+      "optionalDependencies": {
+        "@pkgjs/parseargs": "^0.11.0"
+      }
+    },
     "node_modules/js-yaml": {
       "version": "4.1.1",
       "resolved": "https://registry.npmjs.org/js-yaml/-/js-yaml-4.1.1.tgz",
@@ -3374,6 +3693,13 @@
       "dev": true,
       "license": "MIT"
     },
+    "node_modules/lru-cache": {
+      "version": "10.4.3",
+      "resolved": "https://registry.npmjs.org/lru-cache/-/lru-cache-10.4.3.tgz",
+      "integrity": "sha512-JNAzZcXrCt42VGLuYz0zfAzDfAvJWW6AfYlDBQyDV5DClI2m5sAmK+OIO7s59XfsRsWHp02jAJrRadPRGTt6SQ==",
+      "dev": true,
+      "license": "ISC"
+    },
     "node_modules/magic-string": {
       "version": "0.30.21",
       "resolved": "https://registry.npmjs.org/magic-string/-/magic-string-0.30.21.tgz",
@@ -3384,6 +3710,34 @@
         "@jridgewell/sourcemap-codec": "^1.5.5"
       }
     },
+    "node_modules/magicast": {
+      "version": "0.3.5",
+      "resolved": "https://registry.npmjs.org/magicast/-/magicast-0.3.5.tgz",
+      "integrity": "sha512-L0WhttDl+2BOsybvEOLK7fW3UA0OQ0IQ2d6Zl2x/a6vVRs3bAY0ECOSHHeL5jD+SbOpOCUEi0y1DgHEn9Qn1AQ==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@babel/parser": "^7.25.4",
+        "@babel/types": "^7.25.4",
+        "source-map-js": "^1.2.0"
+      }
+    },
+    "node_modules/make-dir": {
+      "version": "4.0.0",
+      "resolved": "https://registry.npmjs.org/make-dir/-/make-dir-4.0.0.tgz",
+      "integrity": "sha512-hXdUTZYIVOt1Ex//jAQi+wTZZpUpwBj/0QsOzqegb3rGMMeJiSEu5xLHnYfBrRV4RH2+OCSOO95Is/7x1WJ4bw==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "semver": "^7.5.3"
+      },
+      "engines": {
+        "node": ">=10"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/sindresorhus"
+      }
+    },
     "node_modules/math-intrinsics": {
       "version": "1.1.0",
       "resolved": "https://registry.npmjs.org/math-intrinsics/-/math-intrinsics-1.1.0.tgz",
@@ -3514,6 +3868,16 @@
         "url": "https://github.com/sponsors/ljharb"
       }
     },
+    "node_modules/minipass": {
+      "version": "7.1.2",
+      "resolved": "https://registry.npmjs.org/minipass/-/minipass-7.1.2.tgz",
+      "integrity": "sha512-qOOzS1cBTWYF4BH8fVePDBOO9iptMnGUEZwNc/cMWnTV2nVLZ7VoNWEPHkYczZA0pdoA7dl6e7FL659nX9S2aw==",
+      "dev": true,
+      "license": "ISC",
+      "engines": {
+        "node": ">=16 || 14 >=14.17"
+      }
+    },
     "node_modules/mkdirp-classic": {
       "version": "0.5.3",
       "resolved": "https://registry.npmjs.org/mkdirp-classic/-/mkdirp-classic-0.5.3.tgz",
@@ -3662,6 +4026,13 @@
         "url": "https://github.com/sponsors/sindresorhus"
       }
     },
+    "node_modules/package-json-from-dist": {
+      "version": "1.0.1",
+      "resolved": "https://registry.npmjs.org/package-json-from-dist/-/package-json-from-dist-1.0.1.tgz",
+      "integrity": "sha512-UEZIS3/by4OC8vL3P2dTXRETpebLI2NiI5vIrjaD/5UtrkFX/tNbwjTSRAGC/+7CAo2pIcBaRgWmcBBHcsaCIw==",
+      "dev": true,
+      "license": "BlueOak-1.0.0"
+    },
     "node_modules/parent-module": {
       "version": "1.0.1",
       "resolved": "https://registry.npmjs.org/parent-module/-/parent-module-1.0.1.tgz",
@@ -3714,6 +4085,23 @@
         "node": ">=8"
       }
     },
+    "node_modules/path-scurry": {
+      "version": "1.11.1",
+      "resolved": "https://registry.npmjs.org/path-scurry/-/path-scurry-1.11.1.tgz",
+      "integrity": "sha512-Xa4Nw17FS9ApQFJ9umLiJS4orGjm7ZzwUrwamcGQuHSzDyth9boKDaycYdDcZDuqYATXw4HFXgaqWTctW/v1HA==",
+      "dev": true,
+      "license": "BlueOak-1.0.0",
+      "dependencies": {
+        "lru-cache": "^10.2.0",
+        "minipass": "^5.0.0 || ^6.0.2 || ^7.0.0"
+      },
+      "engines": {
+        "node": ">=16 || 14 >=14.18"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/isaacs"
+      }
+    },
     "node_modules/path-to-regexp": {
       "version": "0.1.12",
       "resolved": "https://registry.npmjs.org/path-to-regexp/-/path-to-regexp-0.1.12.tgz",
@@ -4270,6 +4658,19 @@
       "dev": true,
       "license": "ISC"
     },
+    "node_modules/signal-exit": {
+      "version": "4.1.0",
+      "resolved": "https://registry.npmjs.org/signal-exit/-/signal-exit-4.1.0.tgz",
+      "integrity": "sha512-bzyZ1e88w9O1iNJbKnOlvYTrWPDl46O1bG0D3XInv+9tkPrxrN8jUUTiFlDkkmKWgn1M6CfIA13SuGqOa9Korw==",
+      "dev": true,
+      "license": "ISC",
+      "engines": {
+        "node": ">=14"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/isaacs"
+      }
+    },
     "node_modules/simple-concat": {
       "version": "1.0.1",
       "resolved": "https://registry.npmjs.org/simple-concat/-/simple-concat-1.0.1.tgz",
@@ -4367,6 +4768,76 @@
         "safe-buffer": "~5.2.0"
       }
     },
+    "node_modules/string-width": {
+      "version": "5.1.2",
+      "resolved": "https://registry.npmjs.org/string-width/-/string-width-5.1.2.tgz",
+      "integrity": "sha512-HnLOCR3vjcY8beoNLtcjZ5/nxn2afmME6lhrDrebokqMap+XbeW8n9TXpPDOqdGK5qcI3oT0GKTW6wC7EMiVqA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "eastasianwidth": "^0.2.0",
+        "emoji-regex": "^9.2.2",
+        "strip-ansi": "^7.0.1"
+      },
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/sindresorhus"
+      }
+    },
+    "node_modules/string-width-cjs": {
+      "name": "string-width",
+      "version": "4.2.3",
+      "resolved": "https://registry.npmjs.org/string-width/-/string-width-4.2.3.tgz",
+      "integrity": "sha512-wKyQRQpjJ0sIp62ErSZdGsjMJWsap5oRNihHhu6G7JVO/9jIB6UyevL+tXuOqrng8j/cxKTWyWUwvSTriiZz/g==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "emoji-regex": "^8.0.0",
+        "is-fullwidth-code-point": "^3.0.0",
+        "strip-ansi": "^6.0.1"
+      },
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/string-width-cjs/node_modules/emoji-regex": {
+      "version": "8.0.0",
+      "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-8.0.0.tgz",
+      "integrity": "sha512-MSjYzcWNOA0ewAHpz0MxpYFvwg6yjy1NG3xteoqz644VCo/RPgnr1/GGt+ic3iJTzQ8Eu3TdM14SawnVUmGE6A==",
+      "dev": true,
+      "license": "MIT"
+    },
+    "node_modules/string-width/node_modules/ansi-regex": {
+      "version": "6.2.2",
+      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-6.2.2.tgz",
+      "integrity": "sha512-Bq3SmSpyFHaWjPk8If9yc6svM8c56dB5BAtW4Qbw5jHTwwXXcTLoRMkpDJp6VL0XzlWaCHTXrkFURMYmD0sLqg==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/ansi-regex?sponsor=1"
+      }
+    },
+    "node_modules/string-width/node_modules/strip-ansi": {
+      "version": "7.1.2",
+      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-7.1.2.tgz",
+      "integrity": "sha512-gmBGslpoQJtgnMAvOVqGZpEz9dyoKTCzy2nfz/n8aIFhN/jCE/rCmcxabB6jOOHV+0WNnylOxaxBQPSvcWklhA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "ansi-regex": "^6.0.1"
+      },
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/strip-ansi?sponsor=1"
+      }
+    },
     "node_modules/strip-ansi": {
       "version": "6.0.1",
       "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-6.0.1.tgz",
@@ -4380,6 +4851,20 @@
         "node": ">=8"
       }
     },
+    "node_modules/strip-ansi-cjs": {
+      "name": "strip-ansi",
+      "version": "6.0.1",
+      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-6.0.1.tgz",
+      "integrity": "sha512-Y38VPSHcqkFrCpFnQ9vuSXmquuv5oXOKpGeT6aGrr3o3Gc9AlVa6JBfUSOCnbxGGZF+/0ooI7KrPuUSztUdU5A==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "ansi-regex": "^5.0.1"
+      },
+      "engines": {
+        "node": ">=8"
+      }
+    },
     "node_modules/strip-json-comments": {
       "version": "3.1.1",
       "resolved": "https://registry.npmjs.org/strip-json-comments/-/strip-json-comments-3.1.1.tgz",
@@ -4493,6 +4978,43 @@
         "node": ">=6"
       }
     },
+    "node_modules/test-exclude": {
+      "version": "7.0.1",
+      "resolved": "https://registry.npmjs.org/test-exclude/-/test-exclude-7.0.1.tgz",
+      "integrity": "sha512-pFYqmTw68LXVjeWJMST4+borgQP2AyMNbg1BpZh9LbyhUeNkeaPF9gzfPGUAnSMV3qPYdWUwDIjjCLiSDOl7vg==",
+      "dev": true,
+      "license": "ISC",
+      "dependencies": {
+        "@istanbuljs/schema": "^0.1.2",
+        "glob": "^10.4.1",
+        "minimatch": "^9.0.4"
+      },
+      "engines": {
+        "node": ">=18"
+      }
+    },
+    "node_modules/test-exclude/node_modules/glob": {
+      "version": "10.5.0",
+      "resolved": "https://registry.npmjs.org/glob/-/glob-10.5.0.tgz",
+      "integrity": "sha512-DfXN8DfhJ7NH3Oe7cFmu3NCu1wKbkReJ8TorzSAFbSKrlNaQSKfIzqYqVY8zlbs2NLBbWpRiU52GX2PbaBVNkg==",
+      "deprecated": "Old versions of glob are not supported, and contain widely publicized security vulnerabilities, which have been fixed in the current version. Please update. Support for old versions may be purchased (at exorbitant rates) by contacting i@izs.me",
+      "dev": true,
+      "license": "ISC",
+      "dependencies": {
+        "foreground-child": "^3.1.0",
+        "jackspeak": "^3.1.2",
+        "minimatch": "^9.0.4",
+        "minipass": "^7.1.2",
+        "package-json-from-dist": "^1.0.0",
+        "path-scurry": "^1.11.1"
+      },
+      "bin": {
+        "glob": "dist/esm/bin.mjs"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/isaacs"
+      }
+    },
     "node_modules/text-table": {
       "version": "0.2.0",
       "resolved": "https://registry.npmjs.org/text-table/-/text-table-0.2.0.tgz",
@@ -4636,7 +5158,6 @@
       "integrity": "sha512-jl1vZzPDinLr9eUt3J/t7V6FgNEw9QjvBPdysz9KfQDD41fQrC2Y4vKQdiaUpFT4bXlb1RHhLpp8wtm6M5TgSw==",
       "dev": true,
       "license": "Apache-2.0",
-      "peer": true,
       "bin": {
         "tsc": "bin/tsc",
         "tsserver": "bin/tsserver"
@@ -4900,6 +5421,107 @@
         "node": ">=0.10.0"
       }
     },
+    "node_modules/wrap-ansi": {
+      "version": "8.1.0",
+      "resolved": "https://registry.npmjs.org/wrap-ansi/-/wrap-ansi-8.1.0.tgz",
+      "integrity": "sha512-si7QWI6zUMq56bESFvagtmzMdGOtoxfR+Sez11Mobfc7tm+VkUckk9bW2UeffTGVUbOksxmSw0AA2gs8g71NCQ==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "ansi-styles": "^6.1.0",
+        "string-width": "^5.0.1",
+        "strip-ansi": "^7.0.1"
+      },
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/wrap-ansi?sponsor=1"
+      }
+    },
+    "node_modules/wrap-ansi-cjs": {
+      "name": "wrap-ansi",
+      "version": "7.0.0",
+      "resolved": "https://registry.npmjs.org/wrap-ansi/-/wrap-ansi-7.0.0.tgz",
+      "integrity": "sha512-YVGIj2kamLSTxw6NsZjoBxfSwsn0ycdesmc4p+Q21c5zPuZ1pl+NfxVdxPtdHvmNVOQ6XSYG4AUtyt/Fi7D16Q==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "ansi-styles": "^4.0.0",
+        "string-width": "^4.1.0",
+        "strip-ansi": "^6.0.0"
+      },
+      "engines": {
+        "node": ">=10"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/wrap-ansi?sponsor=1"
+      }
+    },
+    "node_modules/wrap-ansi-cjs/node_modules/emoji-regex": {
+      "version": "8.0.0",
+      "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-8.0.0.tgz",
+      "integrity": "sha512-MSjYzcWNOA0ewAHpz0MxpYFvwg6yjy1NG3xteoqz644VCo/RPgnr1/GGt+ic3iJTzQ8Eu3TdM14SawnVUmGE6A==",
+      "dev": true,
+      "license": "MIT"
+    },
+    "node_modules/wrap-ansi-cjs/node_modules/string-width": {
+      "version": "4.2.3",
+      "resolved": "https://registry.npmjs.org/string-width/-/string-width-4.2.3.tgz",
+      "integrity": "sha512-wKyQRQpjJ0sIp62ErSZdGsjMJWsap5oRNihHhu6G7JVO/9jIB6UyevL+tXuOqrng8j/cxKTWyWUwvSTriiZz/g==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "emoji-regex": "^8.0.0",
+        "is-fullwidth-code-point": "^3.0.0",
+        "strip-ansi": "^6.0.1"
+      },
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/wrap-ansi/node_modules/ansi-regex": {
+      "version": "6.2.2",
+      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-6.2.2.tgz",
+      "integrity": "sha512-Bq3SmSpyFHaWjPk8If9yc6svM8c56dB5BAtW4Qbw5jHTwwXXcTLoRMkpDJp6VL0XzlWaCHTXrkFURMYmD0sLqg==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/ansi-regex?sponsor=1"
+      }
+    },
+    "node_modules/wrap-ansi/node_modules/ansi-styles": {
+      "version": "6.2.3",
+      "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-6.2.3.tgz",
+      "integrity": "sha512-4Dj6M28JB+oAH8kFkTLUo+a2jwOFkuqb3yucU0CANcRRUbxS0cP0nZYCGjcc3BNXwRIsUVmDGgzawme7zvJHvg==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/ansi-styles?sponsor=1"
+      }
+    },
+    "node_modules/wrap-ansi/node_modules/strip-ansi": {
+      "version": "7.1.2",
+      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-7.1.2.tgz",
+      "integrity": "sha512-gmBGslpoQJtgnMAvOVqGZpEz9dyoKTCzy2nfz/n8aIFhN/jCE/rCmcxabB6jOOHV+0WNnylOxaxBQPSvcWklhA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "ansi-regex": "^6.0.1"
+      },
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/strip-ansi?sponsor=1"
+      }
+    },
     "node_modules/wrappy": {
       "version": "1.0.2",
       "resolved": "https://registry.npmjs.org/wrappy/-/wrappy-1.0.2.tgz",
diff --git a/src/app.ts b/src/app.ts
new file mode 100644
index 0000000..4dfdd42
--- /dev/null
+++ b/src/app.ts
@@ -0,0 +1,32 @@
+import express from 'express';
+import { getDb } from './db.js';
+import authRoutes from './routes/auth.js';
+import eventRoutes from './routes/events.js';
+import queryRoutes from './routes/queries.js';
+import dashboardRoutes from './routes/dashboards.js';
+import exportRoutes from './routes/export.js';
+import { createUsersRouter } from './routes/users.js';
+
+export function createApp(): express.Express {
+  const app = express();
+
+  app.use(express.json());
+
+  // Initialize database
+  getDb();
+
+  // Routes
+  app.use('/api/auth', authRoutes);
+  app.use('/api/events', eventRoutes);
+  app.use('/api/queries', queryRoutes);
+  app.use('/api/dashboards', dashboardRoutes);
+  app.use('/api/export', exportRoutes);
+  app.use('/api/users', createUsersRouter(getDb()));
+
+  // Health check
+  app.get('/health', (_req, res) => {
+    res.json({ status: 'ok' });
+  });
+
+  return app;
+}
diff --git a/src/db.ts b/src/db.ts
new file mode 100644
index 0000000..091e581
--- /dev/null
+++ b/src/db.ts
@@ -0,0 +1,42 @@
+import Database from 'better-sqlite3';
+import path from 'node:path';
+import fs from 'node:fs';
+
+let db: Database.Database | null = null;
+
+export function getDb(): Database.Database {
+  if (!db) {
+    const dbPath = process.env.DB_PATH || path.join(process.cwd(), 'analytics.db');
+    db = new Database(dbPath);
+    db.pragma('journal_mode = WAL');
+    db.pragma('foreign_keys = ON');
+    initializeSchema(db);
+  }
+  return db;
+}
+
+function initializeSchema(database: Database.Database): void {
+  const schemaPath = path.join(process.cwd(), 'schema.sql');
+  if (fs.existsSync(schemaPath)) {
+    const schema = fs.readFileSync(schemaPath, 'utf-8');
+    database.exec(schema);
+  }
+}
+
+export function resetDb(): void {
+  if (db) {
+    const dbPath = (db as unknown as { name: string }).name;
+    db.close();
+    db = null;
+    if (dbPath && dbPath !== ':memory:') {
+      try { fs.unlinkSync(dbPath); } catch { /* ignore */ }
+    }
+  }
+}
+
+export function closeDb(): void {
+  if (db) {
+    db.close();
+    db = null;
+  }
+}
diff --git a/src/index.ts b/src/index.ts
new file mode 100644
index 0000000..1385629
--- /dev/null
+++ b/src/index.ts
@@ -0,0 +1,12 @@
+import { createApp } from './app.js';
+
+export { createApp };
+
+const port = process.env.PORT || 3000;
+
+if (process.env.NODE_ENV !== 'test') {
+  const app = createApp();
+  app.listen(port, () => {
+    console.log(`Server running on port ${port}`);
+  });
+}
diff --git a/src/middleware/auth.ts b/src/middleware/auth.ts
new file mode 100644
index 0000000..443fe4e
--- /dev/null
+++ b/src/middleware/auth.ts
@@ -0,0 +1,54 @@
+import { Request, Response, NextFunction } from 'express';
+import jwt from 'jsonwebtoken';
+
+const JWT_SECRET = process.env.JWT_SECRET || 'default-secret-key';
+
+export interface AuthUser {
+  userId: string;
+  email?: string;
+  tenantId: string;
+  role: string;
+}
+
+export interface AuthRequest extends Request {
+  user?: AuthUser;
+}
+
+export function authenticate(req: AuthRequest, res: Response, next: NextFunction): void {
+  const authHeader = req.headers.authorization;
+  if (!authHeader || !authHeader.startsWith('Bearer ')) {
+    res.status(401).json({ error: 'Authentication required' });
+    return;
+  }
+
+  const token = authHeader.slice(7);
+  try {
+    const payload = jwt.verify(token, JWT_SECRET) as AuthUser;
+    req.user = {
+      userId: payload.userId,
+      email: payload.email,
+      tenantId: payload.tenantId,
+      role: payload.role,
+    };
+    next();
+  } catch {
+    res.status(401).json({ error: 'Invalid or expired token' });
+  }
+}
+
+export function requireRole(...roles: string[]) {
+  return (req: AuthRequest, res: Response, next: NextFunction): void => {
+    const user = req.user;
+    if (!user || !roles.includes(user.role)) {
+      res.status(403).json({ error: 'Insufficient permissions' });
+      return;
+    }
+    next();
+  };
+}
+
+export function generateToken(user: AuthUser): string {
+  return jwt.sign(user, JWT_SECRET, { expiresIn: '24h' });
+}
+
+export { JWT_SECRET };
diff --git a/src/routes/auth.ts b/src/routes/auth.ts
new file mode 100644
index 0000000..24084e0
--- /dev/null
+++ b/src/routes/auth.ts
@@ -0,0 +1,134 @@
+import { Router, Request, Response } from 'express';
+import { getDb } from '../db.js';
+import { v4 as uuidv4 } from 'uuid';
+import { AuthRequest, authenticate, generateToken } from '../middleware/auth.js';
+import crypto from 'node:crypto';
+
+const router = Router();
+
+function hashPassword(password: string): string {
+  return crypto.createHash('sha256').update(password).digest('hex');
+}
+
+// POST /api/auth/register
+router.post('/register', (req: Request, res: Response): void => {
+  try {
+    const { email, password, tenant_id, tenantId, role } = req.body;
+
+    if (!email || !password) {
+      res.status(400).json({ error: 'email and password are required' });
+      return;
+    }
+
+    const resolvedTenantId = tenant_id || tenantId || uuidv4();
+    const id = uuidv4();
+    const passwordHash = hashPassword(password);
+    const userRole = role || 'admin';
+
+    const db = getDb();
+    db.prepare(
+      `INSERT INTO users (id, email, password_hash, tenant_id, role) VALUES (?, ?, ?, ?, ?)`
+    ).run(id, email, passwordHash, resolvedTenantId, userRole);
+
+    const token = generateToken({ userId: id, email, tenantId: resolvedTenantId, role: userRole });
+
+    res.status(201).json({
+      user: { id, email, tenant_id: resolvedTenantId, role: userRole },
+      token,
+    });
+  } catch (err: unknown) {
+    if (err instanceof Error && err.message.includes('UNIQUE')) {
+      res.status(409).json({ error: 'Email already exists' });
+      return;
+    }
+    res.status(500).json({ error: 'Registration failed', details: String(err) });
+  }
+});
+
+// POST /api/auth/login
+router.post('/login', (req: Request, res: Response): void => {
+  try {
+    const { email, password } = req.body;
+
+    if (!email || !password) {
+      res.status(400).json({ error: 'email and password are required' });
+      return;
+    }
+
+    const db = getDb();
+    const user = db.prepare('SELECT * FROM users WHERE email = ?').get(email) as {
+      id: string; email: string; password_hash: string; tenant_id: string; role: string;
+    } | undefined;
+
+    if (!user || user.password_hash !== hashPassword(password)) {
+      res.status(401).json({ error: 'Invalid credentials' });
+      return;
+    }
+
+    const token = generateToken({ userId: user.id, email: user.email, tenantId: user.tenant_id, role: user.role });
+
+    res.json({
+      user: { id: user.id, email: user.email, tenant_id: user.tenant_id, role: user.role },
+      token,
+    });
+  } catch (err) {
+    res.status(500).json({ error: 'Login failed', details: String(err) });
+  }
+});
+
+// GET /api/auth/me - get current user profile
+router.get('/me', authenticate, (req: AuthRequest, res: Response): void => {
+  try {
+    const user = req.user!;
+    const db = getDb();
+    const row = db.prepare('SELECT id, email, tenant_id, role, created_at FROM users WHERE id = ?').get(user.userId) as {
+      id: string; email: string; tenant_id: string; role: string; created_at: string;
+    } | undefined;
+
+    if (!row) {
+      res.status(404).json({ error: 'User not found' });
+      return;
+    }
+
+    res.json(row);
+  } catch (err) {
+    res.status(500).json({ error: 'Failed to get profile', details: String(err) });
+  }
+});
+
+// PUT /api/auth/users/:id/role - change user role (admin only)
+router.put('/users/:id/role', authenticate, (req: AuthRequest, res: Response): void => {
+  try {
+    const currentUser = req.user!;
+    if (currentUser.role !== 'admin') {
+      res.status(403).json({ error: 'Admin access required' });
+      return;
+    }
+
+    const { role } = req.body;
+    if (!role || !['admin', 'editor', 'viewer'].includes(role)) {
+      res.status(400).json({ error: 'Invalid role. Must be admin, editor, or viewer' });
+      return;
+    }
+
+    const db = getDb();
+    const targetUser = db.prepare('SELECT * FROM users WHERE id = ? AND tenant_id = ?').get(req.params.id, currentUser.tenantId) as { id: string } | undefined;
+
+    if (!targetUser) {
+      res.status(404).json({ error: 'User not found' });
+      return;
+    }
+
+    db.prepare('UPDATE users SET role = ? WHERE id = ?').run(role, req.params.id);
+
+    const updated = db.prepare('SELECT id, email, tenant_id, role, created_at FROM users WHERE id = ?').get(req.params.id) as {
+      id: string; email: string; tenant_id: string; role: string; created_at: string;
+    };
+
+    res.json(updated);
+  } catch (err) {
+    res.status(500).json({ error: 'Failed to update role', details: String(err) });
+  }
+});
+
+export default router;
diff --git a/src/routes/dashboards.ts b/src/routes/dashboards.ts
new file mode 100644
index 0000000..a81287d
--- /dev/null
+++ b/src/routes/dashboards.ts
@@ -0,0 +1,154 @@
+import { Router, Response } from 'express';
+import { AuthRequest, authenticate } from '../middleware/auth.js';
+import { getDb } from '../db.js';
+import { v4 as uuidv4 } from 'uuid';
+
+const router = Router();
+
+interface DashboardRow {
+  id: string;
+  tenant_id: string;
+  name: string;
+  owner_id: string;
+  config: string;
+  created_at: string;
+  updated_at: string;
+}
+
+function formatDashboard(row: DashboardRow) {
+  let config: unknown = {};
+  try {
+    config = JSON.parse(row.config);
+  } catch {
+    config = {};
+  }
+  return {
+    id: row.id,
+    tenant_id: row.tenant_id,
+    name: row.name,
+    description: (config as Record<string, unknown>).description || '',
+    owner_id: row.owner_id,
+    config,
+    created_at: row.created_at,
+    updated_at: row.updated_at,
+  };
+}
+
+// POST /api/dashboards - create dashboard
+router.post('/', authenticate, (req: AuthRequest, res: Response): void => {
+  try {
+    const user = req.user!;
+    const { name, description, config } = req.body;
+
+    if (!name) {
+      res.status(400).json({ error: 'name is required' });
+      return;
+    }
+
+    const id = uuidv4();
+    const now = new Date().toISOString();
+    const dashConfig = JSON.stringify({ description: description || '', ...(config || {}) });
+
+    const db = getDb();
+    db.prepare(
+      `INSERT INTO dashboards (id, tenant_id, name, owner_id, config, created_at, updated_at)
+       VALUES (?, ?, ?, ?, ?, ?, ?)`
+    ).run(id, user.tenantId, name, user.userId, dashConfig, now, now);
+
+    const row = db.prepare('SELECT * FROM dashboards WHERE id = ?').get(id) as DashboardRow;
+    res.status(201).json(formatDashboard(row));
+  } catch (err) {
+    res.status(500).json({ error: 'Failed to create dashboard', details: String(err) });
+  }
+});
+
+// GET /api/dashboards - list tenant dashboards
+router.get('/', authenticate, (req: AuthRequest, res: Response): void => {
+  try {
+    const user = req.user!;
+    const db = getDb();
+    const rows = db.prepare('SELECT * FROM dashboards WHERE tenant_id = ? ORDER BY created_at DESC').all(user.tenantId) as DashboardRow[];
+
+    res.json(rows.map(formatDashboard));
+  } catch (err) {
+    res.status(500).json({ error: 'Failed to list dashboards', details: String(err) });
+  }
+});
+
+// GET /api/dashboards/:id - get single dashboard
+router.get('/:id', authenticate, (req: AuthRequest, res: Response): void => {
+  try {
+    const user = req.user!;
+    const db = getDb();
+    const row = db.prepare('SELECT * FROM dashboards WHERE id = ? AND tenant_id = ?').get(req.params.id, user.tenantId) as DashboardRow | undefined;
+
+    if (!row) {
+      res.status(404).json({ error: 'Dashboard not found' });
+      return;
+    }
+
+    res.json(formatDashboard(row));
+  } catch (err) {
+    res.status(500).json({ error: 'Failed to get dashboard', details: String(err) });
+  }
+});
+
+// PUT /api/dashboards/:id - update dashboard
+router.put('/:id', authenticate, (req: AuthRequest, res: Response): void => {
+  try {
+    const user = req.user!;
+    const db = getDb();
+    const existing = db.prepare('SELECT * FROM dashboards WHERE id = ? AND tenant_id = ?').get(req.params.id, user.tenantId) as DashboardRow | undefined;
+
+    if (!existing) {
+      res.status(404).json({ error: 'Dashboard not found' });
+      return;
+    }
+
+    const { name, description, config } = req.body;
+    const now = new Date().toISOString();
+
+    let existingConfig: Record<string, unknown> = {};
+    try {
+      existingConfig = JSON.parse(existing.config) as Record<string, unknown>;
+    } catch {
+      // ignore parse errors
+    }
+
+    const updatedConfig = JSON.stringify({
+      ...existingConfig,
+      ...(config || {}),
+      ...(description !== undefined ? { description } : {}),
+    });
+
+    db.prepare(
+      `UPDATE dashboards SET name = ?, config = ?, updated_at = ? WHERE id = ? AND tenant_id = ?`
+    ).run(name || existing.name, updatedConfig, now, req.params.id, user.tenantId);
+
+    const row = db.prepare('SELECT * FROM dashboards WHERE id = ?').get(req.params.id) as DashboardRow;
+    res.json(formatDashboard(row));
+  } catch (err) {
+    res.status(500).json({ error: 'Failed to update dashboard', details: String(err) });
+  }
+});
+
+// DELETE /api/dashboards/:id - delete dashboard
+router.delete('/:id', authenticate, (req: AuthRequest, res: Response): void => {
+  try {
+    const user = req.user!;
+    const db = getDb();
+    const existing = db.prepare('SELECT * FROM dashboards WHERE id = ? AND tenant_id = ?').get(req.params.id, user.tenantId) as DashboardRow | undefined;
+
+    if (!existing) {
+      res.status(404).json({ error: 'Dashboard not found' });
+      return;
+    }
+
+    db.prepare('DELETE FROM dashboards WHERE id = ? AND tenant_id = ?').run(req.params.id, user.tenantId);
+    res.status(204).send();
+  } catch (err) {
+    res.status(500).json({ error: 'Failed to delete dashboard', details: String(err) });
+  }
+});
+
+export default router;
diff --git a/src/routes/events.ts b/src/routes/events.ts
new file mode 100644
index 0000000..2fa7d18
--- /dev/null
+++ b/src/routes/events.ts
@@ -0,0 +1,91 @@
+import { Router, Response } from 'express';
+import { AuthRequest, authenticate } from '../middleware/auth.js';
+import { getDb } from '../db.js';
+import { v4 as uuidv4 } from 'uuid';
+
+const router = Router();
+
+// POST /api/events - ingest single event
+router.post('/', authenticate, (req: AuthRequest, res: Response): void => {
+  try {
+    const user = req.user!;
+    const { name, properties, timestamp, session_id } = req.body;
+
+    if (!name || !String(name).trim()) {
+      res.status(400).json({ error: 'Event name is required' });
+      return;
+    }
+
+    const id = uuidv4();
+    const eventTimestamp = timestamp || new Date().toISOString();
+    const eventProperties = JSON.stringify(properties || {});
+
+    const db = getDb();
+    db.prepare(
+      `INSERT INTO events (id, tenant_id, name, properties, timestamp, user_id, session_id)
+       VALUES (?, ?, ?, ?, ?, ?, ?)`
+    ).run(id, user.tenantId, name, eventProperties, eventTimestamp, user.userId, session_id || null);
+
+    res.status(201).json({ id, tenantId: user.tenantId, userId: user.userId, name, properties: properties || {}, timestamp: eventTimestamp });
+  } catch (err) {
+    res.status(500).json({ error: 'Failed to ingest event', details: String(err) });
+  }
+});
+
+// POST /api/events/batch - ingest multiple events
+router.post('/batch', authenticate, (req: AuthRequest, res: Response): void => {
+  try {
+    const user = req.user!;
+    let events: unknown[];
+
+    // Accept both { events: [...] } and raw array formats
+    if (Array.isArray(req.body)) {
+      events = req.body;
+    } else if (req.body && typeof req.body === 'object' && Array.isArray(req.body.events)) {
+      events = req.body.events;
+    } else {
+      res.status(400).json({ error: 'events array is required and must not be empty' });
+      return;
+    }
+
+    if (events.length === 0) {
+      res.status(400).json({ error: 'events array is required and must not be empty' });
+      return;
+    }
+
+    // Validate all events before inserting
+    for (let i = 0; i < events.length; i++) {
+      const event = events[i] as Record<string, unknown>;
+      if (!event.name || !String(event.name).trim()) {
+        res.status(400).json({ error: `Event at index ${i} is missing a name` });
+        return;
+      }
+    }
+
+    const db = getDb();
+    const stmt = db.prepare(
+      `INSERT INTO events (id, tenant_id, name, properties, timestamp, user_id, session_id)
+       VALUES (?, ?, ?, ?, ?, ?, ?)`
+    );
+
+    const results: Array<{ id: string; name: string; tenantId: string; userId: string }> = [];
+
+    const insertAll = db.transaction(() => {
+      for (const event of events as Array<Record<string, unknown>>) {
+        const id = uuidv4();
+        const eventTimestamp = (event.timestamp as string) || new Date().toISOString();
+        const eventProperties = JSON.stringify(event.properties || {});
+        stmt.run(id, user.tenantId, event.name, eventProperties, eventTimestamp, user.userId, (event.session_id as string) || null);
+        results.push({ id, name: event.name as string, tenantId: user.tenantId, userId: user.userId });
+      }
+    });
+
+    insertAll();
+
+    res.status(201).json({ inserted: results.length, events: results });
+  } catch (err) {
+    res.status(500).json({ error: 'Failed to ingest events', details: String(err) });
+  }
+});
+
+export default router;
diff --git a/src/routes/export.test.ts b/src/routes/export.test.ts
new file mode 100644
index 0000000..a686fbc
--- /dev/null
+++ b/src/routes/export.test.ts
@@ -0,0 +1,174 @@
+import { describe, it, expect, beforeAll, afterAll } from 'vitest';
+import request from 'supertest';
+import jwt from 'jsonwebtoken';
+import { createApp } from '../app.js';
+import { getDb, closeDb, resetDb } from '../db.js';
+import { JWT_SECRET } from '../middleware/auth.js';
+import { v4 as uuidv4 } from 'uuid';
+import fs from 'node:fs';
+import path from 'node:path';
+
+function makeToken(user: { userId: string; email: string; tenantId: string; role: string }): string {
+  return jwt.sign(user, JWT_SECRET);
+}
+
+// Clean up any leftover DB file before starting
+resetDb();
+try { fs.unlinkSync(path.join(process.cwd(), 'analytics.db')); } catch { /* ignore */ }
+
+describe('Export endpoints', () => {
+  const app = createApp();
+  const tenantA = 'tenant-a';
+  const tenantB = 'tenant-b';
+  const userA = { userId: uuidv4(), email: 'a@test.com', tenantId: tenantA, role: 'admin' };
+  const userB = { userId: uuidv4(), email: 'b@test.com', tenantId: tenantB, role: 'admin' };
+  const tokenA = makeToken(userA);
+  const tokenB = makeToken(userB);
+
+  let dashboardIdA: string;
+
+  beforeAll(() => {
+    const db = getDb();
+
+    // Insert users
+    db.prepare('INSERT INTO users (id, email, password_hash, tenant_id, role) VALUES (?, ?, ?, ?, ?)').run(
+      userA.userId, userA.email, 'hash', tenantA, 'admin'
+    );
+    db.prepare('INSERT INTO users (id, email, password_hash, tenant_id, role) VALUES (?, ?, ?, ?, ?)').run(
+      userB.userId, userB.email, 'hash', tenantB, 'admin'
+    );
+
+    // Insert events for tenant A
+    db.prepare('INSERT INTO events (id, tenant_id, name, properties, timestamp, user_id) VALUES (?, ?, ?, ?, ?, ?)').run(
+      uuidv4(), tenantA, 'page_view', '{"url":"/home"}', '2024-01-01T00:00:00Z', userA.userId
+    );
+    db.prepare('INSERT INTO events (id, tenant_id, name, properties, timestamp, user_id) VALUES (?, ?, ?, ?, ?, ?)').run(
+      uuidv4(), tenantA, 'click', '{"button":"signup"}', '2024-01-02T00:00:00Z', userA.userId
+    );
+
+    // Insert events for tenant B
+    db.prepare('INSERT INTO events (id, tenant_id, name, properties, timestamp, user_id) VALUES (?, ?, ?, ?, ?, ?)').run(
+      uuidv4(), tenantB, 'page_view', '{"url":"/pricing"}', '2024-01-01T00:00:00Z', userB.userId
+    );
+
+    // Insert dashboard for tenant A
+    dashboardIdA = uuidv4();
+    db.prepare('INSERT INTO dashboards (id, tenant_id, name, owner_id, config) VALUES (?, ?, ?, ?, ?)').run(
+      dashboardIdA, tenantA, 'My Dashboard', userA.userId, '{"theme":"dark"}'
+    );
+
+    // Insert widget for dashboard A
+    db.prepare('INSERT INTO widgets (id, dashboard_id, type, config, position_x, position_y, width, height) VALUES (?, ?, ?, ?, ?, ?, ?, ?)').run(
+      uuidv4(), dashboardIdA, 'counter', '{"event":"page_view"}', 0, 0, 2, 1
+    );
+  });
+
+  afterAll(() => {
+    closeDb();
+  });
+
+  describe('GET /api/export/events', () => {
+    it('should return 401 without auth', async () => {
+      const res = await request(app).get('/api/export/events');
+      expect(res.status).toBe(401);
+    });
+
+    it('should export events as JSON', async () => {
+      const res = await request(app)
+        .get('/api/export/events?format=json')
+        .set('Authorization', `Bearer ${tokenA}`);
+      expect(res.status).toBe(200);
+      expect(res.headers['content-type']).toContain('application/json');
+      expect(res.headers['content-disposition']).toContain('events.json');
+      expect(Array.isArray(res.body)).toBe(true);
+      expect(res.body.length).toBe(2);
+      // All events should belong to tenant A
+      for (const event of res.body) {
+        expect(event.tenant_id).toBe(tenantA);
+      }
+    });
+
+    it('should export events as CSV', async () => {
+      const res = await request(app)
+        .get('/api/export/events?format=csv')
+        .set('Authorization', `Bearer ${tokenA}`);
+      expect(res.status).toBe(200);
+      expect(res.headers['content-type']).toContain('text/csv');
+      expect(res.headers['content-disposition']).toContain('events.csv');
+      const lines = res.text.split('\n');
+      // Header + 2 data rows
+      expect(lines.length).toBe(3);
+      expect(lines[0]).toBe('id,tenant_id,name,properties,timestamp,user_id,session_id');
+    });
+
+    it('should enforce tenant isolation', async () => {
+      const res = await request(app)
+        .get('/api/export/events?format=json')
+        .set('Authorization', `Bearer ${tokenB}`);
+      expect(res.status).toBe(200);
+      expect(res.body.length).toBe(1);
+      expect(res.body[0].tenant_id).toBe(tenantB);
+    });
+
+    it('should default to JSON when no format specified', async () => {
+      const res = await request(app)
+        .get('/api/export/events')
+        .set('Authorization', `Bearer ${tokenA}`);
+      expect(res.status).toBe(200);
+      expect(res.headers['content-type']).toContain('application/json');
+    });
+
+    it('should reject invalid format', async () => {
+      const res = await request(app)
+        .get('/api/export/events?format=xml')
+        .set('Authorization', `Bearer ${tokenA}`);
+      expect(res.status).toBe(400);
+    });
+  });
+
+  describe('GET /api/export/dashboards/:id', () => {
+    it('should return 401 without auth', async () => {
+      const res = await request(app).get(`/api/export/dashboards/${dashboardIdA}`);
+      expect(res.status).toBe(401);
+    });
+
+    it('should export dashboard as JSON', async () => {
+      const res = await request(app)
+        .get(`/api/export/dashboards/${dashboardIdA}?format=json`)
+        .set('Authorization', `Bearer ${tokenA}`);
+      expect(res.status).toBe(200);
+      expect(res.headers['content-type']).toContain('application/json');
+      expect(res.headers['content-disposition']).toContain(`dashboard-${dashboardIdA}.json`);
+      expect(res.body.id).toBe(dashboardIdA);
+      expect(res.body.name).toBe('My Dashboard');
+      expect(Array.isArray(res.body.widgets)).toBe(true);
+      expect(res.body.widgets.length).toBe(1);
+    });
+
+    it('should export dashboard as CSV', async () => {
+      const res = await request(app)
+        .get(`/api/export/dashboards/${dashboardIdA}?format=csv`)
+        .set('Authorization', `Bearer ${tokenA}`);
+      expect(res.status).toBe(200);
+      expect(res.headers['content-type']).toContain('text/csv');
+      expect(res.headers['content-disposition']).toContain(`dashboard-${dashboardIdA}.csv`);
+      // Should contain dashboard header and widget section
+      expect(res.text).toContain('id,tenant_id,name,owner_id,config,created_at,updated_at');
+      expect(res.text).toContain('id,dashboard_id,type,config,position_x,position_y,width,height');
+    });
+
+    it('should enforce tenant isolation - tenant B cannot access tenant A dashboard', async () => {
+      const res = await request(app)
+        .get(`/api/export/dashboards/${dashboardIdA}?format=json`)
+        .set('Authorization', `Bearer ${tokenB}`);
+      expect(res.status).toBe(404);
+    });
+
+    it('should return 404 for nonexistent dashboard', async () => {
+      const res = await request(app)
+        .get('/api/export/dashboards/nonexistent?format=json')
+        .set('Authorization', `Bearer ${tokenA}`);
+      expect(res.status).toBe(404);
+    });
+  });
+});
diff --git a/src/routes/export.ts b/src/routes/export.ts
new file mode 100644
index 0000000..12d7daf
--- /dev/null
+++ b/src/routes/export.ts
@@ -0,0 +1,112 @@
+import { Router, Response } from 'express';
+import { getDb } from '../db.js';
+import { authenticate, AuthRequest } from '../middleware/auth.js';
+
+const router = Router();
+
+// Helper: escape a value for CSV
+function csvEscape(value: unknown): string {
+  if (value === null || value === undefined) {
+    return '';
+  }
+  const str = String(value);
+  // If the value contains a comma, double-quote, or newline, wrap in quotes and escape inner quotes
+  if (str.includes(',') || str.includes('"') || str.includes('\n') || str.includes('\r')) {
+    return '"' + str.replace(/"/g, '""') + '"';
+  }
+  return str;
+}
+
+// Helper: convert array of objects to CSV string
+function toCsv(rows: Record<string, unknown>[], columns: string[]): string {
+  const header = columns.map(csvEscape).join(',');
+  const lines = rows.map(row =>
+    columns.map(col => csvEscape(row[col])).join(',')
+  );
+  return [header, ...lines].join('\n');
+}
+
+// GET /api/export/events?format=csv|json
+router.get('/events', authenticate, (req: AuthRequest, res: Response): void => {
+  const tenantId = req.user!.tenantId;
+  const format = (req.query.format as string || 'json').toLowerCase();
+
+  if (format !== 'csv' && format !== 'json') {
+    res.status(400).json({ error: 'Invalid format. Use csv or json.' });
+    return;
+  }
+
+  const db = getDb();
+  const events = db.prepare(
+    'SELECT id, tenant_id, name, properties, timestamp, user_id, session_id FROM events WHERE tenant_id = ? ORDER BY timestamp DESC'
+  ).all(tenantId) as Record<string, unknown>[];
+
+  if (format === 'csv') {
+    const columns = ['id', 'tenant_id', 'name', 'properties', 'timestamp', 'user_id', 'session_id'];
+    const csvContent = toCsv(events, columns);
+    res.setHeader('Content-Type', 'text/csv');
+    res.setHeader('Content-Disposition', 'attachment; filename="events.csv"');
+    res.send(csvContent);
+  } else {
+    res.setHeader('Content-Type', 'application/json');
+    res.setHeader('Content-Disposition', 'attachment; filename="events.json"');
+    res.json(events);
+  }
+});
+
+// GET /api/export/dashboards/:id?format=csv|json
+router.get('/dashboards/:id', authenticate, (req: AuthRequest, res: Response): void => {
+  const tenantId = req.user!.tenantId;
+  const dashboardId = req.params.id;
+  const format = (req.query.format as string || 'json').toLowerCase();
+
+  if (format !== 'csv' && format !== 'json') {
+    res.status(400).json({ error: 'Invalid format. Use csv or json.' });
+    return;
+  }
+
+  const db = getDb();
+
+  // Fetch the dashboard, enforcing tenant boundary
+  const dashboard = db.prepare(
+    'SELECT id, tenant_id, name, owner_id, config, created_at, updated_at FROM dashboards WHERE id = ? AND tenant_id = ?'
+  ).get(dashboardId, tenantId) as Record<string, unknown> | undefined;
+
+  if (!dashboard) {
+    res.status(404).json({ error: 'Dashboard not found' });
+    return;
+  }
+
+  // Fetch associated widgets
+  const widgets = db.prepare(
+    'SELECT id, dashboard_id, type, config, position_x, position_y, width, height FROM widgets WHERE dashboard_id = ?'
+  ).all(dashboardId) as Record<string, unknown>[];
+
+  if (format === 'csv') {
+    // For CSV, export dashboard info as a header section, then widgets
+    const dashboardColumns = ['id', 'tenant_id', 'name', 'owner_id', 'config', 'created_at', 'updated_at'];
+    const dashboardCsv = toCsv([dashboard], dashboardColumns);
+
+    let csvContent = dashboardCsv;
+
+    if (widgets.length > 0) {
+      const widgetColumns = ['id', 'dashboard_id', 'type', 'config', 'position_x', 'position_y', 'width', 'height'];
+      const widgetsCsv = toCsv(widgets, widgetColumns);
+      csvContent += '\n\n' + widgetsCsv;
+    }
+
+    res.setHeader('Content-Type', 'text/csv');
+    res.setHeader('Content-Disposition', `attachment; filename="dashboard-${dashboardId}.csv"`);
+    res.send(csvContent);
+  } else {
+    const result = {
+      ...dashboard,
+      widgets,
+    };
+    res.setHeader('Content-Type', 'application/json');
+    res.setHeader('Content-Disposition', `attachment; filename="dashboard-${dashboardId}.json"`);
+    res.json(result);
+  }
+});
+
+export default router;
diff --git a/src/routes/queries.ts b/src/routes/queries.ts
new file mode 100644
index 0000000..e325dd9
--- /dev/null
+++ b/src/routes/queries.ts
@@ -0,0 +1,179 @@
+import { Router, Response } from 'express';
+import { AuthRequest, authenticate } from '../middleware/auth.js';
+import { getDb } from '../db.js';
+
+const router = Router();
+
+interface PropertyFilter {
+  key: string;
+  operator?: 'eq' | 'neq' | 'contains' | 'gt' | 'lt' | 'gte' | 'lte' | 'exists' | 'not_exists';
+  value?: string | number | boolean;
+}
+
+interface QueryFilters {
+  event_name?: string;
+  event?: string;
+  name?: string;
+  properties?: PropertyFilter[];
+  filters?: PropertyFilter[];
+  start_date?: string;
+  from?: string;
+  end_date?: string;
+  to?: string;
+}
+
+function buildWhereClause(tenantId: string, filters: QueryFilters): { sql: string; params: (string | number)[] } {
+  const conditions: string[] = ['tenant_id = ?'];
+  const params: (string | number)[] = [tenantId];
+
+  const eventName = filters.event_name || filters.event || filters.name;
+  if (eventName) {
+    conditions.push('name = ?');
+    params.push(eventName);
+  }
+
+  const startDate = filters.start_date || filters.from;
+  if (startDate) {
+    conditions.push('timestamp >= ?');
+    params.push(startDate);
+  }
+
+  const endDate = filters.end_date || filters.to;
+  if (endDate) {
+    conditions.push('timestamp <= ?');
+    params.push(endDate);
+  }
+
+  const propFilters = filters.properties || filters.filters;
+  if (propFilters && Array.isArray(propFilters)) {
+    for (const filter of propFilters) {
+      const op = filter.operator || 'eq';
+      const jsonPath = `json_extract(properties, '$.${filter.key}')`;
+
+      switch (op) {
+        case 'eq':
+          conditions.push(`${jsonPath} = ?`);
+          params.push(String(filter.value));
+          break;
+        case 'neq':
+          conditions.push(`${jsonPath} != ?`);
+          params.push(String(filter.value));
+          break;
+        case 'contains':
+          conditions.push(`${jsonPath} LIKE ?`);
+          params.push(`%${String(filter.value)}%`);
+          break;
+        case 'gt':
+          conditions.push(`${jsonPath} > ?`);
+          params.push(Number(filter.value));
+          break;
+        case 'lt':
+          conditions.push(`${jsonPath} < ?`);
+          params.push(Number(filter.value));
+          break;
+        case 'gte':
+          conditions.push(`${jsonPath} >= ?`);
+          params.push(Number(filter.value));
+          break;
+        case 'lte':
+          conditions.push(`${jsonPath} <= ?`);
+          params.push(Number(filter.value));
+          break;
+        case 'exists':
+          conditions.push(`${jsonPath} IS NOT NULL`);
+          break;
+        case 'not_exists':
+          conditions.push(`${jsonPath} IS NULL`);
+          break;
+      }
+    }
+  }
+
+  return { sql: conditions.join(' AND '), params };
+}
+
+// POST /api/queries/count
+router.post('/count', authenticate, (req: AuthRequest, res: Response): void => {
+  try {
+    const user = req.user!;
+    const filters: QueryFilters = req.body;
+    const { sql, params } = buildWhereClause(user.tenantId, filters);
+
+    const db = getDb();
+    const result = db.prepare(`SELECT COUNT(*) as count FROM events WHERE ${sql}`).get(...params) as { count: number } | undefined;
+
+    res.json({ count: result?.count ?? 0 });
+  } catch (err) {
+    res.status(500).json({ error: 'Query failed', details: String(err) });
+  }
+});
+
+// POST /api/queries/timeseries
+router.post('/timeseries', authenticate, (req: AuthRequest, res: Response): void => {
+  try {
+    const user = req.user!;
+    const { interval, ...filters } = req.body as QueryFilters & { interval?: string; granularity?: string };
+    const granularity = req.body.granularity || interval || 'day';
+    const { sql, params } = buildWhereClause(user.tenantId, filters);
+
+    let dateFormat: string;
+    switch (granularity) {
+      case 'hour':
+        dateFormat = '%Y-%m-%dT%H:00:00';
+        break;
+      case 'week':
+        dateFormat = '%Y-W%W';
+        break;
+      case 'month':
+        dateFormat = '%Y-%m';
+        break;
+      case 'day':
+      default:
+        dateFormat = '%Y-%m-%d';
+        break;
+    }
+
+    const db = getDb();
+    const rows = db.prepare(
+      `SELECT strftime('${dateFormat}', timestamp) as period, COUNT(*) as count
+       FROM events
+       WHERE ${sql}
+       GROUP BY period
+       ORDER BY period ASC`
+    ).all(...params) as Array<{ period: string; count: number }>;
+
+    res.json({ data: rows, interval: granularity });
+  } catch (err) {
+    res.status(500).json({ error: 'Query failed', details: String(err) });
+  }
+});
+
+// POST /api/queries/breakdown
+router.post('/breakdown', authenticate, (req: AuthRequest, res: Response): void => {
+  try {
+    const user = req.user!;
+    const { property, ...filters } = req.body as QueryFilters & { property?: string };
+
+    if (!property) {
+      res.status(400).json({ error: 'property field is required' });
+      return;
+    }
+
+    const { sql, params } = buildWhereClause(user.tenantId, filters);
+
+    const db = getDb();
+    const rows = db.prepare(
+      `SELECT json_extract(properties, '$.' || ?) as value, COUNT(*) as count
+       FROM events
+       WHERE ${sql} AND json_extract(properties, '$.' || ?) IS NOT NULL
+       GROUP BY value
+       ORDER BY count DESC`
+    ).all(property, ...params, property) as Array<{ value: string; count: number }>;
+
+    res.json({ data: rows, property });
+  } catch (err) {
+    res.status(500).json({ error: 'Query failed', details: String(err) });
+  }
+});
+
+export default router;
diff --git a/src/routes/users.ts b/src/routes/users.ts
new file mode 100644
index 0000000..42303dd
--- /dev/null
+++ b/src/routes/users.ts
@@ -0,0 +1,50 @@
+import { Router, Request, Response } from "express";
+import Database from "better-sqlite3";
+import { authenticate, requireRole, AuthRequest } from "../middleware/auth.js";
+
+export function createUsersRouter(db: Database.Database): Router {
+  const router = Router();
+
+  // PUT /api/users/:id/role - admin-only role change within tenant
+  router.put(
+    "/:id/role",
+    authenticate,
+    requireRole("admin"),
+    (req: Request, res: Response): void => {
+      const authReq = req as AuthRequest;
+      const { id } = req.params;
+      const { role } = req.body as { role?: string };
+
+      if (!role || !["admin", "editor", "viewer"].includes(role)) {
+        res.status(400).json({ error: "Valid role is required (admin, editor, viewer)" });
+        return;
+      }
+
+      // Ensure the target user is in the same tenant
+      const targetUser = db.prepare(
+        "SELECT id, email, tenant_id, role FROM users WHERE id = ?"
+      ).get(id) as { id: string; email: string; tenant_id: string; role: string } | undefined;
+
+      if (!targetUser) {
+        res.status(404).json({ error: "User not found" });
+        return;
+      }
+
+      if (targetUser.tenant_id !== authReq.user!.tenantId) {
+        res.status(403).json({ error: "Cannot modify users outside your tenant" });
+        return;
+      }
+
+      db.prepare("UPDATE users SET role = ? WHERE id = ?").run(role, id);
+
+      res.json({
+        id: targetUser.id,
+        email: targetUser.email,
+        tenantId: targetUser.tenant_id,
+        role,
+      });
+    }
+  );
+
+  return router;
+}
diff --git a/tests/events.test.ts b/tests/events.test.ts
new file mode 100644
index 0000000..adb7782
--- /dev/null
+++ b/tests/events.test.ts
@@ -0,0 +1,204 @@
+import { describe, it, expect, beforeEach, afterEach } from "vitest";
+import request from "supertest";
+import { createApp } from "../src/app.js";
+import { generateToken } from "../src/middleware/auth.js";
+import { resetDb, closeDb } from "../src/db.js";
+
+describe("Events API", () => {
+  let app: ReturnType<typeof createApp>;
+  let token: string;
+
+  beforeEach(() => {
+    resetDb();
+    app = createApp();
+    token = generateToken({
+      userId: "user-1",
+      tenantId: "tenant-1",
+      role: "admin",
+    });
+  });
+
+  afterEach(() => {
+    closeDb();
+  });
+
+  describe("POST /api/events", () => {
+    it("should create a single event", async () => {
+      const res = await request(app)
+        .post("/api/events")
+        .set("Authorization", `Bearer ${token}`)
+        .send({ name: "page_view", properties: { url: "/home" } });
+
+      expect(res.status).toBe(201);
+      expect(res.body.id).toBeDefined();
+      expect(res.body.name).toBe("page_view");
+      expect(res.body.properties).toEqual({ url: "/home" });
+      expect(res.body.tenantId).toBe("tenant-1");
+      expect(res.body.userId).toBe("user-1");
+      expect(res.body.timestamp).toBeDefined();
+    });
+
+    it("should use provided timestamp", async () => {
+      const ts = "2024-01-15T10:00:00.000Z";
+      const res = await request(app)
+        .post("/api/events")
+        .set("Authorization", `Bearer ${token}`)
+        .send({ name: "click", timestamp: ts });
+
+      expect(res.status).toBe(201);
+      expect(res.body.timestamp).toBe(ts);
+    });
+
+    it("should default properties to empty object", async () => {
+      const res = await request(app)
+        .post("/api/events")
+        .set("Authorization", `Bearer ${token}`)
+        .send({ name: "page_view" });
+
+      expect(res.status).toBe(201);
+      expect(res.body.properties).toEqual({});
+    });
+
+    it("should reject missing name", async () => {
+      const res = await request(app)
+        .post("/api/events")
+        .set("Authorization", `Bearer ${token}`)
+        .send({ properties: { url: "/home" } });
+
+      expect(res.status).toBe(400);
+      expect(res.body.error).toBeDefined();
+    });
+
+    it("should reject empty name", async () => {
+      const res = await request(app)
+        .post("/api/events")
+        .set("Authorization", `Bearer ${token}`)
+        .send({ name: "  " });
+
+      expect(res.status).toBe(400);
+    });
+
+    it("should reject unauthenticated requests", async () => {
+      const res = await request(app)
+        .post("/api/events")
+        .send({ name: "page_view" });
+
+      expect(res.status).toBe(401);
+    });
+
+    it("should reject invalid token", async () => {
+      const res = await request(app)
+        .post("/api/events")
+        .set("Authorization", "Bearer invalid-token")
+        .send({ name: "page_view" });
+
+      expect(res.status).toBe(401);
+    });
+  });
+
+  describe("POST /api/events/batch", () => {
+    it("should create multiple events", async () => {
+      const events = [
+        { name: "page_view", properties: { url: "/home" } },
+        { name: "click", properties: { button: "signup" } },
+        { name: "form_submit" },
+      ];
+
+      const res = await request(app)
+        .post("/api/events/batch")
+        .set("Authorization", `Bearer ${token}`)
+        .send(events);
+
+      expect(res.status).toBe(201);
+      expect(res.body.inserted).toBe(3);
+      expect(res.body.events).toHaveLength(3);
+      expect(res.body.events[0].name).toBe("page_view");
+      expect(res.body.events[1].name).toBe("click");
+      expect(res.body.events[2].name).toBe("form_submit");
+      for (const event of res.body.events) {
+        expect(event.tenantId).toBe("tenant-1");
+        expect(event.userId).toBe("user-1");
+        expect(event.id).toBeDefined();
+      }
+    });
+
+    it("should accept { events: [...] } format", async () => {
+      const res = await request(app)
+        .post("/api/events/batch")
+        .set("Authorization", `Bearer ${token}`)
+        .send({
+          events: [
+            { name: "page_view" },
+            { name: "click" },
+          ],
+        });
+
+      expect(res.status).toBe(201);
+      expect(res.body.inserted).toBe(2);
+    });
+
+    it("should reject non-array body", async () => {
+      const res = await request(app)
+        .post("/api/events/batch")
+        .set("Authorization", `Bearer ${token}`)
+        .send({ name: "page_view" });
+
+      expect(res.status).toBe(400);
+    });
+
+    it("should reject empty array", async () => {
+      const res = await request(app)
+        .post("/api/events/batch")
+        .set("Authorization", `Bearer ${token}`)
+        .send([]);
+
+      expect(res.status).toBe(400);
+    });
+
+    it("should reject if any event is invalid", async () => {
+      const events = [
+        { name: "page_view" },
+        { properties: { url: "/about" } }, // missing name
+      ];
+
+      const res = await request(app)
+        .post("/api/events/batch")
+        .set("Authorization", `Bearer ${token}`)
+        .send(events);
+
+      expect(res.status).toBe(400);
+      expect(res.body.error).toContain("index 1");
+    });
+
+    it("should reject unauthenticated requests", async () => {
+      const res = await request(app)
+        .post("/api/events/batch")
+        .send([{ name: "page_view" }]);
+
+      expect(res.status).toBe(401);
+    });
+  });
+
+  describe("Tenant isolation", () => {
+    it("should associate events with the authenticated user's tenant", async () => {
+      const token2 = generateToken({
+        userId: "user-2",
+        tenantId: "tenant-2",
+        role: "viewer",
+      });
+
+      const res1 = await request(app)
+        .post("/api/events")
+        .set("Authorization", `Bearer ${token}`)
+        .send({ name: "event_t1" });
+
+      const res2 = await request(app)
+        .post("/api/events")
+        .set("Authorization", `Bearer ${token2}`)
+        .send({ name: "event_t2" });
+
+      expect(res1.body.tenantId).toBe("tenant-1");
+      expect(res2.body.tenantId).toBe("tenant-2");
+    });
+  });
+});
