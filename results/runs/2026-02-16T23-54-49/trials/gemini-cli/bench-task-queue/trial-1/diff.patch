diff --git a/.gemini-output.json b/.gemini-output.json
new file mode 100644
index 0000000..1dc953c
--- /dev/null
+++ b/.gemini-output.json
@@ -0,0 +1,122 @@
+{
+  "session_id": "d5956ce4-95bb-4ffd-a5c3-17978d72a149",
+  "response": "I have completed the task of building a fully-featured in-memory task queue system. The system successfully implements all 12 planned phases, including:\n- **Basic FIFO Queue** with unique task IDs and status tracking.\n- **Named Queues** for independent task management.\n- **Task Priority** (levels 1-10) for urgent task processing.\n- **Delayed and Scheduled Tasks** with precise availability timing.\n- **Automatic Retries with Exponential Backoff** for failed tasks.\n- **Dead Letter Queues** to capture permanently failed tasks.\n- **Task Dependencies** to manage complex task workflows.\n- **Concurrency Control** to limit active tasks per queue.\n- **Progress Tracking and Cancellation** for fine-grained task control.\n- **Recurring Tasks** using cron-like expressions.\n- **Middleware Pipeline** for task interception and transformation.\n- **Graceful Shutdown** with timeouts and cleanup callbacks.\n\nThe implementation is written in TypeScript, passes all 48 unit tests, and adheres to the project's linting and build standards.",
+  "stats": {
+    "models": {
+      "gemini-2.5-flash-lite": {
+        "api": {
+          "totalRequests": 1,
+          "totalErrors": 0,
+          "totalLatencyMs": 3004
+        },
+        "tokens": {
+          "input": 1497,
+          "prompt": 1497,
+          "candidates": 96,
+          "total": 1955,
+          "cached": 0,
+          "thoughts": 362,
+          "tool": 0
+        }
+      },
+      "gemini-3-flash-preview": {
+        "api": {
+          "totalRequests": 98,
+          "totalErrors": 4,
+          "totalLatencyMs": 531291
+        },
+        "tokens": {
+          "input": 399445,
+          "prompt": 3746472,
+          "candidates": 62118,
+          "total": 3822580,
+          "cached": 3347027,
+          "thoughts": 13990,
+          "tool": 0
+        }
+      },
+      "gemini-2.5-flash": {
+        "api": {
+          "totalRequests": 5,
+          "totalErrors": 0,
+          "totalLatencyMs": 20761
+        },
+        "tokens": {
+          "input": 69977,
+          "prompt": 69977,
+          "candidates": 618,
+          "total": 73599,
+          "cached": 0,
+          "thoughts": 3004,
+          "tool": 0
+        }
+      }
+    },
+    "tools": {
+      "totalCalls": 93,
+      "totalSuccess": 84,
+      "totalFail": 9,
+      "totalDurationMs": 53706,
+      "totalDecisions": {
+        "accept": 93,
+        "reject": 0,
+        "modify": 0,
+        "auto_accept": 0
+      },
+      "byName": {
+        "read_file": {
+          "count": 17,
+          "success": 17,
+          "fail": 0,
+          "durationMs": 28,
+          "decisions": {
+            "accept": 17,
+            "reject": 0,
+            "modify": 0,
+            "auto_accept": 0
+          }
+        },
+        "write_file": {
+          "count": 4,
+          "success": 4,
+          "fail": 0,
+          "durationMs": 30,
+          "decisions": {
+            "accept": 4,
+            "reject": 0,
+            "modify": 0,
+            "auto_accept": 0
+          }
+        },
+        "run_shell_command": {
+          "count": 24,
+          "success": 24,
+          "fail": 0,
+          "durationMs": 53448,
+          "decisions": {
+            "accept": 24,
+            "reject": 0,
+            "modify": 0,
+            "auto_accept": 0
+          }
+        },
+        "replace": {
+          "count": 48,
+          "success": 39,
+          "fail": 9,
+          "durationMs": 200,
+          "decisions": {
+            "accept": 48,
+            "reject": 0,
+            "modify": 0,
+            "auto_accept": 0
+          }
+        }
+      }
+    },
+    "files": {
+      "totalLinesAdded": 1208,
+      "totalLinesRemoved": 145
+    }
+  }
+}
\ No newline at end of file
diff --git a/.thunderdome-metrics.json b/.thunderdome-metrics.json
new file mode 100644
index 0000000..c5e4d6c
--- /dev/null
+++ b/.thunderdome-metrics.json
@@ -0,0 +1,10 @@
+{
+  "input_tokens": 470919,
+  "output_tokens": 62832,
+  "cache_read_tokens": 3347027,
+  "cache_creation_tokens": 0,
+  "thought_tokens": 17356,
+  "turns": 93,
+  "total_cost_usd": -1.662359,
+  "note": "google-one-oauth-no-actual-cost"
+}
\ No newline at end of file
diff --git a/.thunderdome-stderr.log b/.thunderdome-stderr.log
new file mode 100644
index 0000000..2bbcd31
--- /dev/null
+++ b/.thunderdome-stderr.log
@@ -0,0 +1,17 @@
+YOLO mode is enabled. All tool calls will be automatically approved.
+Loaded cached credentials.
+YOLO mode is enabled. All tool calls will be automatically approved.
+Hook registry initialized with 0 hook entries
+Attempt 1 failed: You have exhausted your capacity on this model. Your quota will reset after 0s.. Retrying after 278.895441ms...
+Attempt 1 failed: You have exhausted your capacity on this model. Your quota will reset after 0s.. Retrying after 541.482466ms...
+Attempt 1 failed: You have exhausted your capacity on this model. Your quota will reset after 0s.. Retrying after 708.947284ms...
+Error executing tool replace: Error: Failed to edit, could not find the string to replace.
+Error executing tool replace: Error: Failed to edit, could not find the string to replace.
+Error executing tool replace: Error: Failed to edit, could not find the string to replace.
+Error executing tool replace: Error: Failed to edit, could not find the string to replace.
+Error executing tool replace: Error: Failed to edit, could not find the string to replace.
+Error executing tool replace: Error: Failed to edit, could not find the string to replace.
+Error executing tool replace: Error: Failed to edit, could not find the string to replace.
+Error executing tool replace: Error: Failed to edit, could not find the string to replace.
+Attempt 1 failed: You have exhausted your capacity on this model. Your quota will reset after 0s.. Retrying after 63.784123ms...
+Error executing tool replace: Error: Failed to edit, could not find the string to replace.
diff --git a/package-lock.json b/package-lock.json
index 1d53f39..7bfdff3 100644
--- a/package-lock.json
+++ b/package-lock.json
@@ -11,11 +11,83 @@
         "@types/node": "^25.2.3",
         "@typescript-eslint/eslint-plugin": "^7.0.0",
         "@typescript-eslint/parser": "^7.0.0",
+        "@vitest/coverage-v8": "^2.0.0",
         "eslint": "^8.56.0",
         "typescript": "^5.4.0",
         "vitest": "^2.0.0"
       }
     },
+    "node_modules/@ampproject/remapping": {
+      "version": "2.3.0",
+      "resolved": "https://registry.npmjs.org/@ampproject/remapping/-/remapping-2.3.0.tgz",
+      "integrity": "sha512-30iZtAPgz+LTIYoeivqYo853f02jBYSd5uGnGpkFV0M3xOt9aN73erkgYAmZU43x4VfqcnLxW9Kpg3R5LC4YYw==",
+      "dev": true,
+      "license": "Apache-2.0",
+      "dependencies": {
+        "@jridgewell/gen-mapping": "^0.3.5",
+        "@jridgewell/trace-mapping": "^0.3.24"
+      },
+      "engines": {
+        "node": ">=6.0.0"
+      }
+    },
+    "node_modules/@babel/helper-string-parser": {
+      "version": "7.27.1",
+      "resolved": "https://registry.npmjs.org/@babel/helper-string-parser/-/helper-string-parser-7.27.1.tgz",
+      "integrity": "sha512-qMlSxKbpRlAridDExk92nSobyDdpPijUq2DW6oDnUqd0iOGxmQjyqhMIihI9+zv4LPyZdRje2cavWPbCbWm3eA==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=6.9.0"
+      }
+    },
+    "node_modules/@babel/helper-validator-identifier": {
+      "version": "7.28.5",
+      "resolved": "https://registry.npmjs.org/@babel/helper-validator-identifier/-/helper-validator-identifier-7.28.5.tgz",
+      "integrity": "sha512-qSs4ifwzKJSV39ucNjsvc6WVHs6b7S03sOh2OcHF9UHfVPqWWALUsNUVzhSBiItjRZoLHx7nIarVjqKVusUZ1Q==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=6.9.0"
+      }
+    },
+    "node_modules/@babel/parser": {
+      "version": "7.29.0",
+      "resolved": "https://registry.npmjs.org/@babel/parser/-/parser-7.29.0.tgz",
+      "integrity": "sha512-IyDgFV5GeDUVX4YdF/3CPULtVGSXXMLh1xVIgdCgxApktqnQV0r7/8Nqthg+8YLGaAtdyIlo2qIdZrbCv4+7ww==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@babel/types": "^7.29.0"
+      },
+      "bin": {
+        "parser": "bin/babel-parser.js"
+      },
+      "engines": {
+        "node": ">=6.0.0"
+      }
+    },
+    "node_modules/@babel/types": {
+      "version": "7.29.0",
+      "resolved": "https://registry.npmjs.org/@babel/types/-/types-7.29.0.tgz",
+      "integrity": "sha512-LwdZHpScM4Qz8Xw2iKSzS+cfglZzJGvofQICy7W7v4caru4EaAmyUuO6BGrbyQ2mYV11W0U8j5mBhd14dd3B0A==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@babel/helper-string-parser": "^7.27.1",
+        "@babel/helper-validator-identifier": "^7.28.5"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      }
+    },
+    "node_modules/@bcoe/v8-coverage": {
+      "version": "0.2.3",
+      "resolved": "https://registry.npmjs.org/@bcoe/v8-coverage/-/v8-coverage-0.2.3.tgz",
+      "integrity": "sha512-0hYQ8SB4Db5zvZB4axdMHGwEaQjkZzFjQiN9LVYvIFB2nSUHW9tYpxWriPrWDASIxiaXax83REcLxuSdnGPZtw==",
+      "dev": true,
+      "license": "MIT"
+    },
     "node_modules/@esbuild/aix-ppc64": {
       "version": "0.21.5",
       "resolved": "https://registry.npmjs.org/@esbuild/aix-ppc64/-/aix-ppc64-0.21.5.tgz",
@@ -556,6 +628,84 @@
       "dev": true,
       "license": "BSD-3-Clause"
     },
+    "node_modules/@isaacs/cliui": {
+      "version": "8.0.2",
+      "resolved": "https://registry.npmjs.org/@isaacs/cliui/-/cliui-8.0.2.tgz",
+      "integrity": "sha512-O8jcjabXaleOG9DQ0+ARXWZBTfnP4WNAqzuiJK7ll44AmxGKv/J2M4TPjxjY3znBCfvBXFzucm1twdyFybFqEA==",
+      "dev": true,
+      "license": "ISC",
+      "dependencies": {
+        "string-width": "^5.1.2",
+        "string-width-cjs": "npm:string-width@^4.2.0",
+        "strip-ansi": "^7.0.1",
+        "strip-ansi-cjs": "npm:strip-ansi@^6.0.1",
+        "wrap-ansi": "^8.1.0",
+        "wrap-ansi-cjs": "npm:wrap-ansi@^7.0.0"
+      },
+      "engines": {
+        "node": ">=12"
+      }
+    },
+    "node_modules/@isaacs/cliui/node_modules/ansi-regex": {
+      "version": "6.2.2",
+      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-6.2.2.tgz",
+      "integrity": "sha512-Bq3SmSpyFHaWjPk8If9yc6svM8c56dB5BAtW4Qbw5jHTwwXXcTLoRMkpDJp6VL0XzlWaCHTXrkFURMYmD0sLqg==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/ansi-regex?sponsor=1"
+      }
+    },
+    "node_modules/@isaacs/cliui/node_modules/strip-ansi": {
+      "version": "7.1.2",
+      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-7.1.2.tgz",
+      "integrity": "sha512-gmBGslpoQJtgnMAvOVqGZpEz9dyoKTCzy2nfz/n8aIFhN/jCE/rCmcxabB6jOOHV+0WNnylOxaxBQPSvcWklhA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "ansi-regex": "^6.0.1"
+      },
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/strip-ansi?sponsor=1"
+      }
+    },
+    "node_modules/@istanbuljs/schema": {
+      "version": "0.1.3",
+      "resolved": "https://registry.npmjs.org/@istanbuljs/schema/-/schema-0.1.3.tgz",
+      "integrity": "sha512-ZXRY4jNvVgSVQ8DL3LTcakaAtXwTVUxE81hslsyD2AtoXW/wVob10HkOJ1X/pAlcI7D+2YoZKg5do8G/w6RYgA==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/@jridgewell/gen-mapping": {
+      "version": "0.3.13",
+      "resolved": "https://registry.npmjs.org/@jridgewell/gen-mapping/-/gen-mapping-0.3.13.tgz",
+      "integrity": "sha512-2kkt/7niJ6MgEPxF0bYdQ6etZaA+fQvDcLKckhy1yIQOzaoKjBBjSj63/aLVjYE3qhRt5dvM+uUyfCg6UKCBbA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@jridgewell/sourcemap-codec": "^1.5.0",
+        "@jridgewell/trace-mapping": "^0.3.24"
+      }
+    },
+    "node_modules/@jridgewell/resolve-uri": {
+      "version": "3.1.2",
+      "resolved": "https://registry.npmjs.org/@jridgewell/resolve-uri/-/resolve-uri-3.1.2.tgz",
+      "integrity": "sha512-bRISgCIjP20/tbWSPWMEi54QVPRZExkuD9lJL+UIxUKtwVJA8wW1Trb1jMs1RFXo1CBTNZ/5hpC9QvmKWdopKw==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=6.0.0"
+      }
+    },
     "node_modules/@jridgewell/sourcemap-codec": {
       "version": "1.5.5",
       "resolved": "https://registry.npmjs.org/@jridgewell/sourcemap-codec/-/sourcemap-codec-1.5.5.tgz",
@@ -563,6 +713,17 @@
       "dev": true,
       "license": "MIT"
     },
+    "node_modules/@jridgewell/trace-mapping": {
+      "version": "0.3.31",
+      "resolved": "https://registry.npmjs.org/@jridgewell/trace-mapping/-/trace-mapping-0.3.31.tgz",
+      "integrity": "sha512-zzNR+SdQSDJzc8joaeP8QQoCQr8NuYx2dIIytl1QeBEZHJ9uW6hebsrYgbz8hJwUQao3TWCMtmfV8Nu1twOLAw==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@jridgewell/resolve-uri": "^3.1.0",
+        "@jridgewell/sourcemap-codec": "^1.4.14"
+      }
+    },
     "node_modules/@nodelib/fs.scandir": {
       "version": "2.1.5",
       "resolved": "https://registry.npmjs.org/@nodelib/fs.scandir/-/fs.scandir-2.1.5.tgz",
@@ -601,6 +762,17 @@
         "node": ">= 8"
       }
     },
+    "node_modules/@pkgjs/parseargs": {
+      "version": "0.11.0",
+      "resolved": "https://registry.npmjs.org/@pkgjs/parseargs/-/parseargs-0.11.0.tgz",
+      "integrity": "sha512-+1VkjdD0QBLPodGrJUeqarH8VAIvQODIbwh9XpP5Syisf7YoQgsJKPNFoqqLQlu+VQ/tVSshMR6loPMn8U+dPg==",
+      "dev": true,
+      "license": "MIT",
+      "optional": true,
+      "engines": {
+        "node": ">=14"
+      }
+    },
     "node_modules/@rollup/rollup-android-arm-eabi": {
       "version": "4.57.1",
       "resolved": "https://registry.npmjs.org/@rollup/rollup-android-arm-eabi/-/rollup-android-arm-eabi-4.57.1.tgz",
@@ -964,7 +1136,6 @@
       "integrity": "sha512-m0jEgYlYz+mDJZ2+F4v8D1AyQb+QzsNqRuI7xg1VQX/KlKS0qT9r1Mo16yo5F/MtifXFgaofIFsdFMox2SxIbQ==",
       "dev": true,
       "license": "MIT",
-      "peer": true,
       "dependencies": {
         "undici-types": "~7.16.0"
       }
@@ -1009,7 +1180,6 @@
       "integrity": "sha512-4Z+L8I2OqhZV8qA132M4wNL30ypZGYOQVBfMgxDH/K5UX0PNqTu1c6za9ST5r9+tavvHiTWmBnKzpCJ/GlVFtg==",
       "dev": true,
       "license": "BSD-2-Clause",
-      "peer": true,
       "dependencies": {
         "@typescript-eslint/scope-manager": "7.18.0",
         "@typescript-eslint/types": "7.18.0",
@@ -1170,6 +1340,39 @@
       "dev": true,
       "license": "ISC"
     },
+    "node_modules/@vitest/coverage-v8": {
+      "version": "2.1.9",
+      "resolved": "https://registry.npmjs.org/@vitest/coverage-v8/-/coverage-v8-2.1.9.tgz",
+      "integrity": "sha512-Z2cOr0ksM00MpEfyVE8KXIYPEcBFxdbLSs56L8PO0QQMxt/6bDj45uQfxoc96v05KW3clk7vvgP0qfDit9DmfQ==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@ampproject/remapping": "^2.3.0",
+        "@bcoe/v8-coverage": "^0.2.3",
+        "debug": "^4.3.7",
+        "istanbul-lib-coverage": "^3.2.2",
+        "istanbul-lib-report": "^3.0.1",
+        "istanbul-lib-source-maps": "^5.0.6",
+        "istanbul-reports": "^3.1.7",
+        "magic-string": "^0.30.12",
+        "magicast": "^0.3.5",
+        "std-env": "^3.8.0",
+        "test-exclude": "^7.0.1",
+        "tinyrainbow": "^1.2.0"
+      },
+      "funding": {
+        "url": "https://opencollective.com/vitest"
+      },
+      "peerDependencies": {
+        "@vitest/browser": "2.1.9",
+        "vitest": "2.1.9"
+      },
+      "peerDependenciesMeta": {
+        "@vitest/browser": {
+          "optional": true
+        }
+      }
+    },
     "node_modules/@vitest/expect": {
       "version": "2.1.9",
       "resolved": "https://registry.npmjs.org/@vitest/expect/-/expect-2.1.9.tgz",
@@ -1289,7 +1492,6 @@
       "integrity": "sha512-NZyJarBfL7nWwIq+FDL6Zp/yHEhePMNnnJ0y3qfieCrmNvYct8uvtiV41UvlSe6apAfk0fY1FbWx+NwfmpvtTg==",
       "dev": true,
       "license": "MIT",
-      "peer": true,
       "bin": {
         "acorn": "bin/acorn"
       },
@@ -1574,6 +1776,20 @@
         "node": ">=6.0.0"
       }
     },
+    "node_modules/eastasianwidth": {
+      "version": "0.2.0",
+      "resolved": "https://registry.npmjs.org/eastasianwidth/-/eastasianwidth-0.2.0.tgz",
+      "integrity": "sha512-I88TYZWc9XiYHRQ4/3c5rjjfgkjhLyW2luGIheGERbNQ6OY7yTybanSpDXZa8y7VUP9YmDcYa+eyq4ca7iLqWA==",
+      "dev": true,
+      "license": "MIT"
+    },
+    "node_modules/emoji-regex": {
+      "version": "9.2.2",
+      "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-9.2.2.tgz",
+      "integrity": "sha512-L18DaJsXSUk2+42pv8mLs5jJT2hqFkFE4j21wOmgbUqsZ2hL72NsUU785g9RXgo3s0ZNgVl42TiHp3ZtOv/Vyg==",
+      "dev": true,
+      "license": "MIT"
+    },
     "node_modules/es-module-lexer": {
       "version": "1.7.0",
       "resolved": "https://registry.npmjs.org/es-module-lexer/-/es-module-lexer-1.7.0.tgz",
@@ -1640,7 +1856,6 @@
       "deprecated": "This version is no longer supported. Please see https://eslint.org/version-support for other options.",
       "dev": true,
       "license": "MIT",
-      "peer": true,
       "dependencies": {
         "@eslint-community/eslint-utils": "^4.2.0",
         "@eslint-community/regexpp": "^4.6.1",
@@ -1955,6 +2170,23 @@
       "dev": true,
       "license": "ISC"
     },
+    "node_modules/foreground-child": {
+      "version": "3.3.1",
+      "resolved": "https://registry.npmjs.org/foreground-child/-/foreground-child-3.3.1.tgz",
+      "integrity": "sha512-gIXjKqtFuWEgzFRJA9WCQeSJLZDjgJUOMCMzxtvFq/37KojM1BFGufqsCy0r4qSQmYLsZYMeyRqzIWOMup03sw==",
+      "dev": true,
+      "license": "ISC",
+      "dependencies": {
+        "cross-spawn": "^7.0.6",
+        "signal-exit": "^4.0.1"
+      },
+      "engines": {
+        "node": ">=14"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/isaacs"
+      }
+    },
     "node_modules/fs.realpath": {
       "version": "1.0.0",
       "resolved": "https://registry.npmjs.org/fs.realpath/-/fs.realpath-1.0.0.tgz",
@@ -2090,6 +2322,13 @@
         "node": ">=8"
       }
     },
+    "node_modules/html-escaper": {
+      "version": "2.0.2",
+      "resolved": "https://registry.npmjs.org/html-escaper/-/html-escaper-2.0.2.tgz",
+      "integrity": "sha512-H2iMtd0I4Mt5eYiapRdIDjp+XzelXQ0tFE4JS7YFwFevXXMmOp9myNrUvCg0D6ws8iqkRPBfKHgbwig1SmlLfg==",
+      "dev": true,
+      "license": "MIT"
+    },
     "node_modules/ignore": {
       "version": "5.3.2",
       "resolved": "https://registry.npmjs.org/ignore/-/ignore-5.3.2.tgz",
@@ -2156,6 +2395,16 @@
         "node": ">=0.10.0"
       }
     },
+    "node_modules/is-fullwidth-code-point": {
+      "version": "3.0.0",
+      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/is-fullwidth-code-point-3.0.0.tgz",
+      "integrity": "sha512-zymm5+u+sCsSWyD9qNaejV3DFvhCKclKdizYaJUuHA83RLjb7nSuGnddCHGv0hk+KY7BMAlsWeK4Ueg6EV6XQg==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=8"
+      }
+    },
     "node_modules/is-glob": {
       "version": "4.0.3",
       "resolved": "https://registry.npmjs.org/is-glob/-/is-glob-4.0.3.tgz",
@@ -2196,6 +2445,76 @@
       "dev": true,
       "license": "ISC"
     },
+    "node_modules/istanbul-lib-coverage": {
+      "version": "3.2.2",
+      "resolved": "https://registry.npmjs.org/istanbul-lib-coverage/-/istanbul-lib-coverage-3.2.2.tgz",
+      "integrity": "sha512-O8dpsF+r0WV/8MNRKfnmrtCWhuKjxrq2w+jpzBL5UZKTi2LeVWnWOmWRxFlesJONmc+wLAGvKQZEOanko0LFTg==",
+      "dev": true,
+      "license": "BSD-3-Clause",
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/istanbul-lib-report": {
+      "version": "3.0.1",
+      "resolved": "https://registry.npmjs.org/istanbul-lib-report/-/istanbul-lib-report-3.0.1.tgz",
+      "integrity": "sha512-GCfE1mtsHGOELCU8e/Z7YWzpmybrx/+dSTfLrvY8qRmaY6zXTKWn6WQIjaAFw069icm6GVMNkgu0NzI4iPZUNw==",
+      "dev": true,
+      "license": "BSD-3-Clause",
+      "dependencies": {
+        "istanbul-lib-coverage": "^3.0.0",
+        "make-dir": "^4.0.0",
+        "supports-color": "^7.1.0"
+      },
+      "engines": {
+        "node": ">=10"
+      }
+    },
+    "node_modules/istanbul-lib-source-maps": {
+      "version": "5.0.6",
+      "resolved": "https://registry.npmjs.org/istanbul-lib-source-maps/-/istanbul-lib-source-maps-5.0.6.tgz",
+      "integrity": "sha512-yg2d+Em4KizZC5niWhQaIomgf5WlL4vOOjZ5xGCmF8SnPE/mDWWXgvRExdcpCgh9lLRRa1/fSYp2ymmbJ1pI+A==",
+      "dev": true,
+      "license": "BSD-3-Clause",
+      "dependencies": {
+        "@jridgewell/trace-mapping": "^0.3.23",
+        "debug": "^4.1.1",
+        "istanbul-lib-coverage": "^3.0.0"
+      },
+      "engines": {
+        "node": ">=10"
+      }
+    },
+    "node_modules/istanbul-reports": {
+      "version": "3.2.0",
+      "resolved": "https://registry.npmjs.org/istanbul-reports/-/istanbul-reports-3.2.0.tgz",
+      "integrity": "sha512-HGYWWS/ehqTV3xN10i23tkPkpH46MLCIMFNCaaKNavAXTF1RkqxawEPtnjnGZ6XKSInBKkiOA5BKS+aZiY3AvA==",
+      "dev": true,
+      "license": "BSD-3-Clause",
+      "dependencies": {
+        "html-escaper": "^2.0.0",
+        "istanbul-lib-report": "^3.0.0"
+      },
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/jackspeak": {
+      "version": "3.4.3",
+      "resolved": "https://registry.npmjs.org/jackspeak/-/jackspeak-3.4.3.tgz",
+      "integrity": "sha512-OGlZQpz2yfahA/Rd1Y8Cd9SIEsqvXkLVoSw/cgwhnhFMDbsQFeZYoJJ7bIZBS9BcamUW96asq/npPWugM+RQBw==",
+      "dev": true,
+      "license": "BlueOak-1.0.0",
+      "dependencies": {
+        "@isaacs/cliui": "^8.0.2"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/isaacs"
+      },
+      "optionalDependencies": {
+        "@pkgjs/parseargs": "^0.11.0"
+      }
+    },
     "node_modules/js-yaml": {
       "version": "4.1.1",
       "resolved": "https://registry.npmjs.org/js-yaml/-/js-yaml-4.1.1.tgz",
@@ -2284,6 +2603,13 @@
       "dev": true,
       "license": "MIT"
     },
+    "node_modules/lru-cache": {
+      "version": "10.4.3",
+      "resolved": "https://registry.npmjs.org/lru-cache/-/lru-cache-10.4.3.tgz",
+      "integrity": "sha512-JNAzZcXrCt42VGLuYz0zfAzDfAvJWW6AfYlDBQyDV5DClI2m5sAmK+OIO7s59XfsRsWHp02jAJrRadPRGTt6SQ==",
+      "dev": true,
+      "license": "ISC"
+    },
     "node_modules/magic-string": {
       "version": "0.30.21",
       "resolved": "https://registry.npmjs.org/magic-string/-/magic-string-0.30.21.tgz",
@@ -2294,6 +2620,34 @@
         "@jridgewell/sourcemap-codec": "^1.5.5"
       }
     },
+    "node_modules/magicast": {
+      "version": "0.3.5",
+      "resolved": "https://registry.npmjs.org/magicast/-/magicast-0.3.5.tgz",
+      "integrity": "sha512-L0WhttDl+2BOsybvEOLK7fW3UA0OQ0IQ2d6Zl2x/a6vVRs3bAY0ECOSHHeL5jD+SbOpOCUEi0y1DgHEn9Qn1AQ==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@babel/parser": "^7.25.4",
+        "@babel/types": "^7.25.4",
+        "source-map-js": "^1.2.0"
+      }
+    },
+    "node_modules/make-dir": {
+      "version": "4.0.0",
+      "resolved": "https://registry.npmjs.org/make-dir/-/make-dir-4.0.0.tgz",
+      "integrity": "sha512-hXdUTZYIVOt1Ex//jAQi+wTZZpUpwBj/0QsOzqegb3rGMMeJiSEu5xLHnYfBrRV4RH2+OCSOO95Is/7x1WJ4bw==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "semver": "^7.5.3"
+      },
+      "engines": {
+        "node": ">=10"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/sindresorhus"
+      }
+    },
     "node_modules/merge2": {
       "version": "1.4.1",
       "resolved": "https://registry.npmjs.org/merge2/-/merge2-1.4.1.tgz",
@@ -2334,6 +2688,16 @@
         "url": "https://github.com/sponsors/isaacs"
       }
     },
+    "node_modules/minipass": {
+      "version": "7.1.2",
+      "resolved": "https://registry.npmjs.org/minipass/-/minipass-7.1.2.tgz",
+      "integrity": "sha512-qOOzS1cBTWYF4BH8fVePDBOO9iptMnGUEZwNc/cMWnTV2nVLZ7VoNWEPHkYczZA0pdoA7dl6e7FL659nX9S2aw==",
+      "dev": true,
+      "license": "ISC",
+      "engines": {
+        "node": ">=16 || 14 >=14.17"
+      }
+    },
     "node_modules/ms": {
       "version": "2.1.3",
       "resolved": "https://registry.npmjs.org/ms/-/ms-2.1.3.tgz",
@@ -2427,6 +2791,13 @@
         "url": "https://github.com/sponsors/sindresorhus"
       }
     },
+    "node_modules/package-json-from-dist": {
+      "version": "1.0.1",
+      "resolved": "https://registry.npmjs.org/package-json-from-dist/-/package-json-from-dist-1.0.1.tgz",
+      "integrity": "sha512-UEZIS3/by4OC8vL3P2dTXRETpebLI2NiI5vIrjaD/5UtrkFX/tNbwjTSRAGC/+7CAo2pIcBaRgWmcBBHcsaCIw==",
+      "dev": true,
+      "license": "BlueOak-1.0.0"
+    },
     "node_modules/parent-module": {
       "version": "1.0.1",
       "resolved": "https://registry.npmjs.org/parent-module/-/parent-module-1.0.1.tgz",
@@ -2470,6 +2841,23 @@
         "node": ">=8"
       }
     },
+    "node_modules/path-scurry": {
+      "version": "1.11.1",
+      "resolved": "https://registry.npmjs.org/path-scurry/-/path-scurry-1.11.1.tgz",
+      "integrity": "sha512-Xa4Nw17FS9ApQFJ9umLiJS4orGjm7ZzwUrwamcGQuHSzDyth9boKDaycYdDcZDuqYATXw4HFXgaqWTctW/v1HA==",
+      "dev": true,
+      "license": "BlueOak-1.0.0",
+      "dependencies": {
+        "lru-cache": "^10.2.0",
+        "minipass": "^5.0.0 || ^6.0.2 || ^7.0.0"
+      },
+      "engines": {
+        "node": ">=16 || 14 >=14.18"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/isaacs"
+      }
+    },
     "node_modules/path-type": {
       "version": "4.0.0",
       "resolved": "https://registry.npmjs.org/path-type/-/path-type-4.0.0.tgz",
@@ -2737,6 +3125,19 @@
       "dev": true,
       "license": "ISC"
     },
+    "node_modules/signal-exit": {
+      "version": "4.1.0",
+      "resolved": "https://registry.npmjs.org/signal-exit/-/signal-exit-4.1.0.tgz",
+      "integrity": "sha512-bzyZ1e88w9O1iNJbKnOlvYTrWPDl46O1bG0D3XInv+9tkPrxrN8jUUTiFlDkkmKWgn1M6CfIA13SuGqOa9Korw==",
+      "dev": true,
+      "license": "ISC",
+      "engines": {
+        "node": ">=14"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/isaacs"
+      }
+    },
     "node_modules/slash": {
       "version": "3.0.0",
       "resolved": "https://registry.npmjs.org/slash/-/slash-3.0.0.tgz",
@@ -2771,6 +3172,76 @@
       "dev": true,
       "license": "MIT"
     },
+    "node_modules/string-width": {
+      "version": "5.1.2",
+      "resolved": "https://registry.npmjs.org/string-width/-/string-width-5.1.2.tgz",
+      "integrity": "sha512-HnLOCR3vjcY8beoNLtcjZ5/nxn2afmME6lhrDrebokqMap+XbeW8n9TXpPDOqdGK5qcI3oT0GKTW6wC7EMiVqA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "eastasianwidth": "^0.2.0",
+        "emoji-regex": "^9.2.2",
+        "strip-ansi": "^7.0.1"
+      },
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/sindresorhus"
+      }
+    },
+    "node_modules/string-width-cjs": {
+      "name": "string-width",
+      "version": "4.2.3",
+      "resolved": "https://registry.npmjs.org/string-width/-/string-width-4.2.3.tgz",
+      "integrity": "sha512-wKyQRQpjJ0sIp62ErSZdGsjMJWsap5oRNihHhu6G7JVO/9jIB6UyevL+tXuOqrng8j/cxKTWyWUwvSTriiZz/g==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "emoji-regex": "^8.0.0",
+        "is-fullwidth-code-point": "^3.0.0",
+        "strip-ansi": "^6.0.1"
+      },
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/string-width-cjs/node_modules/emoji-regex": {
+      "version": "8.0.0",
+      "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-8.0.0.tgz",
+      "integrity": "sha512-MSjYzcWNOA0ewAHpz0MxpYFvwg6yjy1NG3xteoqz644VCo/RPgnr1/GGt+ic3iJTzQ8Eu3TdM14SawnVUmGE6A==",
+      "dev": true,
+      "license": "MIT"
+    },
+    "node_modules/string-width/node_modules/ansi-regex": {
+      "version": "6.2.2",
+      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-6.2.2.tgz",
+      "integrity": "sha512-Bq3SmSpyFHaWjPk8If9yc6svM8c56dB5BAtW4Qbw5jHTwwXXcTLoRMkpDJp6VL0XzlWaCHTXrkFURMYmD0sLqg==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/ansi-regex?sponsor=1"
+      }
+    },
+    "node_modules/string-width/node_modules/strip-ansi": {
+      "version": "7.1.2",
+      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-7.1.2.tgz",
+      "integrity": "sha512-gmBGslpoQJtgnMAvOVqGZpEz9dyoKTCzy2nfz/n8aIFhN/jCE/rCmcxabB6jOOHV+0WNnylOxaxBQPSvcWklhA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "ansi-regex": "^6.0.1"
+      },
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/strip-ansi?sponsor=1"
+      }
+    },
     "node_modules/strip-ansi": {
       "version": "6.0.1",
       "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-6.0.1.tgz",
@@ -2784,6 +3255,20 @@
         "node": ">=8"
       }
     },
+    "node_modules/strip-ansi-cjs": {
+      "name": "strip-ansi",
+      "version": "6.0.1",
+      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-6.0.1.tgz",
+      "integrity": "sha512-Y38VPSHcqkFrCpFnQ9vuSXmquuv5oXOKpGeT6aGrr3o3Gc9AlVa6JBfUSOCnbxGGZF+/0ooI7KrPuUSztUdU5A==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "ansi-regex": "^5.0.1"
+      },
+      "engines": {
+        "node": ">=8"
+      }
+    },
     "node_modules/strip-json-comments": {
       "version": "3.1.1",
       "resolved": "https://registry.npmjs.org/strip-json-comments/-/strip-json-comments-3.1.1.tgz",
@@ -2810,6 +3295,43 @@
         "node": ">=8"
       }
     },
+    "node_modules/test-exclude": {
+      "version": "7.0.1",
+      "resolved": "https://registry.npmjs.org/test-exclude/-/test-exclude-7.0.1.tgz",
+      "integrity": "sha512-pFYqmTw68LXVjeWJMST4+borgQP2AyMNbg1BpZh9LbyhUeNkeaPF9gzfPGUAnSMV3qPYdWUwDIjjCLiSDOl7vg==",
+      "dev": true,
+      "license": "ISC",
+      "dependencies": {
+        "@istanbuljs/schema": "^0.1.2",
+        "glob": "^10.4.1",
+        "minimatch": "^9.0.4"
+      },
+      "engines": {
+        "node": ">=18"
+      }
+    },
+    "node_modules/test-exclude/node_modules/glob": {
+      "version": "10.5.0",
+      "resolved": "https://registry.npmjs.org/glob/-/glob-10.5.0.tgz",
+      "integrity": "sha512-DfXN8DfhJ7NH3Oe7cFmu3NCu1wKbkReJ8TorzSAFbSKrlNaQSKfIzqYqVY8zlbs2NLBbWpRiU52GX2PbaBVNkg==",
+      "deprecated": "Old versions of glob are not supported, and contain widely publicized security vulnerabilities, which have been fixed in the current version. Please update. Support for old versions may be purchased (at exorbitant rates) by contacting i@izs.me",
+      "dev": true,
+      "license": "ISC",
+      "dependencies": {
+        "foreground-child": "^3.1.0",
+        "jackspeak": "^3.1.2",
+        "minimatch": "^9.0.4",
+        "minipass": "^7.1.2",
+        "package-json-from-dist": "^1.0.0",
+        "path-scurry": "^1.11.1"
+      },
+      "bin": {
+        "glob": "dist/esm/bin.mjs"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/isaacs"
+      }
+    },
     "node_modules/text-table": {
       "version": "0.2.0",
       "resolved": "https://registry.npmjs.org/text-table/-/text-table-0.2.0.tgz",
@@ -2919,7 +3441,6 @@
       "integrity": "sha512-jl1vZzPDinLr9eUt3J/t7V6FgNEw9QjvBPdysz9KfQDD41fQrC2Y4vKQdiaUpFT4bXlb1RHhLpp8wtm6M5TgSw==",
       "dev": true,
       "license": "Apache-2.0",
-      "peer": true,
       "bin": {
         "tsc": "bin/tsc",
         "tsserver": "bin/tsserver"
@@ -2951,7 +3472,6 @@
       "integrity": "sha512-o5a9xKjbtuhY6Bi5S3+HvbRERmouabWbyUcpXXUA1u+GNUKoROi9byOJ8M0nHbHYHkYICiMlqxkg1KkYmm25Sw==",
       "dev": true,
       "license": "MIT",
-      "peer": true,
       "dependencies": {
         "esbuild": "^0.21.3",
         "postcss": "^8.4.43",
@@ -3138,6 +3658,107 @@
         "node": ">=0.10.0"
       }
     },
+    "node_modules/wrap-ansi": {
+      "version": "8.1.0",
+      "resolved": "https://registry.npmjs.org/wrap-ansi/-/wrap-ansi-8.1.0.tgz",
+      "integrity": "sha512-si7QWI6zUMq56bESFvagtmzMdGOtoxfR+Sez11Mobfc7tm+VkUckk9bW2UeffTGVUbOksxmSw0AA2gs8g71NCQ==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "ansi-styles": "^6.1.0",
+        "string-width": "^5.0.1",
+        "strip-ansi": "^7.0.1"
+      },
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/wrap-ansi?sponsor=1"
+      }
+    },
+    "node_modules/wrap-ansi-cjs": {
+      "name": "wrap-ansi",
+      "version": "7.0.0",
+      "resolved": "https://registry.npmjs.org/wrap-ansi/-/wrap-ansi-7.0.0.tgz",
+      "integrity": "sha512-YVGIj2kamLSTxw6NsZjoBxfSwsn0ycdesmc4p+Q21c5zPuZ1pl+NfxVdxPtdHvmNVOQ6XSYG4AUtyt/Fi7D16Q==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "ansi-styles": "^4.0.0",
+        "string-width": "^4.1.0",
+        "strip-ansi": "^6.0.0"
+      },
+      "engines": {
+        "node": ">=10"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/wrap-ansi?sponsor=1"
+      }
+    },
+    "node_modules/wrap-ansi-cjs/node_modules/emoji-regex": {
+      "version": "8.0.0",
+      "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-8.0.0.tgz",
+      "integrity": "sha512-MSjYzcWNOA0ewAHpz0MxpYFvwg6yjy1NG3xteoqz644VCo/RPgnr1/GGt+ic3iJTzQ8Eu3TdM14SawnVUmGE6A==",
+      "dev": true,
+      "license": "MIT"
+    },
+    "node_modules/wrap-ansi-cjs/node_modules/string-width": {
+      "version": "4.2.3",
+      "resolved": "https://registry.npmjs.org/string-width/-/string-width-4.2.3.tgz",
+      "integrity": "sha512-wKyQRQpjJ0sIp62ErSZdGsjMJWsap5oRNihHhu6G7JVO/9jIB6UyevL+tXuOqrng8j/cxKTWyWUwvSTriiZz/g==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "emoji-regex": "^8.0.0",
+        "is-fullwidth-code-point": "^3.0.0",
+        "strip-ansi": "^6.0.1"
+      },
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/wrap-ansi/node_modules/ansi-regex": {
+      "version": "6.2.2",
+      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-6.2.2.tgz",
+      "integrity": "sha512-Bq3SmSpyFHaWjPk8If9yc6svM8c56dB5BAtW4Qbw5jHTwwXXcTLoRMkpDJp6VL0XzlWaCHTXrkFURMYmD0sLqg==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/ansi-regex?sponsor=1"
+      }
+    },
+    "node_modules/wrap-ansi/node_modules/ansi-styles": {
+      "version": "6.2.3",
+      "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-6.2.3.tgz",
+      "integrity": "sha512-4Dj6M28JB+oAH8kFkTLUo+a2jwOFkuqb3yucU0CANcRRUbxS0cP0nZYCGjcc3BNXwRIsUVmDGgzawme7zvJHvg==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/ansi-styles?sponsor=1"
+      }
+    },
+    "node_modules/wrap-ansi/node_modules/strip-ansi": {
+      "version": "7.1.2",
+      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-7.1.2.tgz",
+      "integrity": "sha512-gmBGslpoQJtgnMAvOVqGZpEz9dyoKTCzy2nfz/n8aIFhN/jCE/rCmcxabB6jOOHV+0WNnylOxaxBQPSvcWklhA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "ansi-regex": "^6.0.1"
+      },
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/strip-ansi?sponsor=1"
+      }
+    },
     "node_modules/wrappy": {
       "version": "1.0.2",
       "resolved": "https://registry.npmjs.org/wrappy/-/wrappy-1.0.2.tgz",
diff --git a/src/index.test.ts b/src/index.test.ts
new file mode 100644
index 0000000..9f29cad
--- /dev/null
+++ b/src/index.test.ts
@@ -0,0 +1,508 @@
+import { describe, it, expect, beforeEach } from 'vitest';
+import { TaskQueue } from './index.js';
+
+describe('Phase 1: Basic FIFO Queue', () => {
+  let queue: TaskQueue;
+
+  beforeEach(() => {
+    queue = new TaskQueue();
+  });
+
+  it('should add a task and return a task object', () => {
+    const payload = { foo: 'bar' };
+    const task = queue.addTask(payload);
+
+    expect(task.id).toBeDefined();
+    expect(task.payload).toEqual(payload);
+    expect(task.status).toBe('pending');
+    expect(task.createdAt).toBeInstanceOf(Date);
+  });
+
+  it('should return tasks in FIFO order', () => {
+    queue.addTask(1);
+    queue.addTask(2);
+
+    const next1 = queue.getNextTask();
+    expect(next1?.payload).toBe(1);
+    expect(next1?.status).toBe('processing');
+
+    const next2 = queue.getNextTask();
+    expect(next2?.payload).toBe(2);
+    expect(next2?.status).toBe('processing');
+  });
+
+  it('should return null when no tasks are available', () => {
+    expect(queue.getNextTask()).toBeNull();
+  });
+
+  it('should return the correct count of pending tasks', () => {
+    queue.addTask(1);
+    queue.addTask(2);
+    expect(queue.getPendingCount()).toBe(2);
+
+    queue.getNextTask();
+    expect(queue.getPendingCount()).toBe(1);
+
+    queue.getNextTask();
+    expect(queue.getPendingCount()).toBe(0);
+  });
+
+  describe('Phase 2: Named Queues', () => {
+    it('should add tasks to a default queue if no name is given', () => {
+      queue.addTask('foo');
+      expect(queue.listQueues()).toContain('default');
+      expect(queue.getPendingCount()).toBe(1);
+    });
+
+    it('should add tasks to a specific named queue', () => {
+      queue.addTask('foo', 'my-queue');
+      expect(queue.listQueues()).toContain('my-queue');
+      expect(queue.getPendingCount('my-queue')).toBe(1);
+      expect(queue.getPendingCount('default')).toBe(0);
+    });
+
+    it('should retrieve tasks from the correct queue', () => {
+      queue.addTask('default-task');
+      queue.addTask('custom-task', 'custom');
+
+      const task = queue.getNextTask('custom');
+      expect(task?.payload).toBe('custom-task');
+      expect(queue.getNextTask('custom')).toBeNull();
+      expect(queue.getNextTask('default')?.payload).toBe('default-task');
+    });
+
+    it('should list all queue names', () => {
+      queue.addTask(1, 'q1');
+      queue.addTask(2, 'q2');
+      const queues = queue.listQueues();
+      expect(queues).toContain('q1');
+      expect(queues).toContain('q2');
+      expect(queues.length).toBe(2);
+    });
+
+    it('should return null for non-existent queues', () => {
+      expect(queue.getNextTask('non-existent')).toBeNull();
+      expect(queue.getPendingCount('non-existent')).toBe(0);
+    });
+  });
+
+  describe('Phase 3: Priority', () => {
+    it('should store and expose task priority', () => {
+      const task = queue.addTask('low', 'default', 10);
+      expect(task.priority).toBe(10);
+    });
+
+    it('should process higher priority tasks first', () => {
+      queue.addTask('low', 'default', 10);
+      queue.addTask('high', 'default', 1);
+      queue.addTask('medium', 'default', 5);
+
+      expect(queue.getNextTask()?.payload).toBe('high');
+      expect(queue.getNextTask()?.payload).toBe('medium');
+      expect(queue.getNextTask()?.payload).toBe('low');
+    });
+
+    it('should process same priority tasks in FIFO order', () => {
+      queue.addTask('first', 'default', 5);
+      queue.addTask('second', 'default', 5);
+
+      expect(queue.getNextTask()?.payload).toBe('first');
+      expect(queue.getNextTask()?.payload).toBe('second');
+    });
+
+    it('should throw error for invalid priority levels', () => {
+      expect(() => queue.addTask('bad', 'default', 0)).toThrow();
+      expect(() => queue.addTask('bad', 'default', 11)).toThrow();
+    });
+  });
+
+  describe('Phase 4: Delayed and Scheduled Tasks', () => {
+    it('should not return a task before its availability time', () => {
+      queue.addTask('delayed', { delay: 1000 });
+      expect(queue.getNextTask()).toBeNull();
+    });
+
+    it('should return a task after its availability time', async () => {
+      queue.addTask('soon', { delay: 10 });
+      await new Promise(resolve => setTimeout(resolve, 20));
+      expect(queue.getNextTask()?.payload).toBe('soon');
+    });
+
+    it('should prefer earlier availability time', () => {
+      const now = Date.now();
+      queue.addTask('later', { availableAt: new Date(now - 1000) });
+      queue.addTask('earlier', { availableAt: new Date(now - 2000) });
+
+      expect(queue.getNextTask()?.payload).toBe('earlier');
+      expect(queue.getNextTask()?.payload).toBe('later');
+    });
+
+    it('should order by availability, then priority, then FIFO', () => {
+      const now = new Date(Date.now() - 5000);
+      queue.addTask('p10-early', { availableAt: now, priority: 10 });
+      queue.addTask('p1-late', { availableAt: new Date(now.getTime() + 1000), priority: 1 });
+      queue.addTask('p5-early', { availableAt: now, priority: 5 });
+
+      expect(queue.getNextTask()?.payload).toBe('p5-early');
+      expect(queue.getNextTask()?.payload).toBe('p10-early');
+      expect(queue.getNextTask()?.payload).toBe('p1-late');
+    });
+  });
+
+  describe('Phase 5: Retry with Backoff', () => {
+    it('should mark a task as completed', () => {
+      const task = queue.addTask('work');
+      queue.getNextTask();
+      queue.completeTask(task.id);
+      expect(queue.getTask(task.id)?.status).toBe('completed');
+    });
+
+    it('should retry a failed task with exponential backoff', () => {
+      const task = queue.addTask('fail-me', { baseDelay: 100, maxRetries: 2 });
+      
+      queue.getNextTask();
+      expect(queue.getTask(task.id)?.attempts).toBe(1);
+      
+      queue.failTask(task.id);
+      expect(queue.getTask(task.id)?.status).toBe('pending');
+      expect(queue.getTask(task.id)?.availableAt.getTime()).toBeGreaterThanOrEqual(Date.now() + 90);
+
+      expect(queue.getNextTask()).toBeNull();
+    });
+
+    it('should fail permanently after max retries', () => {
+      const task = queue.addTask('die', { maxRetries: 1, baseDelay: 0 });
+      
+      queue.getNextTask();
+      queue.failTask(task.id);
+      
+      queue.getNextTask();
+      queue.failTask(task.id);
+
+      expect(queue.getTask(task.id)?.status).toBe('failed');
+      expect(queue.getTask(task.id)?.attempts).toBe(2);
+    });
+
+    it('should track attempt count correctly', () => {
+      const task = queue.addTask('track', { baseDelay: 0 });
+      queue.getNextTask();
+      expect(queue.getTask(task.id)?.attempts).toBe(1);
+      queue.failTask(task.id);
+      queue.getNextTask();
+      expect(queue.getTask(task.id)?.attempts).toBe(2);
+    });
+  });
+
+  describe('Phase 6: Dead Letter Queue', () => {
+    it('should move task to DLQ after exhausting retries', () => {
+      const task = queue.addTask('to-dlq', { maxRetries: 0 });
+      queue.getNextTask();
+      queue.failTask(task.id, 'fatal error');
+
+      expect(queue.getTask(task.id)?.status).toBe('failed');
+      const dlq = queue.getDeadLetterTasks();
+      expect(dlq).toHaveLength(1);
+      expect(dlq[0].id).toBe(task.id);
+      expect(dlq[0].error).toBe('fatal error');
+    });
+
+    it('should resubmit a task from DLQ', () => {
+      const task = queue.addTask('resubmit', { maxRetries: 0 });
+      queue.getNextTask();
+      queue.failTask(task.id, 'error');
+
+      const resubmitted = queue.resubmitDeadLetterTask(task.id);
+      expect(resubmitted).toBe(true);
+      expect(queue.getDeadLetterTasks()).toHaveLength(0);
+      expect(queue.getPendingCount()).toBe(1);
+      expect(queue.getTask(task.id)?.status).toBe('pending');
+      expect(queue.getTask(task.id)?.attempts).toBe(0);
+    });
+
+    it('should clear DLQ', () => {
+      const task = queue.addTask('clear', { maxRetries: 0 });
+      queue.getNextTask();
+      queue.failTask(task.id, 'error');
+
+      queue.clearDeadLetterTasks();
+      expect(queue.getDeadLetterTasks()).toHaveLength(0);
+    });
+  });
+
+  describe('Phase 7: Task Dependencies', () => {
+    it('should block a task until its dependency is completed', () => {
+      const dep = queue.addTask('dep');
+      const task = queue.addTask('task', { dependencies: [dep.id] });
+
+      expect(queue.getNextTask()).toBeDefined();
+      expect(queue.getNextTask()).toBeNull();
+
+      queue.completeTask(dep.id);
+      expect(queue.getNextTask()?.id).toBe(task.id);
+    });
+
+    it('should stay blocked if dependency fails', () => {
+      const dep = queue.addTask('dep', { maxRetries: 0 });
+      queue.addTask('task', { dependencies: [dep.id] });
+
+      queue.getNextTask();
+      queue.failTask(dep.id);
+
+      expect(queue.getNextTask()).toBeNull();
+    });
+
+    it('should throw error for non-existent dependency', () => {
+      expect(() => queue.addTask('task', { dependencies: ['non-existent'] })).toThrow();
+    });
+
+    it('should return correct dependency status', () => {
+      const dep1 = queue.addTask('dep1');
+      const dep2 = queue.addTask('dep2');
+      const task = queue.addTask('task', { dependencies: [dep1.id, dep2.id] });
+
+      let status = queue.getDependencyStatus(task.id);
+      expect(status.total).toBe(2);
+      expect(status.met).toBe(0);
+      expect(status.remaining).toContain(dep1.id);
+      expect(status.remaining).toContain(dep2.id);
+
+      queue.getNextTask();
+      queue.completeTask(dep1.id);
+
+      status = queue.getDependencyStatus(task.id);
+      expect(status.met).toBe(1);
+      expect(status.remaining).not.toContain(dep1.id);
+    });
+  });
+
+  describe('Phase 8: Concurrency Control', () => {
+    it('should respect concurrency limits', () => {
+      queue.setConcurrencyLimit('limited', 2);
+      queue.addTask(1, 'limited');
+      queue.addTask(2, 'limited');
+      queue.addTask(3, 'limited');
+
+      expect(queue.getNextTask('limited')).not.toBeNull();
+      expect(queue.getNextTask('limited')).not.toBeNull();
+      expect(queue.getNextTask('limited')).toBeNull();
+    });
+
+    it('should free a slot when a task completes', () => {
+      queue.setConcurrencyLimit('q', 1);
+      const t1 = queue.addTask(1, 'q');
+      queue.addTask(2, 'q');
+
+      queue.getNextTask('q');
+      expect(queue.getNextTask('q')).toBeNull();
+
+      queue.completeTask(t1.id);
+      expect(queue.getNextTask('q')).not.toBeNull();
+    });
+
+    it('should free a slot when a task fails', () => {
+      queue.setConcurrencyLimit('q', 1);
+      const t1 = queue.addTask(1, { queueName: 'q', maxRetries: 0 });
+      queue.addTask(2, 'q');
+
+      queue.getNextTask('q');
+      queue.failTask(t1.id);
+      expect(queue.getNextTask('q')).not.toBeNull();
+    });
+
+    it('should return correct active count', () => {
+      queue.addTask(1, 'q');
+      queue.addTask(2, 'q');
+
+      expect(queue.getActiveCount('q')).toBe(0);
+      queue.getNextTask('q');
+      expect(queue.getActiveCount('q')).toBe(1);
+    });
+  });
+
+  describe('Phase 9: Progress Tracking and Cancellation', () => {
+    it('should report and query task progress', () => {
+      const task = queue.addTask('work');
+      queue.getNextTask();
+      queue.reportTaskProgress(task.id, 50, 'halfway');
+
+      const updated = queue.getTask(task.id);
+      expect(updated?.progress?.percentage).toBe(50);
+      expect(updated?.progress?.message).toBe('halfway');
+    });
+
+    it('should notify listeners of progress changes', () => {
+      const task = queue.addTask('work');
+      queue.getNextTask();
+      let capturedProgress: { percentage: number; message?: string } | undefined;
+      queue.subscribeToTaskProgress(task.id, (p) => {
+        capturedProgress = p;
+      });
+
+      queue.reportTaskProgress(task.id, 75);
+      expect(capturedProgress?.percentage).toBe(75);
+    });
+
+    it('should cancel a pending task', () => {
+      const task = queue.addTask('cancel-me');
+      queue.cancelTask(task.id);
+      expect(queue.getTask(task.id)?.status).toBe('cancelled');
+      expect(queue.getNextTask()).toBeNull();
+    });
+
+    it('should cancel a processing task and free slot', () => {
+      queue.setConcurrencyLimit('q', 1);
+      const task = queue.addTask('cancel-me', 'q');
+      queue.getNextTask('q');
+      expect(queue.getActiveCount('q')).toBe(1);
+
+      queue.cancelTask(task.id);
+      expect(queue.getTask(task.id)?.status).toBe('cancelled');
+      expect(queue.getActiveCount('q')).toBe(0);
+    });
+  });
+
+  describe('Phase 10: Recurring Tasks', () => {
+    it('should create and list schedules', () => {
+      const id = queue.createSchedule('0 * * * *', { msg: 'hour' });
+      const schedules = queue.listSchedules();
+      expect(schedules).toHaveLength(1);
+      expect(schedules[0].id).toBe(id);
+      expect(schedules[0].expression).toBe('0 * * * *');
+    });
+
+    it('should remove schedules', () => {
+      const id = queue.createSchedule('0 * * * *', { msg: 'hour' });
+      queue.removeSchedule(id);
+      expect(queue.listSchedules()).toHaveLength(0);
+    });
+
+    it('should enqueue tasks when due', () => {
+      queue.createSchedule('*/15 * * * *', { job: 'fifteen' });
+      
+      queue.checkSchedules(new Date(2026, 1, 16, 10, 1));
+      expect(queue.getPendingCount()).toBe(0);
+
+      queue.checkSchedules(new Date(2026, 1, 16, 10, 15));
+      expect(queue.getPendingCount()).toBe(1);
+      expect(queue.getNextTask()?.payload).toEqual({ job: 'fifteen' });
+    });
+
+    it('should handle different cron expressions', () => {
+      queue.createSchedule('0 * * * *', { job: 'hour' });
+      queue.createSchedule('0 0 * * *', { job: 'day' });
+
+      queue.checkSchedules(new Date(2026, 1, 16, 0, 0));
+      expect(queue.getPendingCount()).toBe(2);
+      queue.getNextTask(); queue.getNextTask();
+
+      queue.checkSchedules(new Date(2026, 1, 16, 1, 0));
+      expect(queue.getPendingCount()).toBe(1);
+    });
+
+    it('should not enqueue twice in the same minute', () => {
+      queue.createSchedule('*/5 * * * *', { job: 'five' });
+      const now = new Date(2026, 1, 16, 10, 5);
+      
+      queue.checkSchedules(now);
+      expect(queue.getPendingCount()).toBe(1);
+      
+      queue.checkSchedules(now);
+      expect(queue.getPendingCount()).toBe(1);
+    });
+  });
+
+  describe('Phase 11: Middleware Pipeline', () => {
+    it('should run middleware and handler', async () => {
+      const task = queue.addTask({ val: 1 }, 'q');
+      let middlewareRun = false;
+      let handlerRun = false;
+
+      queue.use('q', async (t, next) => {
+        middlewareRun = true;
+        (t.payload as { val: number }).val += 1;
+        await next();
+      });
+
+      queue.registerHandler('q', async (t) => {
+        handlerRun = true;
+        expect((t.payload as { val: number }).val).toBe(2);
+      });
+
+      await queue.processNext('q');
+      expect(middlewareRun).toBe(true);
+      expect(handlerRun).toBe(true);
+      expect(queue.getTask(task.id)?.status).toBe('completed');
+    });
+
+    it('should fail task if middleware throws', async () => {
+      const task = queue.addTask('work', { queueName: 'q', maxRetries: 0 });
+      queue.use('q', async () => {
+        throw new Error('mid-error');
+      });
+
+      await queue.processNext('q');
+      expect(queue.getTask(task.id)?.status).toBe('failed');
+      const error = queue.getTask(task.id)?.error as Error;
+      expect(error.message).toBe('mid-error');
+    });
+
+    it('should skip processing if next is not called', async () => {
+      queue.addTask('work', 'q');
+      let handlerRun = false;
+      queue.use('q', async () => {
+        // Don't call next
+      });
+      queue.registerHandler('q', async () => {
+        handlerRun = true;
+      });
+
+      await queue.processNext('q');
+      expect(handlerRun).toBe(false);
+    });
+  });
+
+  describe('Phase 12: Graceful Shutdown', () => {
+    it('should stop accepting tasks after shutdown', async () => {
+      await queue.shutdown();
+      expect(() => queue.addTask('too late')).toThrow('Queue is shutting down');
+    });
+
+    it('should wait for processing tasks to finish', async () => {
+      const q = new TaskQueue();
+      const task = q.addTask('work');
+      q.getNextTask();
+
+      let finished = false;
+      const shutdownPromise = q.shutdown().then(summary => {
+        finished = true;
+        return summary;
+      });
+
+      expect(finished).toBe(false);
+
+      q.completeTask(task.id);
+      const summary = await shutdownPromise;
+      expect(finished).toBe(true);
+      expect(summary.completed).toBe(1);
+    });
+
+    it('should force-cancel tasks after timeout', async () => {
+      const q = new TaskQueue();
+      const task = q.addTask('work');
+      q.getNextTask();
+
+      const summary = await q.shutdown(10);
+      expect(summary.forceCancelled).toBe(1);
+      expect(q.getTask(task.id)?.status).toBe('cancelled');
+    });
+
+    it('should run shutdown callbacks', async () => {
+      let callbackRun = false;
+      queue.onShutdown(async () => {
+        callbackRun = true;
+      });
+      await queue.shutdown();
+      expect(callbackRun).toBe(true);
+    });
+  });
+});
diff --git a/src/index.ts b/src/index.ts
new file mode 100644
index 0000000..9a082e1
--- /dev/null
+++ b/src/index.ts
@@ -0,0 +1,555 @@
+import { randomUUID } from 'node:crypto';
+
+export type TaskStatus = 'pending' | 'processing' | 'completed' | 'failed' | 'cancelled';
+
+export interface TaskProgress {
+  percentage: number;
+  message?: string;
+}
+
+export interface Task<T = unknown> {
+  id: string;
+  payload: T;
+  status: TaskStatus;
+  priority: number;
+  createdAt: Date;
+  availableAt: Date;
+  attempts: number;
+  maxRetries: number;
+  baseDelay: number;
+  error?: unknown;
+  dependencies: string[];
+  progress?: TaskProgress;
+}
+
+export interface AddTaskOptions {
+  queueName?: string;
+  priority?: number;
+  delay?: number;
+  availableAt?: Date;
+  maxRetries?: number;
+  baseDelay?: number;
+  dependencies?: string[];
+}
+
+export interface RecurringSchedule {
+  id: string;
+  expression: string;
+  queueName: string;
+  payload: unknown;
+  options?: AddTaskOptions;
+  lastRun?: Date;
+}
+
+export type Middleware = (task: Task<unknown>, next: () => Promise<void>) => Promise<void>;
+export type Handler = (task: Task<unknown>) => Promise<void>;
+
+export interface ShutdownSummary {
+  completed: number;
+  forceCancelled: number;
+  durationMs: number;
+}
+
+export class TaskQueue {
+  private queues: Map<string, Task<unknown>[]> = new Map();
+  private dlqs: Map<string, Task<unknown>[]> = new Map();
+  private tasksById: Map<string, { queueName: string, task: Task<unknown> }> = new Map();
+  private concurrencyLimits: Map<string, number> = new Map();
+  private activeCounts: Map<string, number> = new Map();
+  private progressListeners: Map<string, Set<(progress: TaskProgress) => void>> = new Map();
+  private schedules: Map<string, RecurringSchedule> = new Map();
+  private middlewares: Map<string, Middleware[]> = new Map();
+  private handlers: Map<string, Handler> = new Map();
+  private shutdownCallbacks: (() => Promise<void>)[] = [];
+  private isShuttingDown = false;
+  private shutdownResult: ShutdownSummary | null = null;
+  private activeTasksWaiters: (() => void)[] = [];
+  private defaultQueueName = 'default';
+
+  setConcurrencyLimit(queueName: string, limit: number): void {
+    this.concurrencyLimits.set(queueName, limit);
+  }
+
+  getConcurrencyLimit(queueName: string = this.defaultQueueName): number {
+    return this.concurrencyLimits.get(queueName) ?? Infinity;
+  }
+
+  getActiveCount(queueName: string = this.defaultQueueName): number {
+    return this.activeCounts.get(queueName) ?? 0;
+  }
+
+  onShutdown(callback: () => Promise<void>): void {
+    this.shutdownCallbacks.push(callback);
+  }
+
+  async shutdown(timeoutMs: number = 5000): Promise<ShutdownSummary> {
+    if (this.shutdownResult) return this.shutdownResult;
+    this.isShuttingDown = true;
+    const startTime = Date.now();
+
+    await Promise.all(this.shutdownCallbacks.map(cb => cb().catch(() => {})));
+
+    const getTotalActive = () => {
+      let total = 0;
+      for (const count of this.activeCounts.values()) {
+        total += count;
+      }
+      return total;
+    };
+
+    const initialActiveTasks = Array.from(this.tasksById.values())
+      .filter(e => e.task.status === 'processing')
+      .map(e => e.task.id);
+
+    if (getTotalActive() > 0) {
+      const waitPromise = new Promise<void>(resolve => {
+        this.activeTasksWaiters.push(resolve);
+      });
+
+      const timeoutPromise = new Promise<void>(resolve => {
+        setTimeout(resolve, timeoutMs);
+      });
+
+      await Promise.race([waitPromise, timeoutPromise]);
+    }
+
+    let forceCancelled = 0;
+    
+    for (const entry of this.tasksById.values()) {
+      const task = entry.task;
+      if (task.status === 'processing' && initialActiveTasks.includes(task.id)) {
+        this.cancelTask(task.id);
+        forceCancelled++;
+      }
+    }
+    
+    const completed = Array.from(this.tasksById.values()).filter(e => e.task.status === 'completed').length;
+
+    this.shutdownResult = {
+      completed,
+      forceCancelled,
+      durationMs: Date.now() - startTime,
+    };
+
+    return this.shutdownResult;
+  }
+
+  private notifyActiveTaskFinished(): void {
+    const getTotalActive = () => {
+      let total = 0;
+      for (const count of this.activeCounts.values()) {
+        total += count;
+      }
+      return total;
+    };
+
+    if (getTotalActive() === 0) {
+      const waiters = [...this.activeTasksWaiters];
+      this.activeTasksWaiters = [];
+      waiters.forEach(resolve => resolve());
+    }
+  }
+
+  createSchedule(expression: string, payload: unknown, options?: AddTaskOptions): string {
+    const id = randomUUID();
+    this.schedules.set(id, {
+      id,
+      expression,
+      queueName: options?.queueName ?? this.defaultQueueName,
+      payload,
+      options,
+    });
+    return id;
+  }
+
+  removeSchedule(id: string): void {
+    this.schedules.delete(id);
+  }
+
+  listSchedules(): RecurringSchedule[] {
+    return Array.from(this.schedules.values());
+  }
+
+  checkSchedules(now: Date = new Date()): void {
+    for (const schedule of this.schedules.values()) {
+      if (this.shouldRunSchedule(schedule, now)) {
+        this.addTask(schedule.payload, schedule.options);
+        schedule.lastRun = now;
+      }
+    }
+  }
+
+  private shouldRunSchedule(schedule: RecurringSchedule, now: Date): boolean {
+    if (schedule.lastRun && 
+        schedule.lastRun.getFullYear() === now.getFullYear() &&
+        schedule.lastRun.getMonth() === now.getMonth() &&
+        schedule.lastRun.getDate() === now.getDate() &&
+        schedule.lastRun.getHours() === now.getHours() &&
+        schedule.lastRun.getMinutes() === now.getMinutes()) {
+      return false;
+    }
+
+    const { expression } = schedule;
+    const minutes = now.getMinutes();
+    const hours = now.getHours();
+
+    if (expression.startsWith('*/')) {
+      const parts = expression.split(' ');
+      const n = parseInt(parts[0].substring(2), 10);
+      return minutes % n === 0;
+    }
+
+    if (expression === '0 * * * *') {
+      return minutes === 0;
+    }
+
+    if (expression === '0 0 * * *') {
+      return minutes === 0 && hours === 0;
+    }
+
+    return false;
+  }
+
+  reportTaskProgress(taskId: string, percentage: number, message?: string): void {
+    const task = this.getTask(taskId);
+    if (!task || task.status !== 'processing') return;
+
+    const progress: TaskProgress = { percentage, message };
+    task.progress = progress;
+
+    const listeners = this.progressListeners.get(taskId);
+    if (listeners) {
+      listeners.forEach(callback => callback(progress));
+    }
+  }
+
+  subscribeToTaskProgress(taskId: string, callback: (progress: TaskProgress) => void): () => void {
+    if (!this.progressListeners.has(taskId)) {
+      this.progressListeners.set(taskId, new Set());
+    }
+    this.progressListeners.get(taskId)!.add(callback);
+
+    return () => {
+      const listeners = this.progressListeners.get(taskId);
+      if (listeners) {
+        listeners.delete(callback);
+        if (listeners.size === 0) {
+          this.progressListeners.delete(taskId);
+        }
+      }
+    };
+  }
+
+  cancelTask(taskId: string): void {
+    const entry = this.tasksById.get(taskId);
+    if (!entry) return;
+
+    const { task, queueName } = entry;
+    if (task.status === 'pending') {
+      task.status = 'cancelled';
+      const queue = this.queues.get(queueName);
+      if (queue) {
+        const idx = queue.indexOf(task);
+        if (idx !== -1) {
+          queue.splice(idx, 1);
+        }
+      }
+    } else if (task.status === 'processing') {
+      task.status = 'cancelled';
+      const currentActive = this.activeCounts.get(queueName) ?? 0;
+      this.activeCounts.set(queueName, Math.max(0, currentActive - 1));
+      this.notifyActiveTaskFinished();
+    }
+    
+    this.progressListeners.delete(taskId);
+  }
+
+  use(queueName: string, middleware: Middleware): void {
+    if (!this.middlewares.has(queueName)) {
+      this.middlewares.set(queueName, []);
+    }
+    this.middlewares.get(queueName)!.push(middleware);
+  }
+
+  registerHandler(queueName: string, handler: Handler): void {
+    this.handlers.set(queueName, handler);
+  }
+
+  async processNext(queueName: string = this.defaultQueueName): Promise<boolean> {
+    const task = this.getNextTask(queueName);
+    if (!task) return false;
+
+    const middlewares = this.middlewares.get(queueName) || [];
+    const handler = this.handlers.get(queueName);
+
+    let index = 0;
+
+    const next = async (): Promise<void> => {
+      if (index < middlewares.length) {
+        const middleware = middlewares[index++];
+        await middleware(task, next);
+      } else if (handler) {
+        await handler(task);
+      }
+    };
+
+    try {
+      await next();
+      if (task.status === 'processing') {
+        this.completeTask(task.id);
+      }
+    } catch (error) {
+      this.failTask(task.id, error);
+    }
+
+    return true;
+  }
+
+  addTask<T>(payload: T, optionsOrQueueName?: string | AddTaskOptions, priority?: number): Task<T> {
+    if (this.isShuttingDown) {
+      throw new Error('Queue is shutting down');
+    }
+
+    let queueName = this.defaultQueueName;
+    let taskPriority = 5;
+    let delay = 0;
+    let availableAt: Date | undefined;
+    let maxRetries = 3;
+    let baseDelay = 1000;
+    let dependencies: string[] = [];
+
+    if (typeof optionsOrQueueName === 'string') {
+      queueName = optionsOrQueueName;
+      if (priority !== undefined) {
+        taskPriority = priority;
+      }
+    } else if (typeof optionsOrQueueName === 'object') {
+      queueName = optionsOrQueueName.queueName ?? this.defaultQueueName;
+      taskPriority = optionsOrQueueName.priority ?? 5;
+      delay = optionsOrQueueName.delay ?? 0;
+      availableAt = optionsOrQueueName.availableAt;
+      maxRetries = optionsOrQueueName.maxRetries ?? 3;
+      baseDelay = optionsOrQueueName.baseDelay ?? 1000;
+      dependencies = optionsOrQueueName.dependencies ?? [];
+    }
+
+    if (taskPriority < 1 || taskPriority > 10) {
+      throw new Error('Priority must be between 1 and 10');
+    }
+
+    for (const depId of dependencies) {
+      if (!this.tasksById.has(depId)) {
+        throw new Error(`Dependency task ${depId} does not exist`);
+      }
+    }
+
+    const now = new Date();
+    const finalAvailableAt = availableAt ?? (delay > 0 ? new Date(now.getTime() + delay) : new Date(0));
+
+    const task: Task<T> = {
+      id: randomUUID(),
+      payload,
+      status: 'pending',
+      priority: taskPriority,
+      createdAt: now,
+      availableAt: finalAvailableAt,
+      attempts: 0,
+      maxRetries,
+      baseDelay,
+      dependencies,
+    };
+    
+    if (!this.queues.has(queueName)) {
+      this.queues.set(queueName, []);
+    }
+    
+    this.queues.get(queueName)!.push(task as Task<unknown>);
+    this.tasksById.set(task.id, { queueName, task: task as Task<unknown> });
+    return task;
+  }
+
+  getNextTask(queueName: string = this.defaultQueueName): Task<unknown> | null {
+    const limit = this.getConcurrencyLimit(queueName);
+    const active = this.getActiveCount(queueName);
+    if (active >= limit) {
+      return null;
+    }
+
+    const queue = this.queues.get(queueName);
+    if (!queue || queue.length === 0) {
+      return null;
+    }
+
+    const now = new Date();
+    let bestTaskIndex = -1;
+    for (let i = 0; i < queue.length; i++) {
+      const task = queue[i];
+      if (task.status !== 'pending') continue;
+      if (task.availableAt > now) continue;
+
+      let depsResolved = true;
+      for (const depId of task.dependencies) {
+        const dep = this.getTask(depId);
+        if (!dep || dep.status !== 'completed') {
+          depsResolved = false;
+          break;
+        }
+      }
+      if (!depsResolved) continue;
+
+      if (bestTaskIndex === -1) {
+        bestTaskIndex = i;
+      } else {
+        const bestTask = queue[bestTaskIndex];
+        if (task.availableAt < bestTask.availableAt) {
+          bestTaskIndex = i;
+        } else if (task.availableAt.getTime() === bestTask.availableAt.getTime()) {
+           if (task.priority < bestTask.priority) {
+             bestTaskIndex = i;
+           } else if (task.priority === bestTask.priority) {
+             if (task.createdAt < bestTask.createdAt) {
+               bestTaskIndex = i;
+             }
+           }
+        }
+      }
+    }
+
+    if (bestTaskIndex !== -1) {
+      const task = queue[bestTaskIndex];
+      task.status = 'processing';
+      task.attempts++;
+
+      const currentActive = this.activeCounts.get(queueName) ?? 0;
+      this.activeCounts.set(queueName, currentActive + 1);
+
+      return task;
+    }
+    return null;
+  }
+
+  getDependencyStatus(taskId: string): { total: number, met: number, remaining: string[] } {
+    const task = this.getTask(taskId);
+    if (!task) throw new Error('Task not found');
+
+    const remaining: string[] = [];
+    let met = 0;
+    for (const depId of task.dependencies) {
+      const dep = this.getTask(depId);
+      if (dep && dep.status === 'completed') {
+        met++;
+      } else {
+        remaining.push(depId);
+      }
+    }
+
+    return {
+      total: task.dependencies.length,
+      met,
+      remaining,
+    };
+  }
+
+  completeTask(taskId: string): void {
+    const entry = this.tasksById.get(taskId);
+    if (entry && entry.task.status === 'processing') {
+      entry.task.status = 'completed';
+      const currentActive = this.activeCounts.get(entry.queueName) ?? 0;
+      this.activeCounts.set(entry.queueName, Math.max(0, currentActive - 1));
+      this.notifyActiveTaskFinished();
+    } else if (entry) {
+      entry.task.status = 'completed';
+    }
+  }
+
+  failTask(taskId: string, error?: unknown): void {
+    const entry = this.tasksById.get(taskId);
+    if (!entry) return;
+
+    const task = entry.task;
+    if (task.status === 'cancelled') return;
+
+    const wasProcessing = task.status === 'processing';
+    task.error = error;
+
+    if (task.attempts <= task.maxRetries && !this.isShuttingDown) {
+      const delay = task.baseDelay * Math.pow(2, task.attempts - 1);
+      task.availableAt = new Date(Date.now() + delay);
+      task.status = 'pending';
+    } else {
+      task.status = 'failed';
+      const queueName = entry.queueName;
+      if (!this.dlqs.has(queueName)) {
+        this.dlqs.set(queueName, []);
+      }
+      this.dlqs.get(queueName)!.push(task);
+      
+      const queue = this.queues.get(queueName);
+      if (queue) {
+        const idx = queue.indexOf(task);
+        if (idx !== -1) {
+          queue.splice(idx, 1);
+        }
+      }
+    }
+
+    if (wasProcessing) {
+      const currentActive = this.activeCounts.get(entry.queueName) ?? 0;
+      this.activeCounts.set(entry.queueName, Math.max(0, currentActive - 1));
+      this.notifyActiveTaskFinished();
+    }
+  }
+
+  getDeadLetterTasks(queueName: string = this.defaultQueueName): Task<unknown>[] {
+    return this.dlqs.get(queueName) || [];
+  }
+
+  resubmitDeadLetterTask(taskId: string): boolean {
+    const entry = this.tasksById.get(taskId);
+    if (!entry) return false;
+
+    const task = entry.task;
+    if (task.status !== 'failed') return false;
+
+    const queueName = entry.queueName;
+    const dlq = this.dlqs.get(queueName);
+    if (!dlq) return false;
+
+    const idx = dlq.indexOf(task);
+    if (idx === -1) return false;
+
+    dlq.splice(idx, 1);
+
+    task.status = 'pending';
+    task.attempts = 0;
+    task.availableAt = new Date();
+    delete task.error;
+
+    if (!this.queues.has(queueName)) {
+      this.queues.set(queueName, []);
+    }
+    this.queues.get(queueName)!.push(task);
+
+    return true;
+  }
+
+  clearDeadLetterTasks(queueName: string = this.defaultQueueName): void {
+    this.dlqs.set(queueName, []);
+  }
+
+  getPendingCount(queueName: string = this.defaultQueueName): number {
+    const queue = this.queues.get(queueName);
+    if (!queue) {
+      return 0;
+    }
+    return queue.filter(t => t.status === 'pending').length;
+  }
+
+  listQueues(): string[] {
+    return Array.from(this.queues.keys());
+  }
+
+  getTask(taskId: string): Task<unknown> | null {
+    return this.tasksById.get(taskId)?.task ?? null;
+  }
+}
