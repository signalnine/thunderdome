diff --git a/.thunderdome-metrics.json b/.thunderdome-metrics.json
new file mode 100644
index 0000000..f0761b3
--- /dev/null
+++ b/.thunderdome-metrics.json
@@ -0,0 +1,11 @@
+{
+  "input_tokens": 0,
+  "output_tokens": 0,
+  "cache_read_tokens": 0,
+  "cache_creation_tokens": 0,
+  "turns": 0,
+  "tools_used": [],
+  "duration_ms": 0,
+  "total_cost_usd": 0,
+  "note": "interactive-mode-metrics-approximate"
+}
\ No newline at end of file
diff --git a/package-lock.json b/package-lock.json
index 783de11..1c1962f 100644
--- a/package-lock.json
+++ b/package-lock.json
@@ -18,11 +18,83 @@
         "@types/uuid": "^10.0.0",
         "@typescript-eslint/eslint-plugin": "^7.0.0",
         "@typescript-eslint/parser": "^7.0.0",
+        "@vitest/coverage-v8": "^2.0.0",
         "eslint": "^8.56.0",
         "typescript": "^5.4.0",
         "vitest": "^2.0.0"
       }
     },
+    "node_modules/@ampproject/remapping": {
+      "version": "2.3.0",
+      "resolved": "https://registry.npmjs.org/@ampproject/remapping/-/remapping-2.3.0.tgz",
+      "integrity": "sha512-30iZtAPgz+LTIYoeivqYo853f02jBYSd5uGnGpkFV0M3xOt9aN73erkgYAmZU43x4VfqcnLxW9Kpg3R5LC4YYw==",
+      "dev": true,
+      "license": "Apache-2.0",
+      "dependencies": {
+        "@jridgewell/gen-mapping": "^0.3.5",
+        "@jridgewell/trace-mapping": "^0.3.24"
+      },
+      "engines": {
+        "node": ">=6.0.0"
+      }
+    },
+    "node_modules/@babel/helper-string-parser": {
+      "version": "7.27.1",
+      "resolved": "https://registry.npmjs.org/@babel/helper-string-parser/-/helper-string-parser-7.27.1.tgz",
+      "integrity": "sha512-qMlSxKbpRlAridDExk92nSobyDdpPijUq2DW6oDnUqd0iOGxmQjyqhMIihI9+zv4LPyZdRje2cavWPbCbWm3eA==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=6.9.0"
+      }
+    },
+    "node_modules/@babel/helper-validator-identifier": {
+      "version": "7.28.5",
+      "resolved": "https://registry.npmjs.org/@babel/helper-validator-identifier/-/helper-validator-identifier-7.28.5.tgz",
+      "integrity": "sha512-qSs4ifwzKJSV39ucNjsvc6WVHs6b7S03sOh2OcHF9UHfVPqWWALUsNUVzhSBiItjRZoLHx7nIarVjqKVusUZ1Q==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=6.9.0"
+      }
+    },
+    "node_modules/@babel/parser": {
+      "version": "7.29.0",
+      "resolved": "https://registry.npmjs.org/@babel/parser/-/parser-7.29.0.tgz",
+      "integrity": "sha512-IyDgFV5GeDUVX4YdF/3CPULtVGSXXMLh1xVIgdCgxApktqnQV0r7/8Nqthg+8YLGaAtdyIlo2qIdZrbCv4+7ww==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@babel/types": "^7.29.0"
+      },
+      "bin": {
+        "parser": "bin/babel-parser.js"
+      },
+      "engines": {
+        "node": ">=6.0.0"
+      }
+    },
+    "node_modules/@babel/types": {
+      "version": "7.29.0",
+      "resolved": "https://registry.npmjs.org/@babel/types/-/types-7.29.0.tgz",
+      "integrity": "sha512-LwdZHpScM4Qz8Xw2iKSzS+cfglZzJGvofQICy7W7v4caru4EaAmyUuO6BGrbyQ2mYV11W0U8j5mBhd14dd3B0A==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@babel/helper-string-parser": "^7.27.1",
+        "@babel/helper-validator-identifier": "^7.28.5"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      }
+    },
+    "node_modules/@bcoe/v8-coverage": {
+      "version": "0.2.3",
+      "resolved": "https://registry.npmjs.org/@bcoe/v8-coverage/-/v8-coverage-0.2.3.tgz",
+      "integrity": "sha512-0hYQ8SB4Db5zvZB4axdMHGwEaQjkZzFjQiN9LVYvIFB2nSUHW9tYpxWriPrWDASIxiaXax83REcLxuSdnGPZtw==",
+      "dev": true,
+      "license": "MIT"
+    },
     "node_modules/@esbuild/aix-ppc64": {
       "version": "0.21.5",
       "resolved": "https://registry.npmjs.org/@esbuild/aix-ppc64/-/aix-ppc64-0.21.5.tgz",
@@ -563,6 +635,84 @@
       "dev": true,
       "license": "BSD-3-Clause"
     },
+    "node_modules/@isaacs/cliui": {
+      "version": "8.0.2",
+      "resolved": "https://registry.npmjs.org/@isaacs/cliui/-/cliui-8.0.2.tgz",
+      "integrity": "sha512-O8jcjabXaleOG9DQ0+ARXWZBTfnP4WNAqzuiJK7ll44AmxGKv/J2M4TPjxjY3znBCfvBXFzucm1twdyFybFqEA==",
+      "dev": true,
+      "license": "ISC",
+      "dependencies": {
+        "string-width": "^5.1.2",
+        "string-width-cjs": "npm:string-width@^4.2.0",
+        "strip-ansi": "^7.0.1",
+        "strip-ansi-cjs": "npm:strip-ansi@^6.0.1",
+        "wrap-ansi": "^8.1.0",
+        "wrap-ansi-cjs": "npm:wrap-ansi@^7.0.0"
+      },
+      "engines": {
+        "node": ">=12"
+      }
+    },
+    "node_modules/@isaacs/cliui/node_modules/ansi-regex": {
+      "version": "6.2.2",
+      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-6.2.2.tgz",
+      "integrity": "sha512-Bq3SmSpyFHaWjPk8If9yc6svM8c56dB5BAtW4Qbw5jHTwwXXcTLoRMkpDJp6VL0XzlWaCHTXrkFURMYmD0sLqg==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/ansi-regex?sponsor=1"
+      }
+    },
+    "node_modules/@isaacs/cliui/node_modules/strip-ansi": {
+      "version": "7.1.2",
+      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-7.1.2.tgz",
+      "integrity": "sha512-gmBGslpoQJtgnMAvOVqGZpEz9dyoKTCzy2nfz/n8aIFhN/jCE/rCmcxabB6jOOHV+0WNnylOxaxBQPSvcWklhA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "ansi-regex": "^6.0.1"
+      },
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/strip-ansi?sponsor=1"
+      }
+    },
+    "node_modules/@istanbuljs/schema": {
+      "version": "0.1.3",
+      "resolved": "https://registry.npmjs.org/@istanbuljs/schema/-/schema-0.1.3.tgz",
+      "integrity": "sha512-ZXRY4jNvVgSVQ8DL3LTcakaAtXwTVUxE81hslsyD2AtoXW/wVob10HkOJ1X/pAlcI7D+2YoZKg5do8G/w6RYgA==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/@jridgewell/gen-mapping": {
+      "version": "0.3.13",
+      "resolved": "https://registry.npmjs.org/@jridgewell/gen-mapping/-/gen-mapping-0.3.13.tgz",
+      "integrity": "sha512-2kkt/7niJ6MgEPxF0bYdQ6etZaA+fQvDcLKckhy1yIQOzaoKjBBjSj63/aLVjYE3qhRt5dvM+uUyfCg6UKCBbA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@jridgewell/sourcemap-codec": "^1.5.0",
+        "@jridgewell/trace-mapping": "^0.3.24"
+      }
+    },
+    "node_modules/@jridgewell/resolve-uri": {
+      "version": "3.1.2",
+      "resolved": "https://registry.npmjs.org/@jridgewell/resolve-uri/-/resolve-uri-3.1.2.tgz",
+      "integrity": "sha512-bRISgCIjP20/tbWSPWMEi54QVPRZExkuD9lJL+UIxUKtwVJA8wW1Trb1jMs1RFXo1CBTNZ/5hpC9QvmKWdopKw==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=6.0.0"
+      }
+    },
     "node_modules/@jridgewell/sourcemap-codec": {
       "version": "1.5.5",
       "resolved": "https://registry.npmjs.org/@jridgewell/sourcemap-codec/-/sourcemap-codec-1.5.5.tgz",
@@ -570,6 +720,17 @@
       "dev": true,
       "license": "MIT"
     },
+    "node_modules/@jridgewell/trace-mapping": {
+      "version": "0.3.31",
+      "resolved": "https://registry.npmjs.org/@jridgewell/trace-mapping/-/trace-mapping-0.3.31.tgz",
+      "integrity": "sha512-zzNR+SdQSDJzc8joaeP8QQoCQr8NuYx2dIIytl1QeBEZHJ9uW6hebsrYgbz8hJwUQao3TWCMtmfV8Nu1twOLAw==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@jridgewell/resolve-uri": "^3.1.0",
+        "@jridgewell/sourcemap-codec": "^1.4.14"
+      }
+    },
     "node_modules/@nodelib/fs.scandir": {
       "version": "2.1.5",
       "resolved": "https://registry.npmjs.org/@nodelib/fs.scandir/-/fs.scandir-2.1.5.tgz",
@@ -608,6 +769,17 @@
         "node": ">= 8"
       }
     },
+    "node_modules/@pkgjs/parseargs": {
+      "version": "0.11.0",
+      "resolved": "https://registry.npmjs.org/@pkgjs/parseargs/-/parseargs-0.11.0.tgz",
+      "integrity": "sha512-+1VkjdD0QBLPodGrJUeqarH8VAIvQODIbwh9XpP5Syisf7YoQgsJKPNFoqqLQlu+VQ/tVSshMR6loPMn8U+dPg==",
+      "dev": true,
+      "license": "MIT",
+      "optional": true,
+      "engines": {
+        "node": ">=14"
+      }
+    },
     "node_modules/@rollup/rollup-android-arm-eabi": {
       "version": "4.57.1",
       "resolved": "https://registry.npmjs.org/@rollup/rollup-android-arm-eabi/-/rollup-android-arm-eabi-4.57.1.tgz",
@@ -1042,7 +1214,6 @@
       "integrity": "sha512-m0jEgYlYz+mDJZ2+F4v8D1AyQb+QzsNqRuI7xg1VQX/KlKS0qT9r1Mo16yo5F/MtifXFgaofIFsdFMox2SxIbQ==",
       "dev": true,
       "license": "MIT",
-      "peer": true,
       "dependencies": {
         "undici-types": "~7.16.0"
       }
@@ -1141,7 +1312,6 @@
       "integrity": "sha512-4Z+L8I2OqhZV8qA132M4wNL30ypZGYOQVBfMgxDH/K5UX0PNqTu1c6za9ST5r9+tavvHiTWmBnKzpCJ/GlVFtg==",
       "dev": true,
       "license": "BSD-2-Clause",
-      "peer": true,
       "dependencies": {
         "@typescript-eslint/scope-manager": "7.18.0",
         "@typescript-eslint/types": "7.18.0",
@@ -1302,6 +1472,39 @@
       "dev": true,
       "license": "ISC"
     },
+    "node_modules/@vitest/coverage-v8": {
+      "version": "2.1.9",
+      "resolved": "https://registry.npmjs.org/@vitest/coverage-v8/-/coverage-v8-2.1.9.tgz",
+      "integrity": "sha512-Z2cOr0ksM00MpEfyVE8KXIYPEcBFxdbLSs56L8PO0QQMxt/6bDj45uQfxoc96v05KW3clk7vvgP0qfDit9DmfQ==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@ampproject/remapping": "^2.3.0",
+        "@bcoe/v8-coverage": "^0.2.3",
+        "debug": "^4.3.7",
+        "istanbul-lib-coverage": "^3.2.2",
+        "istanbul-lib-report": "^3.0.1",
+        "istanbul-lib-source-maps": "^5.0.6",
+        "istanbul-reports": "^3.1.7",
+        "magic-string": "^0.30.12",
+        "magicast": "^0.3.5",
+        "std-env": "^3.8.0",
+        "test-exclude": "^7.0.1",
+        "tinyrainbow": "^1.2.0"
+      },
+      "funding": {
+        "url": "https://opencollective.com/vitest"
+      },
+      "peerDependencies": {
+        "@vitest/browser": "2.1.9",
+        "vitest": "2.1.9"
+      },
+      "peerDependenciesMeta": {
+        "@vitest/browser": {
+          "optional": true
+        }
+      }
+    },
     "node_modules/@vitest/expect": {
       "version": "2.1.9",
       "resolved": "https://registry.npmjs.org/@vitest/expect/-/expect-2.1.9.tgz",
@@ -1434,7 +1637,6 @@
       "integrity": "sha512-NZyJarBfL7nWwIq+FDL6Zp/yHEhePMNnnJ0y3qfieCrmNvYct8uvtiV41UvlSe6apAfk0fY1FbWx+NwfmpvtTg==",
       "dev": true,
       "license": "MIT",
-      "peer": true,
       "bin": {
         "acorn": "bin/acorn"
       },
@@ -1985,12 +2187,26 @@
         "node": ">= 0.4"
       }
     },
+    "node_modules/eastasianwidth": {
+      "version": "0.2.0",
+      "resolved": "https://registry.npmjs.org/eastasianwidth/-/eastasianwidth-0.2.0.tgz",
+      "integrity": "sha512-I88TYZWc9XiYHRQ4/3c5rjjfgkjhLyW2luGIheGERbNQ6OY7yTybanSpDXZa8y7VUP9YmDcYa+eyq4ca7iLqWA==",
+      "dev": true,
+      "license": "MIT"
+    },
     "node_modules/ee-first": {
       "version": "1.1.1",
       "resolved": "https://registry.npmjs.org/ee-first/-/ee-first-1.1.1.tgz",
       "integrity": "sha512-WMwm9LhRUo+WUaRN+vRuETqG89IgZphVSNkdFgeb6sS/E4OrDIN7t48CAewSHXc6C8lefD8KKfr5vY61brQlow==",
       "license": "MIT"
     },
+    "node_modules/emoji-regex": {
+      "version": "9.2.2",
+      "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-9.2.2.tgz",
+      "integrity": "sha512-L18DaJsXSUk2+42pv8mLs5jJT2hqFkFE4j21wOmgbUqsZ2hL72NsUU785g9RXgo3s0ZNgVl42TiHp3ZtOv/Vyg==",
+      "dev": true,
+      "license": "MIT"
+    },
     "node_modules/encodeurl": {
       "version": "2.0.0",
       "resolved": "https://registry.npmjs.org/encodeurl/-/encodeurl-2.0.0.tgz",
@@ -2111,7 +2327,6 @@
       "deprecated": "This version is no longer supported. Please see https://eslint.org/version-support for other options.",
       "dev": true,
       "license": "MIT",
-      "peer": true,
       "dependencies": {
         "@eslint-community/eslint-utils": "^4.2.0",
         "@eslint-community/regexpp": "^4.6.1",
@@ -2544,6 +2759,23 @@
       "dev": true,
       "license": "ISC"
     },
+    "node_modules/foreground-child": {
+      "version": "3.3.1",
+      "resolved": "https://registry.npmjs.org/foreground-child/-/foreground-child-3.3.1.tgz",
+      "integrity": "sha512-gIXjKqtFuWEgzFRJA9WCQeSJLZDjgJUOMCMzxtvFq/37KojM1BFGufqsCy0r4qSQmYLsZYMeyRqzIWOMup03sw==",
+      "dev": true,
+      "license": "ISC",
+      "dependencies": {
+        "cross-spawn": "^7.0.6",
+        "signal-exit": "^4.0.1"
+      },
+      "engines": {
+        "node": ">=14"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/isaacs"
+      }
+    },
     "node_modules/forwarded": {
       "version": "0.2.0",
       "resolved": "https://registry.npmjs.org/forwarded/-/forwarded-0.2.0.tgz",
@@ -2791,6 +3023,13 @@
         "node": ">= 0.4"
       }
     },
+    "node_modules/html-escaper": {
+      "version": "2.0.2",
+      "resolved": "https://registry.npmjs.org/html-escaper/-/html-escaper-2.0.2.tgz",
+      "integrity": "sha512-H2iMtd0I4Mt5eYiapRdIDjp+XzelXQ0tFE4JS7YFwFevXXMmOp9myNrUvCg0D6ws8iqkRPBfKHgbwig1SmlLfg==",
+      "dev": true,
+      "license": "MIT"
+    },
     "node_modules/http-errors": {
       "version": "2.0.1",
       "resolved": "https://registry.npmjs.org/http-errors/-/http-errors-2.0.1.tgz",
@@ -2923,6 +3162,16 @@
         "node": ">=0.10.0"
       }
     },
+    "node_modules/is-fullwidth-code-point": {
+      "version": "3.0.0",
+      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/is-fullwidth-code-point-3.0.0.tgz",
+      "integrity": "sha512-zymm5+u+sCsSWyD9qNaejV3DFvhCKclKdizYaJUuHA83RLjb7nSuGnddCHGv0hk+KY7BMAlsWeK4Ueg6EV6XQg==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=8"
+      }
+    },
     "node_modules/is-glob": {
       "version": "4.0.3",
       "resolved": "https://registry.npmjs.org/is-glob/-/is-glob-4.0.3.tgz",
@@ -2963,6 +3212,76 @@
       "dev": true,
       "license": "ISC"
     },
+    "node_modules/istanbul-lib-coverage": {
+      "version": "3.2.2",
+      "resolved": "https://registry.npmjs.org/istanbul-lib-coverage/-/istanbul-lib-coverage-3.2.2.tgz",
+      "integrity": "sha512-O8dpsF+r0WV/8MNRKfnmrtCWhuKjxrq2w+jpzBL5UZKTi2LeVWnWOmWRxFlesJONmc+wLAGvKQZEOanko0LFTg==",
+      "dev": true,
+      "license": "BSD-3-Clause",
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/istanbul-lib-report": {
+      "version": "3.0.1",
+      "resolved": "https://registry.npmjs.org/istanbul-lib-report/-/istanbul-lib-report-3.0.1.tgz",
+      "integrity": "sha512-GCfE1mtsHGOELCU8e/Z7YWzpmybrx/+dSTfLrvY8qRmaY6zXTKWn6WQIjaAFw069icm6GVMNkgu0NzI4iPZUNw==",
+      "dev": true,
+      "license": "BSD-3-Clause",
+      "dependencies": {
+        "istanbul-lib-coverage": "^3.0.0",
+        "make-dir": "^4.0.0",
+        "supports-color": "^7.1.0"
+      },
+      "engines": {
+        "node": ">=10"
+      }
+    },
+    "node_modules/istanbul-lib-source-maps": {
+      "version": "5.0.6",
+      "resolved": "https://registry.npmjs.org/istanbul-lib-source-maps/-/istanbul-lib-source-maps-5.0.6.tgz",
+      "integrity": "sha512-yg2d+Em4KizZC5niWhQaIomgf5WlL4vOOjZ5xGCmF8SnPE/mDWWXgvRExdcpCgh9lLRRa1/fSYp2ymmbJ1pI+A==",
+      "dev": true,
+      "license": "BSD-3-Clause",
+      "dependencies": {
+        "@jridgewell/trace-mapping": "^0.3.23",
+        "debug": "^4.1.1",
+        "istanbul-lib-coverage": "^3.0.0"
+      },
+      "engines": {
+        "node": ">=10"
+      }
+    },
+    "node_modules/istanbul-reports": {
+      "version": "3.2.0",
+      "resolved": "https://registry.npmjs.org/istanbul-reports/-/istanbul-reports-3.2.0.tgz",
+      "integrity": "sha512-HGYWWS/ehqTV3xN10i23tkPkpH46MLCIMFNCaaKNavAXTF1RkqxawEPtnjnGZ6XKSInBKkiOA5BKS+aZiY3AvA==",
+      "dev": true,
+      "license": "BSD-3-Clause",
+      "dependencies": {
+        "html-escaper": "^2.0.0",
+        "istanbul-lib-report": "^3.0.0"
+      },
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/jackspeak": {
+      "version": "3.4.3",
+      "resolved": "https://registry.npmjs.org/jackspeak/-/jackspeak-3.4.3.tgz",
+      "integrity": "sha512-OGlZQpz2yfahA/Rd1Y8Cd9SIEsqvXkLVoSw/cgwhnhFMDbsQFeZYoJJ7bIZBS9BcamUW96asq/npPWugM+RQBw==",
+      "dev": true,
+      "license": "BlueOak-1.0.0",
+      "dependencies": {
+        "@isaacs/cliui": "^8.0.2"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/isaacs"
+      },
+      "optionalDependencies": {
+        "@pkgjs/parseargs": "^0.11.0"
+      }
+    },
     "node_modules/js-yaml": {
       "version": "4.1.1",
       "resolved": "https://registry.npmjs.org/js-yaml/-/js-yaml-4.1.1.tgz",
@@ -3051,6 +3370,13 @@
       "dev": true,
       "license": "MIT"
     },
+    "node_modules/lru-cache": {
+      "version": "10.4.3",
+      "resolved": "https://registry.npmjs.org/lru-cache/-/lru-cache-10.4.3.tgz",
+      "integrity": "sha512-JNAzZcXrCt42VGLuYz0zfAzDfAvJWW6AfYlDBQyDV5DClI2m5sAmK+OIO7s59XfsRsWHp02jAJrRadPRGTt6SQ==",
+      "dev": true,
+      "license": "ISC"
+    },
     "node_modules/magic-string": {
       "version": "0.30.21",
       "resolved": "https://registry.npmjs.org/magic-string/-/magic-string-0.30.21.tgz",
@@ -3061,6 +3387,34 @@
         "@jridgewell/sourcemap-codec": "^1.5.5"
       }
     },
+    "node_modules/magicast": {
+      "version": "0.3.5",
+      "resolved": "https://registry.npmjs.org/magicast/-/magicast-0.3.5.tgz",
+      "integrity": "sha512-L0WhttDl+2BOsybvEOLK7fW3UA0OQ0IQ2d6Zl2x/a6vVRs3bAY0ECOSHHeL5jD+SbOpOCUEi0y1DgHEn9Qn1AQ==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@babel/parser": "^7.25.4",
+        "@babel/types": "^7.25.4",
+        "source-map-js": "^1.2.0"
+      }
+    },
+    "node_modules/make-dir": {
+      "version": "4.0.0",
+      "resolved": "https://registry.npmjs.org/make-dir/-/make-dir-4.0.0.tgz",
+      "integrity": "sha512-hXdUTZYIVOt1Ex//jAQi+wTZZpUpwBj/0QsOzqegb3rGMMeJiSEu5xLHnYfBrRV4RH2+OCSOO95Is/7x1WJ4bw==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "semver": "^7.5.3"
+      },
+      "engines": {
+        "node": ">=10"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/sindresorhus"
+      }
+    },
     "node_modules/math-intrinsics": {
       "version": "1.1.0",
       "resolved": "https://registry.npmjs.org/math-intrinsics/-/math-intrinsics-1.1.0.tgz",
@@ -3191,6 +3545,16 @@
         "url": "https://github.com/sponsors/ljharb"
       }
     },
+    "node_modules/minipass": {
+      "version": "7.1.2",
+      "resolved": "https://registry.npmjs.org/minipass/-/minipass-7.1.2.tgz",
+      "integrity": "sha512-qOOzS1cBTWYF4BH8fVePDBOO9iptMnGUEZwNc/cMWnTV2nVLZ7VoNWEPHkYczZA0pdoA7dl6e7FL659nX9S2aw==",
+      "dev": true,
+      "license": "ISC",
+      "engines": {
+        "node": ">=16 || 14 >=14.17"
+      }
+    },
     "node_modules/mkdirp-classic": {
       "version": "0.5.3",
       "resolved": "https://registry.npmjs.org/mkdirp-classic/-/mkdirp-classic-0.5.3.tgz",
@@ -3339,6 +3703,13 @@
         "url": "https://github.com/sponsors/sindresorhus"
       }
     },
+    "node_modules/package-json-from-dist": {
+      "version": "1.0.1",
+      "resolved": "https://registry.npmjs.org/package-json-from-dist/-/package-json-from-dist-1.0.1.tgz",
+      "integrity": "sha512-UEZIS3/by4OC8vL3P2dTXRETpebLI2NiI5vIrjaD/5UtrkFX/tNbwjTSRAGC/+7CAo2pIcBaRgWmcBBHcsaCIw==",
+      "dev": true,
+      "license": "BlueOak-1.0.0"
+    },
     "node_modules/parent-module": {
       "version": "1.0.1",
       "resolved": "https://registry.npmjs.org/parent-module/-/parent-module-1.0.1.tgz",
@@ -3391,6 +3762,23 @@
         "node": ">=8"
       }
     },
+    "node_modules/path-scurry": {
+      "version": "1.11.1",
+      "resolved": "https://registry.npmjs.org/path-scurry/-/path-scurry-1.11.1.tgz",
+      "integrity": "sha512-Xa4Nw17FS9ApQFJ9umLiJS4orGjm7ZzwUrwamcGQuHSzDyth9boKDaycYdDcZDuqYATXw4HFXgaqWTctW/v1HA==",
+      "dev": true,
+      "license": "BlueOak-1.0.0",
+      "dependencies": {
+        "lru-cache": "^10.2.0",
+        "minipass": "^5.0.0 || ^6.0.2 || ^7.0.0"
+      },
+      "engines": {
+        "node": ">=16 || 14 >=14.18"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/isaacs"
+      }
+    },
     "node_modules/path-to-regexp": {
       "version": "0.1.12",
       "resolved": "https://registry.npmjs.org/path-to-regexp/-/path-to-regexp-0.1.12.tgz",
@@ -3947,6 +4335,19 @@
       "dev": true,
       "license": "ISC"
     },
+    "node_modules/signal-exit": {
+      "version": "4.1.0",
+      "resolved": "https://registry.npmjs.org/signal-exit/-/signal-exit-4.1.0.tgz",
+      "integrity": "sha512-bzyZ1e88w9O1iNJbKnOlvYTrWPDl46O1bG0D3XInv+9tkPrxrN8jUUTiFlDkkmKWgn1M6CfIA13SuGqOa9Korw==",
+      "dev": true,
+      "license": "ISC",
+      "engines": {
+        "node": ">=14"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/isaacs"
+      }
+    },
     "node_modules/simple-concat": {
       "version": "1.0.1",
       "resolved": "https://registry.npmjs.org/simple-concat/-/simple-concat-1.0.1.tgz",
@@ -4044,6 +4445,76 @@
         "safe-buffer": "~5.2.0"
       }
     },
+    "node_modules/string-width": {
+      "version": "5.1.2",
+      "resolved": "https://registry.npmjs.org/string-width/-/string-width-5.1.2.tgz",
+      "integrity": "sha512-HnLOCR3vjcY8beoNLtcjZ5/nxn2afmME6lhrDrebokqMap+XbeW8n9TXpPDOqdGK5qcI3oT0GKTW6wC7EMiVqA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "eastasianwidth": "^0.2.0",
+        "emoji-regex": "^9.2.2",
+        "strip-ansi": "^7.0.1"
+      },
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/sindresorhus"
+      }
+    },
+    "node_modules/string-width-cjs": {
+      "name": "string-width",
+      "version": "4.2.3",
+      "resolved": "https://registry.npmjs.org/string-width/-/string-width-4.2.3.tgz",
+      "integrity": "sha512-wKyQRQpjJ0sIp62ErSZdGsjMJWsap5oRNihHhu6G7JVO/9jIB6UyevL+tXuOqrng8j/cxKTWyWUwvSTriiZz/g==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "emoji-regex": "^8.0.0",
+        "is-fullwidth-code-point": "^3.0.0",
+        "strip-ansi": "^6.0.1"
+      },
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/string-width-cjs/node_modules/emoji-regex": {
+      "version": "8.0.0",
+      "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-8.0.0.tgz",
+      "integrity": "sha512-MSjYzcWNOA0ewAHpz0MxpYFvwg6yjy1NG3xteoqz644VCo/RPgnr1/GGt+ic3iJTzQ8Eu3TdM14SawnVUmGE6A==",
+      "dev": true,
+      "license": "MIT"
+    },
+    "node_modules/string-width/node_modules/ansi-regex": {
+      "version": "6.2.2",
+      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-6.2.2.tgz",
+      "integrity": "sha512-Bq3SmSpyFHaWjPk8If9yc6svM8c56dB5BAtW4Qbw5jHTwwXXcTLoRMkpDJp6VL0XzlWaCHTXrkFURMYmD0sLqg==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/ansi-regex?sponsor=1"
+      }
+    },
+    "node_modules/string-width/node_modules/strip-ansi": {
+      "version": "7.1.2",
+      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-7.1.2.tgz",
+      "integrity": "sha512-gmBGslpoQJtgnMAvOVqGZpEz9dyoKTCzy2nfz/n8aIFhN/jCE/rCmcxabB6jOOHV+0WNnylOxaxBQPSvcWklhA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "ansi-regex": "^6.0.1"
+      },
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/strip-ansi?sponsor=1"
+      }
+    },
     "node_modules/strip-ansi": {
       "version": "6.0.1",
       "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-6.0.1.tgz",
@@ -4057,6 +4528,20 @@
         "node": ">=8"
       }
     },
+    "node_modules/strip-ansi-cjs": {
+      "name": "strip-ansi",
+      "version": "6.0.1",
+      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-6.0.1.tgz",
+      "integrity": "sha512-Y38VPSHcqkFrCpFnQ9vuSXmquuv5oXOKpGeT6aGrr3o3Gc9AlVa6JBfUSOCnbxGGZF+/0ooI7KrPuUSztUdU5A==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "ansi-regex": "^5.0.1"
+      },
+      "engines": {
+        "node": ">=8"
+      }
+    },
     "node_modules/strip-json-comments": {
       "version": "3.1.1",
       "resolved": "https://registry.npmjs.org/strip-json-comments/-/strip-json-comments-3.1.1.tgz",
@@ -4111,6 +4596,43 @@
         "node": ">=6"
       }
     },
+    "node_modules/test-exclude": {
+      "version": "7.0.1",
+      "resolved": "https://registry.npmjs.org/test-exclude/-/test-exclude-7.0.1.tgz",
+      "integrity": "sha512-pFYqmTw68LXVjeWJMST4+borgQP2AyMNbg1BpZh9LbyhUeNkeaPF9gzfPGUAnSMV3qPYdWUwDIjjCLiSDOl7vg==",
+      "dev": true,
+      "license": "ISC",
+      "dependencies": {
+        "@istanbuljs/schema": "^0.1.2",
+        "glob": "^10.4.1",
+        "minimatch": "^9.0.4"
+      },
+      "engines": {
+        "node": ">=18"
+      }
+    },
+    "node_modules/test-exclude/node_modules/glob": {
+      "version": "10.5.0",
+      "resolved": "https://registry.npmjs.org/glob/-/glob-10.5.0.tgz",
+      "integrity": "sha512-DfXN8DfhJ7NH3Oe7cFmu3NCu1wKbkReJ8TorzSAFbSKrlNaQSKfIzqYqVY8zlbs2NLBbWpRiU52GX2PbaBVNkg==",
+      "deprecated": "Old versions of glob are not supported, and contain widely publicized security vulnerabilities, which have been fixed in the current version. Please update. Support for old versions may be purchased (at exorbitant rates) by contacting i@izs.me",
+      "dev": true,
+      "license": "ISC",
+      "dependencies": {
+        "foreground-child": "^3.1.0",
+        "jackspeak": "^3.1.2",
+        "minimatch": "^9.0.4",
+        "minipass": "^7.1.2",
+        "package-json-from-dist": "^1.0.0",
+        "path-scurry": "^1.11.1"
+      },
+      "bin": {
+        "glob": "dist/esm/bin.mjs"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/isaacs"
+      }
+    },
     "node_modules/text-table": {
       "version": "0.2.0",
       "resolved": "https://registry.npmjs.org/text-table/-/text-table-0.2.0.tgz",
@@ -4254,7 +4776,6 @@
       "integrity": "sha512-jl1vZzPDinLr9eUt3J/t7V6FgNEw9QjvBPdysz9KfQDD41fQrC2Y4vKQdiaUpFT4bXlb1RHhLpp8wtm6M5TgSw==",
       "dev": true,
       "license": "Apache-2.0",
-      "peer": true,
       "bin": {
         "tsc": "bin/tsc",
         "tsserver": "bin/tsserver"
@@ -4518,6 +5039,107 @@
         "node": ">=0.10.0"
       }
     },
+    "node_modules/wrap-ansi": {
+      "version": "8.1.0",
+      "resolved": "https://registry.npmjs.org/wrap-ansi/-/wrap-ansi-8.1.0.tgz",
+      "integrity": "sha512-si7QWI6zUMq56bESFvagtmzMdGOtoxfR+Sez11Mobfc7tm+VkUckk9bW2UeffTGVUbOksxmSw0AA2gs8g71NCQ==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "ansi-styles": "^6.1.0",
+        "string-width": "^5.0.1",
+        "strip-ansi": "^7.0.1"
+      },
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/wrap-ansi?sponsor=1"
+      }
+    },
+    "node_modules/wrap-ansi-cjs": {
+      "name": "wrap-ansi",
+      "version": "7.0.0",
+      "resolved": "https://registry.npmjs.org/wrap-ansi/-/wrap-ansi-7.0.0.tgz",
+      "integrity": "sha512-YVGIj2kamLSTxw6NsZjoBxfSwsn0ycdesmc4p+Q21c5zPuZ1pl+NfxVdxPtdHvmNVOQ6XSYG4AUtyt/Fi7D16Q==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "ansi-styles": "^4.0.0",
+        "string-width": "^4.1.0",
+        "strip-ansi": "^6.0.0"
+      },
+      "engines": {
+        "node": ">=10"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/wrap-ansi?sponsor=1"
+      }
+    },
+    "node_modules/wrap-ansi-cjs/node_modules/emoji-regex": {
+      "version": "8.0.0",
+      "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-8.0.0.tgz",
+      "integrity": "sha512-MSjYzcWNOA0ewAHpz0MxpYFvwg6yjy1NG3xteoqz644VCo/RPgnr1/GGt+ic3iJTzQ8Eu3TdM14SawnVUmGE6A==",
+      "dev": true,
+      "license": "MIT"
+    },
+    "node_modules/wrap-ansi-cjs/node_modules/string-width": {
+      "version": "4.2.3",
+      "resolved": "https://registry.npmjs.org/string-width/-/string-width-4.2.3.tgz",
+      "integrity": "sha512-wKyQRQpjJ0sIp62ErSZdGsjMJWsap5oRNihHhu6G7JVO/9jIB6UyevL+tXuOqrng8j/cxKTWyWUwvSTriiZz/g==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "emoji-regex": "^8.0.0",
+        "is-fullwidth-code-point": "^3.0.0",
+        "strip-ansi": "^6.0.1"
+      },
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/wrap-ansi/node_modules/ansi-regex": {
+      "version": "6.2.2",
+      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-6.2.2.tgz",
+      "integrity": "sha512-Bq3SmSpyFHaWjPk8If9yc6svM8c56dB5BAtW4Qbw5jHTwwXXcTLoRMkpDJp6VL0XzlWaCHTXrkFURMYmD0sLqg==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/ansi-regex?sponsor=1"
+      }
+    },
+    "node_modules/wrap-ansi/node_modules/ansi-styles": {
+      "version": "6.2.3",
+      "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-6.2.3.tgz",
+      "integrity": "sha512-4Dj6M28JB+oAH8kFkTLUo+a2jwOFkuqb3yucU0CANcRRUbxS0cP0nZYCGjcc3BNXwRIsUVmDGgzawme7zvJHvg==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/ansi-styles?sponsor=1"
+      }
+    },
+    "node_modules/wrap-ansi/node_modules/strip-ansi": {
+      "version": "7.1.2",
+      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-7.1.2.tgz",
+      "integrity": "sha512-gmBGslpoQJtgnMAvOVqGZpEz9dyoKTCzy2nfz/n8aIFhN/jCE/rCmcxabB6jOOHV+0WNnylOxaxBQPSvcWklhA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "ansi-regex": "^6.0.1"
+      },
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/strip-ansi?sponsor=1"
+      }
+    },
     "node_modules/wrappy": {
       "version": "1.0.2",
       "resolved": "https://registry.npmjs.org/wrappy/-/wrappy-1.0.2.tgz",
diff --git a/src/analytics/index.ts b/src/analytics/index.ts
new file mode 100644
index 0000000..bd595c0
--- /dev/null
+++ b/src/analytics/index.ts
@@ -0,0 +1,82 @@
+import { EventBus } from '../bus.js';
+import {
+  AnalyticsService,
+  Events,
+  PaymentProcessedEvent,
+  PaymentStatus,
+  OrderCreatedEvent,
+  CartUpdatedEvent,
+} from '../types.js';
+
+export function createAnalyticsService(bus: EventBus): AnalyticsService {
+  const eventCounts = new Map<string, number>();
+  let totalRevenue = 0;
+  const uniqueCarts = new Set<string>();
+  let orderCount = 0;
+  const productCounts = new Map<string, number>();
+
+  // Track cart items for product ranking when orders are created
+  const cartItems = new Map<string, Array<{ productId: string; quantity: number }>>();
+
+  function trackEvent(eventType: string): void {
+    eventCounts.set(eventType, (eventCounts.get(eventType) ?? 0) + 1);
+  }
+
+  // Listen to all events for counting
+  const allEvents = Object.values(Events);
+  for (const eventName of allEvents) {
+    bus.on(eventName, (payload: unknown) => {
+      trackEvent(eventName);
+
+      if (eventName === Events.PAYMENT_PROCESSED) {
+        const event = payload as PaymentProcessedEvent;
+        if (event.status === PaymentStatus.SUCCESS) {
+          // We need to look up the amount from the event log since PaymentProcessedEvent doesn't include it
+          // Revenue is tracked from orders instead
+        }
+      }
+    });
+  }
+
+  bus.on(Events.CART_UPDATED, (payload: unknown) => {
+    const event = payload as CartUpdatedEvent;
+    uniqueCarts.add(event.cartId);
+    cartItems.set(event.cartId, event.items.map(i => ({ ...i })));
+  });
+
+  bus.on(Events.ORDER_CREATED, (payload: unknown) => {
+    const event = payload as OrderCreatedEvent;
+    orderCount++;
+    totalRevenue += event.total;
+
+    // Track product quantities from the cart
+    const items = cartItems.get(event.cartId);
+    if (items) {
+      for (const item of items) {
+        productCounts.set(item.productId, (productCounts.get(item.productId) ?? 0) + item.quantity);
+      }
+    }
+  });
+
+  return {
+    getEventCount(eventType: string): number {
+      return eventCounts.get(eventType) ?? 0;
+    },
+
+    getRevenue(): number {
+      return totalRevenue;
+    },
+
+    getConversionRate(): number {
+      if (uniqueCarts.size === 0) return 0;
+      return orderCount / uniqueCarts.size;
+    },
+
+    getTopProducts(limit: number) {
+      return Array.from(productCounts.entries())
+        .map(([productId, count]) => ({ productId, count }))
+        .sort((a, b) => b.count - a.count)
+        .slice(0, limit);
+    },
+  };
+}
diff --git a/src/cart/index.ts b/src/cart/index.ts
new file mode 100644
index 0000000..3e0c0fd
--- /dev/null
+++ b/src/cart/index.ts
@@ -0,0 +1,82 @@
+import { EventBus } from '../bus.js';
+import { CartService, Events, CartUpdatedEvent } from '../types.js';
+import { v4 as uuidv4 } from 'uuid';
+
+interface CartItem {
+  productId: string;
+  quantity: number;
+}
+
+interface Cart {
+  id: string;
+  userId: string;
+  items: CartItem[];
+}
+
+export function createCartService(bus: EventBus): CartService {
+  const carts = new Map<string, Cart>();
+
+  function emitCartUpdate(cart: Cart): void {
+    const event: CartUpdatedEvent = {
+      cartId: cart.id,
+      userId: cart.userId,
+      items: cart.items.map(i => ({ ...i })),
+    };
+    void bus.emit(Events.CART_UPDATED, event);
+  }
+
+  return {
+    createCart(userId: string): string {
+      const id = uuidv4();
+      const cart: Cart = { id, userId, items: [] };
+      carts.set(id, cart);
+      return id;
+    },
+
+    addItem(cartId: string, productId: string, quantity: number): void {
+      const cart = carts.get(cartId);
+      if (!cart) return;
+      const existing = cart.items.find(i => i.productId === productId);
+      if (existing) {
+        existing.quantity += quantity;
+      } else {
+        cart.items.push({ productId, quantity });
+      }
+      emitCartUpdate(cart);
+    },
+
+    removeItem(cartId: string, productId: string): void {
+      const cart = carts.get(cartId);
+      if (!cart) return;
+      cart.items = cart.items.filter(i => i.productId !== productId);
+      emitCartUpdate(cart);
+    },
+
+    getCart(cartId: string) {
+      const cart = carts.get(cartId);
+      if (!cart) return null;
+      return {
+        id: cart.id,
+        userId: cart.userId,
+        items: cart.items.map(i => ({ ...i })),
+      };
+    },
+
+    clearCart(cartId: string): void {
+      const cart = carts.get(cartId);
+      if (!cart) return;
+      cart.items = [];
+      emitCartUpdate(cart);
+    },
+
+    updateQuantity(cartId: string, productId: string, quantity: number): void {
+      const cart = carts.get(cartId);
+      if (!cart) return;
+      const item = cart.items.find(i => i.productId === productId);
+      if (item) {
+        item.quantity = quantity;
+      }
+      emitCartUpdate(cart);
+    },
+  };
+}
diff --git a/src/catalog/index.ts b/src/catalog/index.ts
new file mode 100644
index 0000000..409aa99
--- /dev/null
+++ b/src/catalog/index.ts
@@ -0,0 +1,60 @@
+import { EventBus } from '../bus.js';
+import { CatalogService, Events, ProductCreatedEvent } from '../types.js';
+import { v4 as uuidv4 } from 'uuid';
+
+interface Product {
+  id: string;
+  name: string;
+  price: number;
+  category: string;
+}
+
+export function createCatalogService(bus: EventBus): CatalogService {
+  const products = new Map<string, Product>();
+
+  return {
+    createProduct(name: string, price: number, category: string): string {
+      const id = uuidv4();
+      const product: Product = { id, name, price, category };
+      products.set(id, product);
+
+      const event: ProductCreatedEvent = { productId: id, name, price, category };
+      void bus.emit(Events.PRODUCT_CREATED, event);
+
+      return id;
+    },
+
+    getProduct(productId: string) {
+      const p = products.get(productId);
+      if (!p) return null;
+      return { ...p };
+    },
+
+    listProducts(category?: string) {
+      const all = Array.from(products.values());
+      if (category) {
+        return all.filter(p => p.category === category).map(p => ({ ...p }));
+      }
+      return all.map(p => ({ ...p }));
+    },
+
+    searchProducts(query: string) {
+      const lower = query.toLowerCase();
+      return Array.from(products.values())
+        .filter(p => p.name.toLowerCase().includes(lower) || p.category.toLowerCase().includes(lower))
+        .map(p => ({ ...p }));
+    },
+
+    updateProduct(productId: string, updates: Partial<{ name: string; price: number; category: string }>) {
+      const p = products.get(productId);
+      if (!p) return;
+      if (updates.name !== undefined) p.name = updates.name;
+      if (updates.price !== undefined) p.price = updates.price;
+      if (updates.category !== undefined) p.category = updates.category;
+    },
+
+    removeProduct(productId: string): boolean {
+      return products.delete(productId);
+    },
+  };
+}
diff --git a/src/index.ts b/src/index.ts
new file mode 100644
index 0000000..126b959
--- /dev/null
+++ b/src/index.ts
@@ -0,0 +1,9 @@
+export { EventBus } from './bus.js';
+export { createCatalogService } from './catalog/index.js';
+export { createInventoryService } from './inventory/index.js';
+export { createCartService } from './cart/index.js';
+export { createPricingService } from './pricing/index.js';
+export { createOrderService } from './orders/index.js';
+export { createPaymentService } from './payment/index.js';
+export { createNotificationService } from './notifications/index.js';
+export { createAnalyticsService } from './analytics/index.js';
diff --git a/src/inventory/index.ts b/src/inventory/index.ts
new file mode 100644
index 0000000..39821ae
--- /dev/null
+++ b/src/inventory/index.ts
@@ -0,0 +1,59 @@
+import { EventBus } from '../bus.js';
+import { InventoryService, Events, InventoryUpdatedEvent, LowStockAlertEvent } from '../types.js';
+
+export function createInventoryService(bus: EventBus): InventoryService {
+  const stock = new Map<string, number>();
+  const reserved = new Map<string, number>();
+  const thresholds = new Map<string, number>();
+
+  function checkLowStock(productId: string): void {
+    const threshold = thresholds.get(productId);
+    if (threshold === undefined) return;
+    const current = stock.get(productId) ?? 0;
+    if (current <= threshold) {
+      const event: LowStockAlertEvent = { productId, currentQuantity: current, threshold };
+      void bus.emit(Events.LOW_STOCK_ALERT, event);
+    }
+  }
+
+  function emitUpdate(productId: string): void {
+    const quantity = stock.get(productId) ?? 0;
+    const event: InventoryUpdatedEvent = { productId, quantity };
+    void bus.emit(Events.INVENTORY_UPDATED, event);
+  }
+
+  return {
+    setStock(productId: string, quantity: number): void {
+      stock.set(productId, quantity);
+      emitUpdate(productId);
+      checkLowStock(productId);
+    },
+
+    getStock(productId: string): number {
+      return stock.get(productId) ?? 0;
+    },
+
+    reserve(productId: string, quantity: number): boolean {
+      const available = (stock.get(productId) ?? 0) - (reserved.get(productId) ?? 0);
+      if (available < quantity) return false;
+      reserved.set(productId, (reserved.get(productId) ?? 0) + quantity);
+      stock.set(productId, (stock.get(productId) ?? 0) - quantity);
+      emitUpdate(productId);
+      checkLowStock(productId);
+      return true;
+    },
+
+    release(productId: string, quantity: number): void {
+      const currentReserved = reserved.get(productId) ?? 0;
+      const releaseQty = Math.min(quantity, currentReserved);
+      reserved.set(productId, currentReserved - releaseQty);
+      stock.set(productId, (stock.get(productId) ?? 0) + releaseQty);
+      emitUpdate(productId);
+    },
+
+    setLowStockThreshold(productId: string, threshold: number): void {
+      thresholds.set(productId, threshold);
+      checkLowStock(productId);
+    },
+  };
+}
diff --git a/src/notifications/index.ts b/src/notifications/index.ts
new file mode 100644
index 0000000..c56572a
--- /dev/null
+++ b/src/notifications/index.ts
@@ -0,0 +1,65 @@
+import { EventBus } from '../bus.js';
+import {
+  NotificationService,
+  Events,
+  OrderCreatedEvent,
+  OrderStatusChangedEvent,
+  PaymentProcessedEvent,
+  NotificationSentEvent,
+} from '../types.js';
+
+interface Notification {
+  type: string;
+  message: string;
+  timestamp: number;
+}
+
+export function createNotificationService(bus: EventBus): NotificationService {
+  const subscribers = new Set<string>();
+  const notifications = new Map<string, Notification[]>();
+  const orderToUser = new Map<string, string>();
+
+  function addNotification(userId: string, type: string, message: string): void {
+    if (!subscribers.has(userId)) return;
+    const notif: Notification = { type, message, timestamp: Date.now() };
+    if (!notifications.has(userId)) {
+      notifications.set(userId, []);
+    }
+    notifications.get(userId)!.push(notif);
+
+    const event: NotificationSentEvent = { userId, type, message };
+    void bus.emit(Events.NOTIFICATION_SENT, event);
+  }
+
+  bus.on(Events.ORDER_CREATED, (payload: unknown) => {
+    const event = payload as OrderCreatedEvent;
+    orderToUser.set(event.orderId, event.userId);
+    addNotification(event.userId, 'order_created', `Order ${event.orderId} created with total $${event.total}`);
+  });
+
+  bus.on(Events.ORDER_STATUS_CHANGED, (payload: unknown) => {
+    const event = payload as OrderStatusChangedEvent;
+    const userId = orderToUser.get(event.orderId);
+    if (userId) {
+      addNotification(userId, 'order_status', `Order ${event.orderId} status changed from ${event.previousStatus} to ${event.status}`);
+    }
+  });
+
+  bus.on(Events.PAYMENT_PROCESSED, (payload: unknown) => {
+    const event = payload as PaymentProcessedEvent;
+    const userId = orderToUser.get(event.orderId);
+    if (userId) {
+      addNotification(userId, 'payment', `Payment for order ${event.orderId}: ${event.status}`);
+    }
+  });
+
+  return {
+    subscribe(userId: string): void {
+      subscribers.add(userId);
+    },
+
+    getNotifications(userId: string) {
+      return (notifications.get(userId) ?? []).map(n => ({ ...n }));
+    },
+  };
+}
diff --git a/src/orders/index.ts b/src/orders/index.ts
new file mode 100644
index 0000000..e6049e0
--- /dev/null
+++ b/src/orders/index.ts
@@ -0,0 +1,62 @@
+import { EventBus } from '../bus.js';
+import { OrderService, OrderStatus, Events, OrderCreatedEvent, OrderStatusChangedEvent } from '../types.js';
+import { v4 as uuidv4 } from 'uuid';
+
+interface Order {
+  id: string;
+  userId: string;
+  cartId: string;
+  status: OrderStatus;
+  total: number;
+}
+
+const VALID_TRANSITIONS: Record<OrderStatus, OrderStatus[]> = {
+  [OrderStatus.PENDING]: [OrderStatus.CONFIRMED, OrderStatus.CANCELLED],
+  [OrderStatus.CONFIRMED]: [OrderStatus.SHIPPED, OrderStatus.CANCELLED],
+  [OrderStatus.SHIPPED]: [OrderStatus.DELIVERED],
+  [OrderStatus.DELIVERED]: [],
+  [OrderStatus.CANCELLED]: [],
+};
+
+export function createOrderService(bus: EventBus): OrderService {
+  const orders = new Map<string, Order>();
+
+  return {
+    createOrder(userId: string, cartId: string, total: number): string {
+      const id = uuidv4();
+      const order: Order = { id, userId, cartId, status: OrderStatus.PENDING, total };
+      orders.set(id, order);
+
+      const event: OrderCreatedEvent = { orderId: id, userId, cartId, total };
+      void bus.emit(Events.ORDER_CREATED, event);
+
+      return id;
+    },
+
+    getOrder(orderId: string) {
+      const order = orders.get(orderId);
+      if (!order) return null;
+      return { id: order.id, userId: order.userId, status: order.status, total: order.total };
+    },
+
+    updateStatus(orderId: string, status: OrderStatus): void {
+      const order = orders.get(orderId);
+      if (!order) return;
+
+      const allowed = VALID_TRANSITIONS[order.status];
+      if (!allowed.includes(status)) return;
+
+      const previousStatus = order.status;
+      order.status = status;
+
+      const event: OrderStatusChangedEvent = { orderId, status, previousStatus };
+      void bus.emit(Events.ORDER_STATUS_CHANGED, event);
+    },
+
+    listOrders(userId: string) {
+      return Array.from(orders.values())
+        .filter(o => o.userId === userId)
+        .map(o => ({ id: o.id, status: o.status, total: o.total }));
+    },
+  };
+}
diff --git a/src/payment/index.ts b/src/payment/index.ts
new file mode 100644
index 0000000..c2ac76b
--- /dev/null
+++ b/src/payment/index.ts
@@ -0,0 +1,58 @@
+import { EventBus } from '../bus.js';
+import { PaymentService, PaymentStatus, Events, PaymentProcessedEvent } from '../types.js';
+import { v4 as uuidv4 } from 'uuid';
+
+export interface PaymentOptions {
+  simulateFailure?: boolean;
+  simulateTimeout?: boolean;
+  delay?: number;
+}
+
+export function createPaymentService(bus: EventBus, options: PaymentOptions = {}): PaymentService {
+  const transactions = new Map<string, { orderId: string; amount: number; status: PaymentStatus }>();
+
+  return {
+    async processPayment(orderId: string, amount: number) {
+      if (options.delay) {
+        await new Promise(resolve => setTimeout(resolve, options.delay));
+      }
+
+      let status: PaymentStatus;
+      let transactionId: string | undefined;
+      let error: string | undefined;
+
+      if (options.simulateTimeout) {
+        status = PaymentStatus.TIMEOUT;
+        error = 'Payment timed out';
+      } else if (options.simulateFailure) {
+        status = PaymentStatus.FAILED;
+        error = 'Payment failed';
+      } else {
+        status = PaymentStatus.SUCCESS;
+        transactionId = uuidv4();
+        transactions.set(transactionId, { orderId, amount, status });
+      }
+
+      const event: PaymentProcessedEvent = { orderId, status, transactionId, error };
+      await bus.emit(Events.PAYMENT_PROCESSED, event);
+
+      return { status, transactionId, error };
+    },
+
+    async refund(transactionId: string): Promise<boolean> {
+      const tx = transactions.get(transactionId);
+      if (!tx || tx.status !== PaymentStatus.SUCCESS) return false;
+      tx.status = PaymentStatus.FAILED;
+
+      const event: PaymentProcessedEvent = {
+        orderId: tx.orderId,
+        status: PaymentStatus.FAILED,
+        transactionId,
+        error: 'Refunded',
+      };
+      await bus.emit(Events.PAYMENT_PROCESSED, event);
+
+      return true;
+    },
+  };
+}
diff --git a/src/pricing/index.ts b/src/pricing/index.ts
new file mode 100644
index 0000000..17b3d7f
--- /dev/null
+++ b/src/pricing/index.ts
@@ -0,0 +1,48 @@
+import { EventBus } from '../bus.js';
+import { PricingService, Events, ProductCreatedEvent } from '../types.js';
+
+const TAX_RATE = 0.10;
+
+export function createPricingService(bus: EventBus): PricingService {
+  const prices = new Map<string, number>();
+  const discountCodes = new Map<string, number>();
+
+  bus.on(Events.PRODUCT_CREATED, (payload: unknown) => {
+    const event = payload as ProductCreatedEvent;
+    prices.set(event.productId, event.price);
+  });
+
+  return {
+    calculateTotal(
+      items: Array<{ productId: string; quantity: number; price: number }>,
+      discountCode?: string,
+    ) {
+      let subtotal = 0;
+      for (const item of items) {
+        subtotal += item.price * item.quantity;
+      }
+
+      let discount = 0;
+      if (discountCode) {
+        const pct = discountCodes.get(discountCode);
+        if (pct !== undefined) {
+          discount = subtotal * (pct / 100);
+        }
+      }
+
+      const discountedSubtotal = subtotal - discount;
+      const tax = Math.round(discountedSubtotal * TAX_RATE * 100) / 100;
+      const total = Math.round((discountedSubtotal + tax) * 100) / 100;
+
+      return { subtotal, discount, tax, total };
+    },
+
+    addDiscountCode(code: string, percentage: number): void {
+      discountCodes.set(code, percentage);
+    },
+
+    getPrice(productId: string): number {
+      return prices.get(productId) ?? 0;
+    },
+  };
+}
diff --git a/tests/services.test.ts b/tests/services.test.ts
new file mode 100644
index 0000000..ff0d977
--- /dev/null
+++ b/tests/services.test.ts
@@ -0,0 +1,484 @@
+import { describe, it, expect, beforeEach } from 'vitest';
+import { EventBus } from '../src/bus.js';
+import { createCatalogService } from '../src/catalog/index.js';
+import { createInventoryService } from '../src/inventory/index.js';
+import { createCartService } from '../src/cart/index.js';
+import { createPricingService } from '../src/pricing/index.js';
+import { createOrderService } from '../src/orders/index.js';
+import { createPaymentService } from '../src/payment/index.js';
+import { createNotificationService } from '../src/notifications/index.js';
+import { createAnalyticsService } from '../src/analytics/index.js';
+import { OrderStatus, PaymentStatus, Events } from '../src/types.js';
+
+describe('Catalog Service', () => {
+  let bus: EventBus;
+  let catalog: ReturnType<typeof createCatalogService>;
+
+  beforeEach(() => {
+    bus = new EventBus();
+    catalog = createCatalogService(bus);
+  });
+
+  it('should create and retrieve a product', () => {
+    const id = catalog.createProduct('Widget', 9.99, 'gadgets');
+    const product = catalog.getProduct(id);
+    expect(product).toEqual({ id, name: 'Widget', price: 9.99, category: 'gadgets' });
+  });
+
+  it('should return null for nonexistent product', () => {
+    expect(catalog.getProduct('nope')).toBeNull();
+  });
+
+  it('should list products, optionally by category', () => {
+    catalog.createProduct('A', 1, 'cat1');
+    catalog.createProduct('B', 2, 'cat2');
+    catalog.createProduct('C', 3, 'cat1');
+    expect(catalog.listProducts()).toHaveLength(3);
+    expect(catalog.listProducts('cat1')).toHaveLength(2);
+    expect(catalog.listProducts('cat2')).toHaveLength(1);
+  });
+
+  it('should search products by name or category', () => {
+    catalog.createProduct('Blue Widget', 5, 'tools');
+    catalog.createProduct('Red Gadget', 10, 'widgets');
+    expect(catalog.searchProducts('widget')).toHaveLength(2); // name match + category match
+    expect(catalog.searchProducts('gadget')).toHaveLength(1);
+  });
+
+  it('should update a product', () => {
+    const id = catalog.createProduct('Old', 5, 'cat');
+    catalog.updateProduct(id, { name: 'New', price: 10 });
+    expect(catalog.getProduct(id)).toEqual({ id, name: 'New', price: 10, category: 'cat' });
+  });
+
+  it('should remove a product', () => {
+    const id = catalog.createProduct('Gone', 5, 'cat');
+    expect(catalog.removeProduct(id)).toBe(true);
+    expect(catalog.getProduct(id)).toBeNull();
+    expect(catalog.removeProduct('nope')).toBe(false);
+  });
+
+  it('should emit product:created event', async () => {
+    const events: unknown[] = [];
+    bus.on(Events.PRODUCT_CREATED, (p) => { events.push(p); });
+    catalog.createProduct('Test', 5, 'cat');
+    // Event is emitted via void bus.emit, let's check the log
+    await new Promise(r => setTimeout(r, 10));
+    expect(events.length).toBe(1);
+  });
+});
+
+describe('Inventory Service', () => {
+  let bus: EventBus;
+  let inventory: ReturnType<typeof createInventoryService>;
+
+  beforeEach(() => {
+    bus = new EventBus();
+    inventory = createInventoryService(bus);
+  });
+
+  it('should set and get stock', () => {
+    inventory.setStock('p1', 100);
+    expect(inventory.getStock('p1')).toBe(100);
+  });
+
+  it('should return 0 for unknown product', () => {
+    expect(inventory.getStock('unknown')).toBe(0);
+  });
+
+  it('should reserve stock successfully', () => {
+    inventory.setStock('p1', 10);
+    expect(inventory.reserve('p1', 5)).toBe(true);
+    expect(inventory.getStock('p1')).toBe(5);
+  });
+
+  it('should fail to reserve if insufficient stock', () => {
+    inventory.setStock('p1', 3);
+    expect(inventory.reserve('p1', 5)).toBe(false);
+  });
+
+  it('should release reserved stock', () => {
+    inventory.setStock('p1', 10);
+    inventory.reserve('p1', 5);
+    inventory.release('p1', 3);
+    expect(inventory.getStock('p1')).toBe(8);
+  });
+
+  it('should emit low stock alert', async () => {
+    const alerts: unknown[] = [];
+    bus.on(Events.LOW_STOCK_ALERT, (p) => { alerts.push(p); });
+    inventory.setLowStockThreshold('p1', 5);
+    inventory.setStock('p1', 3);
+    await new Promise(r => setTimeout(r, 10));
+    expect(alerts.length).toBeGreaterThanOrEqual(1);
+  });
+});
+
+describe('Cart Service', () => {
+  let bus: EventBus;
+  let cart: ReturnType<typeof createCartService>;
+
+  beforeEach(() => {
+    bus = new EventBus();
+    cart = createCartService(bus);
+  });
+
+  it('should create a cart and retrieve it', () => {
+    const id = cart.createCart('user1');
+    const c = cart.getCart(id);
+    expect(c).toEqual({ id, userId: 'user1', items: [] });
+  });
+
+  it('should return null for nonexistent cart', () => {
+    expect(cart.getCart('nope')).toBeNull();
+  });
+
+  it('should add items and consolidate duplicates', () => {
+    const id = cart.createCart('user1');
+    cart.addItem(id, 'p1', 2);
+    cart.addItem(id, 'p1', 3);
+    const c = cart.getCart(id);
+    expect(c!.items).toEqual([{ productId: 'p1', quantity: 5 }]);
+  });
+
+  it('should remove items', () => {
+    const id = cart.createCart('user1');
+    cart.addItem(id, 'p1', 2);
+    cart.addItem(id, 'p2', 1);
+    cart.removeItem(id, 'p1');
+    expect(cart.getCart(id)!.items).toEqual([{ productId: 'p2', quantity: 1 }]);
+  });
+
+  it('should clear cart', () => {
+    const id = cart.createCart('user1');
+    cart.addItem(id, 'p1', 2);
+    cart.clearCart(id);
+    expect(cart.getCart(id)!.items).toEqual([]);
+  });
+
+  it('should update quantity', () => {
+    const id = cart.createCart('user1');
+    cart.addItem(id, 'p1', 2);
+    cart.updateQuantity(id, 'p1', 10);
+    expect(cart.getCart(id)!.items).toEqual([{ productId: 'p1', quantity: 10 }]);
+  });
+});
+
+describe('Pricing Service', () => {
+  let bus: EventBus;
+  let pricing: ReturnType<typeof createPricingService>;
+
+  beforeEach(() => {
+    bus = new EventBus();
+    pricing = createPricingService(bus);
+  });
+
+  it('should calculate total with tax', () => {
+    const result = pricing.calculateTotal([{ productId: 'p1', quantity: 2, price: 10 }]);
+    expect(result.subtotal).toBe(20);
+    expect(result.discount).toBe(0);
+    expect(result.tax).toBe(2);
+    expect(result.total).toBe(22);
+  });
+
+  it('should apply discount code', () => {
+    pricing.addDiscountCode('SAVE10', 10);
+    const result = pricing.calculateTotal(
+      [{ productId: 'p1', quantity: 1, price: 100 }],
+      'SAVE10'
+    );
+    expect(result.subtotal).toBe(100);
+    expect(result.discount).toBe(10);
+    expect(result.tax).toBe(9);
+    expect(result.total).toBe(99);
+  });
+
+  it('should track prices from product:created events', async () => {
+    await bus.emit(Events.PRODUCT_CREATED, { productId: 'p1', name: 'Test', price: 42, category: 'cat' });
+    expect(pricing.getPrice('p1')).toBe(42);
+  });
+
+  it('should return 0 for unknown product price', () => {
+    expect(pricing.getPrice('unknown')).toBe(0);
+  });
+});
+
+describe('Order Service', () => {
+  let bus: EventBus;
+  let orders: ReturnType<typeof createOrderService>;
+
+  beforeEach(() => {
+    bus = new EventBus();
+    orders = createOrderService(bus);
+  });
+
+  it('should create an order in pending status', () => {
+    const id = orders.createOrder('user1', 'cart1', 50);
+    const order = orders.getOrder(id);
+    expect(order).toEqual({ id, userId: 'user1', status: OrderStatus.PENDING, total: 50 });
+  });
+
+  it('should update status through valid transitions', () => {
+    const id = orders.createOrder('user1', 'cart1', 50);
+    orders.updateStatus(id, OrderStatus.CONFIRMED);
+    expect(orders.getOrder(id)!.status).toBe(OrderStatus.CONFIRMED);
+    orders.updateStatus(id, OrderStatus.SHIPPED);
+    expect(orders.getOrder(id)!.status).toBe(OrderStatus.SHIPPED);
+    orders.updateStatus(id, OrderStatus.DELIVERED);
+    expect(orders.getOrder(id)!.status).toBe(OrderStatus.DELIVERED);
+  });
+
+  it('should not allow invalid transitions', () => {
+    const id = orders.createOrder('user1', 'cart1', 50);
+    orders.updateStatus(id, OrderStatus.DELIVERED); // skip straight to delivered
+    expect(orders.getOrder(id)!.status).toBe(OrderStatus.PENDING);
+  });
+
+  it('should allow cancellation from pending or confirmed', () => {
+    const id1 = orders.createOrder('user1', 'cart1', 50);
+    orders.updateStatus(id1, OrderStatus.CANCELLED);
+    expect(orders.getOrder(id1)!.status).toBe(OrderStatus.CANCELLED);
+
+    const id2 = orders.createOrder('user1', 'cart2', 50);
+    orders.updateStatus(id2, OrderStatus.CONFIRMED);
+    orders.updateStatus(id2, OrderStatus.CANCELLED);
+    expect(orders.getOrder(id2)!.status).toBe(OrderStatus.CANCELLED);
+  });
+
+  it('should list orders for a user', () => {
+    orders.createOrder('user1', 'cart1', 50);
+    orders.createOrder('user2', 'cart2', 30);
+    orders.createOrder('user1', 'cart3', 20);
+    expect(orders.listOrders('user1')).toHaveLength(2);
+    expect(orders.listOrders('user2')).toHaveLength(1);
+  });
+
+  it('should emit order events', async () => {
+    const created: unknown[] = [];
+    const changed: unknown[] = [];
+    bus.on(Events.ORDER_CREATED, (p) => { created.push(p); });
+    bus.on(Events.ORDER_STATUS_CHANGED, (p) => { changed.push(p); });
+    const id = orders.createOrder('user1', 'cart1', 50);
+    orders.updateStatus(id, OrderStatus.CONFIRMED);
+    await new Promise(r => setTimeout(r, 10));
+    expect(created.length).toBe(1);
+    expect(changed.length).toBe(1);
+  });
+});
+
+describe('Payment Service', () => {
+  let bus: EventBus;
+
+  beforeEach(() => {
+    bus = new EventBus();
+  });
+
+  it('should process payment successfully', async () => {
+    const payment = createPaymentService(bus);
+    const result = await payment.processPayment('order1', 100);
+    expect(result.status).toBe(PaymentStatus.SUCCESS);
+    expect(result.transactionId).toBeDefined();
+  });
+
+  it('should simulate failure', async () => {
+    const payment = createPaymentService(bus, { simulateFailure: true });
+    const result = await payment.processPayment('order1', 100);
+    expect(result.status).toBe(PaymentStatus.FAILED);
+    expect(result.error).toBeDefined();
+  });
+
+  it('should simulate timeout', async () => {
+    const payment = createPaymentService(bus, { simulateTimeout: true });
+    const result = await payment.processPayment('order1', 100);
+    expect(result.status).toBe(PaymentStatus.TIMEOUT);
+  });
+
+  it('should refund a successful payment', async () => {
+    const payment = createPaymentService(bus);
+    const result = await payment.processPayment('order1', 100);
+    const refunded = await payment.refund(result.transactionId!);
+    expect(refunded).toBe(true);
+  });
+
+  it('should not refund invalid transaction', async () => {
+    const payment = createPaymentService(bus);
+    const refunded = await payment.refund('nonexistent');
+    expect(refunded).toBe(false);
+  });
+
+  it('should emit payment:processed event', async () => {
+    const events: unknown[] = [];
+    bus.on(Events.PAYMENT_PROCESSED, (p) => { events.push(p); });
+    const payment = createPaymentService(bus);
+    await payment.processPayment('order1', 100);
+    expect(events.length).toBe(1);
+  });
+});
+
+describe('Notification Service', () => {
+  let bus: EventBus;
+  let notifications: ReturnType<typeof createNotificationService>;
+
+  beforeEach(() => {
+    bus = new EventBus();
+    notifications = createNotificationService(bus);
+  });
+
+  it('should deliver notifications to subscribed users', async () => {
+    notifications.subscribe('user1');
+    await bus.emit(Events.ORDER_CREATED, { orderId: 'o1', userId: 'user1', cartId: 'c1', total: 50 });
+    const notifs = notifications.getNotifications('user1');
+    expect(notifs.length).toBe(1);
+    expect(notifs[0].type).toBe('order_created');
+  });
+
+  it('should not deliver to unsubscribed users', async () => {
+    await bus.emit(Events.ORDER_CREATED, { orderId: 'o1', userId: 'user1', cartId: 'c1', total: 50 });
+    expect(notifications.getNotifications('user1')).toHaveLength(0);
+  });
+
+  it('should track order-to-user mapping for status changes', async () => {
+    notifications.subscribe('user1');
+    await bus.emit(Events.ORDER_CREATED, { orderId: 'o1', userId: 'user1', cartId: 'c1', total: 50 });
+    await bus.emit(Events.ORDER_STATUS_CHANGED, { orderId: 'o1', status: 'confirmed', previousStatus: 'pending' });
+    const notifs = notifications.getNotifications('user1');
+    expect(notifs.length).toBe(2);
+    expect(notifs[1].type).toBe('order_status');
+  });
+
+  it('should track payment events', async () => {
+    notifications.subscribe('user1');
+    await bus.emit(Events.ORDER_CREATED, { orderId: 'o1', userId: 'user1', cartId: 'c1', total: 50 });
+    await bus.emit(Events.PAYMENT_PROCESSED, { orderId: 'o1', status: 'success', transactionId: 'tx1' });
+    const notifs = notifications.getNotifications('user1');
+    expect(notifs.length).toBe(2);
+    expect(notifs[1].type).toBe('payment');
+  });
+});
+
+describe('Analytics Service', () => {
+  let bus: EventBus;
+  let analytics: ReturnType<typeof createAnalyticsService>;
+
+  beforeEach(() => {
+    bus = new EventBus();
+    analytics = createAnalyticsService(bus);
+  });
+
+  it('should count events by type', async () => {
+    await bus.emit(Events.PRODUCT_CREATED, { productId: 'p1', name: 'A', price: 10, category: 'cat' });
+    await bus.emit(Events.PRODUCT_CREATED, { productId: 'p2', name: 'B', price: 20, category: 'cat' });
+    expect(analytics.getEventCount(Events.PRODUCT_CREATED)).toBe(2);
+  });
+
+  it('should track revenue from orders', async () => {
+    await bus.emit(Events.ORDER_CREATED, { orderId: 'o1', userId: 'u1', cartId: 'c1', total: 50 });
+    await bus.emit(Events.ORDER_CREATED, { orderId: 'o2', userId: 'u1', cartId: 'c2', total: 30 });
+    expect(analytics.getRevenue()).toBe(80);
+  });
+
+  it('should calculate conversion rate', async () => {
+    await bus.emit(Events.CART_UPDATED, { cartId: 'c1', userId: 'u1', items: [] });
+    await bus.emit(Events.CART_UPDATED, { cartId: 'c2', userId: 'u2', items: [] });
+    await bus.emit(Events.ORDER_CREATED, { orderId: 'o1', userId: 'u1', cartId: 'c1', total: 50 });
+    expect(analytics.getConversionRate()).toBe(0.5);
+  });
+
+  it('should return 0 conversion rate with no carts', () => {
+    expect(analytics.getConversionRate()).toBe(0);
+  });
+
+  it('should rank products by order quantity', async () => {
+    await bus.emit(Events.CART_UPDATED, { cartId: 'c1', userId: 'u1', items: [{ productId: 'p1', quantity: 5 }, { productId: 'p2', quantity: 2 }] });
+    await bus.emit(Events.ORDER_CREATED, { orderId: 'o1', userId: 'u1', cartId: 'c1', total: 50 });
+    const top = analytics.getTopProducts(10);
+    expect(top[0]).toEqual({ productId: 'p1', count: 5 });
+    expect(top[1]).toEqual({ productId: 'p2', count: 2 });
+  });
+});
+
+describe('Integration: Full E2E flow', () => {
+  it('should process a full order lifecycle', async () => {
+    const bus = new EventBus();
+
+    // Set up all services
+    const catalog = createCatalogService(bus);
+    const inventory = createInventoryService(bus);
+    const cartSvc = createCartService(bus);
+    const pricing = createPricingService(bus);
+    const orderSvc = createOrderService(bus);
+    const payment = createPaymentService(bus);
+    const notifSvc = createNotificationService(bus);
+    const analytics = createAnalyticsService(bus);
+
+    // Subscribe user for notifications
+    notifSvc.subscribe('user1');
+
+    // Create products
+    const p1 = catalog.createProduct('Laptop', 999, 'electronics');
+    const p2 = catalog.createProduct('Mouse', 29, 'electronics');
+
+    // Wait for events to propagate
+    await new Promise(r => setTimeout(r, 10));
+
+    // Set inventory
+    inventory.setStock(p1, 10);
+    inventory.setStock(p2, 50);
+
+    // Create cart and add items
+    const cartId = cartSvc.createCart('user1');
+    cartSvc.addItem(cartId, p1, 1);
+    cartSvc.addItem(cartId, p2, 2);
+
+    // Wait for cart events
+    await new Promise(r => setTimeout(r, 10));
+
+    // Calculate price
+    const price1 = pricing.getPrice(p1);
+    const price2 = pricing.getPrice(p2);
+    expect(price1).toBe(999);
+    expect(price2).toBe(29);
+
+    const totals = pricing.calculateTotal([
+      { productId: p1, quantity: 1, price: price1 },
+      { productId: p2, quantity: 2, price: price2 },
+    ]);
+    expect(totals.subtotal).toBe(1057);
+    expect(totals.tax).toBeCloseTo(105.7);
+
+    // Reserve inventory
+    expect(inventory.reserve(p1, 1)).toBe(true);
+    expect(inventory.reserve(p2, 2)).toBe(true);
+
+    // Create order
+    const orderId = orderSvc.createOrder('user1', cartId, totals.total);
+
+    // Wait for order events
+    await new Promise(r => setTimeout(r, 10));
+
+    // Process payment
+    const payResult = await payment.processPayment(orderId, totals.total);
+    expect(payResult.status).toBe(PaymentStatus.SUCCESS);
+
+    // Update order status through lifecycle
+    orderSvc.updateStatus(orderId, OrderStatus.CONFIRMED);
+    orderSvc.updateStatus(orderId, OrderStatus.SHIPPED);
+    orderSvc.updateStatus(orderId, OrderStatus.DELIVERED);
+
+    await new Promise(r => setTimeout(r, 10));
+
+    const order = orderSvc.getOrder(orderId);
+    expect(order!.status).toBe(OrderStatus.DELIVERED);
+
+    // Check notifications
+    const notifs = notifSvc.getNotifications('user1');
+    expect(notifs.length).toBeGreaterThanOrEqual(4); // order created + payment + status changes
+
+    // Check analytics
+    expect(analytics.getEventCount(Events.ORDER_CREATED)).toBeGreaterThanOrEqual(1);
+    expect(analytics.getRevenue()).toBe(totals.total);
+    expect(analytics.getConversionRate()).toBeGreaterThan(0);
+    const topProducts = analytics.getTopProducts(5);
+    expect(topProducts.length).toBeGreaterThanOrEqual(1);
+  });
+});
