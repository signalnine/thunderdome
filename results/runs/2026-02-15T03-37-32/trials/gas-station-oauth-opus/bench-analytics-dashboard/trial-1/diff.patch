diff --git a/.runtime/agent.lock b/.runtime/agent.lock
new file mode 100644
index 0000000..cf0845e
--- /dev/null
+++ b/.runtime/agent.lock
@@ -0,0 +1,6 @@
+{
+  "pid": 874,
+  "acquired_at": "2026-02-15T03:37:37.482303961Z",
+  "session_id": "bench/rust",
+  "hostname": "41fe60538383"
+}
\ No newline at end of file
diff --git a/.thunderdome-metrics.json b/.thunderdome-metrics.json
new file mode 100644
index 0000000..f1e084c
--- /dev/null
+++ b/.thunderdome-metrics.json
@@ -0,0 +1,18 @@
+{
+  "input_tokens": 57,
+  "output_tokens": 23568,
+  "cache_read_tokens": 2188193,
+  "cache_creation_tokens": 49925,
+  "turns": 61,
+  "tools_used": [
+    "TodoWrite",
+    "Bash",
+    "Read",
+    "Write",
+    "Grep",
+    "Glob",
+    "Edit"
+  ],
+  "duration_ms": 366674,
+  "total_cost_usd": 2.01021975
+}
\ No newline at end of file
diff --git a/package-lock.json b/package-lock.json
index 16cc798..53f6fc4 100644
--- a/package-lock.json
+++ b/package-lock.json
@@ -22,12 +22,84 @@
         "@types/uuid": "^10.0.0",
         "@typescript-eslint/eslint-plugin": "^7.0.0",
         "@typescript-eslint/parser": "^7.0.0",
+        "@vitest/coverage-v8": "^2.0.0",
         "eslint": "^8.56.0",
         "supertest": "^7.0.0",
         "typescript": "^5.4.0",
         "vitest": "^2.0.0"
       }
     },
+    "node_modules/@ampproject/remapping": {
+      "version": "2.3.0",
+      "resolved": "https://registry.npmjs.org/@ampproject/remapping/-/remapping-2.3.0.tgz",
+      "integrity": "sha512-30iZtAPgz+LTIYoeivqYo853f02jBYSd5uGnGpkFV0M3xOt9aN73erkgYAmZU43x4VfqcnLxW9Kpg3R5LC4YYw==",
+      "dev": true,
+      "license": "Apache-2.0",
+      "dependencies": {
+        "@jridgewell/gen-mapping": "^0.3.5",
+        "@jridgewell/trace-mapping": "^0.3.24"
+      },
+      "engines": {
+        "node": ">=6.0.0"
+      }
+    },
+    "node_modules/@babel/helper-string-parser": {
+      "version": "7.27.1",
+      "resolved": "https://registry.npmjs.org/@babel/helper-string-parser/-/helper-string-parser-7.27.1.tgz",
+      "integrity": "sha512-qMlSxKbpRlAridDExk92nSobyDdpPijUq2DW6oDnUqd0iOGxmQjyqhMIihI9+zv4LPyZdRje2cavWPbCbWm3eA==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=6.9.0"
+      }
+    },
+    "node_modules/@babel/helper-validator-identifier": {
+      "version": "7.28.5",
+      "resolved": "https://registry.npmjs.org/@babel/helper-validator-identifier/-/helper-validator-identifier-7.28.5.tgz",
+      "integrity": "sha512-qSs4ifwzKJSV39ucNjsvc6WVHs6b7S03sOh2OcHF9UHfVPqWWALUsNUVzhSBiItjRZoLHx7nIarVjqKVusUZ1Q==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=6.9.0"
+      }
+    },
+    "node_modules/@babel/parser": {
+      "version": "7.29.0",
+      "resolved": "https://registry.npmjs.org/@babel/parser/-/parser-7.29.0.tgz",
+      "integrity": "sha512-IyDgFV5GeDUVX4YdF/3CPULtVGSXXMLh1xVIgdCgxApktqnQV0r7/8Nqthg+8YLGaAtdyIlo2qIdZrbCv4+7ww==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@babel/types": "^7.29.0"
+      },
+      "bin": {
+        "parser": "bin/babel-parser.js"
+      },
+      "engines": {
+        "node": ">=6.0.0"
+      }
+    },
+    "node_modules/@babel/types": {
+      "version": "7.29.0",
+      "resolved": "https://registry.npmjs.org/@babel/types/-/types-7.29.0.tgz",
+      "integrity": "sha512-LwdZHpScM4Qz8Xw2iKSzS+cfglZzJGvofQICy7W7v4caru4EaAmyUuO6BGrbyQ2mYV11W0U8j5mBhd14dd3B0A==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@babel/helper-string-parser": "^7.27.1",
+        "@babel/helper-validator-identifier": "^7.28.5"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      }
+    },
+    "node_modules/@bcoe/v8-coverage": {
+      "version": "0.2.3",
+      "resolved": "https://registry.npmjs.org/@bcoe/v8-coverage/-/v8-coverage-0.2.3.tgz",
+      "integrity": "sha512-0hYQ8SB4Db5zvZB4axdMHGwEaQjkZzFjQiN9LVYvIFB2nSUHW9tYpxWriPrWDASIxiaXax83REcLxuSdnGPZtw==",
+      "dev": true,
+      "license": "MIT"
+    },
     "node_modules/@esbuild/aix-ppc64": {
       "version": "0.21.5",
       "resolved": "https://registry.npmjs.org/@esbuild/aix-ppc64/-/aix-ppc64-0.21.5.tgz",
@@ -568,6 +640,84 @@
       "dev": true,
       "license": "BSD-3-Clause"
     },
+    "node_modules/@isaacs/cliui": {
+      "version": "8.0.2",
+      "resolved": "https://registry.npmjs.org/@isaacs/cliui/-/cliui-8.0.2.tgz",
+      "integrity": "sha512-O8jcjabXaleOG9DQ0+ARXWZBTfnP4WNAqzuiJK7ll44AmxGKv/J2M4TPjxjY3znBCfvBXFzucm1twdyFybFqEA==",
+      "dev": true,
+      "license": "ISC",
+      "dependencies": {
+        "string-width": "^5.1.2",
+        "string-width-cjs": "npm:string-width@^4.2.0",
+        "strip-ansi": "^7.0.1",
+        "strip-ansi-cjs": "npm:strip-ansi@^6.0.1",
+        "wrap-ansi": "^8.1.0",
+        "wrap-ansi-cjs": "npm:wrap-ansi@^7.0.0"
+      },
+      "engines": {
+        "node": ">=12"
+      }
+    },
+    "node_modules/@isaacs/cliui/node_modules/ansi-regex": {
+      "version": "6.2.2",
+      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-6.2.2.tgz",
+      "integrity": "sha512-Bq3SmSpyFHaWjPk8If9yc6svM8c56dB5BAtW4Qbw5jHTwwXXcTLoRMkpDJp6VL0XzlWaCHTXrkFURMYmD0sLqg==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/ansi-regex?sponsor=1"
+      }
+    },
+    "node_modules/@isaacs/cliui/node_modules/strip-ansi": {
+      "version": "7.1.2",
+      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-7.1.2.tgz",
+      "integrity": "sha512-gmBGslpoQJtgnMAvOVqGZpEz9dyoKTCzy2nfz/n8aIFhN/jCE/rCmcxabB6jOOHV+0WNnylOxaxBQPSvcWklhA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "ansi-regex": "^6.0.1"
+      },
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/strip-ansi?sponsor=1"
+      }
+    },
+    "node_modules/@istanbuljs/schema": {
+      "version": "0.1.3",
+      "resolved": "https://registry.npmjs.org/@istanbuljs/schema/-/schema-0.1.3.tgz",
+      "integrity": "sha512-ZXRY4jNvVgSVQ8DL3LTcakaAtXwTVUxE81hslsyD2AtoXW/wVob10HkOJ1X/pAlcI7D+2YoZKg5do8G/w6RYgA==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/@jridgewell/gen-mapping": {
+      "version": "0.3.13",
+      "resolved": "https://registry.npmjs.org/@jridgewell/gen-mapping/-/gen-mapping-0.3.13.tgz",
+      "integrity": "sha512-2kkt/7niJ6MgEPxF0bYdQ6etZaA+fQvDcLKckhy1yIQOzaoKjBBjSj63/aLVjYE3qhRt5dvM+uUyfCg6UKCBbA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@jridgewell/sourcemap-codec": "^1.5.0",
+        "@jridgewell/trace-mapping": "^0.3.24"
+      }
+    },
+    "node_modules/@jridgewell/resolve-uri": {
+      "version": "3.1.2",
+      "resolved": "https://registry.npmjs.org/@jridgewell/resolve-uri/-/resolve-uri-3.1.2.tgz",
+      "integrity": "sha512-bRISgCIjP20/tbWSPWMEi54QVPRZExkuD9lJL+UIxUKtwVJA8wW1Trb1jMs1RFXo1CBTNZ/5hpC9QvmKWdopKw==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=6.0.0"
+      }
+    },
     "node_modules/@jridgewell/sourcemap-codec": {
       "version": "1.5.5",
       "resolved": "https://registry.npmjs.org/@jridgewell/sourcemap-codec/-/sourcemap-codec-1.5.5.tgz",
@@ -575,6 +725,17 @@
       "dev": true,
       "license": "MIT"
     },
+    "node_modules/@jridgewell/trace-mapping": {
+      "version": "0.3.31",
+      "resolved": "https://registry.npmjs.org/@jridgewell/trace-mapping/-/trace-mapping-0.3.31.tgz",
+      "integrity": "sha512-zzNR+SdQSDJzc8joaeP8QQoCQr8NuYx2dIIytl1QeBEZHJ9uW6hebsrYgbz8hJwUQao3TWCMtmfV8Nu1twOLAw==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@jridgewell/resolve-uri": "^3.1.0",
+        "@jridgewell/sourcemap-codec": "^1.4.14"
+      }
+    },
     "node_modules/@noble/hashes": {
       "version": "1.8.0",
       "resolved": "https://registry.npmjs.org/@noble/hashes/-/hashes-1.8.0.tgz",
@@ -636,6 +797,17 @@
         "@noble/hashes": "^1.1.5"
       }
     },
+    "node_modules/@pkgjs/parseargs": {
+      "version": "0.11.0",
+      "resolved": "https://registry.npmjs.org/@pkgjs/parseargs/-/parseargs-0.11.0.tgz",
+      "integrity": "sha512-+1VkjdD0QBLPodGrJUeqarH8VAIvQODIbwh9XpP5Syisf7YoQgsJKPNFoqqLQlu+VQ/tVSshMR6loPMn8U+dPg==",
+      "dev": true,
+      "license": "MIT",
+      "optional": true,
+      "engines": {
+        "node": ">=14"
+      }
+    },
     "node_modules/@rollup/rollup-android-arm-eabi": {
       "version": "4.57.1",
       "resolved": "https://registry.npmjs.org/@rollup/rollup-android-arm-eabi/-/rollup-android-arm-eabi-4.57.1.tgz",
@@ -1102,7 +1274,6 @@
       "integrity": "sha512-m0jEgYlYz+mDJZ2+F4v8D1AyQb+QzsNqRuI7xg1VQX/KlKS0qT9r1Mo16yo5F/MtifXFgaofIFsdFMox2SxIbQ==",
       "dev": true,
       "license": "MIT",
-      "peer": true,
       "dependencies": {
         "undici-types": "~7.16.0"
       }
@@ -1225,7 +1396,6 @@
       "integrity": "sha512-4Z+L8I2OqhZV8qA132M4wNL30ypZGYOQVBfMgxDH/K5UX0PNqTu1c6za9ST5r9+tavvHiTWmBnKzpCJ/GlVFtg==",
       "dev": true,
       "license": "BSD-2-Clause",
-      "peer": true,
       "dependencies": {
         "@typescript-eslint/scope-manager": "7.18.0",
         "@typescript-eslint/types": "7.18.0",
@@ -1386,6 +1556,39 @@
       "dev": true,
       "license": "ISC"
     },
+    "node_modules/@vitest/coverage-v8": {
+      "version": "2.1.9",
+      "resolved": "https://registry.npmjs.org/@vitest/coverage-v8/-/coverage-v8-2.1.9.tgz",
+      "integrity": "sha512-Z2cOr0ksM00MpEfyVE8KXIYPEcBFxdbLSs56L8PO0QQMxt/6bDj45uQfxoc96v05KW3clk7vvgP0qfDit9DmfQ==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@ampproject/remapping": "^2.3.0",
+        "@bcoe/v8-coverage": "^0.2.3",
+        "debug": "^4.3.7",
+        "istanbul-lib-coverage": "^3.2.2",
+        "istanbul-lib-report": "^3.0.1",
+        "istanbul-lib-source-maps": "^5.0.6",
+        "istanbul-reports": "^3.1.7",
+        "magic-string": "^0.30.12",
+        "magicast": "^0.3.5",
+        "std-env": "^3.8.0",
+        "test-exclude": "^7.0.1",
+        "tinyrainbow": "^1.2.0"
+      },
+      "funding": {
+        "url": "https://opencollective.com/vitest"
+      },
+      "peerDependencies": {
+        "@vitest/browser": "2.1.9",
+        "vitest": "2.1.9"
+      },
+      "peerDependenciesMeta": {
+        "@vitest/browser": {
+          "optional": true
+        }
+      }
+    },
     "node_modules/@vitest/expect": {
       "version": "2.1.9",
       "resolved": "https://registry.npmjs.org/@vitest/expect/-/expect-2.1.9.tgz",
@@ -1518,7 +1721,6 @@
       "integrity": "sha512-NZyJarBfL7nWwIq+FDL6Zp/yHEhePMNnnJ0y3qfieCrmNvYct8uvtiV41UvlSe6apAfk0fY1FbWx+NwfmpvtTg==",
       "dev": true,
       "license": "MIT",
-      "peer": true,
       "bin": {
         "acorn": "bin/acorn"
       },
@@ -2140,6 +2342,13 @@
         "node": ">= 0.4"
       }
     },
+    "node_modules/eastasianwidth": {
+      "version": "0.2.0",
+      "resolved": "https://registry.npmjs.org/eastasianwidth/-/eastasianwidth-0.2.0.tgz",
+      "integrity": "sha512-I88TYZWc9XiYHRQ4/3c5rjjfgkjhLyW2luGIheGERbNQ6OY7yTybanSpDXZa8y7VUP9YmDcYa+eyq4ca7iLqWA==",
+      "dev": true,
+      "license": "MIT"
+    },
     "node_modules/ecdsa-sig-formatter": {
       "version": "1.0.11",
       "resolved": "https://registry.npmjs.org/ecdsa-sig-formatter/-/ecdsa-sig-formatter-1.0.11.tgz",
@@ -2155,6 +2364,13 @@
       "integrity": "sha512-WMwm9LhRUo+WUaRN+vRuETqG89IgZphVSNkdFgeb6sS/E4OrDIN7t48CAewSHXc6C8lefD8KKfr5vY61brQlow==",
       "license": "MIT"
     },
+    "node_modules/emoji-regex": {
+      "version": "9.2.2",
+      "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-9.2.2.tgz",
+      "integrity": "sha512-L18DaJsXSUk2+42pv8mLs5jJT2hqFkFE4j21wOmgbUqsZ2hL72NsUU785g9RXgo3s0ZNgVl42TiHp3ZtOv/Vyg==",
+      "dev": true,
+      "license": "MIT"
+    },
     "node_modules/encodeurl": {
       "version": "2.0.0",
       "resolved": "https://registry.npmjs.org/encodeurl/-/encodeurl-2.0.0.tgz",
@@ -2291,7 +2507,6 @@
       "deprecated": "This version is no longer supported. Please see https://eslint.org/version-support for other options.",
       "dev": true,
       "license": "MIT",
-      "peer": true,
       "dependencies": {
         "@eslint-community/eslint-utils": "^4.2.0",
         "@eslint-community/regexpp": "^4.6.1",
@@ -2731,6 +2946,23 @@
       "dev": true,
       "license": "ISC"
     },
+    "node_modules/foreground-child": {
+      "version": "3.3.1",
+      "resolved": "https://registry.npmjs.org/foreground-child/-/foreground-child-3.3.1.tgz",
+      "integrity": "sha512-gIXjKqtFuWEgzFRJA9WCQeSJLZDjgJUOMCMzxtvFq/37KojM1BFGufqsCy0r4qSQmYLsZYMeyRqzIWOMup03sw==",
+      "dev": true,
+      "license": "ISC",
+      "dependencies": {
+        "cross-spawn": "^7.0.6",
+        "signal-exit": "^4.0.1"
+      },
+      "engines": {
+        "node": ">=14"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/isaacs"
+      }
+    },
     "node_modules/form-data": {
       "version": "4.0.5",
       "resolved": "https://registry.npmjs.org/form-data/-/form-data-4.0.5.tgz",
@@ -3029,6 +3261,13 @@
         "node": ">= 0.4"
       }
     },
+    "node_modules/html-escaper": {
+      "version": "2.0.2",
+      "resolved": "https://registry.npmjs.org/html-escaper/-/html-escaper-2.0.2.tgz",
+      "integrity": "sha512-H2iMtd0I4Mt5eYiapRdIDjp+XzelXQ0tFE4JS7YFwFevXXMmOp9myNrUvCg0D6ws8iqkRPBfKHgbwig1SmlLfg==",
+      "dev": true,
+      "license": "MIT"
+    },
     "node_modules/http-errors": {
       "version": "2.0.1",
       "resolved": "https://registry.npmjs.org/http-errors/-/http-errors-2.0.1.tgz",
@@ -3161,6 +3400,16 @@
         "node": ">=0.10.0"
       }
     },
+    "node_modules/is-fullwidth-code-point": {
+      "version": "3.0.0",
+      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/is-fullwidth-code-point-3.0.0.tgz",
+      "integrity": "sha512-zymm5+u+sCsSWyD9qNaejV3DFvhCKclKdizYaJUuHA83RLjb7nSuGnddCHGv0hk+KY7BMAlsWeK4Ueg6EV6XQg==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=8"
+      }
+    },
     "node_modules/is-glob": {
       "version": "4.0.3",
       "resolved": "https://registry.npmjs.org/is-glob/-/is-glob-4.0.3.tgz",
@@ -3201,6 +3450,76 @@
       "dev": true,
       "license": "ISC"
     },
+    "node_modules/istanbul-lib-coverage": {
+      "version": "3.2.2",
+      "resolved": "https://registry.npmjs.org/istanbul-lib-coverage/-/istanbul-lib-coverage-3.2.2.tgz",
+      "integrity": "sha512-O8dpsF+r0WV/8MNRKfnmrtCWhuKjxrq2w+jpzBL5UZKTi2LeVWnWOmWRxFlesJONmc+wLAGvKQZEOanko0LFTg==",
+      "dev": true,
+      "license": "BSD-3-Clause",
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/istanbul-lib-report": {
+      "version": "3.0.1",
+      "resolved": "https://registry.npmjs.org/istanbul-lib-report/-/istanbul-lib-report-3.0.1.tgz",
+      "integrity": "sha512-GCfE1mtsHGOELCU8e/Z7YWzpmybrx/+dSTfLrvY8qRmaY6zXTKWn6WQIjaAFw069icm6GVMNkgu0NzI4iPZUNw==",
+      "dev": true,
+      "license": "BSD-3-Clause",
+      "dependencies": {
+        "istanbul-lib-coverage": "^3.0.0",
+        "make-dir": "^4.0.0",
+        "supports-color": "^7.1.0"
+      },
+      "engines": {
+        "node": ">=10"
+      }
+    },
+    "node_modules/istanbul-lib-source-maps": {
+      "version": "5.0.6",
+      "resolved": "https://registry.npmjs.org/istanbul-lib-source-maps/-/istanbul-lib-source-maps-5.0.6.tgz",
+      "integrity": "sha512-yg2d+Em4KizZC5niWhQaIomgf5WlL4vOOjZ5xGCmF8SnPE/mDWWXgvRExdcpCgh9lLRRa1/fSYp2ymmbJ1pI+A==",
+      "dev": true,
+      "license": "BSD-3-Clause",
+      "dependencies": {
+        "@jridgewell/trace-mapping": "^0.3.23",
+        "debug": "^4.1.1",
+        "istanbul-lib-coverage": "^3.0.0"
+      },
+      "engines": {
+        "node": ">=10"
+      }
+    },
+    "node_modules/istanbul-reports": {
+      "version": "3.2.0",
+      "resolved": "https://registry.npmjs.org/istanbul-reports/-/istanbul-reports-3.2.0.tgz",
+      "integrity": "sha512-HGYWWS/ehqTV3xN10i23tkPkpH46MLCIMFNCaaKNavAXTF1RkqxawEPtnjnGZ6XKSInBKkiOA5BKS+aZiY3AvA==",
+      "dev": true,
+      "license": "BSD-3-Clause",
+      "dependencies": {
+        "html-escaper": "^2.0.0",
+        "istanbul-lib-report": "^3.0.0"
+      },
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/jackspeak": {
+      "version": "3.4.3",
+      "resolved": "https://registry.npmjs.org/jackspeak/-/jackspeak-3.4.3.tgz",
+      "integrity": "sha512-OGlZQpz2yfahA/Rd1Y8Cd9SIEsqvXkLVoSw/cgwhnhFMDbsQFeZYoJJ7bIZBS9BcamUW96asq/npPWugM+RQBw==",
+      "dev": true,
+      "license": "BlueOak-1.0.0",
+      "dependencies": {
+        "@isaacs/cliui": "^8.0.2"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/isaacs"
+      },
+      "optionalDependencies": {
+        "@pkgjs/parseargs": "^0.11.0"
+      }
+    },
     "node_modules/js-yaml": {
       "version": "4.1.1",
       "resolved": "https://registry.npmjs.org/js-yaml/-/js-yaml-4.1.1.tgz",
@@ -3374,6 +3693,13 @@
       "dev": true,
       "license": "MIT"
     },
+    "node_modules/lru-cache": {
+      "version": "10.4.3",
+      "resolved": "https://registry.npmjs.org/lru-cache/-/lru-cache-10.4.3.tgz",
+      "integrity": "sha512-JNAzZcXrCt42VGLuYz0zfAzDfAvJWW6AfYlDBQyDV5DClI2m5sAmK+OIO7s59XfsRsWHp02jAJrRadPRGTt6SQ==",
+      "dev": true,
+      "license": "ISC"
+    },
     "node_modules/magic-string": {
       "version": "0.30.21",
       "resolved": "https://registry.npmjs.org/magic-string/-/magic-string-0.30.21.tgz",
@@ -3384,6 +3710,34 @@
         "@jridgewell/sourcemap-codec": "^1.5.5"
       }
     },
+    "node_modules/magicast": {
+      "version": "0.3.5",
+      "resolved": "https://registry.npmjs.org/magicast/-/magicast-0.3.5.tgz",
+      "integrity": "sha512-L0WhttDl+2BOsybvEOLK7fW3UA0OQ0IQ2d6Zl2x/a6vVRs3bAY0ECOSHHeL5jD+SbOpOCUEi0y1DgHEn9Qn1AQ==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@babel/parser": "^7.25.4",
+        "@babel/types": "^7.25.4",
+        "source-map-js": "^1.2.0"
+      }
+    },
+    "node_modules/make-dir": {
+      "version": "4.0.0",
+      "resolved": "https://registry.npmjs.org/make-dir/-/make-dir-4.0.0.tgz",
+      "integrity": "sha512-hXdUTZYIVOt1Ex//jAQi+wTZZpUpwBj/0QsOzqegb3rGMMeJiSEu5xLHnYfBrRV4RH2+OCSOO95Is/7x1WJ4bw==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "semver": "^7.5.3"
+      },
+      "engines": {
+        "node": ">=10"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/sindresorhus"
+      }
+    },
     "node_modules/math-intrinsics": {
       "version": "1.1.0",
       "resolved": "https://registry.npmjs.org/math-intrinsics/-/math-intrinsics-1.1.0.tgz",
@@ -3514,6 +3868,16 @@
         "url": "https://github.com/sponsors/ljharb"
       }
     },
+    "node_modules/minipass": {
+      "version": "7.1.2",
+      "resolved": "https://registry.npmjs.org/minipass/-/minipass-7.1.2.tgz",
+      "integrity": "sha512-qOOzS1cBTWYF4BH8fVePDBOO9iptMnGUEZwNc/cMWnTV2nVLZ7VoNWEPHkYczZA0pdoA7dl6e7FL659nX9S2aw==",
+      "dev": true,
+      "license": "ISC",
+      "engines": {
+        "node": ">=16 || 14 >=14.17"
+      }
+    },
     "node_modules/mkdirp-classic": {
       "version": "0.5.3",
       "resolved": "https://registry.npmjs.org/mkdirp-classic/-/mkdirp-classic-0.5.3.tgz",
@@ -3662,6 +4026,13 @@
         "url": "https://github.com/sponsors/sindresorhus"
       }
     },
+    "node_modules/package-json-from-dist": {
+      "version": "1.0.1",
+      "resolved": "https://registry.npmjs.org/package-json-from-dist/-/package-json-from-dist-1.0.1.tgz",
+      "integrity": "sha512-UEZIS3/by4OC8vL3P2dTXRETpebLI2NiI5vIrjaD/5UtrkFX/tNbwjTSRAGC/+7CAo2pIcBaRgWmcBBHcsaCIw==",
+      "dev": true,
+      "license": "BlueOak-1.0.0"
+    },
     "node_modules/parent-module": {
       "version": "1.0.1",
       "resolved": "https://registry.npmjs.org/parent-module/-/parent-module-1.0.1.tgz",
@@ -3714,6 +4085,23 @@
         "node": ">=8"
       }
     },
+    "node_modules/path-scurry": {
+      "version": "1.11.1",
+      "resolved": "https://registry.npmjs.org/path-scurry/-/path-scurry-1.11.1.tgz",
+      "integrity": "sha512-Xa4Nw17FS9ApQFJ9umLiJS4orGjm7ZzwUrwamcGQuHSzDyth9boKDaycYdDcZDuqYATXw4HFXgaqWTctW/v1HA==",
+      "dev": true,
+      "license": "BlueOak-1.0.0",
+      "dependencies": {
+        "lru-cache": "^10.2.0",
+        "minipass": "^5.0.0 || ^6.0.2 || ^7.0.0"
+      },
+      "engines": {
+        "node": ">=16 || 14 >=14.18"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/isaacs"
+      }
+    },
     "node_modules/path-to-regexp": {
       "version": "0.1.12",
       "resolved": "https://registry.npmjs.org/path-to-regexp/-/path-to-regexp-0.1.12.tgz",
@@ -4270,6 +4658,19 @@
       "dev": true,
       "license": "ISC"
     },
+    "node_modules/signal-exit": {
+      "version": "4.1.0",
+      "resolved": "https://registry.npmjs.org/signal-exit/-/signal-exit-4.1.0.tgz",
+      "integrity": "sha512-bzyZ1e88w9O1iNJbKnOlvYTrWPDl46O1bG0D3XInv+9tkPrxrN8jUUTiFlDkkmKWgn1M6CfIA13SuGqOa9Korw==",
+      "dev": true,
+      "license": "ISC",
+      "engines": {
+        "node": ">=14"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/isaacs"
+      }
+    },
     "node_modules/simple-concat": {
       "version": "1.0.1",
       "resolved": "https://registry.npmjs.org/simple-concat/-/simple-concat-1.0.1.tgz",
@@ -4367,6 +4768,76 @@
         "safe-buffer": "~5.2.0"
       }
     },
+    "node_modules/string-width": {
+      "version": "5.1.2",
+      "resolved": "https://registry.npmjs.org/string-width/-/string-width-5.1.2.tgz",
+      "integrity": "sha512-HnLOCR3vjcY8beoNLtcjZ5/nxn2afmME6lhrDrebokqMap+XbeW8n9TXpPDOqdGK5qcI3oT0GKTW6wC7EMiVqA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "eastasianwidth": "^0.2.0",
+        "emoji-regex": "^9.2.2",
+        "strip-ansi": "^7.0.1"
+      },
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/sindresorhus"
+      }
+    },
+    "node_modules/string-width-cjs": {
+      "name": "string-width",
+      "version": "4.2.3",
+      "resolved": "https://registry.npmjs.org/string-width/-/string-width-4.2.3.tgz",
+      "integrity": "sha512-wKyQRQpjJ0sIp62ErSZdGsjMJWsap5oRNihHhu6G7JVO/9jIB6UyevL+tXuOqrng8j/cxKTWyWUwvSTriiZz/g==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "emoji-regex": "^8.0.0",
+        "is-fullwidth-code-point": "^3.0.0",
+        "strip-ansi": "^6.0.1"
+      },
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/string-width-cjs/node_modules/emoji-regex": {
+      "version": "8.0.0",
+      "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-8.0.0.tgz",
+      "integrity": "sha512-MSjYzcWNOA0ewAHpz0MxpYFvwg6yjy1NG3xteoqz644VCo/RPgnr1/GGt+ic3iJTzQ8Eu3TdM14SawnVUmGE6A==",
+      "dev": true,
+      "license": "MIT"
+    },
+    "node_modules/string-width/node_modules/ansi-regex": {
+      "version": "6.2.2",
+      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-6.2.2.tgz",
+      "integrity": "sha512-Bq3SmSpyFHaWjPk8If9yc6svM8c56dB5BAtW4Qbw5jHTwwXXcTLoRMkpDJp6VL0XzlWaCHTXrkFURMYmD0sLqg==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/ansi-regex?sponsor=1"
+      }
+    },
+    "node_modules/string-width/node_modules/strip-ansi": {
+      "version": "7.1.2",
+      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-7.1.2.tgz",
+      "integrity": "sha512-gmBGslpoQJtgnMAvOVqGZpEz9dyoKTCzy2nfz/n8aIFhN/jCE/rCmcxabB6jOOHV+0WNnylOxaxBQPSvcWklhA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "ansi-regex": "^6.0.1"
+      },
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/strip-ansi?sponsor=1"
+      }
+    },
     "node_modules/strip-ansi": {
       "version": "6.0.1",
       "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-6.0.1.tgz",
@@ -4380,6 +4851,20 @@
         "node": ">=8"
       }
     },
+    "node_modules/strip-ansi-cjs": {
+      "name": "strip-ansi",
+      "version": "6.0.1",
+      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-6.0.1.tgz",
+      "integrity": "sha512-Y38VPSHcqkFrCpFnQ9vuSXmquuv5oXOKpGeT6aGrr3o3Gc9AlVa6JBfUSOCnbxGGZF+/0ooI7KrPuUSztUdU5A==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "ansi-regex": "^5.0.1"
+      },
+      "engines": {
+        "node": ">=8"
+      }
+    },
     "node_modules/strip-json-comments": {
       "version": "3.1.1",
       "resolved": "https://registry.npmjs.org/strip-json-comments/-/strip-json-comments-3.1.1.tgz",
@@ -4493,6 +4978,43 @@
         "node": ">=6"
       }
     },
+    "node_modules/test-exclude": {
+      "version": "7.0.1",
+      "resolved": "https://registry.npmjs.org/test-exclude/-/test-exclude-7.0.1.tgz",
+      "integrity": "sha512-pFYqmTw68LXVjeWJMST4+borgQP2AyMNbg1BpZh9LbyhUeNkeaPF9gzfPGUAnSMV3qPYdWUwDIjjCLiSDOl7vg==",
+      "dev": true,
+      "license": "ISC",
+      "dependencies": {
+        "@istanbuljs/schema": "^0.1.2",
+        "glob": "^10.4.1",
+        "minimatch": "^9.0.4"
+      },
+      "engines": {
+        "node": ">=18"
+      }
+    },
+    "node_modules/test-exclude/node_modules/glob": {
+      "version": "10.5.0",
+      "resolved": "https://registry.npmjs.org/glob/-/glob-10.5.0.tgz",
+      "integrity": "sha512-DfXN8DfhJ7NH3Oe7cFmu3NCu1wKbkReJ8TorzSAFbSKrlNaQSKfIzqYqVY8zlbs2NLBbWpRiU52GX2PbaBVNkg==",
+      "deprecated": "Old versions of glob are not supported, and contain widely publicized security vulnerabilities, which have been fixed in the current version. Please update. Support for old versions may be purchased (at exorbitant rates) by contacting i@izs.me",
+      "dev": true,
+      "license": "ISC",
+      "dependencies": {
+        "foreground-child": "^3.1.0",
+        "jackspeak": "^3.1.2",
+        "minimatch": "^9.0.4",
+        "minipass": "^7.1.2",
+        "package-json-from-dist": "^1.0.0",
+        "path-scurry": "^1.11.1"
+      },
+      "bin": {
+        "glob": "dist/esm/bin.mjs"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/isaacs"
+      }
+    },
     "node_modules/text-table": {
       "version": "0.2.0",
       "resolved": "https://registry.npmjs.org/text-table/-/text-table-0.2.0.tgz",
@@ -4636,7 +5158,6 @@
       "integrity": "sha512-jl1vZzPDinLr9eUt3J/t7V6FgNEw9QjvBPdysz9KfQDD41fQrC2Y4vKQdiaUpFT4bXlb1RHhLpp8wtm6M5TgSw==",
       "dev": true,
       "license": "Apache-2.0",
-      "peer": true,
       "bin": {
         "tsc": "bin/tsc",
         "tsserver": "bin/tsserver"
@@ -4900,6 +5421,107 @@
         "node": ">=0.10.0"
       }
     },
+    "node_modules/wrap-ansi": {
+      "version": "8.1.0",
+      "resolved": "https://registry.npmjs.org/wrap-ansi/-/wrap-ansi-8.1.0.tgz",
+      "integrity": "sha512-si7QWI6zUMq56bESFvagtmzMdGOtoxfR+Sez11Mobfc7tm+VkUckk9bW2UeffTGVUbOksxmSw0AA2gs8g71NCQ==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "ansi-styles": "^6.1.0",
+        "string-width": "^5.0.1",
+        "strip-ansi": "^7.0.1"
+      },
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/wrap-ansi?sponsor=1"
+      }
+    },
+    "node_modules/wrap-ansi-cjs": {
+      "name": "wrap-ansi",
+      "version": "7.0.0",
+      "resolved": "https://registry.npmjs.org/wrap-ansi/-/wrap-ansi-7.0.0.tgz",
+      "integrity": "sha512-YVGIj2kamLSTxw6NsZjoBxfSwsn0ycdesmc4p+Q21c5zPuZ1pl+NfxVdxPtdHvmNVOQ6XSYG4AUtyt/Fi7D16Q==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "ansi-styles": "^4.0.0",
+        "string-width": "^4.1.0",
+        "strip-ansi": "^6.0.0"
+      },
+      "engines": {
+        "node": ">=10"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/wrap-ansi?sponsor=1"
+      }
+    },
+    "node_modules/wrap-ansi-cjs/node_modules/emoji-regex": {
+      "version": "8.0.0",
+      "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-8.0.0.tgz",
+      "integrity": "sha512-MSjYzcWNOA0ewAHpz0MxpYFvwg6yjy1NG3xteoqz644VCo/RPgnr1/GGt+ic3iJTzQ8Eu3TdM14SawnVUmGE6A==",
+      "dev": true,
+      "license": "MIT"
+    },
+    "node_modules/wrap-ansi-cjs/node_modules/string-width": {
+      "version": "4.2.3",
+      "resolved": "https://registry.npmjs.org/string-width/-/string-width-4.2.3.tgz",
+      "integrity": "sha512-wKyQRQpjJ0sIp62ErSZdGsjMJWsap5oRNihHhu6G7JVO/9jIB6UyevL+tXuOqrng8j/cxKTWyWUwvSTriiZz/g==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "emoji-regex": "^8.0.0",
+        "is-fullwidth-code-point": "^3.0.0",
+        "strip-ansi": "^6.0.1"
+      },
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/wrap-ansi/node_modules/ansi-regex": {
+      "version": "6.2.2",
+      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-6.2.2.tgz",
+      "integrity": "sha512-Bq3SmSpyFHaWjPk8If9yc6svM8c56dB5BAtW4Qbw5jHTwwXXcTLoRMkpDJp6VL0XzlWaCHTXrkFURMYmD0sLqg==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/ansi-regex?sponsor=1"
+      }
+    },
+    "node_modules/wrap-ansi/node_modules/ansi-styles": {
+      "version": "6.2.3",
+      "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-6.2.3.tgz",
+      "integrity": "sha512-4Dj6M28JB+oAH8kFkTLUo+a2jwOFkuqb3yucU0CANcRRUbxS0cP0nZYCGjcc3BNXwRIsUVmDGgzawme7zvJHvg==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/ansi-styles?sponsor=1"
+      }
+    },
+    "node_modules/wrap-ansi/node_modules/strip-ansi": {
+      "version": "7.1.2",
+      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-7.1.2.tgz",
+      "integrity": "sha512-gmBGslpoQJtgnMAvOVqGZpEz9dyoKTCzy2nfz/n8aIFhN/jCE/rCmcxabB6jOOHV+0WNnylOxaxBQPSvcWklhA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "ansi-regex": "^6.0.1"
+      },
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/strip-ansi?sponsor=1"
+      }
+    },
     "node_modules/wrappy": {
       "version": "1.0.2",
       "resolved": "https://registry.npmjs.org/wrappy/-/wrappy-1.0.2.tgz",
diff --git a/src/app.ts b/src/app.ts
new file mode 100644
index 0000000..b609f5b
--- /dev/null
+++ b/src/app.ts
@@ -0,0 +1,29 @@
+import express from "express";
+import { createDatabase } from "./db.js";
+import { errorHandler } from "./auth.js";
+import { createUserRoutes } from "./routes/users.js";
+import { createEventRoutes } from "./routes/events.js";
+import { createQueryRoutes } from "./routes/queries.js";
+import { createDashboardRoutes } from "./routes/dashboards.js";
+import { createExportRoutes } from "./routes/export.js";
+
+export function createApp(dbPath?: string) {
+  const app = express();
+  const db = createDatabase(dbPath);
+
+  app.use(express.json());
+
+  app.get("/health", (_req, res) => {
+    res.json({ status: "ok" });
+  });
+
+  app.use("/api/users", createUserRoutes(db));
+  app.use("/api/events", createEventRoutes(db));
+  app.use("/api/queries", createQueryRoutes(db));
+  app.use("/api/dashboards", createDashboardRoutes(db));
+  app.use("/api/export", createExportRoutes(db));
+
+  app.use(errorHandler);
+
+  return app;
+}
diff --git a/src/auth.ts b/src/auth.ts
new file mode 100644
index 0000000..06c8f3d
--- /dev/null
+++ b/src/auth.ts
@@ -0,0 +1,67 @@
+import { Request, Response, NextFunction } from "express";
+import jwt from "jsonwebtoken";
+
+const JWT_SECRET = process.env.JWT_SECRET || "analytics-dashboard-secret";
+
+export interface JwtPayload {
+  sub: string;
+  tid: string;
+  role: string;
+  email: string;
+}
+
+export interface AuthenticatedRequest extends Request {
+  user?: JwtPayload;
+}
+
+export function generateToken(payload: JwtPayload): string {
+  return jwt.sign(
+    { sub: payload.sub, tid: payload.tid, role: payload.role, email: payload.email },
+    JWT_SECRET,
+    { expiresIn: "24h" }
+  );
+}
+
+export function verifyToken(token: string): JwtPayload {
+  return jwt.verify(token, JWT_SECRET) as JwtPayload;
+}
+
+export function authMiddleware(
+  req: AuthenticatedRequest,
+  res: Response,
+  next: NextFunction
+): void {
+  const authHeader = req.headers.authorization;
+  if (!authHeader || !authHeader.startsWith("Bearer ")) {
+    res.status(401).json({ error: "Authentication required", code: "UNAUTHORIZED" });
+    return;
+  }
+
+  const token = authHeader.slice(7);
+  try {
+    const payload = verifyToken(token);
+    req.user = payload;
+    next();
+  } catch {
+    res.status(401).json({ error: "Invalid or expired token", code: "UNAUTHORIZED" });
+  }
+}
+
+export function requireRole(...roles: string[]) {
+  return (req: AuthenticatedRequest, res: Response, next: NextFunction): void => {
+    if (!req.user) {
+      res.status(401).json({ error: "Authentication required", code: "UNAUTHORIZED" });
+      return;
+    }
+    if (!roles.includes(req.user.role)) {
+      res.status(403).json({ error: "Insufficient permissions", code: "FORBIDDEN" });
+      return;
+    }
+    next();
+  };
+}
+
+export function errorHandler(err: Error, _req: Request, res: Response, _next: NextFunction): void {
+  console.error(err.stack);
+  res.status(500).json({ error: "Internal server error", code: "INTERNAL_ERROR" });
+}
diff --git a/src/db.ts b/src/db.ts
new file mode 100644
index 0000000..afb02f1
--- /dev/null
+++ b/src/db.ts
@@ -0,0 +1,22 @@
+import Database from "better-sqlite3";
+import { readFileSync } from "fs";
+import { join } from "path";
+
+export function createDatabase(dbPath: string = ":memory:"): Database.Database {
+  const db = new Database(dbPath);
+  db.pragma("journal_mode = WAL");
+  db.pragma("foreign_keys = ON");
+
+  const schemaPath = join(__dirname, "..", "schema.sql");
+  try {
+    const schema = readFileSync(schemaPath, "utf-8");
+    db.exec(schema);
+  } catch {
+    // If schema.sql not found relative to dist, try from cwd
+    const fallbackPath = join(process.cwd(), "schema.sql");
+    const schema = readFileSync(fallbackPath, "utf-8");
+    db.exec(schema);
+  }
+
+  return db;
+}
diff --git a/src/index.ts b/src/index.ts
new file mode 100644
index 0000000..4f4395a
--- /dev/null
+++ b/src/index.ts
@@ -0,0 +1 @@
+export { createApp } from "./app.js";
diff --git a/src/routes/dashboards.ts b/src/routes/dashboards.ts
new file mode 100644
index 0000000..e5c5b6e
--- /dev/null
+++ b/src/routes/dashboards.ts
@@ -0,0 +1,235 @@
+import { Router, Response } from "express";
+import Database from "better-sqlite3";
+import { v4 as uuidv4 } from "uuid";
+import { AuthenticatedRequest, authMiddleware } from "../auth.js";
+
+export function createDashboardRoutes(db: Database.Database): Router {
+  const router = Router();
+
+  // Create dashboard
+  router.post(
+    "/",
+    authMiddleware,
+    (req: AuthenticatedRequest, res: Response): void => {
+      const tenantId = req.user!.tid;
+      const ownerId = req.user!.sub;
+      const { name, config } = req.body as { name: string; config?: Record<string, unknown> };
+
+      if (!name) {
+        res.status(400).json({ error: "Dashboard name is required", code: "BAD_REQUEST" });
+        return;
+      }
+
+      const id = uuidv4();
+      const configStr = JSON.stringify(config || {});
+      const now = new Date().toISOString();
+
+      db.prepare(
+        "INSERT INTO dashboards (id, tenant_id, name, owner_id, config, created_at, updated_at) VALUES (?, ?, ?, ?, ?, ?, ?)"
+      ).run(id, tenantId, name, ownerId, configStr, now, now);
+
+      res.status(201).json({
+        id,
+        tenantId,
+        name,
+        ownerId,
+        config: config || {},
+        createdAt: now,
+        updatedAt: now,
+      });
+    }
+  );
+
+  // List dashboards for tenant
+  router.get(
+    "/",
+    authMiddleware,
+    (req: AuthenticatedRequest, res: Response): void => {
+      const tenantId = req.user!.tid;
+
+      const rows = db
+        .prepare(
+          "SELECT id, tenant_id, name, owner_id, config, created_at, updated_at FROM dashboards WHERE tenant_id = ? ORDER BY created_at DESC"
+        )
+        .all(tenantId) as Array<{
+        id: string;
+        tenant_id: string;
+        name: string;
+        owner_id: string;
+        config: string;
+        created_at: string;
+        updated_at: string;
+      }>;
+
+      const dashboards = rows.map((row) => ({
+        id: row.id,
+        tenantId: row.tenant_id,
+        name: row.name,
+        ownerId: row.owner_id,
+        config: JSON.parse(row.config),
+        createdAt: row.created_at,
+        updatedAt: row.updated_at,
+      }));
+
+      res.json({ dashboards });
+    }
+  );
+
+  // Get dashboard by ID
+  router.get(
+    "/:id",
+    authMiddleware,
+    (req: AuthenticatedRequest, res: Response): void => {
+      const tenantId = req.user!.tid;
+      const { id } = req.params;
+
+      const row = db
+        .prepare(
+          "SELECT id, tenant_id, name, owner_id, config, created_at, updated_at FROM dashboards WHERE id = ? AND tenant_id = ?"
+        )
+        .get(id, tenantId) as
+        | {
+            id: string;
+            tenant_id: string;
+            name: string;
+            owner_id: string;
+            config: string;
+            created_at: string;
+            updated_at: string;
+          }
+        | undefined;
+
+      if (!row) {
+        res.status(404).json({ error: "Dashboard not found", code: "NOT_FOUND" });
+        return;
+      }
+
+      const widgets = db
+        .prepare(
+          "SELECT id, dashboard_id, type, config, position_x, position_y, width, height FROM widgets WHERE dashboard_id = ?"
+        )
+        .all(id) as Array<{
+        id: string;
+        dashboard_id: string;
+        type: string;
+        config: string;
+        position_x: number;
+        position_y: number;
+        width: number;
+        height: number;
+      }>;
+
+      res.json({
+        id: row.id,
+        tenantId: row.tenant_id,
+        name: row.name,
+        ownerId: row.owner_id,
+        config: JSON.parse(row.config),
+        createdAt: row.created_at,
+        updatedAt: row.updated_at,
+        widgets: widgets.map((w) => ({
+          id: w.id,
+          dashboardId: w.dashboard_id,
+          type: w.type,
+          config: JSON.parse(w.config),
+          positionX: w.position_x,
+          positionY: w.position_y,
+          width: w.width,
+          height: w.height,
+        })),
+      });
+    }
+  );
+
+  // Update dashboard
+  router.put(
+    "/:id",
+    authMiddleware,
+    (req: AuthenticatedRequest, res: Response): void => {
+      const tenantId = req.user!.tid;
+      const { id } = req.params;
+      const { name, config } = req.body as {
+        name?: string;
+        config?: Record<string, unknown>;
+      };
+
+      const existing = db
+        .prepare("SELECT id FROM dashboards WHERE id = ? AND tenant_id = ?")
+        .get(id, tenantId) as { id: string } | undefined;
+
+      if (!existing) {
+        res.status(404).json({ error: "Dashboard not found", code: "NOT_FOUND" });
+        return;
+      }
+
+      const now = new Date().toISOString();
+
+      if (name !== undefined && config !== undefined) {
+        db.prepare(
+          "UPDATE dashboards SET name = ?, config = ?, updated_at = ? WHERE id = ?"
+        ).run(name, JSON.stringify(config), now, id);
+      } else if (name !== undefined) {
+        db.prepare("UPDATE dashboards SET name = ?, updated_at = ? WHERE id = ?").run(
+          name,
+          now,
+          id
+        );
+      } else if (config !== undefined) {
+        db.prepare("UPDATE dashboards SET config = ?, updated_at = ? WHERE id = ?").run(
+          JSON.stringify(config),
+          now,
+          id
+        );
+      }
+
+      const updated = db
+        .prepare(
+          "SELECT id, tenant_id, name, owner_id, config, created_at, updated_at FROM dashboards WHERE id = ?"
+        )
+        .get(id) as {
+        id: string;
+        tenant_id: string;
+        name: string;
+        owner_id: string;
+        config: string;
+        created_at: string;
+        updated_at: string;
+      };
+
+      res.json({
+        id: updated.id,
+        tenantId: updated.tenant_id,
+        name: updated.name,
+        ownerId: updated.owner_id,
+        config: JSON.parse(updated.config),
+        createdAt: updated.created_at,
+        updatedAt: updated.updated_at,
+      });
+    }
+  );
+
+  // Delete dashboard
+  router.delete(
+    "/:id",
+    authMiddleware,
+    (req: AuthenticatedRequest, res: Response): void => {
+      const tenantId = req.user!.tid;
+      const { id } = req.params;
+
+      const existing = db
+        .prepare("SELECT id FROM dashboards WHERE id = ? AND tenant_id = ?")
+        .get(id, tenantId) as { id: string } | undefined;
+
+      if (!existing) {
+        res.status(404).json({ error: "Dashboard not found", code: "NOT_FOUND" });
+        return;
+      }
+
+      db.prepare("DELETE FROM dashboards WHERE id = ?").run(id);
+
+      res.status(204).send();
+    }
+  );
+
+  return router;
+}
diff --git a/src/routes/events.ts b/src/routes/events.ts
new file mode 100644
index 0000000..b7b476e
--- /dev/null
+++ b/src/routes/events.ts
@@ -0,0 +1,132 @@
+import { Router, Response } from "express";
+import Database from "better-sqlite3";
+import { v4 as uuidv4 } from "uuid";
+import { AuthenticatedRequest, authMiddleware } from "../auth.js";
+
+interface EventInput {
+  name: string;
+  properties?: Record<string, unknown>;
+  timestamp?: string;
+  userId?: string;
+  sessionId?: string;
+}
+
+export function createEventRoutes(db: Database.Database): Router {
+  const router = Router();
+
+  // Ingest single event
+  router.post(
+    "/",
+    authMiddleware,
+    (req: AuthenticatedRequest, res: Response): void => {
+      const tenantId = req.user!.tid;
+      const { name, properties, timestamp, userId, sessionId } = req.body as EventInput;
+
+      if (!name) {
+        res.status(400).json({ error: "Event name is required", code: "BAD_REQUEST" });
+        return;
+      }
+
+      const id = uuidv4();
+      const eventTimestamp = timestamp || new Date().toISOString();
+      const eventProperties = JSON.stringify(properties || {});
+
+      db.prepare(
+        "INSERT INTO events (id, tenant_id, name, properties, timestamp, user_id, session_id) VALUES (?, ?, ?, ?, ?, ?, ?)"
+      ).run(id, tenantId, name, eventProperties, eventTimestamp, userId || null, sessionId || null);
+
+      res.status(201).json({ id, name, tenantId, timestamp: eventTimestamp });
+    }
+  );
+
+  // Ingest batch of events
+  router.post(
+    "/batch",
+    authMiddleware,
+    (req: AuthenticatedRequest, res: Response): void => {
+      const tenantId = req.user!.tid;
+      const { events } = req.body as { events: EventInput[] };
+
+      if (!events || !Array.isArray(events) || events.length === 0) {
+        res.status(400).json({ error: "events array is required and must not be empty", code: "BAD_REQUEST" });
+        return;
+      }
+
+      const insertStmt = db.prepare(
+        "INSERT INTO events (id, tenant_id, name, properties, timestamp, user_id, session_id) VALUES (?, ?, ?, ?, ?, ?, ?)"
+      );
+
+      const results: { id: string; name: string }[] = [];
+
+      const insertAll = db.transaction(() => {
+        for (const event of events) {
+          if (!event.name) continue;
+          const id = uuidv4();
+          const eventTimestamp = event.timestamp || new Date().toISOString();
+          const eventProperties = JSON.stringify(event.properties || {});
+          insertStmt.run(
+            id,
+            tenantId,
+            event.name,
+            eventProperties,
+            eventTimestamp,
+            event.userId || null,
+            event.sessionId || null
+          );
+          results.push({ id, name: event.name });
+        }
+      });
+
+      insertAll();
+
+      res.status(201).json({ inserted: results.length, events: results });
+    }
+  );
+
+  // List events for tenant
+  router.get(
+    "/",
+    authMiddleware,
+    (req: AuthenticatedRequest, res: Response): void => {
+      const tenantId = req.user!.tid;
+      const limit = Math.min(parseInt(req.query.limit as string) || 100, 1000);
+      const offset = parseInt(req.query.offset as string) || 0;
+      const name = req.query.name as string | undefined;
+
+      let query = "SELECT id, tenant_id, name, properties, timestamp, user_id, session_id FROM events WHERE tenant_id = ?";
+      const params: (string | number)[] = [tenantId];
+
+      if (name) {
+        query += " AND name = ?";
+        params.push(name);
+      }
+
+      query += " ORDER BY timestamp DESC LIMIT ? OFFSET ?";
+      params.push(limit, offset);
+
+      const rows = db.prepare(query).all(...params) as Array<{
+        id: string;
+        tenant_id: string;
+        name: string;
+        properties: string;
+        timestamp: string;
+        user_id: string | null;
+        session_id: string | null;
+      }>;
+
+      const events = rows.map((row) => ({
+        id: row.id,
+        tenantId: row.tenant_id,
+        name: row.name,
+        properties: JSON.parse(row.properties),
+        timestamp: row.timestamp,
+        userId: row.user_id,
+        sessionId: row.session_id,
+      }));
+
+      res.json({ events, limit, offset });
+    }
+  );
+
+  return router;
+}
diff --git a/src/routes/export.ts b/src/routes/export.ts
new file mode 100644
index 0000000..9464c66
--- /dev/null
+++ b/src/routes/export.ts
@@ -0,0 +1,276 @@
+import { Router, Response } from "express";
+import Database from "better-sqlite3";
+import { AuthenticatedRequest, authMiddleware } from "../auth.js";
+
+interface EventRow {
+  id: string;
+  tenant_id: string;
+  name: string;
+  properties: string;
+  timestamp: string;
+  user_id: string | null;
+  session_id: string | null;
+}
+
+function escapeCsvField(value: string): string {
+  if (value.includes(",") || value.includes('"') || value.includes("\n")) {
+    return '"' + value.replace(/"/g, '""') + '"';
+  }
+  return value;
+}
+
+function eventsToCsv(events: EventRow[]): string {
+  const headers = ["id", "tenant_id", "name", "properties", "timestamp", "user_id", "session_id"];
+  const lines = [headers.join(",")];
+
+  for (const event of events) {
+    const row = [
+      escapeCsvField(event.id),
+      escapeCsvField(event.tenant_id),
+      escapeCsvField(event.name),
+      escapeCsvField(event.properties),
+      escapeCsvField(event.timestamp),
+      escapeCsvField(event.user_id || ""),
+      escapeCsvField(event.session_id || ""),
+    ];
+    lines.push(row.join(","));
+  }
+
+  return lines.join("\n");
+}
+
+export function createExportRoutes(db: Database.Database): Router {
+  const router = Router();
+
+  // Export events as JSON
+  router.get(
+    "/events/json",
+    authMiddleware,
+    (req: AuthenticatedRequest, res: Response): void => {
+      const tenantId = req.user!.tid;
+      const eventName = req.query.eventName as string | undefined;
+      const startDate = req.query.startDate as string | undefined;
+      const endDate = req.query.endDate as string | undefined;
+
+      let query =
+        "SELECT id, tenant_id, name, properties, timestamp, user_id, session_id FROM events WHERE tenant_id = ?";
+      const params: string[] = [tenantId];
+
+      if (eventName) {
+        query += " AND name = ?";
+        params.push(eventName);
+      }
+      if (startDate) {
+        query += " AND timestamp >= ?";
+        params.push(startDate);
+      }
+      if (endDate) {
+        query += " AND timestamp <= ?";
+        params.push(endDate);
+      }
+
+      query += " ORDER BY timestamp DESC";
+
+      const rows = db.prepare(query).all(...params) as EventRow[];
+
+      const events = rows.map((row) => ({
+        id: row.id,
+        tenantId: row.tenant_id,
+        name: row.name,
+        properties: JSON.parse(row.properties),
+        timestamp: row.timestamp,
+        userId: row.user_id,
+        sessionId: row.session_id,
+      }));
+
+      res.setHeader("Content-Type", "application/json");
+      res.setHeader("Content-Disposition", "attachment; filename=events.json");
+      res.json({ events });
+    }
+  );
+
+  // Export events as CSV
+  router.get(
+    "/events/csv",
+    authMiddleware,
+    (req: AuthenticatedRequest, res: Response): void => {
+      const tenantId = req.user!.tid;
+      const eventName = req.query.eventName as string | undefined;
+      const startDate = req.query.startDate as string | undefined;
+      const endDate = req.query.endDate as string | undefined;
+
+      let query =
+        "SELECT id, tenant_id, name, properties, timestamp, user_id, session_id FROM events WHERE tenant_id = ?";
+      const params: string[] = [tenantId];
+
+      if (eventName) {
+        query += " AND name = ?";
+        params.push(eventName);
+      }
+      if (startDate) {
+        query += " AND timestamp >= ?";
+        params.push(startDate);
+      }
+      if (endDate) {
+        query += " AND timestamp <= ?";
+        params.push(endDate);
+      }
+
+      query += " ORDER BY timestamp DESC";
+
+      const rows = db.prepare(query).all(...params) as EventRow[];
+
+      res.setHeader("Content-Type", "text/csv");
+      res.setHeader("Content-Disposition", "attachment; filename=events.csv");
+      res.send(eventsToCsv(rows));
+    }
+  );
+
+  // Export dashboard as JSON
+  router.get(
+    "/dashboards/:id/json",
+    authMiddleware,
+    (req: AuthenticatedRequest, res: Response): void => {
+      const tenantId = req.user!.tid;
+      const { id } = req.params;
+
+      const dashboard = db
+        .prepare(
+          "SELECT id, tenant_id, name, owner_id, config, created_at, updated_at FROM dashboards WHERE id = ? AND tenant_id = ?"
+        )
+        .get(id, tenantId) as
+        | {
+            id: string;
+            tenant_id: string;
+            name: string;
+            owner_id: string;
+            config: string;
+            created_at: string;
+            updated_at: string;
+          }
+        | undefined;
+
+      if (!dashboard) {
+        res.status(404).json({ error: "Dashboard not found", code: "NOT_FOUND" });
+        return;
+      }
+
+      const widgets = db
+        .prepare(
+          "SELECT id, dashboard_id, type, config, position_x, position_y, width, height FROM widgets WHERE dashboard_id = ?"
+        )
+        .all(id) as Array<{
+        id: string;
+        dashboard_id: string;
+        type: string;
+        config: string;
+        position_x: number;
+        position_y: number;
+        width: number;
+        height: number;
+      }>;
+
+      res.setHeader("Content-Type", "application/json");
+      res.setHeader("Content-Disposition", `attachment; filename=dashboard-${id}.json`);
+      res.json({
+        dashboard: {
+          id: dashboard.id,
+          tenantId: dashboard.tenant_id,
+          name: dashboard.name,
+          ownerId: dashboard.owner_id,
+          config: JSON.parse(dashboard.config),
+          createdAt: dashboard.created_at,
+          updatedAt: dashboard.updated_at,
+          widgets: widgets.map((w) => ({
+            id: w.id,
+            dashboardId: w.dashboard_id,
+            type: w.type,
+            config: JSON.parse(w.config),
+            positionX: w.position_x,
+            positionY: w.position_y,
+            width: w.width,
+            height: w.height,
+          })),
+        },
+      });
+    }
+  );
+
+  // Export dashboard as CSV
+  router.get(
+    "/dashboards/:id/csv",
+    authMiddleware,
+    (req: AuthenticatedRequest, res: Response): void => {
+      const tenantId = req.user!.tid;
+      const { id } = req.params;
+
+      const dashboard = db
+        .prepare(
+          "SELECT id, tenant_id, name, owner_id, config, created_at, updated_at FROM dashboards WHERE id = ? AND tenant_id = ?"
+        )
+        .get(id, tenantId) as
+        | {
+            id: string;
+            tenant_id: string;
+            name: string;
+            owner_id: string;
+            config: string;
+            created_at: string;
+            updated_at: string;
+          }
+        | undefined;
+
+      if (!dashboard) {
+        res.status(404).json({ error: "Dashboard not found", code: "NOT_FOUND" });
+        return;
+      }
+
+      const widgets = db
+        .prepare(
+          "SELECT id, dashboard_id, type, config, position_x, position_y, width, height FROM widgets WHERE dashboard_id = ?"
+        )
+        .all(id) as Array<{
+        id: string;
+        dashboard_id: string;
+        type: string;
+        config: string;
+        position_x: number;
+        position_y: number;
+        width: number;
+        height: number;
+      }>;
+
+      const headers = [
+        "id",
+        "dashboard_id",
+        "type",
+        "config",
+        "position_x",
+        "position_y",
+        "width",
+        "height",
+      ];
+      const lines = [headers.join(",")];
+
+      for (const w of widgets) {
+        const row = [
+          escapeCsvField(w.id),
+          escapeCsvField(w.dashboard_id),
+          escapeCsvField(w.type),
+          escapeCsvField(w.config),
+          String(w.position_x),
+          String(w.position_y),
+          String(w.width),
+          String(w.height),
+        ];
+        lines.push(row.join(","));
+      }
+
+      res.setHeader("Content-Type", "text/csv");
+      res.setHeader("Content-Disposition", `attachment; filename=dashboard-${id}.csv`);
+      res.send(lines.join("\n"));
+    }
+  );
+
+  return router;
+}
diff --git a/src/routes/queries.ts b/src/routes/queries.ts
new file mode 100644
index 0000000..cf2a3e2
--- /dev/null
+++ b/src/routes/queries.ts
@@ -0,0 +1,165 @@
+import { Router, Response } from "express";
+import Database from "better-sqlite3";
+import { AuthenticatedRequest, authMiddleware } from "../auth.js";
+
+export function createQueryRoutes(db: Database.Database): Router {
+  const router = Router();
+
+  // Count query
+  router.post(
+    "/count",
+    authMiddleware,
+    (req: AuthenticatedRequest, res: Response): void => {
+      const tenantId = req.user!.tid;
+      const { eventName, startDate, endDate, filters } = req.body as {
+        eventName?: string;
+        startDate?: string;
+        endDate?: string;
+        filters?: Record<string, unknown>;
+      };
+
+      let query = "SELECT COUNT(*) as count FROM events WHERE tenant_id = ?";
+      const params: string[] = [tenantId];
+
+      if (eventName) {
+        query += " AND name = ?";
+        params.push(eventName);
+      }
+      if (startDate) {
+        query += " AND timestamp >= ?";
+        params.push(startDate);
+      }
+      if (endDate) {
+        query += " AND timestamp <= ?";
+        params.push(endDate);
+      }
+
+      if (filters) {
+        for (const [key, value] of Object.entries(filters)) {
+          query += " AND json_extract(properties, ?) = ?";
+          params.push(`$.${key}`, String(value));
+        }
+      }
+
+      const result = db.prepare(query).get(...params) as { count: number };
+      res.json({ count: result.count });
+    }
+  );
+
+  // Timeseries query
+  router.post(
+    "/timeseries",
+    authMiddleware,
+    (req: AuthenticatedRequest, res: Response): void => {
+      const tenantId = req.user!.tid;
+      const { eventName, startDate, endDate, interval, filters } = req.body as {
+        eventName?: string;
+        startDate?: string;
+        endDate?: string;
+        interval?: string;
+        filters?: Record<string, unknown>;
+      };
+
+      let dateFormat: string;
+      switch (interval) {
+        case "hour":
+          dateFormat = "%Y-%m-%dT%H:00:00";
+          break;
+        case "month":
+          dateFormat = "%Y-%m-01";
+          break;
+        case "day":
+        default:
+          dateFormat = "%Y-%m-%d";
+          break;
+      }
+
+      let query = `SELECT strftime('${dateFormat}', timestamp) as bucket, COUNT(*) as count FROM events WHERE tenant_id = ?`;
+      const params: string[] = [tenantId];
+
+      if (eventName) {
+        query += " AND name = ?";
+        params.push(eventName);
+      }
+      if (startDate) {
+        query += " AND timestamp >= ?";
+        params.push(startDate);
+      }
+      if (endDate) {
+        query += " AND timestamp <= ?";
+        params.push(endDate);
+      }
+
+      if (filters) {
+        for (const [key, value] of Object.entries(filters)) {
+          query += " AND json_extract(properties, ?) = ?";
+          params.push(`$.${key}`, String(value));
+        }
+      }
+
+      query += " GROUP BY bucket ORDER BY bucket ASC";
+
+      const rows = db.prepare(query).all(...params) as Array<{
+        bucket: string;
+        count: number;
+      }>;
+
+      res.json({ timeseries: rows });
+    }
+  );
+
+  // Breakdown query
+  router.post(
+    "/breakdown",
+    authMiddleware,
+    (req: AuthenticatedRequest, res: Response): void => {
+      const tenantId = req.user!.tid;
+      const { eventName, property, startDate, endDate, filters } = req.body as {
+        eventName?: string;
+        property: string;
+        startDate?: string;
+        endDate?: string;
+        filters?: Record<string, unknown>;
+      };
+
+      if (!property) {
+        res.status(400).json({ error: "property is required for breakdown queries", code: "BAD_REQUEST" });
+        return;
+      }
+
+      let query = `SELECT json_extract(properties, ?) as value, COUNT(*) as count FROM events WHERE tenant_id = ?`;
+      const params: string[] = [`$.${property}`, tenantId];
+
+      if (eventName) {
+        query += " AND name = ?";
+        params.push(eventName);
+      }
+      if (startDate) {
+        query += " AND timestamp >= ?";
+        params.push(startDate);
+      }
+      if (endDate) {
+        query += " AND timestamp <= ?";
+        params.push(endDate);
+      }
+
+      if (filters) {
+        for (const [key, value] of Object.entries(filters)) {
+          query += " AND json_extract(properties, ?) = ?";
+          params.push(`$.${key}`, String(value));
+        }
+      }
+
+      query += " GROUP BY value ORDER BY count DESC";
+
+      const rows = db.prepare(query).all(...params) as Array<{
+        value: string | null;
+        count: number;
+      }>;
+
+      res.json({ breakdown: rows });
+    }
+  );
+
+  return router;
+}
diff --git a/src/routes/users.ts b/src/routes/users.ts
new file mode 100644
index 0000000..7bc264f
--- /dev/null
+++ b/src/routes/users.ts
@@ -0,0 +1,155 @@
+import { Router, Response } from "express";
+import Database from "better-sqlite3";
+import { createHash } from "crypto";
+import { v4 as uuidv4 } from "uuid";
+import {
+  AuthenticatedRequest,
+  authMiddleware,
+  generateToken,
+  requireRole,
+} from "../auth.js";
+
+function hashPassword(password: string): string {
+  return createHash("sha256").update(password).digest("hex");
+}
+
+export function createUserRoutes(db: Database.Database): Router {
+  const router = Router();
+
+  // Register
+  router.post("/register", (req: AuthenticatedRequest, res: Response): void => {
+    const { email, password, tenantId, role } = req.body;
+
+    if (!email || !password || !tenantId) {
+      res.status(400).json({ error: "email, password, and tenantId are required", code: "BAD_REQUEST" });
+      return;
+    }
+
+    const validRoles = ["admin", "editor", "viewer"];
+    const userRole = role && validRoles.includes(role) ? role : "viewer";
+
+    const existing = db
+      .prepare("SELECT id FROM users WHERE email = ?")
+      .get(email) as { id: string } | undefined;
+
+    if (existing) {
+      res.status(409).json({ error: "Email already registered", code: "CONFLICT" });
+      return;
+    }
+
+    const id = uuidv4();
+    const passwordHash = hashPassword(password);
+
+    db.prepare(
+      "INSERT INTO users (id, email, password_hash, tenant_id, role) VALUES (?, ?, ?, ?, ?)"
+    ).run(id, email, passwordHash, tenantId, userRole);
+
+    const token = generateToken({
+      sub: id,
+      email,
+      tid: tenantId,
+      role: userRole,
+    });
+
+    res.status(201).json({ id, email, tenantId, role: userRole, token });
+  });
+
+  // Login
+  router.post("/login", (req: AuthenticatedRequest, res: Response): void => {
+    const { email, password } = req.body;
+
+    if (!email || !password) {
+      res.status(400).json({ error: "email and password are required", code: "BAD_REQUEST" });
+      return;
+    }
+
+    const user = db
+      .prepare("SELECT id, email, password_hash, tenant_id, role FROM users WHERE email = ?")
+      .get(email) as
+      | { id: string; email: string; password_hash: string; tenant_id: string; role: string }
+      | undefined;
+
+    if (!user || user.password_hash !== hashPassword(password)) {
+      res.status(401).json({ error: "Invalid credentials", code: "UNAUTHORIZED" });
+      return;
+    }
+
+    const token = generateToken({
+      sub: user.id,
+      email: user.email,
+      tid: user.tenant_id,
+      role: user.role,
+    });
+
+    res.json({
+      id: user.id,
+      email: user.email,
+      tenantId: user.tenant_id,
+      role: user.role,
+      token,
+    });
+  });
+
+  // Get profile
+  router.get(
+    "/me",
+    authMiddleware,
+    (req: AuthenticatedRequest, res: Response): void => {
+      const user = db
+        .prepare("SELECT id, email, tenant_id, role, created_at FROM users WHERE id = ?")
+        .get(req.user!.sub) as
+        | { id: string; email: string; tenant_id: string; role: string; created_at: string }
+        | undefined;
+
+      if (!user) {
+        res.status(404).json({ error: "User not found", code: "NOT_FOUND" });
+        return;
+      }
+
+      res.json({
+        id: user.id,
+        email: user.email,
+        tenantId: user.tenant_id,
+        role: user.role,
+        createdAt: user.created_at,
+      });
+    }
+  );
+
+  // Update user role (admin only)
+  router.put(
+    "/:userId/role",
+    authMiddleware,
+    requireRole("admin"),
+    (req: AuthenticatedRequest, res: Response): void => {
+      const { userId } = req.params;
+      const { role } = req.body;
+
+      const validRoles = ["admin", "editor", "viewer"];
+      if (!role || !validRoles.includes(role)) {
+        res.status(400).json({ error: "Valid role is required (admin, editor, viewer)", code: "BAD_REQUEST" });
+        return;
+      }
+
+      const targetUser = db
+        .prepare("SELECT id, tenant_id FROM users WHERE id = ?")
+        .get(userId) as { id: string; tenant_id: string } | undefined;
+
+      if (!targetUser) {
+        res.status(404).json({ error: "User not found", code: "NOT_FOUND" });
+        return;
+      }
+
+      if (targetUser.tenant_id !== req.user!.tid) {
+        res.status(403).json({ error: "Cannot modify users in other tenants", code: "FORBIDDEN" });
+        return;
+      }
+
+      db.prepare("UPDATE users SET role = ? WHERE id = ?").run(role, userId);
+
+      res.json({ id: userId, role });
+    }
+  );
+
+  return router;
+}
diff --git a/tests/api.test.ts b/tests/api.test.ts
new file mode 100644
index 0000000..ca1c96f
--- /dev/null
+++ b/tests/api.test.ts
@@ -0,0 +1,364 @@
+import { describe, it, expect, beforeAll } from "vitest";
+import request from "supertest";
+import { createApp } from "../src/app.js";
+
+const app = createApp(":memory:");
+
+describe("Analytics Dashboard API", () => {
+  let token: string;
+  let userId: string;
+  let token2: string;
+  const tenantId = "tenant-1";
+  const tenantId2 = "tenant-2";
+
+  describe("User Management", () => {
+    it("should register a new user", async () => {
+      const res = await request(app)
+        .post("/api/users/register")
+        .send({ email: "admin@test.com", password: "pass123", tenantId, role: "admin" });
+
+      expect(res.status).toBe(201);
+      expect(res.body.id).toBeDefined();
+      expect(res.body.email).toBe("admin@test.com");
+      expect(res.body.tenantId).toBe(tenantId);
+      expect(res.body.role).toBe("admin");
+      expect(res.body.token).toBeDefined();
+      token = res.body.token;
+      userId = res.body.id;
+    });
+
+    it("should reject duplicate email", async () => {
+      const res = await request(app)
+        .post("/api/users/register")
+        .send({ email: "admin@test.com", password: "pass123", tenantId });
+
+      expect(res.status).toBe(409);
+    });
+
+    it("should login", async () => {
+      const res = await request(app)
+        .post("/api/users/login")
+        .send({ email: "admin@test.com", password: "pass123" });
+
+      expect(res.status).toBe(200);
+      expect(res.body.token).toBeDefined();
+      expect(res.body.role).toBe("admin");
+    });
+
+    it("should reject bad login", async () => {
+      const res = await request(app)
+        .post("/api/users/login")
+        .send({ email: "admin@test.com", password: "wrong" });
+
+      expect(res.status).toBe(401);
+    });
+
+    it("should get profile", async () => {
+      const res = await request(app)
+        .get("/api/users/me")
+        .set("Authorization", `Bearer ${token}`);
+
+      expect(res.status).toBe(200);
+      expect(res.body.email).toBe("admin@test.com");
+      expect(res.body.tenantId).toBe(tenantId);
+    });
+
+    it("should reject unauthenticated profile request", async () => {
+      const res = await request(app).get("/api/users/me");
+      expect(res.status).toBe(401);
+    });
+
+    it("should register a second tenant user", async () => {
+      const res = await request(app)
+        .post("/api/users/register")
+        .send({ email: "user2@test.com", password: "pass123", tenantId: tenantId2, role: "admin" });
+
+      expect(res.status).toBe(201);
+      token2 = res.body.token;
+    });
+
+    it("should update user role", async () => {
+      // Register a viewer first
+      const viewer = await request(app)
+        .post("/api/users/register")
+        .send({ email: "viewer@test.com", password: "pass123", tenantId, role: "viewer" });
+
+      const res = await request(app)
+        .put(`/api/users/${viewer.body.id}/role`)
+        .set("Authorization", `Bearer ${token}`)
+        .send({ role: "editor" });
+
+      expect(res.status).toBe(200);
+      expect(res.body.role).toBe("editor");
+    });
+
+    it("should not allow cross-tenant role update", async () => {
+      const res = await request(app)
+        .put(`/api/users/${userId}/role`)
+        .set("Authorization", `Bearer ${token2}`)
+        .send({ role: "viewer" });
+
+      expect(res.status).toBe(403);
+    });
+  });
+
+  describe("Event Ingestion", () => {
+    it("should ingest a single event", async () => {
+      const res = await request(app)
+        .post("/api/events")
+        .set("Authorization", `Bearer ${token}`)
+        .send({
+          name: "page_view",
+          properties: { url: "/home", browser: "Chrome" },
+          timestamp: "2024-01-15T10:00:00Z",
+        });
+
+      expect(res.status).toBe(201);
+      expect(res.body.id).toBeDefined();
+      expect(res.body.name).toBe("page_view");
+    });
+
+    it("should reject unauthenticated event", async () => {
+      const res = await request(app)
+        .post("/api/events")
+        .send({ name: "page_view" });
+
+      expect(res.status).toBe(401);
+    });
+
+    it("should ingest batch events", async () => {
+      const events = [
+        { name: "page_view", properties: { url: "/about" }, timestamp: "2024-01-15T11:00:00Z" },
+        { name: "page_view", properties: { url: "/home" }, timestamp: "2024-01-16T10:00:00Z" },
+        { name: "click", properties: { button: "signup" }, timestamp: "2024-01-16T11:00:00Z" },
+        { name: "page_view", properties: { url: "/pricing" }, timestamp: "2024-01-17T10:00:00Z" },
+      ];
+
+      const res = await request(app)
+        .post("/api/events/batch")
+        .set("Authorization", `Bearer ${token}`)
+        .send({ events });
+
+      expect(res.status).toBe(201);
+      expect(res.body.inserted).toBe(4);
+    });
+
+    it("should list events", async () => {
+      const res = await request(app)
+        .get("/api/events")
+        .set("Authorization", `Bearer ${token}`);
+
+      expect(res.status).toBe(200);
+      expect(res.body.events.length).toBe(5);
+    });
+
+    it("should isolate tenant events", async () => {
+      // Ingest event for tenant 2
+      await request(app)
+        .post("/api/events")
+        .set("Authorization", `Bearer ${token2}`)
+        .send({ name: "page_view", properties: { url: "/other" } });
+
+      // Tenant 1 should still only see their events
+      const res = await request(app)
+        .get("/api/events")
+        .set("Authorization", `Bearer ${token}`);
+
+      expect(res.body.events.length).toBe(5);
+
+      // Tenant 2 should only see their event
+      const res2 = await request(app)
+        .get("/api/events")
+        .set("Authorization", `Bearer ${token2}`);
+
+      expect(res2.body.events.length).toBe(1);
+    });
+  });
+
+  describe("Query Engine", () => {
+    it("should count events", async () => {
+      const res = await request(app)
+        .post("/api/queries/count")
+        .set("Authorization", `Bearer ${token}`)
+        .send({ eventName: "page_view" });
+
+      expect(res.status).toBe(200);
+      expect(res.body.count).toBe(4);
+    });
+
+    it("should count with date filter", async () => {
+      const res = await request(app)
+        .post("/api/queries/count")
+        .set("Authorization", `Bearer ${token}`)
+        .send({
+          eventName: "page_view",
+          startDate: "2024-01-16T00:00:00Z",
+          endDate: "2024-01-16T23:59:59Z",
+        });
+
+      expect(res.status).toBe(200);
+      expect(res.body.count).toBe(1);
+    });
+
+    it("should isolate tenant counts", async () => {
+      const res = await request(app)
+        .post("/api/queries/count")
+        .set("Authorization", `Bearer ${token2}`)
+        .send({});
+
+      expect(res.body.count).toBe(1);
+    });
+
+    it("should return timeseries", async () => {
+      const res = await request(app)
+        .post("/api/queries/timeseries")
+        .set("Authorization", `Bearer ${token}`)
+        .send({
+          eventName: "page_view",
+          interval: "day",
+          startDate: "2024-01-15T00:00:00Z",
+          endDate: "2024-01-17T23:59:59Z",
+        });
+
+      expect(res.status).toBe(200);
+      expect(res.body.timeseries.length).toBeGreaterThanOrEqual(2);
+    });
+
+    it("should return breakdown", async () => {
+      const res = await request(app)
+        .post("/api/queries/breakdown")
+        .set("Authorization", `Bearer ${token}`)
+        .send({ eventName: "page_view", property: "url" });
+
+      expect(res.status).toBe(200);
+      expect(res.body.breakdown.length).toBeGreaterThanOrEqual(2);
+    });
+  });
+
+  describe("Dashboards", () => {
+    let dashboardId: string;
+
+    it("should create a dashboard", async () => {
+      const res = await request(app)
+        .post("/api/dashboards")
+        .set("Authorization", `Bearer ${token}`)
+        .send({ name: "My Dashboard", config: { theme: "dark" } });
+
+      expect(res.status).toBe(201);
+      expect(res.body.id).toBeDefined();
+      expect(res.body.name).toBe("My Dashboard");
+      dashboardId = res.body.id;
+    });
+
+    it("should list dashboards", async () => {
+      const res = await request(app)
+        .get("/api/dashboards")
+        .set("Authorization", `Bearer ${token}`);
+
+      expect(res.status).toBe(200);
+      expect(res.body.dashboards.length).toBe(1);
+    });
+
+    it("should get dashboard by id", async () => {
+      const res = await request(app)
+        .get(`/api/dashboards/${dashboardId}`)
+        .set("Authorization", `Bearer ${token}`);
+
+      expect(res.status).toBe(200);
+      expect(res.body.name).toBe("My Dashboard");
+      expect(res.body.widgets).toBeDefined();
+    });
+
+    it("should isolate tenant dashboards", async () => {
+      const res = await request(app)
+        .get(`/api/dashboards/${dashboardId}`)
+        .set("Authorization", `Bearer ${token2}`);
+
+      expect(res.status).toBe(404);
+    });
+
+    it("should update a dashboard", async () => {
+      const res = await request(app)
+        .put(`/api/dashboards/${dashboardId}`)
+        .set("Authorization", `Bearer ${token}`)
+        .send({ name: "Updated Dashboard" });
+
+      expect(res.status).toBe(200);
+      expect(res.body.name).toBe("Updated Dashboard");
+    });
+
+    it("should delete a dashboard", async () => {
+      const res = await request(app)
+        .delete(`/api/dashboards/${dashboardId}`)
+        .set("Authorization", `Bearer ${token}`);
+
+      expect(res.status).toBe(204);
+
+      const check = await request(app)
+        .get(`/api/dashboards/${dashboardId}`)
+        .set("Authorization", `Bearer ${token}`);
+
+      expect(check.status).toBe(404);
+    });
+  });
+
+  describe("Data Export", () => {
+    it("should export events as JSON", async () => {
+      const res = await request(app)
+        .get("/api/export/events/json")
+        .set("Authorization", `Bearer ${token}`);
+
+      expect(res.status).toBe(200);
+      expect(res.body.events).toBeDefined();
+      expect(res.body.events.length).toBe(5);
+    });
+
+    it("should export events as CSV", async () => {
+      const res = await request(app)
+        .get("/api/export/events/csv")
+        .set("Authorization", `Bearer ${token}`);
+
+      expect(res.status).toBe(200);
+      expect(res.headers["content-type"]).toContain("text/csv");
+      expect(res.text).toContain("id,tenant_id,name");
+    });
+
+    it("should isolate tenant exports", async () => {
+      const res = await request(app)
+        .get("/api/export/events/json")
+        .set("Authorization", `Bearer ${token2}`);
+
+      expect(res.body.events.length).toBe(1);
+    });
+
+    it("should export dashboard as JSON", async () => {
+      // Create a dashboard first
+      const dashboard = await request(app)
+        .post("/api/dashboards")
+        .set("Authorization", `Bearer ${token}`)
+        .send({ name: "Export Test" });
+
+      const res = await request(app)
+        .get(`/api/export/dashboards/${dashboard.body.id}/json`)
+        .set("Authorization", `Bearer ${token}`);
+
+      expect(res.status).toBe(200);
+      expect(res.body.dashboard).toBeDefined();
+      expect(res.body.dashboard.name).toBe("Export Test");
+    });
+
+    it("should export dashboard as CSV", async () => {
+      const dashboard = await request(app)
+        .post("/api/dashboards")
+        .set("Authorization", `Bearer ${token}`)
+        .send({ name: "CSV Test" });
+
+      const res = await request(app)
+        .get(`/api/export/dashboards/${dashboard.body.id}/csv`)
+        .set("Authorization", `Bearer ${token}`);
+
+      expect(res.status).toBe(200);
+      expect(res.headers["content-type"]).toContain("text/csv");
+    });
+  });
+});
