diff --git a/.runtime/agent.lock b/.runtime/agent.lock
new file mode 100644
index 0000000..2d57499
--- /dev/null
+++ b/.runtime/agent.lock
@@ -0,0 +1,6 @@
+{
+  "pid": 866,
+  "acquired_at": "2026-02-15T03:37:37.498341037Z",
+  "session_id": "bench/rust",
+  "hostname": "da5aff50dc86"
+}
\ No newline at end of file
diff --git a/.thunderdome-metrics.json b/.thunderdome-metrics.json
new file mode 100644
index 0000000..1e1db74
--- /dev/null
+++ b/.thunderdome-metrics.json
@@ -0,0 +1,17 @@
+{
+  "input_tokens": 17,
+  "output_tokens": 7473,
+  "cache_read_tokens": 538575,
+  "cache_creation_tokens": 30558,
+  "turns": 31,
+  "tools_used": [
+    "Task",
+    "Bash",
+    "Read",
+    "TodoWrite",
+    "Write",
+    "Edit"
+  ],
+  "duration_ms": 186486,
+  "total_cost_usd": 0.7460200000000001
+}
\ No newline at end of file
diff --git a/package-lock.json b/package-lock.json
index 1ad5780..9aa4811 100644
--- a/package-lock.json
+++ b/package-lock.json
@@ -1098,7 +1098,6 @@
       "integrity": "sha512-4Z+L8I2OqhZV8qA132M4wNL30ypZGYOQVBfMgxDH/K5UX0PNqTu1c6za9ST5r9+tavvHiTWmBnKzpCJ/GlVFtg==",
       "dev": true,
       "license": "BSD-2-Clause",
-      "peer": true,
       "dependencies": {
         "@typescript-eslint/scope-manager": "7.18.0",
         "@typescript-eslint/types": "7.18.0",
@@ -1391,7 +1390,6 @@
       "integrity": "sha512-NZyJarBfL7nWwIq+FDL6Zp/yHEhePMNnnJ0y3qfieCrmNvYct8uvtiV41UvlSe6apAfk0fY1FbWx+NwfmpvtTg==",
       "dev": true,
       "license": "MIT",
-      "peer": true,
       "bin": {
         "acorn": "bin/acorn"
       },
@@ -1917,7 +1915,6 @@
       "deprecated": "This version is no longer supported. Please see https://eslint.org/version-support for other options.",
       "dev": true,
       "license": "MIT",
-      "peer": true,
       "dependencies": {
         "@eslint-community/eslint-utils": "^4.2.0",
         "@eslint-community/regexpp": "^4.6.1",
@@ -3765,7 +3762,6 @@
       "integrity": "sha512-jl1vZzPDinLr9eUt3J/t7V6FgNEw9QjvBPdysz9KfQDD41fQrC2Y4vKQdiaUpFT4bXlb1RHhLpp8wtm6M5TgSw==",
       "dev": true,
       "license": "Apache-2.0",
-      "peer": true,
       "bin": {
         "tsc": "bin/tsc",
         "tsserver": "bin/tsserver"
@@ -3814,7 +3810,6 @@
       "integrity": "sha512-o5a9xKjbtuhY6Bi5S3+HvbRERmouabWbyUcpXXUA1u+GNUKoROi9byOJ8M0nHbHYHkYICiMlqxkg1KkYmm25Sw==",
       "dev": true,
       "license": "MIT",
-      "peer": true,
       "dependencies": {
         "esbuild": "^0.21.3",
         "postcss": "^8.4.43",
diff --git a/src/plugins/asset-pipeline.ts b/src/plugins/asset-pipeline.ts
new file mode 100644
index 0000000..2e8e755
--- /dev/null
+++ b/src/plugins/asset-pipeline.ts
@@ -0,0 +1,32 @@
+import { Plugin, ContentFile, BuildContext } from '../core/types.js';
+
+export function createAssetPipelinePlugin(): Plugin {
+  return {
+    name: 'asset-pipeline',
+    version: '1.0.0',
+    dependencies: [],
+    hooks: {
+      transformContent(file: ContentFile, ctx: BuildContext): ContentFile {
+        const assets: string[] = [];
+
+        // Match src="./..." and href="./..."
+        const content = file.content.replace(
+          /(src|href)="\.\/([^"]+)"/g,
+          (_match, attr: string, path: string) => {
+            assets.push(path);
+            return `${attr}="/assets/${path}"`;
+          }
+        );
+
+        // Update or create asset manifest
+        if (assets.length > 0) {
+          const existing = ctx.data.get('asset-manifest') as { assets: string[] } | undefined;
+          const allAssets = existing ? [...existing.assets, ...assets] : assets;
+          ctx.data.set('asset-manifest', { assets: allAssets });
+        }
+
+        return { ...file, content };
+      },
+    },
+  };
+}
diff --git a/src/plugins/dev-server.ts b/src/plugins/dev-server.ts
new file mode 100644
index 0000000..b883cc0
--- /dev/null
+++ b/src/plugins/dev-server.ts
@@ -0,0 +1,54 @@
+import { Plugin, BuildContext } from '../core/types.js';
+
+interface DevServerRoute {
+  path: string;
+  handler: string;
+}
+
+interface DevServerConfig {
+  port: number;
+  routes: DevServerRoute[];
+  assetPaths: string[];
+  searchIndexPath: string;
+}
+
+export function createDevServerPlugin(): Plugin {
+  return {
+    name: 'dev-server',
+    version: '1.0.0',
+    dependencies: ['asset-pipeline', 'search-index'],
+    hooks: {
+      afterBuild(ctx: BuildContext): void {
+        const routes: DevServerRoute[] = [];
+        const assetManifest = ctx.data.get('asset-manifest') as { assets: string[] } | undefined;
+        const assetPaths = assetManifest ? assetManifest.assets : [];
+
+        // Add asset routes
+        for (const asset of assetPaths) {
+          routes.push({ path: `/assets/${asset}`, handler: 'asset' });
+        }
+
+        // Add content routes for HTML files
+        for (const [path] of ctx.output) {
+          if (path.endsWith('.html')) {
+            routes.push({ path: `/${path}`, handler: 'static' });
+          }
+        }
+
+        // Determine search index path
+        const searchIndexPath = ctx.output.has('search-index.json')
+          ? '/search-index.json'
+          : '';
+
+        const config: DevServerConfig = {
+          port: 3000,
+          routes,
+          assetPaths,
+          searchIndexPath,
+        };
+
+        ctx.data.set('dev-server-config', config);
+      },
+    },
+  };
+}
diff --git a/src/plugins/markdown-ext.ts b/src/plugins/markdown-ext.ts
new file mode 100644
index 0000000..e2b355d
--- /dev/null
+++ b/src/plugins/markdown-ext.ts
@@ -0,0 +1,116 @@
+import { Plugin, ContentFile, BuildContext } from '../core/types.js';
+
+function processFootnotes(content: string): string {
+  // Collect footnote definitions: [^N]: text
+  const footnoteDefRegex = /^\[\^(\d+)\]:\s*(.+)$/gm;
+  const footnotes: Map<string, string> = new Map();
+  let match: RegExpExecArray | null;
+
+  while ((match = footnoteDefRegex.exec(content)) !== null) {
+    footnotes.set(match[1], match[2]);
+  }
+
+  if (footnotes.size === 0) return content;
+
+  // Remove footnote definitions from content
+  let result = content.replace(/^\[\^(\d+)\]:\s*(.+)$/gm, '');
+
+  // Replace footnote references [^N] with superscript links
+  result = result.replace(/\[\^(\d+)\]/g, (_m, id: string) => {
+    return `<sup><a href="#fn-${id}">${id}</a></sup>`;
+  });
+
+  // Build footnote section
+  const footnoteItems = Array.from(footnotes.entries())
+    .map(([id, text]) => `<li id="fn-${id}">${text}</li>`)
+    .join('\n');
+
+  result += `\n<section class="footnotes">\n<ol>\n${footnoteItems}\n</ol>\n</section>`;
+
+  return result;
+}
+
+function processAdmonitions(content: string): string {
+  return content.replace(/^:::(note|warning|tip)\n([\s\S]*?)^:::/gm, (_m, type: string, body: string) => {
+    return `<div class="admonition admonition-${type}">\n${body.trim()}\n</div>`;
+  });
+}
+
+function markdownToHtml(content: string): string {
+  // Process headings
+  let html = content.replace(/^######\s+(.+)$/gm, '<h6>$1</h6>');
+  html = html.replace(/^#####\s+(.+)$/gm, '<h5>$1</h5>');
+  html = html.replace(/^####\s+(.+)$/gm, '<h4>$1</h4>');
+  html = html.replace(/^###\s+(.+)$/gm, '<h3>$1</h3>');
+  html = html.replace(/^##\s+(.+)$/gm, '<h2>$1</h2>');
+  html = html.replace(/^#\s+(.+)$/gm, '<h1>$1</h1>');
+
+  // Process bold
+  html = html.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
+
+  // Process italic
+  html = html.replace(/\*(.+?)\*/g, '<em>$1</em>');
+
+  // Process paragraphs - wrap non-tagged lines
+  const lines = html.split('\n');
+  const result: string[] = [];
+  for (const line of lines) {
+    const trimmed = line.trim();
+    if (trimmed === '') {
+      result.push('');
+    } else if (
+      trimmed.startsWith('<h') ||
+      trimmed.startsWith('<div') ||
+      trimmed.startsWith('</div') ||
+      trimmed.startsWith('<section') ||
+      trimmed.startsWith('</section') ||
+      trimmed.startsWith('<ol') ||
+      trimmed.startsWith('</ol') ||
+      trimmed.startsWith('<li') ||
+      trimmed.startsWith('<p') ||
+      trimmed.startsWith('<pre') ||
+      trimmed.startsWith('<blockquote') ||
+      trimmed.startsWith('<ul') ||
+      trimmed.startsWith('<table')
+    ) {
+      result.push(line);
+    } else {
+      result.push(`<p>${trimmed}</p>`);
+    }
+  }
+
+  return result.filter(l => l.trim() !== '').join('\n');
+}
+
+export function createMarkdownExtPlugin(): Plugin {
+  return {
+    name: 'markdown-ext',
+    version: '1.0.0',
+    dependencies: [],
+    hooks: {
+      transformContent(file: ContentFile, _ctx: BuildContext): ContentFile {
+        let content = file.content;
+
+        if (!content) {
+          return { ...file, content: '' };
+        }
+
+        // If content is already HTML (starts with <), preserve it but still process admonitions/footnotes
+        const isAlreadyHtml = content.trim().startsWith('<');
+
+        // Process admonitions first (before markdown conversion)
+        content = processAdmonitions(content);
+
+        // Process footnotes
+        content = processFootnotes(content);
+
+        // Convert markdown to HTML if not already HTML
+        if (!isAlreadyHtml) {
+          content = markdownToHtml(content);
+        }
+
+        return { ...file, content };
+      },
+    },
+  };
+}
diff --git a/src/plugins/rss-feed.ts b/src/plugins/rss-feed.ts
new file mode 100644
index 0000000..3430d85
--- /dev/null
+++ b/src/plugins/rss-feed.ts
@@ -0,0 +1,54 @@
+import { Plugin, BuildContext } from '../core/types.js';
+
+export function createRssFeedPlugin(): Plugin {
+  return {
+    name: 'rss-feed',
+    version: '1.0.0',
+    dependencies: ['markdown-ext', 'taxonomy'],
+    hooks: {
+      afterBuild(ctx: BuildContext): void {
+        const { config, files } = ctx;
+
+        // Sort files by date, newest first; files without dates go last
+        const sorted = [...files].sort((a, b) => {
+          if (!a.date && !b.date) return 0;
+          if (!a.date) return 1;
+          if (!b.date) return -1;
+          return new Date(b.date).getTime() - new Date(a.date).getTime();
+        });
+
+        const items = sorted.map(file => {
+          let itemXml = `    <item>\n`;
+          itemXml += `      <title>${file.title}</title>\n`;
+          itemXml += `      <link>${config.baseUrl}/${file.slug}.html</link>\n`;
+          itemXml += `      <description><![CDATA[${file.content}]]></description>\n`;
+
+          if (file.date) {
+            itemXml += `      <pubDate>${file.date}</pubDate>\n`;
+          }
+
+          if (file.tags) {
+            for (const tag of file.tags) {
+              itemXml += `      <category>${tag}</category>\n`;
+            }
+          }
+
+          itemXml += `    </item>`;
+          return itemXml;
+        }).join('\n');
+
+        const feed = `<?xml version="1.0" encoding="UTF-8"?>
+<rss version="2.0">
+  <channel>
+    <title>${config.title}</title>
+    <link>${config.baseUrl}</link>
+    <description>${config.title} RSS Feed</description>
+${items}
+  </channel>
+</rss>`;
+
+        ctx.output.set('feed.xml', feed);
+      },
+    },
+  };
+}
diff --git a/src/plugins/search-index.ts b/src/plugins/search-index.ts
new file mode 100644
index 0000000..ae852d5
--- /dev/null
+++ b/src/plugins/search-index.ts
@@ -0,0 +1,32 @@
+import { Plugin, BuildContext } from '../core/types.js';
+
+function stripHtml(html: string): string {
+  return html.replace(/<[^>]*>/g, '').trim();
+}
+
+export function createSearchIndexPlugin(): Plugin {
+  return {
+    name: 'search-index',
+    version: '1.0.0',
+    dependencies: ['markdown-ext', 'syntax-highlight'],
+    hooks: {
+      afterBuild(ctx: BuildContext): void {
+        const index = ctx.files.map(file => {
+          const entry: Record<string, unknown> = {
+            title: file.title,
+            slug: file.slug,
+            content: stripHtml(file.content),
+          };
+
+          if (file.tags && file.tags.length > 0) {
+            entry.tags = file.tags;
+          }
+
+          return entry;
+        });
+
+        ctx.output.set('search-index.json', JSON.stringify(index, null, 2));
+      },
+    },
+  };
+}
diff --git a/src/plugins/sitemap.ts b/src/plugins/sitemap.ts
new file mode 100644
index 0000000..92a1be9
--- /dev/null
+++ b/src/plugins/sitemap.ts
@@ -0,0 +1,31 @@
+import { Plugin, BuildContext } from '../core/types.js';
+
+export function createSitemapPlugin(): Plugin {
+  return {
+    name: 'sitemap',
+    version: '1.0.0',
+    dependencies: ['taxonomy', 'rss-feed'],
+    hooks: {
+      afterBuild(ctx: BuildContext): void {
+        const { config, output } = ctx;
+        const urls: string[] = [];
+
+        for (const [path] of output) {
+          if (path === 'sitemap.xml') continue;
+          urls.push(`${config.baseUrl}/${path}`);
+        }
+
+        const urlEntries = urls
+          .map(url => `  <url>\n    <loc>${url}</loc>\n  </url>`)
+          .join('\n');
+
+        const sitemap = `<?xml version="1.0" encoding="UTF-8"?>
+<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
+${urlEntries}
+</urlset>`;
+
+        ctx.output.set('sitemap.xml', sitemap);
+      },
+    },
+  };
+}
diff --git a/src/plugins/syntax-highlight.ts b/src/plugins/syntax-highlight.ts
new file mode 100644
index 0000000..29e0bea
--- /dev/null
+++ b/src/plugins/syntax-highlight.ts
@@ -0,0 +1,22 @@
+import { Plugin, ContentFile, BuildContext } from '../core/types.js';
+
+export function createSyntaxHighlightPlugin(): Plugin {
+  return {
+    name: 'syntax-highlight',
+    version: '1.0.0',
+    dependencies: [],
+    hooks: {
+      transformContent(file: ContentFile, _ctx: BuildContext): ContentFile {
+        // Match <pre><code class="language-xxx">...</code></pre>
+        const content = file.content.replace(
+          /<pre><code class="language-(\w+)">([\s\S]*?)<\/code><\/pre>/g,
+          (_match, lang: string, code: string) => {
+            return `<pre data-language="${lang}"><code class="language-${lang} highlighted">${code}</code></pre>`;
+          }
+        );
+
+        return { ...file, content };
+      },
+    },
+  };
+}
diff --git a/src/plugins/taxonomy.ts b/src/plugins/taxonomy.ts
new file mode 100644
index 0000000..1b5b6b3
--- /dev/null
+++ b/src/plugins/taxonomy.ts
@@ -0,0 +1,50 @@
+import { Plugin, ContentFile, BuildContext } from '../core/types.js';
+
+export function createTaxonomyPlugin(): Plugin {
+  return {
+    name: 'taxonomy',
+    version: '1.0.0',
+    dependencies: [],
+    hooks: {
+      beforeBuild(ctx: BuildContext): void {
+        const tagMap = new Map<string, ContentFile[]>();
+
+        for (const file of ctx.files) {
+          if (!file.tags || file.tags.length === 0) continue;
+          for (const tag of file.tags) {
+            const normalized = tag.toLowerCase();
+            const existing = tagMap.get(normalized) || [];
+            existing.push(file);
+            tagMap.set(normalized, existing);
+          }
+        }
+
+        ctx.data.set('taxonomy-tags', tagMap);
+      },
+
+      afterBuild(ctx: BuildContext): void {
+        const tagMap = ctx.data.get('taxonomy-tags') as Map<string, ContentFile[]> | undefined;
+        if (!tagMap) return;
+
+        for (const [tag, files] of tagMap) {
+          const fileLinks = files
+            .map(f => `<li><a href="/${f.slug}.html">${f.title}</a></li>`)
+            .join('\n');
+
+          const html = `<!DOCTYPE html>
+<html>
+<head><title>Tag: ${tag}</title></head>
+<body>
+<h1>Tag: ${tag}</h1>
+<ul>
+${fileLinks}
+</ul>
+</body>
+</html>`;
+
+          ctx.output.set(`tags/${tag}.html`, html);
+        }
+      },
+    },
+  };
+}
