diff --git a/.thunderdome-metrics.json b/.thunderdome-metrics.json
new file mode 100644
index 0000000..1b84554
--- /dev/null
+++ b/.thunderdome-metrics.json
@@ -0,0 +1,154 @@
+{
+  "input_tokens": 269,
+  "output_tokens": 48231,
+  "cache_read_tokens": 2953429,
+  "cache_creation_tokens": 142839,
+  "turns": 171,
+  "tools_used": [
+    "Read",
+    "Bash",
+    "TodoWrite",
+    "Write",
+    "Edit",
+    "Glob",
+    "Grep"
+  ],
+  "duration_ms": 425000,
+  "total_cost_usd": 3.672,
+  "gastown_meta": {
+    "strategy": "parallel",
+    "polecat_count": 4,
+    "roles": {
+      "mayor": {
+        "input_tokens": 3,
+        "output_tokens": 2053,
+        "cache_read_tokens": 7687,
+        "cache_creation_tokens": 1316,
+        "turns": 1,
+        "tools_used": [],
+        "duration_ms": 36798,
+        "total_cost_usd": 0.0634085
+      },
+      "polecat-0": {
+        "input_tokens": 71,
+        "output_tokens": 9739,
+        "cache_read_tokens": 600050,
+        "cache_creation_tokens": 18438,
+        "turns": 29,
+        "tools_used": [
+          "Read",
+          "Bash",
+          "TodoWrite",
+          "Write",
+          "Edit"
+        ],
+        "duration_ms": 169834,
+        "total_cost_usd": 0.6809245000000004
+      },
+      "polecat-1": {
+        "input_tokens": 67,
+        "output_tokens": 6904,
+        "cache_read_tokens": 459543,
+        "cache_creation_tokens": 14808,
+        "turns": 22,
+        "tools_used": [
+          "Read",
+          "TodoWrite",
+          "Bash",
+          "Write"
+        ],
+        "duration_ms": 142949,
+        "total_cost_usd": 0.5151225
+      },
+      "polecat-2": {
+        "input_tokens": 72,
+        "output_tokens": 9206,
+        "cache_read_tokens": 657794,
+        "cache_creation_tokens": 20960,
+        "turns": 30,
+        "tools_used": [
+          "Read",
+          "Glob",
+          "TodoWrite",
+          "Write",
+          "Edit",
+          "Bash"
+        ],
+        "duration_ms": 168010,
+        "total_cost_usd": 0.70401
+      },
+      "polecat-3": {
+        "input_tokens": 29,
+        "output_tokens": 11428,
+        "cache_read_tokens": 761746,
+        "cache_creation_tokens": 22461,
+        "turns": 37,
+        "tools_used": [
+          "Read",
+          "Bash",
+          "TodoWrite",
+          "Write"
+        ],
+        "duration_ms": 218162,
+        "total_cost_usd": 0.83275525
+      },
+      "refinery-fixup": {
+        "input_tokens": 8,
+        "output_tokens": 1380,
+        "cache_read_tokens": 160782,
+        "cache_creation_tokens": 28907,
+        "turns": 25,
+        "tools_used": [
+          "Read",
+          "Glob",
+          "Bash"
+        ],
+        "duration_ms": 33719,
+        "total_cost_usd": 0.30329675
+      },
+      "refinery-merge-1": {
+        "input_tokens": 6,
+        "output_tokens": 388,
+        "cache_read_tokens": 71078,
+        "cache_creation_tokens": 2987,
+        "turns": 4,
+        "tools_used": [
+          "Read",
+          "Write",
+          "Bash"
+        ],
+        "duration_ms": 14851,
+        "total_cost_usd": 0.06599674999999999
+      },
+      "refinery-merge-2": {
+        "input_tokens": 6,
+        "output_tokens": 455,
+        "cache_read_tokens": 71794,
+        "cache_creation_tokens": 3198,
+        "turns": 4,
+        "tools_used": [
+          "Read",
+          "Write",
+          "Bash"
+        ],
+        "duration_ms": 15365,
+        "total_cost_usd": 0.06932250000000001
+      },
+      "refinery-merge-3": {
+        "input_tokens": 7,
+        "output_tokens": 6678,
+        "cache_read_tokens": 162955,
+        "cache_creation_tokens": 29764,
+        "turns": 19,
+        "tools_used": [
+          "Read",
+          "Write",
+          "Bash",
+          "Grep"
+        ],
+        "duration_ms": 82734,
+        "total_cost_usd": 0.43673049999999997
+      }
+    }
+  }
+}
\ No newline at end of file
diff --git a/package-lock.json b/package-lock.json
index 783de11..1c1962f 100644
--- a/package-lock.json
+++ b/package-lock.json
@@ -18,11 +18,83 @@
         "@types/uuid": "^10.0.0",
         "@typescript-eslint/eslint-plugin": "^7.0.0",
         "@typescript-eslint/parser": "^7.0.0",
+        "@vitest/coverage-v8": "^2.0.0",
         "eslint": "^8.56.0",
         "typescript": "^5.4.0",
         "vitest": "^2.0.0"
       }
     },
+    "node_modules/@ampproject/remapping": {
+      "version": "2.3.0",
+      "resolved": "https://registry.npmjs.org/@ampproject/remapping/-/remapping-2.3.0.tgz",
+      "integrity": "sha512-30iZtAPgz+LTIYoeivqYo853f02jBYSd5uGnGpkFV0M3xOt9aN73erkgYAmZU43x4VfqcnLxW9Kpg3R5LC4YYw==",
+      "dev": true,
+      "license": "Apache-2.0",
+      "dependencies": {
+        "@jridgewell/gen-mapping": "^0.3.5",
+        "@jridgewell/trace-mapping": "^0.3.24"
+      },
+      "engines": {
+        "node": ">=6.0.0"
+      }
+    },
+    "node_modules/@babel/helper-string-parser": {
+      "version": "7.27.1",
+      "resolved": "https://registry.npmjs.org/@babel/helper-string-parser/-/helper-string-parser-7.27.1.tgz",
+      "integrity": "sha512-qMlSxKbpRlAridDExk92nSobyDdpPijUq2DW6oDnUqd0iOGxmQjyqhMIihI9+zv4LPyZdRje2cavWPbCbWm3eA==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=6.9.0"
+      }
+    },
+    "node_modules/@babel/helper-validator-identifier": {
+      "version": "7.28.5",
+      "resolved": "https://registry.npmjs.org/@babel/helper-validator-identifier/-/helper-validator-identifier-7.28.5.tgz",
+      "integrity": "sha512-qSs4ifwzKJSV39ucNjsvc6WVHs6b7S03sOh2OcHF9UHfVPqWWALUsNUVzhSBiItjRZoLHx7nIarVjqKVusUZ1Q==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=6.9.0"
+      }
+    },
+    "node_modules/@babel/parser": {
+      "version": "7.29.0",
+      "resolved": "https://registry.npmjs.org/@babel/parser/-/parser-7.29.0.tgz",
+      "integrity": "sha512-IyDgFV5GeDUVX4YdF/3CPULtVGSXXMLh1xVIgdCgxApktqnQV0r7/8Nqthg+8YLGaAtdyIlo2qIdZrbCv4+7ww==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@babel/types": "^7.29.0"
+      },
+      "bin": {
+        "parser": "bin/babel-parser.js"
+      },
+      "engines": {
+        "node": ">=6.0.0"
+      }
+    },
+    "node_modules/@babel/types": {
+      "version": "7.29.0",
+      "resolved": "https://registry.npmjs.org/@babel/types/-/types-7.29.0.tgz",
+      "integrity": "sha512-LwdZHpScM4Qz8Xw2iKSzS+cfglZzJGvofQICy7W7v4caru4EaAmyUuO6BGrbyQ2mYV11W0U8j5mBhd14dd3B0A==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@babel/helper-string-parser": "^7.27.1",
+        "@babel/helper-validator-identifier": "^7.28.5"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      }
+    },
+    "node_modules/@bcoe/v8-coverage": {
+      "version": "0.2.3",
+      "resolved": "https://registry.npmjs.org/@bcoe/v8-coverage/-/v8-coverage-0.2.3.tgz",
+      "integrity": "sha512-0hYQ8SB4Db5zvZB4axdMHGwEaQjkZzFjQiN9LVYvIFB2nSUHW9tYpxWriPrWDASIxiaXax83REcLxuSdnGPZtw==",
+      "dev": true,
+      "license": "MIT"
+    },
     "node_modules/@esbuild/aix-ppc64": {
       "version": "0.21.5",
       "resolved": "https://registry.npmjs.org/@esbuild/aix-ppc64/-/aix-ppc64-0.21.5.tgz",
@@ -563,6 +635,84 @@
       "dev": true,
       "license": "BSD-3-Clause"
     },
+    "node_modules/@isaacs/cliui": {
+      "version": "8.0.2",
+      "resolved": "https://registry.npmjs.org/@isaacs/cliui/-/cliui-8.0.2.tgz",
+      "integrity": "sha512-O8jcjabXaleOG9DQ0+ARXWZBTfnP4WNAqzuiJK7ll44AmxGKv/J2M4TPjxjY3znBCfvBXFzucm1twdyFybFqEA==",
+      "dev": true,
+      "license": "ISC",
+      "dependencies": {
+        "string-width": "^5.1.2",
+        "string-width-cjs": "npm:string-width@^4.2.0",
+        "strip-ansi": "^7.0.1",
+        "strip-ansi-cjs": "npm:strip-ansi@^6.0.1",
+        "wrap-ansi": "^8.1.0",
+        "wrap-ansi-cjs": "npm:wrap-ansi@^7.0.0"
+      },
+      "engines": {
+        "node": ">=12"
+      }
+    },
+    "node_modules/@isaacs/cliui/node_modules/ansi-regex": {
+      "version": "6.2.2",
+      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-6.2.2.tgz",
+      "integrity": "sha512-Bq3SmSpyFHaWjPk8If9yc6svM8c56dB5BAtW4Qbw5jHTwwXXcTLoRMkpDJp6VL0XzlWaCHTXrkFURMYmD0sLqg==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/ansi-regex?sponsor=1"
+      }
+    },
+    "node_modules/@isaacs/cliui/node_modules/strip-ansi": {
+      "version": "7.1.2",
+      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-7.1.2.tgz",
+      "integrity": "sha512-gmBGslpoQJtgnMAvOVqGZpEz9dyoKTCzy2nfz/n8aIFhN/jCE/rCmcxabB6jOOHV+0WNnylOxaxBQPSvcWklhA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "ansi-regex": "^6.0.1"
+      },
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/strip-ansi?sponsor=1"
+      }
+    },
+    "node_modules/@istanbuljs/schema": {
+      "version": "0.1.3",
+      "resolved": "https://registry.npmjs.org/@istanbuljs/schema/-/schema-0.1.3.tgz",
+      "integrity": "sha512-ZXRY4jNvVgSVQ8DL3LTcakaAtXwTVUxE81hslsyD2AtoXW/wVob10HkOJ1X/pAlcI7D+2YoZKg5do8G/w6RYgA==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/@jridgewell/gen-mapping": {
+      "version": "0.3.13",
+      "resolved": "https://registry.npmjs.org/@jridgewell/gen-mapping/-/gen-mapping-0.3.13.tgz",
+      "integrity": "sha512-2kkt/7niJ6MgEPxF0bYdQ6etZaA+fQvDcLKckhy1yIQOzaoKjBBjSj63/aLVjYE3qhRt5dvM+uUyfCg6UKCBbA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@jridgewell/sourcemap-codec": "^1.5.0",
+        "@jridgewell/trace-mapping": "^0.3.24"
+      }
+    },
+    "node_modules/@jridgewell/resolve-uri": {
+      "version": "3.1.2",
+      "resolved": "https://registry.npmjs.org/@jridgewell/resolve-uri/-/resolve-uri-3.1.2.tgz",
+      "integrity": "sha512-bRISgCIjP20/tbWSPWMEi54QVPRZExkuD9lJL+UIxUKtwVJA8wW1Trb1jMs1RFXo1CBTNZ/5hpC9QvmKWdopKw==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=6.0.0"
+      }
+    },
     "node_modules/@jridgewell/sourcemap-codec": {
       "version": "1.5.5",
       "resolved": "https://registry.npmjs.org/@jridgewell/sourcemap-codec/-/sourcemap-codec-1.5.5.tgz",
@@ -570,6 +720,17 @@
       "dev": true,
       "license": "MIT"
     },
+    "node_modules/@jridgewell/trace-mapping": {
+      "version": "0.3.31",
+      "resolved": "https://registry.npmjs.org/@jridgewell/trace-mapping/-/trace-mapping-0.3.31.tgz",
+      "integrity": "sha512-zzNR+SdQSDJzc8joaeP8QQoCQr8NuYx2dIIytl1QeBEZHJ9uW6hebsrYgbz8hJwUQao3TWCMtmfV8Nu1twOLAw==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@jridgewell/resolve-uri": "^3.1.0",
+        "@jridgewell/sourcemap-codec": "^1.4.14"
+      }
+    },
     "node_modules/@nodelib/fs.scandir": {
       "version": "2.1.5",
       "resolved": "https://registry.npmjs.org/@nodelib/fs.scandir/-/fs.scandir-2.1.5.tgz",
@@ -608,6 +769,17 @@
         "node": ">= 8"
       }
     },
+    "node_modules/@pkgjs/parseargs": {
+      "version": "0.11.0",
+      "resolved": "https://registry.npmjs.org/@pkgjs/parseargs/-/parseargs-0.11.0.tgz",
+      "integrity": "sha512-+1VkjdD0QBLPodGrJUeqarH8VAIvQODIbwh9XpP5Syisf7YoQgsJKPNFoqqLQlu+VQ/tVSshMR6loPMn8U+dPg==",
+      "dev": true,
+      "license": "MIT",
+      "optional": true,
+      "engines": {
+        "node": ">=14"
+      }
+    },
     "node_modules/@rollup/rollup-android-arm-eabi": {
       "version": "4.57.1",
       "resolved": "https://registry.npmjs.org/@rollup/rollup-android-arm-eabi/-/rollup-android-arm-eabi-4.57.1.tgz",
@@ -1042,7 +1214,6 @@
       "integrity": "sha512-m0jEgYlYz+mDJZ2+F4v8D1AyQb+QzsNqRuI7xg1VQX/KlKS0qT9r1Mo16yo5F/MtifXFgaofIFsdFMox2SxIbQ==",
       "dev": true,
       "license": "MIT",
-      "peer": true,
       "dependencies": {
         "undici-types": "~7.16.0"
       }
@@ -1141,7 +1312,6 @@
       "integrity": "sha512-4Z+L8I2OqhZV8qA132M4wNL30ypZGYOQVBfMgxDH/K5UX0PNqTu1c6za9ST5r9+tavvHiTWmBnKzpCJ/GlVFtg==",
       "dev": true,
       "license": "BSD-2-Clause",
-      "peer": true,
       "dependencies": {
         "@typescript-eslint/scope-manager": "7.18.0",
         "@typescript-eslint/types": "7.18.0",
@@ -1302,6 +1472,39 @@
       "dev": true,
       "license": "ISC"
     },
+    "node_modules/@vitest/coverage-v8": {
+      "version": "2.1.9",
+      "resolved": "https://registry.npmjs.org/@vitest/coverage-v8/-/coverage-v8-2.1.9.tgz",
+      "integrity": "sha512-Z2cOr0ksM00MpEfyVE8KXIYPEcBFxdbLSs56L8PO0QQMxt/6bDj45uQfxoc96v05KW3clk7vvgP0qfDit9DmfQ==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@ampproject/remapping": "^2.3.0",
+        "@bcoe/v8-coverage": "^0.2.3",
+        "debug": "^4.3.7",
+        "istanbul-lib-coverage": "^3.2.2",
+        "istanbul-lib-report": "^3.0.1",
+        "istanbul-lib-source-maps": "^5.0.6",
+        "istanbul-reports": "^3.1.7",
+        "magic-string": "^0.30.12",
+        "magicast": "^0.3.5",
+        "std-env": "^3.8.0",
+        "test-exclude": "^7.0.1",
+        "tinyrainbow": "^1.2.0"
+      },
+      "funding": {
+        "url": "https://opencollective.com/vitest"
+      },
+      "peerDependencies": {
+        "@vitest/browser": "2.1.9",
+        "vitest": "2.1.9"
+      },
+      "peerDependenciesMeta": {
+        "@vitest/browser": {
+          "optional": true
+        }
+      }
+    },
     "node_modules/@vitest/expect": {
       "version": "2.1.9",
       "resolved": "https://registry.npmjs.org/@vitest/expect/-/expect-2.1.9.tgz",
@@ -1434,7 +1637,6 @@
       "integrity": "sha512-NZyJarBfL7nWwIq+FDL6Zp/yHEhePMNnnJ0y3qfieCrmNvYct8uvtiV41UvlSe6apAfk0fY1FbWx+NwfmpvtTg==",
       "dev": true,
       "license": "MIT",
-      "peer": true,
       "bin": {
         "acorn": "bin/acorn"
       },
@@ -1985,12 +2187,26 @@
         "node": ">= 0.4"
       }
     },
+    "node_modules/eastasianwidth": {
+      "version": "0.2.0",
+      "resolved": "https://registry.npmjs.org/eastasianwidth/-/eastasianwidth-0.2.0.tgz",
+      "integrity": "sha512-I88TYZWc9XiYHRQ4/3c5rjjfgkjhLyW2luGIheGERbNQ6OY7yTybanSpDXZa8y7VUP9YmDcYa+eyq4ca7iLqWA==",
+      "dev": true,
+      "license": "MIT"
+    },
     "node_modules/ee-first": {
       "version": "1.1.1",
       "resolved": "https://registry.npmjs.org/ee-first/-/ee-first-1.1.1.tgz",
       "integrity": "sha512-WMwm9LhRUo+WUaRN+vRuETqG89IgZphVSNkdFgeb6sS/E4OrDIN7t48CAewSHXc6C8lefD8KKfr5vY61brQlow==",
       "license": "MIT"
     },
+    "node_modules/emoji-regex": {
+      "version": "9.2.2",
+      "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-9.2.2.tgz",
+      "integrity": "sha512-L18DaJsXSUk2+42pv8mLs5jJT2hqFkFE4j21wOmgbUqsZ2hL72NsUU785g9RXgo3s0ZNgVl42TiHp3ZtOv/Vyg==",
+      "dev": true,
+      "license": "MIT"
+    },
     "node_modules/encodeurl": {
       "version": "2.0.0",
       "resolved": "https://registry.npmjs.org/encodeurl/-/encodeurl-2.0.0.tgz",
@@ -2111,7 +2327,6 @@
       "deprecated": "This version is no longer supported. Please see https://eslint.org/version-support for other options.",
       "dev": true,
       "license": "MIT",
-      "peer": true,
       "dependencies": {
         "@eslint-community/eslint-utils": "^4.2.0",
         "@eslint-community/regexpp": "^4.6.1",
@@ -2544,6 +2759,23 @@
       "dev": true,
       "license": "ISC"
     },
+    "node_modules/foreground-child": {
+      "version": "3.3.1",
+      "resolved": "https://registry.npmjs.org/foreground-child/-/foreground-child-3.3.1.tgz",
+      "integrity": "sha512-gIXjKqtFuWEgzFRJA9WCQeSJLZDjgJUOMCMzxtvFq/37KojM1BFGufqsCy0r4qSQmYLsZYMeyRqzIWOMup03sw==",
+      "dev": true,
+      "license": "ISC",
+      "dependencies": {
+        "cross-spawn": "^7.0.6",
+        "signal-exit": "^4.0.1"
+      },
+      "engines": {
+        "node": ">=14"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/isaacs"
+      }
+    },
     "node_modules/forwarded": {
       "version": "0.2.0",
       "resolved": "https://registry.npmjs.org/forwarded/-/forwarded-0.2.0.tgz",
@@ -2791,6 +3023,13 @@
         "node": ">= 0.4"
       }
     },
+    "node_modules/html-escaper": {
+      "version": "2.0.2",
+      "resolved": "https://registry.npmjs.org/html-escaper/-/html-escaper-2.0.2.tgz",
+      "integrity": "sha512-H2iMtd0I4Mt5eYiapRdIDjp+XzelXQ0tFE4JS7YFwFevXXMmOp9myNrUvCg0D6ws8iqkRPBfKHgbwig1SmlLfg==",
+      "dev": true,
+      "license": "MIT"
+    },
     "node_modules/http-errors": {
       "version": "2.0.1",
       "resolved": "https://registry.npmjs.org/http-errors/-/http-errors-2.0.1.tgz",
@@ -2923,6 +3162,16 @@
         "node": ">=0.10.0"
       }
     },
+    "node_modules/is-fullwidth-code-point": {
+      "version": "3.0.0",
+      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/is-fullwidth-code-point-3.0.0.tgz",
+      "integrity": "sha512-zymm5+u+sCsSWyD9qNaejV3DFvhCKclKdizYaJUuHA83RLjb7nSuGnddCHGv0hk+KY7BMAlsWeK4Ueg6EV6XQg==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=8"
+      }
+    },
     "node_modules/is-glob": {
       "version": "4.0.3",
       "resolved": "https://registry.npmjs.org/is-glob/-/is-glob-4.0.3.tgz",
@@ -2963,6 +3212,76 @@
       "dev": true,
       "license": "ISC"
     },
+    "node_modules/istanbul-lib-coverage": {
+      "version": "3.2.2",
+      "resolved": "https://registry.npmjs.org/istanbul-lib-coverage/-/istanbul-lib-coverage-3.2.2.tgz",
+      "integrity": "sha512-O8dpsF+r0WV/8MNRKfnmrtCWhuKjxrq2w+jpzBL5UZKTi2LeVWnWOmWRxFlesJONmc+wLAGvKQZEOanko0LFTg==",
+      "dev": true,
+      "license": "BSD-3-Clause",
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/istanbul-lib-report": {
+      "version": "3.0.1",
+      "resolved": "https://registry.npmjs.org/istanbul-lib-report/-/istanbul-lib-report-3.0.1.tgz",
+      "integrity": "sha512-GCfE1mtsHGOELCU8e/Z7YWzpmybrx/+dSTfLrvY8qRmaY6zXTKWn6WQIjaAFw069icm6GVMNkgu0NzI4iPZUNw==",
+      "dev": true,
+      "license": "BSD-3-Clause",
+      "dependencies": {
+        "istanbul-lib-coverage": "^3.0.0",
+        "make-dir": "^4.0.0",
+        "supports-color": "^7.1.0"
+      },
+      "engines": {
+        "node": ">=10"
+      }
+    },
+    "node_modules/istanbul-lib-source-maps": {
+      "version": "5.0.6",
+      "resolved": "https://registry.npmjs.org/istanbul-lib-source-maps/-/istanbul-lib-source-maps-5.0.6.tgz",
+      "integrity": "sha512-yg2d+Em4KizZC5niWhQaIomgf5WlL4vOOjZ5xGCmF8SnPE/mDWWXgvRExdcpCgh9lLRRa1/fSYp2ymmbJ1pI+A==",
+      "dev": true,
+      "license": "BSD-3-Clause",
+      "dependencies": {
+        "@jridgewell/trace-mapping": "^0.3.23",
+        "debug": "^4.1.1",
+        "istanbul-lib-coverage": "^3.0.0"
+      },
+      "engines": {
+        "node": ">=10"
+      }
+    },
+    "node_modules/istanbul-reports": {
+      "version": "3.2.0",
+      "resolved": "https://registry.npmjs.org/istanbul-reports/-/istanbul-reports-3.2.0.tgz",
+      "integrity": "sha512-HGYWWS/ehqTV3xN10i23tkPkpH46MLCIMFNCaaKNavAXTF1RkqxawEPtnjnGZ6XKSInBKkiOA5BKS+aZiY3AvA==",
+      "dev": true,
+      "license": "BSD-3-Clause",
+      "dependencies": {
+        "html-escaper": "^2.0.0",
+        "istanbul-lib-report": "^3.0.0"
+      },
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/jackspeak": {
+      "version": "3.4.3",
+      "resolved": "https://registry.npmjs.org/jackspeak/-/jackspeak-3.4.3.tgz",
+      "integrity": "sha512-OGlZQpz2yfahA/Rd1Y8Cd9SIEsqvXkLVoSw/cgwhnhFMDbsQFeZYoJJ7bIZBS9BcamUW96asq/npPWugM+RQBw==",
+      "dev": true,
+      "license": "BlueOak-1.0.0",
+      "dependencies": {
+        "@isaacs/cliui": "^8.0.2"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/isaacs"
+      },
+      "optionalDependencies": {
+        "@pkgjs/parseargs": "^0.11.0"
+      }
+    },
     "node_modules/js-yaml": {
       "version": "4.1.1",
       "resolved": "https://registry.npmjs.org/js-yaml/-/js-yaml-4.1.1.tgz",
@@ -3051,6 +3370,13 @@
       "dev": true,
       "license": "MIT"
     },
+    "node_modules/lru-cache": {
+      "version": "10.4.3",
+      "resolved": "https://registry.npmjs.org/lru-cache/-/lru-cache-10.4.3.tgz",
+      "integrity": "sha512-JNAzZcXrCt42VGLuYz0zfAzDfAvJWW6AfYlDBQyDV5DClI2m5sAmK+OIO7s59XfsRsWHp02jAJrRadPRGTt6SQ==",
+      "dev": true,
+      "license": "ISC"
+    },
     "node_modules/magic-string": {
       "version": "0.30.21",
       "resolved": "https://registry.npmjs.org/magic-string/-/magic-string-0.30.21.tgz",
@@ -3061,6 +3387,34 @@
         "@jridgewell/sourcemap-codec": "^1.5.5"
       }
     },
+    "node_modules/magicast": {
+      "version": "0.3.5",
+      "resolved": "https://registry.npmjs.org/magicast/-/magicast-0.3.5.tgz",
+      "integrity": "sha512-L0WhttDl+2BOsybvEOLK7fW3UA0OQ0IQ2d6Zl2x/a6vVRs3bAY0ECOSHHeL5jD+SbOpOCUEi0y1DgHEn9Qn1AQ==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@babel/parser": "^7.25.4",
+        "@babel/types": "^7.25.4",
+        "source-map-js": "^1.2.0"
+      }
+    },
+    "node_modules/make-dir": {
+      "version": "4.0.0",
+      "resolved": "https://registry.npmjs.org/make-dir/-/make-dir-4.0.0.tgz",
+      "integrity": "sha512-hXdUTZYIVOt1Ex//jAQi+wTZZpUpwBj/0QsOzqegb3rGMMeJiSEu5xLHnYfBrRV4RH2+OCSOO95Is/7x1WJ4bw==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "semver": "^7.5.3"
+      },
+      "engines": {
+        "node": ">=10"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/sindresorhus"
+      }
+    },
     "node_modules/math-intrinsics": {
       "version": "1.1.0",
       "resolved": "https://registry.npmjs.org/math-intrinsics/-/math-intrinsics-1.1.0.tgz",
@@ -3191,6 +3545,16 @@
         "url": "https://github.com/sponsors/ljharb"
       }
     },
+    "node_modules/minipass": {
+      "version": "7.1.2",
+      "resolved": "https://registry.npmjs.org/minipass/-/minipass-7.1.2.tgz",
+      "integrity": "sha512-qOOzS1cBTWYF4BH8fVePDBOO9iptMnGUEZwNc/cMWnTV2nVLZ7VoNWEPHkYczZA0pdoA7dl6e7FL659nX9S2aw==",
+      "dev": true,
+      "license": "ISC",
+      "engines": {
+        "node": ">=16 || 14 >=14.17"
+      }
+    },
     "node_modules/mkdirp-classic": {
       "version": "0.5.3",
       "resolved": "https://registry.npmjs.org/mkdirp-classic/-/mkdirp-classic-0.5.3.tgz",
@@ -3339,6 +3703,13 @@
         "url": "https://github.com/sponsors/sindresorhus"
       }
     },
+    "node_modules/package-json-from-dist": {
+      "version": "1.0.1",
+      "resolved": "https://registry.npmjs.org/package-json-from-dist/-/package-json-from-dist-1.0.1.tgz",
+      "integrity": "sha512-UEZIS3/by4OC8vL3P2dTXRETpebLI2NiI5vIrjaD/5UtrkFX/tNbwjTSRAGC/+7CAo2pIcBaRgWmcBBHcsaCIw==",
+      "dev": true,
+      "license": "BlueOak-1.0.0"
+    },
     "node_modules/parent-module": {
       "version": "1.0.1",
       "resolved": "https://registry.npmjs.org/parent-module/-/parent-module-1.0.1.tgz",
@@ -3391,6 +3762,23 @@
         "node": ">=8"
       }
     },
+    "node_modules/path-scurry": {
+      "version": "1.11.1",
+      "resolved": "https://registry.npmjs.org/path-scurry/-/path-scurry-1.11.1.tgz",
+      "integrity": "sha512-Xa4Nw17FS9ApQFJ9umLiJS4orGjm7ZzwUrwamcGQuHSzDyth9boKDaycYdDcZDuqYATXw4HFXgaqWTctW/v1HA==",
+      "dev": true,
+      "license": "BlueOak-1.0.0",
+      "dependencies": {
+        "lru-cache": "^10.2.0",
+        "minipass": "^5.0.0 || ^6.0.2 || ^7.0.0"
+      },
+      "engines": {
+        "node": ">=16 || 14 >=14.18"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/isaacs"
+      }
+    },
     "node_modules/path-to-regexp": {
       "version": "0.1.12",
       "resolved": "https://registry.npmjs.org/path-to-regexp/-/path-to-regexp-0.1.12.tgz",
@@ -3947,6 +4335,19 @@
       "dev": true,
       "license": "ISC"
     },
+    "node_modules/signal-exit": {
+      "version": "4.1.0",
+      "resolved": "https://registry.npmjs.org/signal-exit/-/signal-exit-4.1.0.tgz",
+      "integrity": "sha512-bzyZ1e88w9O1iNJbKnOlvYTrWPDl46O1bG0D3XInv+9tkPrxrN8jUUTiFlDkkmKWgn1M6CfIA13SuGqOa9Korw==",
+      "dev": true,
+      "license": "ISC",
+      "engines": {
+        "node": ">=14"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/isaacs"
+      }
+    },
     "node_modules/simple-concat": {
       "version": "1.0.1",
       "resolved": "https://registry.npmjs.org/simple-concat/-/simple-concat-1.0.1.tgz",
@@ -4044,6 +4445,76 @@
         "safe-buffer": "~5.2.0"
       }
     },
+    "node_modules/string-width": {
+      "version": "5.1.2",
+      "resolved": "https://registry.npmjs.org/string-width/-/string-width-5.1.2.tgz",
+      "integrity": "sha512-HnLOCR3vjcY8beoNLtcjZ5/nxn2afmME6lhrDrebokqMap+XbeW8n9TXpPDOqdGK5qcI3oT0GKTW6wC7EMiVqA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "eastasianwidth": "^0.2.0",
+        "emoji-regex": "^9.2.2",
+        "strip-ansi": "^7.0.1"
+      },
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/sindresorhus"
+      }
+    },
+    "node_modules/string-width-cjs": {
+      "name": "string-width",
+      "version": "4.2.3",
+      "resolved": "https://registry.npmjs.org/string-width/-/string-width-4.2.3.tgz",
+      "integrity": "sha512-wKyQRQpjJ0sIp62ErSZdGsjMJWsap5oRNihHhu6G7JVO/9jIB6UyevL+tXuOqrng8j/cxKTWyWUwvSTriiZz/g==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "emoji-regex": "^8.0.0",
+        "is-fullwidth-code-point": "^3.0.0",
+        "strip-ansi": "^6.0.1"
+      },
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/string-width-cjs/node_modules/emoji-regex": {
+      "version": "8.0.0",
+      "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-8.0.0.tgz",
+      "integrity": "sha512-MSjYzcWNOA0ewAHpz0MxpYFvwg6yjy1NG3xteoqz644VCo/RPgnr1/GGt+ic3iJTzQ8Eu3TdM14SawnVUmGE6A==",
+      "dev": true,
+      "license": "MIT"
+    },
+    "node_modules/string-width/node_modules/ansi-regex": {
+      "version": "6.2.2",
+      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-6.2.2.tgz",
+      "integrity": "sha512-Bq3SmSpyFHaWjPk8If9yc6svM8c56dB5BAtW4Qbw5jHTwwXXcTLoRMkpDJp6VL0XzlWaCHTXrkFURMYmD0sLqg==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/ansi-regex?sponsor=1"
+      }
+    },
+    "node_modules/string-width/node_modules/strip-ansi": {
+      "version": "7.1.2",
+      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-7.1.2.tgz",
+      "integrity": "sha512-gmBGslpoQJtgnMAvOVqGZpEz9dyoKTCzy2nfz/n8aIFhN/jCE/rCmcxabB6jOOHV+0WNnylOxaxBQPSvcWklhA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "ansi-regex": "^6.0.1"
+      },
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/strip-ansi?sponsor=1"
+      }
+    },
     "node_modules/strip-ansi": {
       "version": "6.0.1",
       "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-6.0.1.tgz",
@@ -4057,6 +4528,20 @@
         "node": ">=8"
       }
     },
+    "node_modules/strip-ansi-cjs": {
+      "name": "strip-ansi",
+      "version": "6.0.1",
+      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-6.0.1.tgz",
+      "integrity": "sha512-Y38VPSHcqkFrCpFnQ9vuSXmquuv5oXOKpGeT6aGrr3o3Gc9AlVa6JBfUSOCnbxGGZF+/0ooI7KrPuUSztUdU5A==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "ansi-regex": "^5.0.1"
+      },
+      "engines": {
+        "node": ">=8"
+      }
+    },
     "node_modules/strip-json-comments": {
       "version": "3.1.1",
       "resolved": "https://registry.npmjs.org/strip-json-comments/-/strip-json-comments-3.1.1.tgz",
@@ -4111,6 +4596,43 @@
         "node": ">=6"
       }
     },
+    "node_modules/test-exclude": {
+      "version": "7.0.1",
+      "resolved": "https://registry.npmjs.org/test-exclude/-/test-exclude-7.0.1.tgz",
+      "integrity": "sha512-pFYqmTw68LXVjeWJMST4+borgQP2AyMNbg1BpZh9LbyhUeNkeaPF9gzfPGUAnSMV3qPYdWUwDIjjCLiSDOl7vg==",
+      "dev": true,
+      "license": "ISC",
+      "dependencies": {
+        "@istanbuljs/schema": "^0.1.2",
+        "glob": "^10.4.1",
+        "minimatch": "^9.0.4"
+      },
+      "engines": {
+        "node": ">=18"
+      }
+    },
+    "node_modules/test-exclude/node_modules/glob": {
+      "version": "10.5.0",
+      "resolved": "https://registry.npmjs.org/glob/-/glob-10.5.0.tgz",
+      "integrity": "sha512-DfXN8DfhJ7NH3Oe7cFmu3NCu1wKbkReJ8TorzSAFbSKrlNaQSKfIzqYqVY8zlbs2NLBbWpRiU52GX2PbaBVNkg==",
+      "deprecated": "Old versions of glob are not supported, and contain widely publicized security vulnerabilities, which have been fixed in the current version. Please update. Support for old versions may be purchased (at exorbitant rates) by contacting i@izs.me",
+      "dev": true,
+      "license": "ISC",
+      "dependencies": {
+        "foreground-child": "^3.1.0",
+        "jackspeak": "^3.1.2",
+        "minimatch": "^9.0.4",
+        "minipass": "^7.1.2",
+        "package-json-from-dist": "^1.0.0",
+        "path-scurry": "^1.11.1"
+      },
+      "bin": {
+        "glob": "dist/esm/bin.mjs"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/isaacs"
+      }
+    },
     "node_modules/text-table": {
       "version": "0.2.0",
       "resolved": "https://registry.npmjs.org/text-table/-/text-table-0.2.0.tgz",
@@ -4254,7 +4776,6 @@
       "integrity": "sha512-jl1vZzPDinLr9eUt3J/t7V6FgNEw9QjvBPdysz9KfQDD41fQrC2Y4vKQdiaUpFT4bXlb1RHhLpp8wtm6M5TgSw==",
       "dev": true,
       "license": "Apache-2.0",
-      "peer": true,
       "bin": {
         "tsc": "bin/tsc",
         "tsserver": "bin/tsserver"
@@ -4518,6 +5039,107 @@
         "node": ">=0.10.0"
       }
     },
+    "node_modules/wrap-ansi": {
+      "version": "8.1.0",
+      "resolved": "https://registry.npmjs.org/wrap-ansi/-/wrap-ansi-8.1.0.tgz",
+      "integrity": "sha512-si7QWI6zUMq56bESFvagtmzMdGOtoxfR+Sez11Mobfc7tm+VkUckk9bW2UeffTGVUbOksxmSw0AA2gs8g71NCQ==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "ansi-styles": "^6.1.0",
+        "string-width": "^5.0.1",
+        "strip-ansi": "^7.0.1"
+      },
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/wrap-ansi?sponsor=1"
+      }
+    },
+    "node_modules/wrap-ansi-cjs": {
+      "name": "wrap-ansi",
+      "version": "7.0.0",
+      "resolved": "https://registry.npmjs.org/wrap-ansi/-/wrap-ansi-7.0.0.tgz",
+      "integrity": "sha512-YVGIj2kamLSTxw6NsZjoBxfSwsn0ycdesmc4p+Q21c5zPuZ1pl+NfxVdxPtdHvmNVOQ6XSYG4AUtyt/Fi7D16Q==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "ansi-styles": "^4.0.0",
+        "string-width": "^4.1.0",
+        "strip-ansi": "^6.0.0"
+      },
+      "engines": {
+        "node": ">=10"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/wrap-ansi?sponsor=1"
+      }
+    },
+    "node_modules/wrap-ansi-cjs/node_modules/emoji-regex": {
+      "version": "8.0.0",
+      "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-8.0.0.tgz",
+      "integrity": "sha512-MSjYzcWNOA0ewAHpz0MxpYFvwg6yjy1NG3xteoqz644VCo/RPgnr1/GGt+ic3iJTzQ8Eu3TdM14SawnVUmGE6A==",
+      "dev": true,
+      "license": "MIT"
+    },
+    "node_modules/wrap-ansi-cjs/node_modules/string-width": {
+      "version": "4.2.3",
+      "resolved": "https://registry.npmjs.org/string-width/-/string-width-4.2.3.tgz",
+      "integrity": "sha512-wKyQRQpjJ0sIp62ErSZdGsjMJWsap5oRNihHhu6G7JVO/9jIB6UyevL+tXuOqrng8j/cxKTWyWUwvSTriiZz/g==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "emoji-regex": "^8.0.0",
+        "is-fullwidth-code-point": "^3.0.0",
+        "strip-ansi": "^6.0.1"
+      },
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/wrap-ansi/node_modules/ansi-regex": {
+      "version": "6.2.2",
+      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-6.2.2.tgz",
+      "integrity": "sha512-Bq3SmSpyFHaWjPk8If9yc6svM8c56dB5BAtW4Qbw5jHTwwXXcTLoRMkpDJp6VL0XzlWaCHTXrkFURMYmD0sLqg==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/ansi-regex?sponsor=1"
+      }
+    },
+    "node_modules/wrap-ansi/node_modules/ansi-styles": {
+      "version": "6.2.3",
+      "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-6.2.3.tgz",
+      "integrity": "sha512-4Dj6M28JB+oAH8kFkTLUo+a2jwOFkuqb3yucU0CANcRRUbxS0cP0nZYCGjcc3BNXwRIsUVmDGgzawme7zvJHvg==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/ansi-styles?sponsor=1"
+      }
+    },
+    "node_modules/wrap-ansi/node_modules/strip-ansi": {
+      "version": "7.1.2",
+      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-7.1.2.tgz",
+      "integrity": "sha512-gmBGslpoQJtgnMAvOVqGZpEz9dyoKTCzy2nfz/n8aIFhN/jCE/rCmcxabB6jOOHV+0WNnylOxaxBQPSvcWklhA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "ansi-regex": "^6.0.1"
+      },
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/strip-ansi?sponsor=1"
+      }
+    },
     "node_modules/wrappy": {
       "version": "1.0.2",
       "resolved": "https://registry.npmjs.org/wrappy/-/wrappy-1.0.2.tgz",
diff --git a/src/analytics/index.ts b/src/analytics/index.ts
new file mode 100644
index 0000000..371e8bb
--- /dev/null
+++ b/src/analytics/index.ts
@@ -0,0 +1,124 @@
+import { EventBus } from '../bus.js';
+import type {
+  AnalyticsService,
+  OrderCreatedEvent,
+  PaymentProcessedEvent,
+  CartUpdatedEvent,
+} from '../types.js';
+import { PaymentStatus } from '../types.js';
+
+export function createAnalyticsService(bus: EventBus): AnalyticsService {
+  const eventCounts = new Map<string, number>();
+  let revenue = 0;
+  const uniqueCarts = new Set<string>();
+  let orderCount = 0;
+  const productQuantities = new Map<string, number>();
+
+  // Track cart contents so we can look up items when an order is created
+  const cartItems = new Map<string, Array<{ productId: string; quantity: number }>>();
+
+  // Track order amounts for revenue calculation from payment events
+  const orderAmounts = new Map<string, number>();
+
+  // Track transactionId -> amount for refund handling
+  const transactionAmounts = new Map<string, number>();
+
+  function incrementEvent(eventType: string): void {
+    eventCounts.set(eventType, (eventCounts.get(eventType) ?? 0) + 1);
+  }
+
+  bus.on('order:created', (payload: unknown) => {
+    const event = payload as OrderCreatedEvent;
+    incrementEvent('order:created');
+    orderCount++;
+
+    // Store order amount for later payment/refund tracking
+    orderAmounts.set(event.orderId, event.total);
+
+    // Track product quantities from the cart associated with this order
+    const items = cartItems.get(event.cartId);
+    if (items) {
+      for (const item of items) {
+        productQuantities.set(
+          item.productId,
+          (productQuantities.get(item.productId) ?? 0) + item.quantity,
+        );
+      }
+    }
+  });
+
+  bus.on('payment:processed', (payload: unknown) => {
+    const event = payload as PaymentProcessedEvent;
+    incrementEvent('payment:processed');
+
+    if (event.status === PaymentStatus.SUCCESS) {
+      const amount = orderAmounts.get(event.orderId);
+      if (amount !== undefined) {
+        revenue += amount;
+        // Map transactionId to amount for potential refund
+        if (event.transactionId) {
+          transactionAmounts.set(event.transactionId, amount);
+        }
+      }
+    }
+  });
+
+  bus.on('payment:refunded', (payload: unknown) => {
+    incrementEvent('payment:refunded');
+
+    // The refund payload could carry the amount or transactionId
+    // Try multiple approaches to determine the refund amount
+    const event = payload as Record<string, unknown>;
+
+    if (typeof event.amount === 'number') {
+      revenue -= event.amount;
+    } else if (typeof event.transactionId === 'string') {
+      const amount = transactionAmounts.get(event.transactionId);
+      if (amount !== undefined) {
+        revenue -= amount;
+      }
+    } else if (typeof event.orderId === 'string') {
+      const amount = orderAmounts.get(event.orderId);
+      if (amount !== undefined) {
+        revenue -= amount;
+      }
+    }
+  });
+
+  bus.on('cart:created', (payload: unknown) => {
+    const event = payload as { cartId: string };
+    incrementEvent('cart:created');
+    uniqueCarts.add(event.cartId);
+  });
+
+  // Also listen to cart:updated to track cart items for product quantity tracking
+  bus.on('cart:updated', (payload: unknown) => {
+    const event = payload as CartUpdatedEvent;
+    incrementEvent('cart:updated');
+    cartItems.set(event.cartId, event.items);
+    // Also track unique carts from cart:updated in case cart:created is not emitted
+    uniqueCarts.add(event.cartId);
+  });
+
+  return {
+    getEventCount(eventType: string): number {
+      return eventCounts.get(eventType) ?? 0;
+    },
+
+    getRevenue(): number {
+      return revenue;
+    },
+
+    getConversionRate(): number {
+      if (uniqueCarts.size === 0) return 0;
+      return orderCount / uniqueCarts.size;
+    },
+
+    getTopProducts(limit = 10): Array<{ productId: string; count: number }> {
+      return Array.from(productQuantities.entries())
+        .map(([productId, count]) => ({ productId, count }))
+        .sort((a, b) => b.count - a.count)
+        .slice(0, limit);
+    },
+  };
+}
diff --git a/src/cart/index.ts b/src/cart/index.ts
new file mode 100644
index 0000000..2632ced
--- /dev/null
+++ b/src/cart/index.ts
@@ -0,0 +1,74 @@
+import { v4 as uuid } from 'uuid';
+import type { EventBus } from '../bus.js';
+import type { CartService } from '../types.js';
+
+interface CartItem {
+  productId: string;
+  quantity: number;
+}
+
+interface Cart {
+  id: string;
+  userId: string;
+  items: CartItem[];
+}
+
+export function createCartService(bus: EventBus): CartService {
+  const carts = new Map<string, Cart>();
+
+  return {
+    createCart(userId: string): string {
+      const id = uuid();
+      const cart: Cart = { id, userId, items: [] };
+      carts.set(id, cart);
+
+      void bus.emit('cart:created', { cartId: id, userId });
+
+      return id;
+    },
+
+    addItem(cartId: string, productId: string, quantity: number): void {
+      const cart = carts.get(cartId);
+      if (!cart) return;
+
+      const existing = cart.items.find(i => i.productId === productId);
+      if (existing) {
+        existing.quantity += quantity;
+      } else {
+        cart.items.push({ productId, quantity });
+      }
+    },
+
+    removeItem(cartId: string, productId: string): void {
+      const cart = carts.get(cartId);
+      if (!cart) return;
+      cart.items = cart.items.filter(i => i.productId !== productId);
+    },
+
+    getCart(cartId: string): { id: string; userId: string; items: CartItem[] } | null {
+      const cart = carts.get(cartId);
+      if (!cart) return null;
+      return {
+        id: cart.id,
+        userId: cart.userId,
+        items: cart.items.map(i => ({ ...i })),
+      };
+    },
+
+    clearCart(cartId: string): void {
+      const cart = carts.get(cartId);
+      if (!cart) return;
+      cart.items = [];
+    },
+
+    updateQuantity(cartId: string, productId: string, quantity: number): void {
+      const cart = carts.get(cartId);
+      if (!cart) return;
+
+      const existing = cart.items.find(i => i.productId === productId);
+      if (existing) {
+        existing.quantity = quantity;
+      }
+    },
+  };
+}
diff --git a/src/catalog/index.ts b/src/catalog/index.ts
new file mode 100644
index 0000000..9d910f0
--- /dev/null
+++ b/src/catalog/index.ts
@@ -0,0 +1,59 @@
+import { v4 as uuid } from 'uuid';
+import type { EventBus } from '../bus.js';
+import type { CatalogService, ProductCreatedEvent } from '../types.js';
+import { Events } from '../types.js';
+
+interface Product {
+  id: string;
+  name: string;
+  price: number;
+  category: string;
+}
+
+export function createCatalogService(bus: EventBus): CatalogService {
+  const products = new Map<string, Product>();
+
+  return {
+    createProduct(name: string, price: number, category: string): string {
+      const id = uuid();
+      const product: Product = { id, name, price, category };
+      products.set(id, product);
+
+      const event: ProductCreatedEvent = { productId: id, name, price, category };
+      void bus.emit(Events.PRODUCT_CREATED, event);
+
+      return id;
+    },
+
+    getProduct(productId: string): Product | null {
+      return products.get(productId) ?? null;
+    },
+
+    listProducts(category?: string): Product[] {
+      const all = Array.from(products.values());
+      if (category !== undefined) {
+        return all.filter(p => p.category === category);
+      }
+      return all;
+    },
+
+    searchProducts(query: string): Product[] {
+      const lower = query.toLowerCase();
+      return Array.from(products.values()).filter(
+        p => p.name.toLowerCase().includes(lower) || p.category.toLowerCase().includes(lower)
+      );
+    },
+
+    updateProduct(productId: string, updates: Partial<{ name: string; price: number; category: string }>): void {
+      const product = products.get(productId);
+      if (!product) return;
+      if (updates.name !== undefined) product.name = updates.name;
+      if (updates.price !== undefined) product.price = updates.price;
+      if (updates.category !== undefined) product.category = updates.category;
+    },
+
+    removeProduct(productId: string): boolean {
+      return products.delete(productId);
+    },
+  };
+}
diff --git a/src/index.ts b/src/index.ts
new file mode 100644
index 0000000..f894b40
--- /dev/null
+++ b/src/index.ts
@@ -0,0 +1,35 @@
+export { EventBus } from './bus.js';
+export {
+  OrderStatus,
+  PaymentStatus,
+  Events,
+} from './types.js';
+export type {
+  ProductCreatedEvent,
+  InventoryUpdatedEvent,
+  CartUpdatedEvent,
+  PriceCalculatedEvent,
+  OrderCreatedEvent,
+  OrderStatusChangedEvent,
+  PaymentProcessedEvent,
+  NotificationSentEvent,
+  AnalyticsEvent,
+  LowStockAlertEvent,
+  CatalogService,
+  InventoryService,
+  CartService,
+  PricingService,
+  OrderService,
+  PaymentService,
+  NotificationService,
+  AnalyticsService,
+} from './types.js';
+
+export { createCatalogService } from './catalog/index.js';
+export { createInventoryService } from './inventory/index.js';
+export { createCartService } from './cart/index.js';
+export { createPricingService } from './pricing/index.js';
+export { createOrdersService } from './orders/index.js';
+export { createPaymentService } from './payment/index.js';
+export { createNotificationsService } from './notifications/index.js';
+export { createAnalyticsService } from './analytics/index.js';
diff --git a/src/inventory/index.ts b/src/inventory/index.ts
new file mode 100644
index 0000000..3ce409d
--- /dev/null
+++ b/src/inventory/index.ts
@@ -0,0 +1,71 @@
+import type { EventBus } from '../bus.js';
+import type { InventoryService, LowStockAlertEvent } from '../types.js';
+import { Events } from '../types.js';
+
+interface StockEntry {
+  available: number;
+  reserved: number;
+}
+
+export function createInventoryService(bus: EventBus): InventoryService {
+  const stock = new Map<string, StockEntry>();
+  const thresholds = new Map<string, number>();
+
+  function getEntry(productId: string): StockEntry {
+    let entry = stock.get(productId);
+    if (!entry) {
+      entry = { available: 0, reserved: 0 };
+      stock.set(productId, entry);
+    }
+    return entry;
+  }
+
+  function checkLowStock(productId: string): void {
+    const threshold = thresholds.get(productId);
+    if (threshold === undefined) return;
+
+    const entry = getEntry(productId);
+    if (entry.available < threshold) {
+      const event: LowStockAlertEvent = {
+        productId,
+        currentQuantity: entry.available,
+        threshold,
+      };
+      void bus.emit(Events.LOW_STOCK_ALERT, event);
+    }
+  }
+
+  return {
+    setStock(productId: string, quantity: number): void {
+      const entry = getEntry(productId);
+      entry.available = quantity;
+      checkLowStock(productId);
+    },
+
+    getStock(productId: string): number {
+      return getEntry(productId).available;
+    },
+
+    reserve(productId: string, quantity: number): boolean {
+      const entry = getEntry(productId);
+      if (entry.available < quantity) return false;
+      entry.available -= quantity;
+      entry.reserved += quantity;
+      checkLowStock(productId);
+      return true;
+    },
+
+    release(productId: string, quantity: number): void {
+      const entry = getEntry(productId);
+      const toRelease = Math.min(quantity, entry.reserved);
+      entry.reserved -= toRelease;
+      entry.available += toRelease;
+      checkLowStock(productId);
+    },
+
+    setLowStockThreshold(productId: string, threshold: number): void {
+      thresholds.set(productId, threshold);
+      checkLowStock(productId);
+    },
+  };
+}
diff --git a/src/notifications/index.ts b/src/notifications/index.ts
new file mode 100644
index 0000000..2013293
--- /dev/null
+++ b/src/notifications/index.ts
@@ -0,0 +1,95 @@
+import { EventBus } from '../bus.js';
+import { Events } from '../types.js';
+import type {
+  NotificationService,
+  OrderCreatedEvent,
+  OrderStatusChangedEvent,
+  PaymentProcessedEvent,
+} from '../types.js';
+
+interface Notification {
+  type: string;
+  message: string;
+  timestamp: number;
+}
+
+export function createNotificationsService(bus: EventBus): NotificationService & { unsubscribe(userId: string): void } {
+  const orderToUser = new Map<string, string>();
+  const notifications = new Map<string, Notification[]>();
+  const subscribed = new Set<string>();
+
+  // Listen for order:created to map orderId â†’ userId
+  bus.on(Events.ORDER_CREATED, (payload: unknown) => {
+    const event = payload as OrderCreatedEvent;
+    orderToUser.set(event.orderId, event.userId);
+  });
+
+  // Listen for order:status_changed
+  bus.on(Events.ORDER_STATUS_CHANGED, (payload: unknown) => {
+    const event = payload as OrderStatusChangedEvent;
+    const userId = orderToUser.get(event.orderId);
+    if (!userId) return;
+    if (!subscribed.has(userId)) return;
+
+    addNotification(userId, {
+      type: 'order:status_changed',
+      message: `Order ${event.orderId} status changed from ${event.previousStatus} to ${event.status}`,
+      timestamp: Date.now(),
+    });
+  });
+
+  // Listen for payment:processed
+  bus.on(Events.PAYMENT_PROCESSED, (payload: unknown) => {
+    const event = payload as PaymentProcessedEvent;
+    const userId = orderToUser.get(event.orderId);
+    if (!userId) return;
+    if (!subscribed.has(userId)) return;
+
+    addNotification(userId, {
+      type: 'payment:processed',
+      message: `Payment for order ${event.orderId}: ${event.status}`,
+      timestamp: Date.now(),
+    });
+  });
+
+  // Listen for payment:refunded
+  bus.on('payment:refunded', (payload: unknown) => {
+    const event = payload as { transactionId: string; orderId: string; amount: number };
+    const userId = orderToUser.get(event.orderId);
+    if (!userId) return;
+    if (!subscribed.has(userId)) return;
+
+    addNotification(userId, {
+      type: 'payment:refunded',
+      message: `Payment refunded for order ${event.orderId}: $${event.amount}`,
+      timestamp: Date.now(),
+    });
+  });
+
+  function addNotification(userId: string, notification: Notification): void {
+    if (!notifications.has(userId)) {
+      notifications.set(userId, []);
+    }
+    notifications.get(userId)!.push(notification);
+
+    bus.emit(Events.NOTIFICATION_SENT, {
+      userId,
+      type: notification.type,
+      message: notification.message,
+    });
+  }
+
+  function subscribe(userId: string): void {
+    subscribed.add(userId);
+  }
+
+  function unsubscribe(userId: string): void {
+    subscribed.delete(userId);
+  }
+
+  function getNotifications(userId: string): Array<{ type: string; message: string; timestamp: number }> {
+    return notifications.get(userId) ?? [];
+  }
+
+  return { subscribe, unsubscribe, getNotifications };
+}
diff --git a/src/notifications/notifications.test.ts b/src/notifications/notifications.test.ts
new file mode 100644
index 0000000..e7c98e3
--- /dev/null
+++ b/src/notifications/notifications.test.ts
@@ -0,0 +1,96 @@
+import { describe, it, expect, beforeEach } from 'vitest';
+import { EventBus } from '../bus.js';
+import { Events, PaymentStatus, OrderStatus } from '../types.js';
+import { createNotificationsService } from './index.js';
+
+describe('NotificationsService', () => {
+  let bus: EventBus;
+
+  beforeEach(() => {
+    bus = new EventBus();
+  });
+
+  it('returns empty notifications for unknown user', () => {
+    const svc = createNotificationsService(bus);
+    expect(svc.getNotifications('user-1')).toEqual([]);
+  });
+
+  it('records notifications for subscribed users on order:status_changed', async () => {
+    const svc = createNotificationsService(bus);
+    svc.subscribe('user-1');
+
+    // Simulate order creation so orderId maps to userId
+    await bus.emit(Events.ORDER_CREATED, { orderId: 'order-1', userId: 'user-1', cartId: 'cart-1', total: 100 });
+
+    // Simulate order status change
+    await bus.emit(Events.ORDER_STATUS_CHANGED, { orderId: 'order-1', status: OrderStatus.CONFIRMED, previousStatus: OrderStatus.PENDING });
+
+    const notifs = svc.getNotifications('user-1');
+    expect(notifs).toHaveLength(1);
+    expect(notifs[0].type).toBe('order:status_changed');
+    expect(notifs[0].message).toContain('order-1');
+    expect(notifs[0].timestamp).toBeGreaterThan(0);
+  });
+
+  it('records notifications for subscribed users on payment:processed', async () => {
+    const svc = createNotificationsService(bus);
+    svc.subscribe('user-1');
+
+    await bus.emit(Events.ORDER_CREATED, { orderId: 'order-1', userId: 'user-1', cartId: 'cart-1', total: 100 });
+    await bus.emit(Events.PAYMENT_PROCESSED, { orderId: 'order-1', status: PaymentStatus.SUCCESS, transactionId: 'tx-1' });
+
+    const notifs = svc.getNotifications('user-1');
+    expect(notifs).toHaveLength(1);
+    expect(notifs[0].type).toBe('payment:processed');
+  });
+
+  it('records notifications for subscribed users on payment:refunded', async () => {
+    const svc = createNotificationsService(bus);
+    svc.subscribe('user-1');
+
+    await bus.emit(Events.ORDER_CREATED, { orderId: 'order-1', userId: 'user-1', cartId: 'cart-1', total: 100 });
+    await bus.emit('payment:refunded', { transactionId: 'tx-1', orderId: 'order-1', amount: 100 });
+
+    const notifs = svc.getNotifications('user-1');
+    expect(notifs).toHaveLength(1);
+    expect(notifs[0].type).toBe('payment:refunded');
+    expect(notifs[0].message).toContain('100');
+  });
+
+  it('does not record notifications for unsubscribed users', async () => {
+    const svc = createNotificationsService(bus);
+    // user-1 is NOT subscribed
+
+    await bus.emit(Events.ORDER_CREATED, { orderId: 'order-1', userId: 'user-1', cartId: 'cart-1', total: 100 });
+    await bus.emit(Events.ORDER_STATUS_CHANGED, { orderId: 'order-1', status: OrderStatus.CONFIRMED, previousStatus: OrderStatus.PENDING });
+
+    const notifs = svc.getNotifications('user-1');
+    expect(notifs).toHaveLength(0);
+  });
+
+  it('stops notifications after unsubscribe', async () => {
+    const svc = createNotificationsService(bus);
+    svc.subscribe('user-1');
+
+    await bus.emit(Events.ORDER_CREATED, { orderId: 'order-1', userId: 'user-1', cartId: 'cart-1', total: 100 });
+    await bus.emit(Events.ORDER_STATUS_CHANGED, { orderId: 'order-1', status: OrderStatus.CONFIRMED, previousStatus: OrderStatus.PENDING });
+
+    expect(svc.getNotifications('user-1')).toHaveLength(1);
+
+    svc.unsubscribe('user-1');
+
+    await bus.emit(Events.ORDER_STATUS_CHANGED, { orderId: 'order-1', status: OrderStatus.SHIPPED, previousStatus: OrderStatus.CONFIRMED });
+
+    expect(svc.getNotifications('user-1')).toHaveLength(1); // still 1, no new notification
+  });
+
+  it('ignores events for orders with no mapped user', async () => {
+    const svc = createNotificationsService(bus);
+    svc.subscribe('user-1');
+
+    // No order:created event, so orderId won't map to any user
+    await bus.emit(Events.ORDER_STATUS_CHANGED, { orderId: 'unknown-order', status: OrderStatus.CONFIRMED, previousStatus: OrderStatus.PENDING });
+
+    expect(svc.getNotifications('user-1')).toHaveLength(0);
+  });
+});
diff --git a/src/orders/index.ts b/src/orders/index.ts
new file mode 100644
index 0000000..6382a8c
--- /dev/null
+++ b/src/orders/index.ts
@@ -0,0 +1,102 @@
+import type { EventBus } from '../bus.js';
+import type { OrderService, OrderCreatedEvent, OrderStatusChangedEvent } from '../types.js';
+import { OrderStatus, Events } from '../types.js';
+
+interface Order {
+  id: string;
+  userId: string;
+  cartId: string;
+  status: OrderStatus;
+  total: number;
+}
+
+// Valid status transitions
+const validTransitions: Record<OrderStatus, OrderStatus[]> = {
+  [OrderStatus.PENDING]: [OrderStatus.CONFIRMED, OrderStatus.CANCELLED],
+  [OrderStatus.CONFIRMED]: [OrderStatus.SHIPPED, OrderStatus.CANCELLED],
+  [OrderStatus.SHIPPED]: [OrderStatus.DELIVERED],
+  [OrderStatus.DELIVERED]: [],
+  [OrderStatus.CANCELLED]: [],
+};
+
+let orderCounter = 0;
+
+export function createOrdersService(bus: EventBus): OrderService {
+  const orders = new Map<string, Order>();
+
+  return {
+    createOrder(userId: string, cartId: string, total: number): string {
+      orderCounter++;
+      const orderId = `order-${orderCounter}`;
+
+      const order: Order = {
+        id: orderId,
+        userId,
+        cartId,
+        status: OrderStatus.PENDING,
+        total,
+      };
+
+      orders.set(orderId, order);
+
+      const event: OrderCreatedEvent = {
+        orderId,
+        userId,
+        cartId,
+        total,
+      };
+      bus.emit(Events.ORDER_CREATED, event);
+
+      return orderId;
+    },
+
+    getOrder(orderId: string): { id: string; userId: string; status: OrderStatus; total: number } | null {
+      const order = orders.get(orderId);
+      if (!order) return null;
+      return {
+        id: order.id,
+        userId: order.userId,
+        status: order.status,
+        total: order.total,
+      };
+    },
+
+    updateStatus(orderId: string, status: OrderStatus): void {
+      const order = orders.get(orderId);
+      if (!order) {
+        throw new Error(`Order ${orderId} not found`);
+      }
+
+      const allowed = validTransitions[order.status];
+      if (!allowed.includes(status)) {
+        throw new Error(
+          `Invalid status transition from ${order.status} to ${status}`,
+        );
+      }
+
+      const previousStatus = order.status;
+      order.status = status;
+
+      const event: OrderStatusChangedEvent = {
+        orderId,
+        status,
+        previousStatus,
+      };
+      bus.emit(Events.ORDER_STATUS_CHANGED, event);
+    },
+
+    listOrders(userId: string): Array<{ id: string; status: OrderStatus; total: number }> {
+      const result: Array<{ id: string; status: OrderStatus; total: number }> = [];
+      for (const order of orders.values()) {
+        if (order.userId === userId) {
+          result.push({
+            id: order.id,
+            status: order.status,
+            total: order.total,
+          });
+        }
+      }
+      return result;
+    },
+  };
+}
diff --git a/src/payment/index.ts b/src/payment/index.ts
new file mode 100644
index 0000000..5fbc5a4
--- /dev/null
+++ b/src/payment/index.ts
@@ -0,0 +1,91 @@
+import { EventBus } from '../bus.js';
+import { PaymentStatus, Events } from '../types.js';
+import type { PaymentService, PaymentProcessedEvent } from '../types.js';
+import { v4 as uuid } from 'uuid';
+
+interface PaymentOptions {
+  simulateFailure?: boolean;
+  simulateTimeout?: boolean;
+}
+
+interface Transaction {
+  id: string;
+  orderId: string;
+  amount: number;
+  status: PaymentStatus;
+}
+
+export function createPaymentService(bus: EventBus, options?: PaymentOptions): PaymentService {
+  const transactions = new Map<string, Transaction>();
+  const refundedSet = new Set<string>();
+  const opts = options ?? {};
+
+  async function processPayment(orderId: string, amount: number): Promise<{ status: PaymentStatus; transactionId?: string; error?: string }> {
+    const transactionId = uuid();
+
+    if (opts.simulateTimeout) {
+      const tx: Transaction = { id: transactionId, orderId, amount, status: PaymentStatus.TIMEOUT };
+      transactions.set(transactionId, tx);
+
+      const event: PaymentProcessedEvent = {
+        orderId,
+        status: PaymentStatus.TIMEOUT,
+        transactionId,
+        error: 'Payment timed out',
+      };
+      await bus.emit(Events.PAYMENT_PROCESSED, event);
+
+      return { status: PaymentStatus.TIMEOUT, transactionId, error: 'Payment timed out' };
+    }
+
+    if (opts.simulateFailure) {
+      const tx: Transaction = { id: transactionId, orderId, amount, status: PaymentStatus.FAILED };
+      transactions.set(transactionId, tx);
+
+      const event: PaymentProcessedEvent = {
+        orderId,
+        status: PaymentStatus.FAILED,
+        transactionId,
+        error: 'Payment failed',
+      };
+      await bus.emit(Events.PAYMENT_PROCESSED, event);
+
+      return { status: PaymentStatus.FAILED, transactionId, error: 'Payment failed' };
+    }
+
+    // Success case
+    const tx: Transaction = { id: transactionId, orderId, amount, status: PaymentStatus.SUCCESS };
+    transactions.set(transactionId, tx);
+
+    const event: PaymentProcessedEvent = {
+      orderId,
+      status: PaymentStatus.SUCCESS,
+      transactionId,
+    };
+    await bus.emit(Events.PAYMENT_PROCESSED, event);
+
+    return { status: PaymentStatus.SUCCESS, transactionId };
+  }
+
+  async function refund(transactionId: string): Promise<boolean> {
+    const tx = transactions.get(transactionId);
+    if (!tx) {
+      return false;
+    }
+    if (tx.status !== PaymentStatus.SUCCESS || refundedSet.has(transactionId)) {
+      return false;
+    }
+
+    refundedSet.add(transactionId);
+
+    await bus.emit('payment:refunded', {
+      transactionId: tx.id,
+      orderId: tx.orderId,
+      amount: tx.amount,
+    });
+
+    return true;
+  }
+
+  return { processPayment, refund };
+}
diff --git a/src/payment/payment.test.ts b/src/payment/payment.test.ts
new file mode 100644
index 0000000..585e18e
--- /dev/null
+++ b/src/payment/payment.test.ts
@@ -0,0 +1,86 @@
+import { describe, it, expect, beforeEach } from 'vitest';
+import { EventBus } from '../bus.js';
+import { PaymentStatus, Events } from '../types.js';
+import { createPaymentService } from './index.js';
+
+describe('PaymentService', () => {
+  let bus: EventBus;
+
+  beforeEach(() => {
+    bus = new EventBus();
+  });
+
+  it('processes a successful payment', async () => {
+    const svc = createPaymentService(bus);
+    const result = await svc.processPayment('order-1', 99.99);
+
+    expect(result.status).toBe(PaymentStatus.SUCCESS);
+    expect(result.transactionId).toBeDefined();
+    expect(result.error).toBeUndefined();
+  });
+
+  it('emits payment:processed event on success', async () => {
+    const svc = createPaymentService(bus);
+    const events: unknown[] = [];
+    bus.on(Events.PAYMENT_PROCESSED, (p) => { events.push(p); });
+
+    await svc.processPayment('order-1', 50);
+
+    expect(events).toHaveLength(1);
+    const evt = events[0] as { orderId: string; status: PaymentStatus };
+    expect(evt.orderId).toBe('order-1');
+    expect(evt.status).toBe(PaymentStatus.SUCCESS);
+  });
+
+  it('simulates payment failure', async () => {
+    const svc = createPaymentService(bus, { simulateFailure: true });
+    const result = await svc.processPayment('order-2', 50);
+
+    expect(result.status).toBe(PaymentStatus.FAILED);
+    expect(result.error).toBeDefined();
+  });
+
+  it('simulates payment timeout', async () => {
+    const svc = createPaymentService(bus, { simulateTimeout: true });
+    const result = await svc.processPayment('order-3', 50);
+
+    expect(result.status).toBe(PaymentStatus.TIMEOUT);
+    expect(result.error).toBeDefined();
+  });
+
+  it('refunds a successful transaction', async () => {
+    const svc = createPaymentService(bus);
+    const result = await svc.processPayment('order-1', 100);
+    const refundEvents: unknown[] = [];
+    bus.on('payment:refunded', (p) => { refundEvents.push(p); });
+
+    const refunded = await svc.refund(result.transactionId!);
+    expect(refunded).toBe(true);
+    expect(refundEvents).toHaveLength(1);
+    const evt = refundEvents[0] as { transactionId: string; orderId: string; amount: number };
+    expect(evt.transactionId).toBe(result.transactionId);
+    expect(evt.orderId).toBe('order-1');
+    expect(evt.amount).toBe(100);
+  });
+
+  it('returns false when refunding non-existent transaction', async () => {
+    const svc = createPaymentService(bus);
+    const refunded = await svc.refund('non-existent');
+    expect(refunded).toBe(false);
+  });
+
+  it('returns false when refunding a failed transaction', async () => {
+    const svc = createPaymentService(bus, { simulateFailure: true });
+    const result = await svc.processPayment('order-1', 50);
+    const refunded = await svc.refund(result.transactionId!);
+    expect(refunded).toBe(false);
+  });
+
+  it('returns false when refunding an already refunded transaction', async () => {
+    const svc = createPaymentService(bus);
+    const result = await svc.processPayment('order-1', 100);
+    await svc.refund(result.transactionId!);
+    const secondRefund = await svc.refund(result.transactionId!);
+    expect(secondRefund).toBe(false);
+  });
+});
diff --git a/src/pricing/index.ts b/src/pricing/index.ts
new file mode 100644
index 0000000..5f03d7b
--- /dev/null
+++ b/src/pricing/index.ts
@@ -0,0 +1,56 @@
+import type { EventBus } from '../bus.js';
+import type { PricingService, ProductCreatedEvent } from '../types.js';
+import { Events } from '../types.js';
+
+export function createPricingService(bus: EventBus): PricingService {
+  const prices = new Map<string, number>();
+  const discountCodes = new Map<string, number>(); // code -> decimal fraction (0-1)
+
+  // Listen for product:created events to track prices
+  bus.on(Events.PRODUCT_CREATED, (payload: unknown) => {
+    const event = payload as ProductCreatedEvent;
+    prices.set(event.productId, event.price);
+  });
+
+  return {
+    calculateTotal(
+      items: Array<{ productId: string; quantity: number; price: number }>,
+      discountCode?: string,
+    ): { subtotal: number; discount: number; tax: number; total: number } {
+      // Compute subtotal from item quantities Ã— prices
+      const subtotal = items.reduce((sum, item) => sum + item.quantity * item.price, 0);
+
+      // Apply discount if valid code provided
+      let discountAmount = 0;
+      if (discountCode && discountCodes.has(discountCode)) {
+        const percentage = discountCodes.get(discountCode)!;
+        discountAmount = subtotal * percentage;
+      }
+
+      const discountedSubtotal = subtotal - discountAmount;
+
+      // Apply 10% tax on the discounted subtotal
+      const tax = discountedSubtotal * 0.1;
+
+      const total = discountedSubtotal + tax;
+
+      return {
+        subtotal: Math.round(subtotal * 100) / 100,
+        discount: Math.round(discountAmount * 100) / 100,
+        tax: Math.round(tax * 100) / 100,
+        total: Math.round(total * 100) / 100,
+      };
+    },
+
+    addDiscountCode(code: string, percentage: number): void {
+      // Support both decimal (0.1) and whole-number (10) percentage values
+      // If > 1, treat as a percentage (e.g., 10 means 10%)
+      const decimal = percentage > 1 ? percentage / 100 : percentage;
+      discountCodes.set(code, decimal);
+    },
+
+    getPrice(productId: string): number {
+      return prices.get(productId) ?? 0;
+    },
+  };
+}
diff --git a/tests/analytics.test.ts b/tests/analytics.test.ts
new file mode 100644
index 0000000..74848cb
--- /dev/null
+++ b/tests/analytics.test.ts
@@ -0,0 +1,190 @@
+import { describe, it, expect, beforeEach } from 'vitest';
+import { EventBus } from '../src/bus.js';
+import { createAnalyticsService } from '../src/analytics/index.js';
+import { PaymentStatus } from '../src/types.js';
+
+describe('Analytics Service', () => {
+  let bus: EventBus;
+  let analytics: ReturnType<typeof createAnalyticsService>;
+
+  beforeEach(() => {
+    bus = new EventBus();
+    analytics = createAnalyticsService(bus);
+  });
+
+  describe('getEventCount', () => {
+    it('returns 0 for unknown event types', () => {
+      expect(analytics.getEventCount('unknown:event')).toBe(0);
+    });
+
+    it('counts order:created events', async () => {
+      await bus.emit('order:created', { orderId: 'o1', userId: 'u1', cartId: 'c1', total: 100 });
+      await bus.emit('order:created', { orderId: 'o2', userId: 'u2', cartId: 'c2', total: 200 });
+      expect(analytics.getEventCount('order:created')).toBe(2);
+    });
+
+    it('counts payment:processed events', async () => {
+      await bus.emit('payment:processed', { orderId: 'o1', status: PaymentStatus.SUCCESS, transactionId: 't1' });
+      expect(analytics.getEventCount('payment:processed')).toBe(1);
+    });
+
+    it('counts payment:refunded events', async () => {
+      await bus.emit('payment:refunded', { transactionId: 't1', amount: 50 });
+      expect(analytics.getEventCount('payment:refunded')).toBe(1);
+    });
+
+    it('counts cart:created events', async () => {
+      await bus.emit('cart:created', { cartId: 'c1', userId: 'u1' });
+      expect(analytics.getEventCount('cart:created')).toBe(1);
+    });
+  });
+
+  describe('getRevenue', () => {
+    it('returns 0 initially', () => {
+      expect(analytics.getRevenue()).toBe(0);
+    });
+
+    it('tracks revenue from successful payments', async () => {
+      await bus.emit('order:created', { orderId: 'o1', userId: 'u1', cartId: 'c1', total: 100 });
+      await bus.emit('payment:processed', { orderId: 'o1', status: PaymentStatus.SUCCESS, transactionId: 't1' });
+      expect(analytics.getRevenue()).toBe(100);
+    });
+
+    it('does not add revenue for failed payments', async () => {
+      await bus.emit('order:created', { orderId: 'o1', userId: 'u1', cartId: 'c1', total: 100 });
+      await bus.emit('payment:processed', { orderId: 'o1', status: PaymentStatus.FAILED, error: 'declined' });
+      expect(analytics.getRevenue()).toBe(0);
+    });
+
+    it('subtracts refunds from revenue (by transactionId)', async () => {
+      await bus.emit('order:created', { orderId: 'o1', userId: 'u1', cartId: 'c1', total: 100 });
+      await bus.emit('payment:processed', { orderId: 'o1', status: PaymentStatus.SUCCESS, transactionId: 't1' });
+      await bus.emit('payment:refunded', { transactionId: 't1' });
+      expect(analytics.getRevenue()).toBe(0);
+    });
+
+    it('subtracts refunds from revenue (by amount)', async () => {
+      await bus.emit('order:created', { orderId: 'o1', userId: 'u1', cartId: 'c1', total: 100 });
+      await bus.emit('payment:processed', { orderId: 'o1', status: PaymentStatus.SUCCESS, transactionId: 't1' });
+      await bus.emit('payment:refunded', { amount: 100 });
+      expect(analytics.getRevenue()).toBe(0);
+    });
+
+    it('accumulates revenue across multiple orders', async () => {
+      await bus.emit('order:created', { orderId: 'o1', userId: 'u1', cartId: 'c1', total: 100 });
+      await bus.emit('order:created', { orderId: 'o2', userId: 'u2', cartId: 'c2', total: 200 });
+      await bus.emit('payment:processed', { orderId: 'o1', status: PaymentStatus.SUCCESS, transactionId: 't1' });
+      await bus.emit('payment:processed', { orderId: 'o2', status: PaymentStatus.SUCCESS, transactionId: 't2' });
+      expect(analytics.getRevenue()).toBe(300);
+    });
+  });
+
+  describe('getConversionRate', () => {
+    it('returns 0 when no carts exist', () => {
+      expect(analytics.getConversionRate()).toBe(0);
+    });
+
+    it('returns 0 when carts exist but no orders', async () => {
+      await bus.emit('cart:created', { cartId: 'c1', userId: 'u1' });
+      expect(analytics.getConversionRate()).toBe(0);
+    });
+
+    it('calculates orders / unique carts ratio', async () => {
+      await bus.emit('cart:created', { cartId: 'c1', userId: 'u1' });
+      await bus.emit('cart:created', { cartId: 'c2', userId: 'u2' });
+      await bus.emit('order:created', { orderId: 'o1', userId: 'u1', cartId: 'c1', total: 100 });
+      expect(analytics.getConversionRate()).toBe(0.5);
+    });
+
+    it('returns 1.0 when all carts convert', async () => {
+      await bus.emit('cart:created', { cartId: 'c1', userId: 'u1' });
+      await bus.emit('order:created', { orderId: 'o1', userId: 'u1', cartId: 'c1', total: 100 });
+      expect(analytics.getConversionRate()).toBe(1);
+    });
+
+    it('also tracks carts from cart:updated events', async () => {
+      await bus.emit('cart:updated', { cartId: 'c1', userId: 'u1', items: [] });
+      await bus.emit('order:created', { orderId: 'o1', userId: 'u1', cartId: 'c1', total: 100 });
+      expect(analytics.getConversionRate()).toBe(1);
+    });
+  });
+
+  describe('getTopProducts', () => {
+    it('returns empty array when no orders', () => {
+      expect(analytics.getTopProducts(5)).toEqual([]);
+    });
+
+    it('tracks product quantities from orders via cart:updated', async () => {
+      await bus.emit('cart:updated', {
+        cartId: 'c1',
+        userId: 'u1',
+        items: [
+          { productId: 'p1', quantity: 3 },
+          { productId: 'p2', quantity: 1 },
+        ],
+      });
+      await bus.emit('order:created', { orderId: 'o1', userId: 'u1', cartId: 'c1', total: 100 });
+
+      const top = analytics.getTopProducts(10);
+      expect(top).toEqual([
+        { productId: 'p1', count: 3 },
+        { productId: 'p2', count: 1 },
+      ]);
+    });
+
+    it('accumulates quantities across multiple orders', async () => {
+      await bus.emit('cart:updated', {
+        cartId: 'c1',
+        userId: 'u1',
+        items: [{ productId: 'p1', quantity: 2 }],
+      });
+      await bus.emit('order:created', { orderId: 'o1', userId: 'u1', cartId: 'c1', total: 50 });
+
+      await bus.emit('cart:updated', {
+        cartId: 'c2',
+        userId: 'u2',
+        items: [{ productId: 'p1', quantity: 5 }],
+      });
+      await bus.emit('order:created', { orderId: 'o2', userId: 'u2', cartId: 'c2', total: 125 });
+
+      const top = analytics.getTopProducts(10);
+      expect(top).toEqual([{ productId: 'p1', count: 7 }]);
+    });
+
+    it('respects the limit parameter', async () => {
+      await bus.emit('cart:updated', {
+        cartId: 'c1',
+        userId: 'u1',
+        items: [
+          { productId: 'p1', quantity: 10 },
+          { productId: 'p2', quantity: 5 },
+          { productId: 'p3', quantity: 1 },
+        ],
+      });
+      await bus.emit('order:created', { orderId: 'o1', userId: 'u1', cartId: 'c1', total: 100 });
+
+      const top = analytics.getTopProducts(2);
+      expect(top).toHaveLength(2);
+      expect(top[0].productId).toBe('p1');
+      expect(top[1].productId).toBe('p2');
+    });
+
+    it('sorts by quantity descending', async () => {
+      await bus.emit('cart:updated', {
+        cartId: 'c1',
+        userId: 'u1',
+        items: [
+          { productId: 'p1', quantity: 1 },
+          { productId: 'p2', quantity: 10 },
+          { productId: 'p3', quantity: 5 },
+        ],
+      });
+      await bus.emit('order:created', { orderId: 'o1', userId: 'u1', cartId: 'c1', total: 100 });
+
+      const top = analytics.getTopProducts(3);
+      expect(top[0]).toEqual({ productId: 'p2', count: 10 });
+      expect(top[1]).toEqual({ productId: 'p3', count: 5 });
+      expect(top[2]).toEqual({ productId: 'p1', count: 1 });
+    });
+  });
+});
diff --git a/tests/barrel.test.ts b/tests/barrel.test.ts
new file mode 100644
index 0000000..7573ce2
--- /dev/null
+++ b/tests/barrel.test.ts
@@ -0,0 +1,30 @@
+import { describe, it, expect } from 'vitest';
+import * as barrel from '../src/index.js';
+
+describe('Barrel export (src/index.ts)', () => {
+  it('exports EventBus', () => {
+    expect(barrel.EventBus).toBeDefined();
+    expect(typeof barrel.EventBus).toBe('function');
+  });
+
+  it('exports enums', () => {
+    expect(barrel.OrderStatus).toBeDefined();
+    expect(barrel.PaymentStatus).toBeDefined();
+  });
+
+  it('exports Events constants', () => {
+    expect(barrel.Events).toBeDefined();
+    expect(barrel.Events.ORDER_CREATED).toBe('order:created');
+  });
+
+  it('exports all 8 factory functions', () => {
+    expect(typeof barrel.createCatalogService).toBe('function');
+    expect(typeof barrel.createInventoryService).toBe('function');
+    expect(typeof barrel.createCartService).toBe('function');
+    expect(typeof barrel.createPricingService).toBe('function');
+    expect(typeof barrel.createOrdersService).toBe('function');
+    expect(typeof barrel.createPaymentService).toBe('function');
+    expect(typeof barrel.createNotificationsService).toBe('function');
+    expect(typeof barrel.createAnalyticsService).toBe('function');
+  });
+});
diff --git a/tests/pricing-orders.test.ts b/tests/pricing-orders.test.ts
new file mode 100644
index 0000000..d9158d9
--- /dev/null
+++ b/tests/pricing-orders.test.ts
@@ -0,0 +1,195 @@
+import { describe, it, expect, beforeEach } from 'vitest';
+import { EventBus } from '../src/bus.js';
+import { createPricingService } from '../src/pricing/index.js';
+import { createOrdersService } from '../src/orders/index.js';
+import { Events, OrderStatus } from '../src/types.js';
+
+describe('PricingService', () => {
+  let bus: EventBus;
+  let pricing: ReturnType<typeof createPricingService>;
+
+  beforeEach(() => {
+    bus = new EventBus();
+    pricing = createPricingService(bus);
+  });
+
+  it('should track prices from product:created events', async () => {
+    await bus.emit(Events.PRODUCT_CREATED, {
+      productId: 'p1',
+      name: 'Widget',
+      price: 10,
+      category: 'general',
+    });
+    expect(pricing.getPrice('p1')).toBe(10);
+  });
+
+  it('should return 0 for unknown product prices', () => {
+    expect(pricing.getPrice('unknown')).toBe(0);
+  });
+
+  it('should calculate total without discount', () => {
+    const result = pricing.calculateTotal([
+      { productId: 'p1', quantity: 2, price: 10 },
+      { productId: 'p2', quantity: 1, price: 20 },
+    ]);
+    // subtotal = 2*10 + 1*20 = 40
+    // discount = 0
+    // tax = 40 * 0.1 = 4
+    // total = 40 + 4 = 44
+    expect(result.subtotal).toBe(40);
+    expect(result.discount).toBe(0);
+    expect(result.tax).toBe(4);
+    expect(result.total).toBe(44);
+  });
+
+  it('should apply discount code (decimal)', () => {
+    pricing.addDiscountCode('SAVE10', 0.1);
+    const result = pricing.calculateTotal(
+      [{ productId: 'p1', quantity: 2, price: 50 }],
+      'SAVE10',
+    );
+    // subtotal = 100
+    // discount = 100 * 0.1 = 10
+    // discountedSubtotal = 90
+    // tax = 90 * 0.1 = 9
+    // total = 90 + 9 = 99
+    expect(result.subtotal).toBe(100);
+    expect(result.discount).toBe(10);
+    expect(result.tax).toBe(9);
+    expect(result.total).toBe(99);
+  });
+
+  it('should apply discount code (percentage > 1)', () => {
+    pricing.addDiscountCode('SAVE20', 20);
+    const result = pricing.calculateTotal(
+      [{ productId: 'p1', quantity: 1, price: 100 }],
+      'SAVE20',
+    );
+    // subtotal = 100
+    // discount = 100 * 0.2 = 20
+    // discountedSubtotal = 80
+    // tax = 80 * 0.1 = 8
+    // total = 80 + 8 = 88
+    expect(result.subtotal).toBe(100);
+    expect(result.discount).toBe(20);
+    expect(result.tax).toBe(8);
+    expect(result.total).toBe(88);
+  });
+
+  it('should ignore invalid discount codes', () => {
+    const result = pricing.calculateTotal(
+      [{ productId: 'p1', quantity: 1, price: 100 }],
+      'INVALID',
+    );
+    expect(result.discount).toBe(0);
+    expect(result.total).toBe(110);
+  });
+});
+
+describe('OrdersService', () => {
+  let bus: EventBus;
+  let orders: ReturnType<typeof createOrdersService>;
+
+  beforeEach(() => {
+    bus = new EventBus();
+    orders = createOrdersService(bus);
+  });
+
+  it('should create an order with PENDING status', () => {
+    const orderId = orders.createOrder('user1', 'cart1', 100);
+    expect(orderId).toBeTruthy();
+    const order = orders.getOrder(orderId);
+    expect(order).not.toBeNull();
+    expect(order!.userId).toBe('user1');
+    expect(order!.status).toBe(OrderStatus.PENDING);
+    expect(order!.total).toBe(100);
+  });
+
+  it('should emit order:created event', async () => {
+    const events: unknown[] = [];
+    bus.on(Events.ORDER_CREATED, (payload) => {
+      events.push(payload);
+    });
+    orders.createOrder('user1', 'cart1', 50);
+    // bus.emit is async, but createOrder calls it fire-and-forget style
+    // The handler should have been called since we registered before
+    expect(events.length).toBe(1);
+  });
+
+  it('should return null for unknown order', () => {
+    expect(orders.getOrder('nonexistent')).toBeNull();
+  });
+
+  it('should list orders for a user', () => {
+    orders.createOrder('user1', 'cart1', 100);
+    orders.createOrder('user1', 'cart2', 200);
+    orders.createOrder('user2', 'cart3', 300);
+    const user1Orders = orders.listOrders('user1');
+    expect(user1Orders.length).toBe(2);
+    const user2Orders = orders.listOrders('user2');
+    expect(user2Orders.length).toBe(1);
+  });
+
+  it('should allow valid status transitions', () => {
+    const orderId = orders.createOrder('user1', 'cart1', 100);
+    orders.updateStatus(orderId, OrderStatus.CONFIRMED);
+    expect(orders.getOrder(orderId)!.status).toBe(OrderStatus.CONFIRMED);
+
+    orders.updateStatus(orderId, OrderStatus.SHIPPED);
+    expect(orders.getOrder(orderId)!.status).toBe(OrderStatus.SHIPPED);
+
+    orders.updateStatus(orderId, OrderStatus.DELIVERED);
+    expect(orders.getOrder(orderId)!.status).toBe(OrderStatus.DELIVERED);
+  });
+
+  it('should allow cancellation from PENDING', () => {
+    const orderId = orders.createOrder('user1', 'cart1', 100);
+    orders.updateStatus(orderId, OrderStatus.CANCELLED);
+    expect(orders.getOrder(orderId)!.status).toBe(OrderStatus.CANCELLED);
+  });
+
+  it('should allow cancellation from CONFIRMED', () => {
+    const orderId = orders.createOrder('user1', 'cart1', 100);
+    orders.updateStatus(orderId, OrderStatus.CONFIRMED);
+    orders.updateStatus(orderId, OrderStatus.CANCELLED);
+    expect(orders.getOrder(orderId)!.status).toBe(OrderStatus.CANCELLED);
+  });
+
+  it('should reject invalid transitions', () => {
+    const orderId = orders.createOrder('user1', 'cart1', 100);
+    expect(() => orders.updateStatus(orderId, OrderStatus.SHIPPED)).toThrow();
+    expect(() => orders.updateStatus(orderId, OrderStatus.DELIVERED)).toThrow();
+  });
+
+  it('should reject transitions from CANCELLED', () => {
+    const orderId = orders.createOrder('user1', 'cart1', 100);
+    orders.updateStatus(orderId, OrderStatus.CANCELLED);
+    expect(() => orders.updateStatus(orderId, OrderStatus.CONFIRMED)).toThrow();
+  });
+
+  it('should reject transitions from DELIVERED', () => {
+    const orderId = orders.createOrder('user1', 'cart1', 100);
+    orders.updateStatus(orderId, OrderStatus.CONFIRMED);
+    orders.updateStatus(orderId, OrderStatus.SHIPPED);
+    orders.updateStatus(orderId, OrderStatus.DELIVERED);
+    expect(() => orders.updateStatus(orderId, OrderStatus.CANCELLED)).toThrow();
+  });
+
+  it('should emit order:status_changed event with previous status', async () => {
+    const events: unknown[] = [];
+    bus.on(Events.ORDER_STATUS_CHANGED, (payload) => {
+      events.push(payload);
+    });
+    const orderId = orders.createOrder('user1', 'cart1', 100);
+    orders.updateStatus(orderId, OrderStatus.CONFIRMED);
+    expect(events.length).toBe(1);
+    const event = events[0] as { orderId: string; status: string; previousStatus: string };
+    expect(event.orderId).toBe(orderId);
+    expect(event.status).toBe(OrderStatus.CONFIRMED);
+    expect(event.previousStatus).toBe(OrderStatus.PENDING);
+  });
+
+  it('should throw for unknown order updateStatus', () => {
+    expect(() => orders.updateStatus('nonexistent', OrderStatus.CONFIRMED)).toThrow();
+  });
+});
diff --git a/tests/services.test.ts b/tests/services.test.ts
new file mode 100644
index 0000000..d6b9743
--- /dev/null
+++ b/tests/services.test.ts
@@ -0,0 +1,245 @@
+import { describe, it, expect, beforeEach } from 'vitest';
+import { EventBus } from '../src/bus.js';
+import { createCatalogService } from '../src/catalog/index.js';
+import { createInventoryService } from '../src/inventory/index.js';
+import { createCartService } from '../src/cart/index.js';
+import { Events } from '../src/types.js';
+
+describe('CatalogService', () => {
+  let bus: EventBus;
+  let catalog: ReturnType<typeof createCatalogService>;
+
+  beforeEach(() => {
+    bus = new EventBus();
+    catalog = createCatalogService(bus);
+  });
+
+  it('should create a product and return id', () => {
+    const id = catalog.createProduct('Widget', 9.99, 'gadgets');
+    expect(id).toBeTruthy();
+    expect(typeof id).toBe('string');
+  });
+
+  it('should retrieve a product by id', () => {
+    const id = catalog.createProduct('Widget', 9.99, 'gadgets');
+    const product = catalog.getProduct(id);
+    expect(product).toEqual({ id, name: 'Widget', price: 9.99, category: 'gadgets' });
+  });
+
+  it('should return null for unknown product', () => {
+    expect(catalog.getProduct('unknown')).toBeNull();
+  });
+
+  it('should list all products', () => {
+    catalog.createProduct('A', 1, 'cat1');
+    catalog.createProduct('B', 2, 'cat2');
+    expect(catalog.listProducts()).toHaveLength(2);
+  });
+
+  it('should list products filtered by category', () => {
+    catalog.createProduct('A', 1, 'cat1');
+    catalog.createProduct('B', 2, 'cat2');
+    catalog.createProduct('C', 3, 'cat1');
+    const result = catalog.listProducts('cat1');
+    expect(result).toHaveLength(2);
+    expect(result.every(p => p.category === 'cat1')).toBe(true);
+  });
+
+  it('should search products by name', () => {
+    catalog.createProduct('Blue Widget', 5, 'stuff');
+    catalog.createProduct('Red Gadget', 10, 'stuff');
+    const results = catalog.searchProducts('widget');
+    expect(results).toHaveLength(1);
+    expect(results[0].name).toBe('Blue Widget');
+  });
+
+  it('should search products by category', () => {
+    catalog.createProduct('Item', 5, 'electronics');
+    const results = catalog.searchProducts('electron');
+    expect(results).toHaveLength(1);
+  });
+
+  it('should update product fields', () => {
+    const id = catalog.createProduct('Widget', 9.99, 'gadgets');
+    catalog.updateProduct(id, { name: 'Super Widget', price: 19.99 });
+    const product = catalog.getProduct(id);
+    expect(product?.name).toBe('Super Widget');
+    expect(product?.price).toBe(19.99);
+    expect(product?.category).toBe('gadgets');
+  });
+
+  it('should remove a product', () => {
+    const id = catalog.createProduct('Widget', 9.99, 'gadgets');
+    expect(catalog.removeProduct(id)).toBe(true);
+    expect(catalog.getProduct(id)).toBeNull();
+    expect(catalog.removeProduct(id)).toBe(false);
+  });
+
+  it('should emit product:created event', async () => {
+    const events: unknown[] = [];
+    bus.on(Events.PRODUCT_CREATED, (payload) => { events.push(payload); });
+    catalog.createProduct('Widget', 9.99, 'gadgets');
+    // emit is async but we fire-and-forget with void, need to wait a tick
+    await new Promise(r => setTimeout(r, 10));
+    expect(events).toHaveLength(1);
+    expect(events[0]).toMatchObject({ name: 'Widget', price: 9.99, category: 'gadgets' });
+  });
+});
+
+describe('InventoryService', () => {
+  let bus: EventBus;
+  let inventory: ReturnType<typeof createInventoryService>;
+
+  beforeEach(() => {
+    bus = new EventBus();
+    inventory = createInventoryService(bus);
+  });
+
+  it('should set and get stock', () => {
+    inventory.setStock('p1', 100);
+    expect(inventory.getStock('p1')).toBe(100);
+  });
+
+  it('should return 0 for unknown product stock', () => {
+    expect(inventory.getStock('unknown')).toBe(0);
+  });
+
+  it('should reserve stock successfully', () => {
+    inventory.setStock('p1', 10);
+    expect(inventory.reserve('p1', 5)).toBe(true);
+    expect(inventory.getStock('p1')).toBe(5);
+  });
+
+  it('should fail to reserve insufficient stock', () => {
+    inventory.setStock('p1', 3);
+    expect(inventory.reserve('p1', 5)).toBe(false);
+    expect(inventory.getStock('p1')).toBe(3);
+  });
+
+  it('should release reserved stock', () => {
+    inventory.setStock('p1', 10);
+    inventory.reserve('p1', 5);
+    inventory.release('p1', 3);
+    expect(inventory.getStock('p1')).toBe(8);
+  });
+
+  it('should emit low stock event when stock falls below threshold', async () => {
+    const events: unknown[] = [];
+    bus.on(Events.LOW_STOCK_ALERT, (payload) => { events.push(payload); });
+
+    inventory.setStock('p1', 10);
+    inventory.setLowStockThreshold('p1', 5);
+
+    // Stock is 10, threshold 5 â€” no alert yet
+    await new Promise(r => setTimeout(r, 10));
+    expect(events).toHaveLength(0);
+
+    // Reserve to bring stock below threshold
+    inventory.reserve('p1', 7);
+    await new Promise(r => setTimeout(r, 10));
+    expect(events).toHaveLength(1);
+    expect(events[0]).toMatchObject({ productId: 'p1', currentQuantity: 3, threshold: 5 });
+  });
+
+  it('should emit low stock event on setStock if below threshold', async () => {
+    const events: unknown[] = [];
+    bus.on(Events.LOW_STOCK_ALERT, (payload) => { events.push(payload); });
+
+    inventory.setStock('p1', 10); // start above threshold
+    inventory.setLowStockThreshold('p1', 5); // no alert since 10 >= 5
+    await new Promise(r => setTimeout(r, 10));
+    expect(events).toHaveLength(0);
+
+    inventory.setStock('p1', 2); // now below threshold
+    await new Promise(r => setTimeout(r, 10));
+    expect(events).toHaveLength(1);
+    expect(events[0]).toMatchObject({ productId: 'p1', currentQuantity: 2, threshold: 5 });
+  });
+
+  it('should emit low stock when setting threshold above current stock', async () => {
+    const events: unknown[] = [];
+    bus.on(Events.LOW_STOCK_ALERT, (payload) => { events.push(payload); });
+
+    inventory.setStock('p1', 3);
+    inventory.setLowStockThreshold('p1', 10);
+    await new Promise(r => setTimeout(r, 10));
+    expect(events).toHaveLength(1);
+  });
+});
+
+describe('CartService', () => {
+  let bus: EventBus;
+  let cart: ReturnType<typeof createCartService>;
+
+  beforeEach(() => {
+    bus = new EventBus();
+    cart = createCartService(bus);
+  });
+
+  it('should create a cart and return cartId', () => {
+    const cartId = cart.createCart('user1');
+    expect(cartId).toBeTruthy();
+  });
+
+  it('should emit cart:created event', async () => {
+    const events: unknown[] = [];
+    bus.on('cart:created', (payload) => { events.push(payload); });
+    const cartId = cart.createCart('user1');
+    await new Promise(r => setTimeout(r, 10));
+    expect(events).toHaveLength(1);
+    expect(events[0]).toMatchObject({ cartId, userId: 'user1' });
+  });
+
+  it('should add items to cart', () => {
+    const cartId = cart.createCart('user1');
+    cart.addItem(cartId, 'prod1', 2);
+    const result = cart.getCart(cartId);
+    expect(result?.items).toEqual([{ productId: 'prod1', quantity: 2 }]);
+  });
+
+  it('should consolidate quantities for same product', () => {
+    const cartId = cart.createCart('user1');
+    cart.addItem(cartId, 'prod1', 2);
+    cart.addItem(cartId, 'prod1', 3);
+    const result = cart.getCart(cartId);
+    expect(result?.items).toEqual([{ productId: 'prod1', quantity: 5 }]);
+  });
+
+  it('should remove an item from cart', () => {
+    const cartId = cart.createCart('user1');
+    cart.addItem(cartId, 'prod1', 2);
+    cart.addItem(cartId, 'prod2', 1);
+    cart.removeItem(cartId, 'prod1');
+    const result = cart.getCart(cartId);
+    expect(result?.items).toEqual([{ productId: 'prod2', quantity: 1 }]);
+  });
+
+  it('should update item quantity', () => {
+    const cartId = cart.createCart('user1');
+    cart.addItem(cartId, 'prod1', 2);
+    cart.updateQuantity(cartId, 'prod1', 10);
+    const result = cart.getCart(cartId);
+    expect(result?.items).toEqual([{ productId: 'prod1', quantity: 10 }]);
+  });
+
+  it('should clear cart', () => {
+    const cartId = cart.createCart('user1');
+    cart.addItem(cartId, 'prod1', 2);
+    cart.clearCart(cartId);
+    const result = cart.getCart(cartId);
+    expect(result?.items).toEqual([]);
+  });
+
+  it('should return null for unknown cart', () => {
+    expect(cart.getCart('unknown')).toBeNull();
+  });
+
+  it('should return a copy of items, not mutable reference', () => {
+    const cartId = cart.createCart('user1');
+    cart.addItem(cartId, 'prod1', 2);
+    const result1 = cart.getCart(cartId);
+    result1!.items.push({ productId: 'prod2', quantity: 99 });
+    const result2 = cart.getCart(cartId);
+    expect(result2?.items).toHaveLength(1);
+  });
+});
