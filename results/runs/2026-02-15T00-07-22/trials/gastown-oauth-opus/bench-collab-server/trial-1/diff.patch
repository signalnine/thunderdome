diff --git a/.runtime/agent.lock b/.runtime/agent.lock
new file mode 100644
index 0000000..89e69fe
--- /dev/null
+++ b/.runtime/agent.lock
@@ -0,0 +1,6 @@
+{
+  "pid": 901,
+  "acquired_at": "2026-02-15T00:07:26.673917522Z",
+  "session_id": "bench/rust",
+  "hostname": "d83f948f2f00"
+}
\ No newline at end of file
diff --git a/.thunderdome-metrics.json b/.thunderdome-metrics.json
new file mode 100644
index 0000000..b32f74f
--- /dev/null
+++ b/.thunderdome-metrics.json
@@ -0,0 +1,19 @@
+{
+  "input_tokens": 72,
+  "output_tokens": 55508,
+  "cache_read_tokens": 3671062,
+  "cache_creation_tokens": 111617,
+  "turns": 78,
+  "tools_used": [
+    "Task",
+    "Bash",
+    "Read",
+    "TodoWrite",
+    "Write",
+    "Edit",
+    "Glob",
+    "TaskOutput"
+  ],
+  "duration_ms": 994569,
+  "total_cost_usd": 4.029685999999998
+}
\ No newline at end of file
diff --git a/package-lock.json b/package-lock.json
index b36b372..6f03430 100644
--- a/package-lock.json
+++ b/package-lock.json
@@ -19,12 +19,84 @@
         "@types/ws": "^8.5.0",
         "@typescript-eslint/eslint-plugin": "^7.0.0",
         "@typescript-eslint/parser": "^7.0.0",
+        "@vitest/coverage-v8": "^2.0.0",
         "eslint": "^8.56.0",
         "supertest": "^7.0.0",
         "typescript": "^5.4.0",
         "vitest": "^2.0.0"
       }
     },
+    "node_modules/@ampproject/remapping": {
+      "version": "2.3.0",
+      "resolved": "https://registry.npmjs.org/@ampproject/remapping/-/remapping-2.3.0.tgz",
+      "integrity": "sha512-30iZtAPgz+LTIYoeivqYo853f02jBYSd5uGnGpkFV0M3xOt9aN73erkgYAmZU43x4VfqcnLxW9Kpg3R5LC4YYw==",
+      "dev": true,
+      "license": "Apache-2.0",
+      "dependencies": {
+        "@jridgewell/gen-mapping": "^0.3.5",
+        "@jridgewell/trace-mapping": "^0.3.24"
+      },
+      "engines": {
+        "node": ">=6.0.0"
+      }
+    },
+    "node_modules/@babel/helper-string-parser": {
+      "version": "7.27.1",
+      "resolved": "https://registry.npmjs.org/@babel/helper-string-parser/-/helper-string-parser-7.27.1.tgz",
+      "integrity": "sha512-qMlSxKbpRlAridDExk92nSobyDdpPijUq2DW6oDnUqd0iOGxmQjyqhMIihI9+zv4LPyZdRje2cavWPbCbWm3eA==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=6.9.0"
+      }
+    },
+    "node_modules/@babel/helper-validator-identifier": {
+      "version": "7.28.5",
+      "resolved": "https://registry.npmjs.org/@babel/helper-validator-identifier/-/helper-validator-identifier-7.28.5.tgz",
+      "integrity": "sha512-qSs4ifwzKJSV39ucNjsvc6WVHs6b7S03sOh2OcHF9UHfVPqWWALUsNUVzhSBiItjRZoLHx7nIarVjqKVusUZ1Q==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=6.9.0"
+      }
+    },
+    "node_modules/@babel/parser": {
+      "version": "7.29.0",
+      "resolved": "https://registry.npmjs.org/@babel/parser/-/parser-7.29.0.tgz",
+      "integrity": "sha512-IyDgFV5GeDUVX4YdF/3CPULtVGSXXMLh1xVIgdCgxApktqnQV0r7/8Nqthg+8YLGaAtdyIlo2qIdZrbCv4+7ww==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@babel/types": "^7.29.0"
+      },
+      "bin": {
+        "parser": "bin/babel-parser.js"
+      },
+      "engines": {
+        "node": ">=6.0.0"
+      }
+    },
+    "node_modules/@babel/types": {
+      "version": "7.29.0",
+      "resolved": "https://registry.npmjs.org/@babel/types/-/types-7.29.0.tgz",
+      "integrity": "sha512-LwdZHpScM4Qz8Xw2iKSzS+cfglZzJGvofQICy7W7v4caru4EaAmyUuO6BGrbyQ2mYV11W0U8j5mBhd14dd3B0A==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@babel/helper-string-parser": "^7.27.1",
+        "@babel/helper-validator-identifier": "^7.28.5"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      }
+    },
+    "node_modules/@bcoe/v8-coverage": {
+      "version": "0.2.3",
+      "resolved": "https://registry.npmjs.org/@bcoe/v8-coverage/-/v8-coverage-0.2.3.tgz",
+      "integrity": "sha512-0hYQ8SB4Db5zvZB4axdMHGwEaQjkZzFjQiN9LVYvIFB2nSUHW9tYpxWriPrWDASIxiaXax83REcLxuSdnGPZtw==",
+      "dev": true,
+      "license": "MIT"
+    },
     "node_modules/@esbuild/aix-ppc64": {
       "version": "0.21.5",
       "resolved": "https://registry.npmjs.org/@esbuild/aix-ppc64/-/aix-ppc64-0.21.5.tgz",
@@ -565,6 +637,84 @@
       "dev": true,
       "license": "BSD-3-Clause"
     },
+    "node_modules/@isaacs/cliui": {
+      "version": "8.0.2",
+      "resolved": "https://registry.npmjs.org/@isaacs/cliui/-/cliui-8.0.2.tgz",
+      "integrity": "sha512-O8jcjabXaleOG9DQ0+ARXWZBTfnP4WNAqzuiJK7ll44AmxGKv/J2M4TPjxjY3znBCfvBXFzucm1twdyFybFqEA==",
+      "dev": true,
+      "license": "ISC",
+      "dependencies": {
+        "string-width": "^5.1.2",
+        "string-width-cjs": "npm:string-width@^4.2.0",
+        "strip-ansi": "^7.0.1",
+        "strip-ansi-cjs": "npm:strip-ansi@^6.0.1",
+        "wrap-ansi": "^8.1.0",
+        "wrap-ansi-cjs": "npm:wrap-ansi@^7.0.0"
+      },
+      "engines": {
+        "node": ">=12"
+      }
+    },
+    "node_modules/@isaacs/cliui/node_modules/ansi-regex": {
+      "version": "6.2.2",
+      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-6.2.2.tgz",
+      "integrity": "sha512-Bq3SmSpyFHaWjPk8If9yc6svM8c56dB5BAtW4Qbw5jHTwwXXcTLoRMkpDJp6VL0XzlWaCHTXrkFURMYmD0sLqg==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/ansi-regex?sponsor=1"
+      }
+    },
+    "node_modules/@isaacs/cliui/node_modules/strip-ansi": {
+      "version": "7.1.2",
+      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-7.1.2.tgz",
+      "integrity": "sha512-gmBGslpoQJtgnMAvOVqGZpEz9dyoKTCzy2nfz/n8aIFhN/jCE/rCmcxabB6jOOHV+0WNnylOxaxBQPSvcWklhA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "ansi-regex": "^6.0.1"
+      },
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/strip-ansi?sponsor=1"
+      }
+    },
+    "node_modules/@istanbuljs/schema": {
+      "version": "0.1.3",
+      "resolved": "https://registry.npmjs.org/@istanbuljs/schema/-/schema-0.1.3.tgz",
+      "integrity": "sha512-ZXRY4jNvVgSVQ8DL3LTcakaAtXwTVUxE81hslsyD2AtoXW/wVob10HkOJ1X/pAlcI7D+2YoZKg5do8G/w6RYgA==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/@jridgewell/gen-mapping": {
+      "version": "0.3.13",
+      "resolved": "https://registry.npmjs.org/@jridgewell/gen-mapping/-/gen-mapping-0.3.13.tgz",
+      "integrity": "sha512-2kkt/7niJ6MgEPxF0bYdQ6etZaA+fQvDcLKckhy1yIQOzaoKjBBjSj63/aLVjYE3qhRt5dvM+uUyfCg6UKCBbA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@jridgewell/sourcemap-codec": "^1.5.0",
+        "@jridgewell/trace-mapping": "^0.3.24"
+      }
+    },
+    "node_modules/@jridgewell/resolve-uri": {
+      "version": "3.1.2",
+      "resolved": "https://registry.npmjs.org/@jridgewell/resolve-uri/-/resolve-uri-3.1.2.tgz",
+      "integrity": "sha512-bRISgCIjP20/tbWSPWMEi54QVPRZExkuD9lJL+UIxUKtwVJA8wW1Trb1jMs1RFXo1CBTNZ/5hpC9QvmKWdopKw==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=6.0.0"
+      }
+    },
     "node_modules/@jridgewell/sourcemap-codec": {
       "version": "1.5.5",
       "resolved": "https://registry.npmjs.org/@jridgewell/sourcemap-codec/-/sourcemap-codec-1.5.5.tgz",
@@ -572,6 +722,17 @@
       "dev": true,
       "license": "MIT"
     },
+    "node_modules/@jridgewell/trace-mapping": {
+      "version": "0.3.31",
+      "resolved": "https://registry.npmjs.org/@jridgewell/trace-mapping/-/trace-mapping-0.3.31.tgz",
+      "integrity": "sha512-zzNR+SdQSDJzc8joaeP8QQoCQr8NuYx2dIIytl1QeBEZHJ9uW6hebsrYgbz8hJwUQao3TWCMtmfV8Nu1twOLAw==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@jridgewell/resolve-uri": "^3.1.0",
+        "@jridgewell/sourcemap-codec": "^1.4.14"
+      }
+    },
     "node_modules/@noble/hashes": {
       "version": "1.8.0",
       "resolved": "https://registry.npmjs.org/@noble/hashes/-/hashes-1.8.0.tgz",
@@ -633,6 +794,17 @@
         "@noble/hashes": "^1.1.5"
       }
     },
+    "node_modules/@pkgjs/parseargs": {
+      "version": "0.11.0",
+      "resolved": "https://registry.npmjs.org/@pkgjs/parseargs/-/parseargs-0.11.0.tgz",
+      "integrity": "sha512-+1VkjdD0QBLPodGrJUeqarH8VAIvQODIbwh9XpP5Syisf7YoQgsJKPNFoqqLQlu+VQ/tVSshMR6loPMn8U+dPg==",
+      "dev": true,
+      "license": "MIT",
+      "optional": true,
+      "engines": {
+        "node": ">=14"
+      }
+    },
     "node_modules/@rollup/rollup-android-arm-eabi": {
       "version": "4.57.1",
       "resolved": "https://registry.npmjs.org/@rollup/rollup-android-arm-eabi/-/rollup-android-arm-eabi-4.57.1.tgz",
@@ -1081,7 +1253,6 @@
       "integrity": "sha512-m0jEgYlYz+mDJZ2+F4v8D1AyQb+QzsNqRuI7xg1VQX/KlKS0qT9r1Mo16yo5F/MtifXFgaofIFsdFMox2SxIbQ==",
       "dev": true,
       "license": "MIT",
-      "peer": true,
       "dependencies": {
         "undici-types": "~7.16.0"
       }
@@ -1207,7 +1378,6 @@
       "integrity": "sha512-4Z+L8I2OqhZV8qA132M4wNL30ypZGYOQVBfMgxDH/K5UX0PNqTu1c6za9ST5r9+tavvHiTWmBnKzpCJ/GlVFtg==",
       "dev": true,
       "license": "BSD-2-Clause",
-      "peer": true,
       "dependencies": {
         "@typescript-eslint/scope-manager": "7.18.0",
         "@typescript-eslint/types": "7.18.0",
@@ -1368,6 +1538,39 @@
       "dev": true,
       "license": "ISC"
     },
+    "node_modules/@vitest/coverage-v8": {
+      "version": "2.1.9",
+      "resolved": "https://registry.npmjs.org/@vitest/coverage-v8/-/coverage-v8-2.1.9.tgz",
+      "integrity": "sha512-Z2cOr0ksM00MpEfyVE8KXIYPEcBFxdbLSs56L8PO0QQMxt/6bDj45uQfxoc96v05KW3clk7vvgP0qfDit9DmfQ==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@ampproject/remapping": "^2.3.0",
+        "@bcoe/v8-coverage": "^0.2.3",
+        "debug": "^4.3.7",
+        "istanbul-lib-coverage": "^3.2.2",
+        "istanbul-lib-report": "^3.0.1",
+        "istanbul-lib-source-maps": "^5.0.6",
+        "istanbul-reports": "^3.1.7",
+        "magic-string": "^0.30.12",
+        "magicast": "^0.3.5",
+        "std-env": "^3.8.0",
+        "test-exclude": "^7.0.1",
+        "tinyrainbow": "^1.2.0"
+      },
+      "funding": {
+        "url": "https://opencollective.com/vitest"
+      },
+      "peerDependencies": {
+        "@vitest/browser": "2.1.9",
+        "vitest": "2.1.9"
+      },
+      "peerDependenciesMeta": {
+        "@vitest/browser": {
+          "optional": true
+        }
+      }
+    },
     "node_modules/@vitest/expect": {
       "version": "2.1.9",
       "resolved": "https://registry.npmjs.org/@vitest/expect/-/expect-2.1.9.tgz",
@@ -1500,7 +1703,6 @@
       "integrity": "sha512-NZyJarBfL7nWwIq+FDL6Zp/yHEhePMNnnJ0y3qfieCrmNvYct8uvtiV41UvlSe6apAfk0fY1FbWx+NwfmpvtTg==",
       "dev": true,
       "license": "MIT",
-      "peer": true,
       "bin": {
         "acorn": "bin/acorn"
       },
@@ -2116,12 +2318,26 @@
         "node": ">= 0.4"
       }
     },
+    "node_modules/eastasianwidth": {
+      "version": "0.2.0",
+      "resolved": "https://registry.npmjs.org/eastasianwidth/-/eastasianwidth-0.2.0.tgz",
+      "integrity": "sha512-I88TYZWc9XiYHRQ4/3c5rjjfgkjhLyW2luGIheGERbNQ6OY7yTybanSpDXZa8y7VUP9YmDcYa+eyq4ca7iLqWA==",
+      "dev": true,
+      "license": "MIT"
+    },
     "node_modules/ee-first": {
       "version": "1.1.1",
       "resolved": "https://registry.npmjs.org/ee-first/-/ee-first-1.1.1.tgz",
       "integrity": "sha512-WMwm9LhRUo+WUaRN+vRuETqG89IgZphVSNkdFgeb6sS/E4OrDIN7t48CAewSHXc6C8lefD8KKfr5vY61brQlow==",
       "license": "MIT"
     },
+    "node_modules/emoji-regex": {
+      "version": "9.2.2",
+      "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-9.2.2.tgz",
+      "integrity": "sha512-L18DaJsXSUk2+42pv8mLs5jJT2hqFkFE4j21wOmgbUqsZ2hL72NsUU785g9RXgo3s0ZNgVl42TiHp3ZtOv/Vyg==",
+      "dev": true,
+      "license": "MIT"
+    },
     "node_modules/encodeurl": {
       "version": "2.0.0",
       "resolved": "https://registry.npmjs.org/encodeurl/-/encodeurl-2.0.0.tgz",
@@ -2258,7 +2474,6 @@
       "deprecated": "This version is no longer supported. Please see https://eslint.org/version-support for other options.",
       "dev": true,
       "license": "MIT",
-      "peer": true,
       "dependencies": {
         "@eslint-community/eslint-utils": "^4.2.0",
         "@eslint-community/regexpp": "^4.6.1",
@@ -2698,6 +2913,23 @@
       "dev": true,
       "license": "ISC"
     },
+    "node_modules/foreground-child": {
+      "version": "3.3.1",
+      "resolved": "https://registry.npmjs.org/foreground-child/-/foreground-child-3.3.1.tgz",
+      "integrity": "sha512-gIXjKqtFuWEgzFRJA9WCQeSJLZDjgJUOMCMzxtvFq/37KojM1BFGufqsCy0r4qSQmYLsZYMeyRqzIWOMup03sw==",
+      "dev": true,
+      "license": "ISC",
+      "dependencies": {
+        "cross-spawn": "^7.0.6",
+        "signal-exit": "^4.0.1"
+      },
+      "engines": {
+        "node": ">=14"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/isaacs"
+      }
+    },
     "node_modules/form-data": {
       "version": "4.0.5",
       "resolved": "https://registry.npmjs.org/form-data/-/form-data-4.0.5.tgz",
@@ -2996,6 +3228,13 @@
         "node": ">= 0.4"
       }
     },
+    "node_modules/html-escaper": {
+      "version": "2.0.2",
+      "resolved": "https://registry.npmjs.org/html-escaper/-/html-escaper-2.0.2.tgz",
+      "integrity": "sha512-H2iMtd0I4Mt5eYiapRdIDjp+XzelXQ0tFE4JS7YFwFevXXMmOp9myNrUvCg0D6ws8iqkRPBfKHgbwig1SmlLfg==",
+      "dev": true,
+      "license": "MIT"
+    },
     "node_modules/http-errors": {
       "version": "2.0.1",
       "resolved": "https://registry.npmjs.org/http-errors/-/http-errors-2.0.1.tgz",
@@ -3128,6 +3367,16 @@
         "node": ">=0.10.0"
       }
     },
+    "node_modules/is-fullwidth-code-point": {
+      "version": "3.0.0",
+      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/is-fullwidth-code-point-3.0.0.tgz",
+      "integrity": "sha512-zymm5+u+sCsSWyD9qNaejV3DFvhCKclKdizYaJUuHA83RLjb7nSuGnddCHGv0hk+KY7BMAlsWeK4Ueg6EV6XQg==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=8"
+      }
+    },
     "node_modules/is-glob": {
       "version": "4.0.3",
       "resolved": "https://registry.npmjs.org/is-glob/-/is-glob-4.0.3.tgz",
@@ -3168,6 +3417,76 @@
       "dev": true,
       "license": "ISC"
     },
+    "node_modules/istanbul-lib-coverage": {
+      "version": "3.2.2",
+      "resolved": "https://registry.npmjs.org/istanbul-lib-coverage/-/istanbul-lib-coverage-3.2.2.tgz",
+      "integrity": "sha512-O8dpsF+r0WV/8MNRKfnmrtCWhuKjxrq2w+jpzBL5UZKTi2LeVWnWOmWRxFlesJONmc+wLAGvKQZEOanko0LFTg==",
+      "dev": true,
+      "license": "BSD-3-Clause",
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/istanbul-lib-report": {
+      "version": "3.0.1",
+      "resolved": "https://registry.npmjs.org/istanbul-lib-report/-/istanbul-lib-report-3.0.1.tgz",
+      "integrity": "sha512-GCfE1mtsHGOELCU8e/Z7YWzpmybrx/+dSTfLrvY8qRmaY6zXTKWn6WQIjaAFw069icm6GVMNkgu0NzI4iPZUNw==",
+      "dev": true,
+      "license": "BSD-3-Clause",
+      "dependencies": {
+        "istanbul-lib-coverage": "^3.0.0",
+        "make-dir": "^4.0.0",
+        "supports-color": "^7.1.0"
+      },
+      "engines": {
+        "node": ">=10"
+      }
+    },
+    "node_modules/istanbul-lib-source-maps": {
+      "version": "5.0.6",
+      "resolved": "https://registry.npmjs.org/istanbul-lib-source-maps/-/istanbul-lib-source-maps-5.0.6.tgz",
+      "integrity": "sha512-yg2d+Em4KizZC5niWhQaIomgf5WlL4vOOjZ5xGCmF8SnPE/mDWWXgvRExdcpCgh9lLRRa1/fSYp2ymmbJ1pI+A==",
+      "dev": true,
+      "license": "BSD-3-Clause",
+      "dependencies": {
+        "@jridgewell/trace-mapping": "^0.3.23",
+        "debug": "^4.1.1",
+        "istanbul-lib-coverage": "^3.0.0"
+      },
+      "engines": {
+        "node": ">=10"
+      }
+    },
+    "node_modules/istanbul-reports": {
+      "version": "3.2.0",
+      "resolved": "https://registry.npmjs.org/istanbul-reports/-/istanbul-reports-3.2.0.tgz",
+      "integrity": "sha512-HGYWWS/ehqTV3xN10i23tkPkpH46MLCIMFNCaaKNavAXTF1RkqxawEPtnjnGZ6XKSInBKkiOA5BKS+aZiY3AvA==",
+      "dev": true,
+      "license": "BSD-3-Clause",
+      "dependencies": {
+        "html-escaper": "^2.0.0",
+        "istanbul-lib-report": "^3.0.0"
+      },
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/jackspeak": {
+      "version": "3.4.3",
+      "resolved": "https://registry.npmjs.org/jackspeak/-/jackspeak-3.4.3.tgz",
+      "integrity": "sha512-OGlZQpz2yfahA/Rd1Y8Cd9SIEsqvXkLVoSw/cgwhnhFMDbsQFeZYoJJ7bIZBS9BcamUW96asq/npPWugM+RQBw==",
+      "dev": true,
+      "license": "BlueOak-1.0.0",
+      "dependencies": {
+        "@isaacs/cliui": "^8.0.2"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/isaacs"
+      },
+      "optionalDependencies": {
+        "@pkgjs/parseargs": "^0.11.0"
+      }
+    },
     "node_modules/js-yaml": {
       "version": "4.1.1",
       "resolved": "https://registry.npmjs.org/js-yaml/-/js-yaml-4.1.1.tgz",
@@ -3256,6 +3575,13 @@
       "dev": true,
       "license": "MIT"
     },
+    "node_modules/lru-cache": {
+      "version": "10.4.3",
+      "resolved": "https://registry.npmjs.org/lru-cache/-/lru-cache-10.4.3.tgz",
+      "integrity": "sha512-JNAzZcXrCt42VGLuYz0zfAzDfAvJWW6AfYlDBQyDV5DClI2m5sAmK+OIO7s59XfsRsWHp02jAJrRadPRGTt6SQ==",
+      "dev": true,
+      "license": "ISC"
+    },
     "node_modules/magic-string": {
       "version": "0.30.21",
       "resolved": "https://registry.npmjs.org/magic-string/-/magic-string-0.30.21.tgz",
@@ -3266,6 +3592,34 @@
         "@jridgewell/sourcemap-codec": "^1.5.5"
       }
     },
+    "node_modules/magicast": {
+      "version": "0.3.5",
+      "resolved": "https://registry.npmjs.org/magicast/-/magicast-0.3.5.tgz",
+      "integrity": "sha512-L0WhttDl+2BOsybvEOLK7fW3UA0OQ0IQ2d6Zl2x/a6vVRs3bAY0ECOSHHeL5jD+SbOpOCUEi0y1DgHEn9Qn1AQ==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@babel/parser": "^7.25.4",
+        "@babel/types": "^7.25.4",
+        "source-map-js": "^1.2.0"
+      }
+    },
+    "node_modules/make-dir": {
+      "version": "4.0.0",
+      "resolved": "https://registry.npmjs.org/make-dir/-/make-dir-4.0.0.tgz",
+      "integrity": "sha512-hXdUTZYIVOt1Ex//jAQi+wTZZpUpwBj/0QsOzqegb3rGMMeJiSEu5xLHnYfBrRV4RH2+OCSOO95Is/7x1WJ4bw==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "semver": "^7.5.3"
+      },
+      "engines": {
+        "node": ">=10"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/sindresorhus"
+      }
+    },
     "node_modules/math-intrinsics": {
       "version": "1.1.0",
       "resolved": "https://registry.npmjs.org/math-intrinsics/-/math-intrinsics-1.1.0.tgz",
@@ -3396,6 +3750,16 @@
         "url": "https://github.com/sponsors/ljharb"
       }
     },
+    "node_modules/minipass": {
+      "version": "7.1.2",
+      "resolved": "https://registry.npmjs.org/minipass/-/minipass-7.1.2.tgz",
+      "integrity": "sha512-qOOzS1cBTWYF4BH8fVePDBOO9iptMnGUEZwNc/cMWnTV2nVLZ7VoNWEPHkYczZA0pdoA7dl6e7FL659nX9S2aw==",
+      "dev": true,
+      "license": "ISC",
+      "engines": {
+        "node": ">=16 || 14 >=14.17"
+      }
+    },
     "node_modules/mkdirp-classic": {
       "version": "0.5.3",
       "resolved": "https://registry.npmjs.org/mkdirp-classic/-/mkdirp-classic-0.5.3.tgz",
@@ -3544,6 +3908,13 @@
         "url": "https://github.com/sponsors/sindresorhus"
       }
     },
+    "node_modules/package-json-from-dist": {
+      "version": "1.0.1",
+      "resolved": "https://registry.npmjs.org/package-json-from-dist/-/package-json-from-dist-1.0.1.tgz",
+      "integrity": "sha512-UEZIS3/by4OC8vL3P2dTXRETpebLI2NiI5vIrjaD/5UtrkFX/tNbwjTSRAGC/+7CAo2pIcBaRgWmcBBHcsaCIw==",
+      "dev": true,
+      "license": "BlueOak-1.0.0"
+    },
     "node_modules/parent-module": {
       "version": "1.0.1",
       "resolved": "https://registry.npmjs.org/parent-module/-/parent-module-1.0.1.tgz",
@@ -3596,6 +3967,23 @@
         "node": ">=8"
       }
     },
+    "node_modules/path-scurry": {
+      "version": "1.11.1",
+      "resolved": "https://registry.npmjs.org/path-scurry/-/path-scurry-1.11.1.tgz",
+      "integrity": "sha512-Xa4Nw17FS9ApQFJ9umLiJS4orGjm7ZzwUrwamcGQuHSzDyth9boKDaycYdDcZDuqYATXw4HFXgaqWTctW/v1HA==",
+      "dev": true,
+      "license": "BlueOak-1.0.0",
+      "dependencies": {
+        "lru-cache": "^10.2.0",
+        "minipass": "^5.0.0 || ^6.0.2 || ^7.0.0"
+      },
+      "engines": {
+        "node": ">=16 || 14 >=14.18"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/isaacs"
+      }
+    },
     "node_modules/path-to-regexp": {
       "version": "0.1.12",
       "resolved": "https://registry.npmjs.org/path-to-regexp/-/path-to-regexp-0.1.12.tgz",
@@ -4152,6 +4540,19 @@
       "dev": true,
       "license": "ISC"
     },
+    "node_modules/signal-exit": {
+      "version": "4.1.0",
+      "resolved": "https://registry.npmjs.org/signal-exit/-/signal-exit-4.1.0.tgz",
+      "integrity": "sha512-bzyZ1e88w9O1iNJbKnOlvYTrWPDl46O1bG0D3XInv+9tkPrxrN8jUUTiFlDkkmKWgn1M6CfIA13SuGqOa9Korw==",
+      "dev": true,
+      "license": "ISC",
+      "engines": {
+        "node": ">=14"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/isaacs"
+      }
+    },
     "node_modules/simple-concat": {
       "version": "1.0.1",
       "resolved": "https://registry.npmjs.org/simple-concat/-/simple-concat-1.0.1.tgz",
@@ -4249,6 +4650,76 @@
         "safe-buffer": "~5.2.0"
       }
     },
+    "node_modules/string-width": {
+      "version": "5.1.2",
+      "resolved": "https://registry.npmjs.org/string-width/-/string-width-5.1.2.tgz",
+      "integrity": "sha512-HnLOCR3vjcY8beoNLtcjZ5/nxn2afmME6lhrDrebokqMap+XbeW8n9TXpPDOqdGK5qcI3oT0GKTW6wC7EMiVqA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "eastasianwidth": "^0.2.0",
+        "emoji-regex": "^9.2.2",
+        "strip-ansi": "^7.0.1"
+      },
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/sindresorhus"
+      }
+    },
+    "node_modules/string-width-cjs": {
+      "name": "string-width",
+      "version": "4.2.3",
+      "resolved": "https://registry.npmjs.org/string-width/-/string-width-4.2.3.tgz",
+      "integrity": "sha512-wKyQRQpjJ0sIp62ErSZdGsjMJWsap5oRNihHhu6G7JVO/9jIB6UyevL+tXuOqrng8j/cxKTWyWUwvSTriiZz/g==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "emoji-regex": "^8.0.0",
+        "is-fullwidth-code-point": "^3.0.0",
+        "strip-ansi": "^6.0.1"
+      },
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/string-width-cjs/node_modules/emoji-regex": {
+      "version": "8.0.0",
+      "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-8.0.0.tgz",
+      "integrity": "sha512-MSjYzcWNOA0ewAHpz0MxpYFvwg6yjy1NG3xteoqz644VCo/RPgnr1/GGt+ic3iJTzQ8Eu3TdM14SawnVUmGE6A==",
+      "dev": true,
+      "license": "MIT"
+    },
+    "node_modules/string-width/node_modules/ansi-regex": {
+      "version": "6.2.2",
+      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-6.2.2.tgz",
+      "integrity": "sha512-Bq3SmSpyFHaWjPk8If9yc6svM8c56dB5BAtW4Qbw5jHTwwXXcTLoRMkpDJp6VL0XzlWaCHTXrkFURMYmD0sLqg==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/ansi-regex?sponsor=1"
+      }
+    },
+    "node_modules/string-width/node_modules/strip-ansi": {
+      "version": "7.1.2",
+      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-7.1.2.tgz",
+      "integrity": "sha512-gmBGslpoQJtgnMAvOVqGZpEz9dyoKTCzy2nfz/n8aIFhN/jCE/rCmcxabB6jOOHV+0WNnylOxaxBQPSvcWklhA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "ansi-regex": "^6.0.1"
+      },
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/strip-ansi?sponsor=1"
+      }
+    },
     "node_modules/strip-ansi": {
       "version": "6.0.1",
       "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-6.0.1.tgz",
@@ -4262,6 +4733,20 @@
         "node": ">=8"
       }
     },
+    "node_modules/strip-ansi-cjs": {
+      "name": "strip-ansi",
+      "version": "6.0.1",
+      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-6.0.1.tgz",
+      "integrity": "sha512-Y38VPSHcqkFrCpFnQ9vuSXmquuv5oXOKpGeT6aGrr3o3Gc9AlVa6JBfUSOCnbxGGZF+/0ooI7KrPuUSztUdU5A==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "ansi-regex": "^5.0.1"
+      },
+      "engines": {
+        "node": ">=8"
+      }
+    },
     "node_modules/strip-json-comments": {
       "version": "3.1.1",
       "resolved": "https://registry.npmjs.org/strip-json-comments/-/strip-json-comments-3.1.1.tgz",
@@ -4375,6 +4860,43 @@
         "node": ">=6"
       }
     },
+    "node_modules/test-exclude": {
+      "version": "7.0.1",
+      "resolved": "https://registry.npmjs.org/test-exclude/-/test-exclude-7.0.1.tgz",
+      "integrity": "sha512-pFYqmTw68LXVjeWJMST4+borgQP2AyMNbg1BpZh9LbyhUeNkeaPF9gzfPGUAnSMV3qPYdWUwDIjjCLiSDOl7vg==",
+      "dev": true,
+      "license": "ISC",
+      "dependencies": {
+        "@istanbuljs/schema": "^0.1.2",
+        "glob": "^10.4.1",
+        "minimatch": "^9.0.4"
+      },
+      "engines": {
+        "node": ">=18"
+      }
+    },
+    "node_modules/test-exclude/node_modules/glob": {
+      "version": "10.5.0",
+      "resolved": "https://registry.npmjs.org/glob/-/glob-10.5.0.tgz",
+      "integrity": "sha512-DfXN8DfhJ7NH3Oe7cFmu3NCu1wKbkReJ8TorzSAFbSKrlNaQSKfIzqYqVY8zlbs2NLBbWpRiU52GX2PbaBVNkg==",
+      "deprecated": "Old versions of glob are not supported, and contain widely publicized security vulnerabilities, which have been fixed in the current version. Please update. Support for old versions may be purchased (at exorbitant rates) by contacting i@izs.me",
+      "dev": true,
+      "license": "ISC",
+      "dependencies": {
+        "foreground-child": "^3.1.0",
+        "jackspeak": "^3.1.2",
+        "minimatch": "^9.0.4",
+        "minipass": "^7.1.2",
+        "package-json-from-dist": "^1.0.0",
+        "path-scurry": "^1.11.1"
+      },
+      "bin": {
+        "glob": "dist/esm/bin.mjs"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/isaacs"
+      }
+    },
     "node_modules/text-table": {
       "version": "0.2.0",
       "resolved": "https://registry.npmjs.org/text-table/-/text-table-0.2.0.tgz",
@@ -4518,7 +5040,6 @@
       "integrity": "sha512-jl1vZzPDinLr9eUt3J/t7V6FgNEw9QjvBPdysz9KfQDD41fQrC2Y4vKQdiaUpFT4bXlb1RHhLpp8wtm6M5TgSw==",
       "dev": true,
       "license": "Apache-2.0",
-      "peer": true,
       "bin": {
         "tsc": "bin/tsc",
         "tsserver": "bin/tsserver"
@@ -4769,6 +5290,107 @@
         "node": ">=0.10.0"
       }
     },
+    "node_modules/wrap-ansi": {
+      "version": "8.1.0",
+      "resolved": "https://registry.npmjs.org/wrap-ansi/-/wrap-ansi-8.1.0.tgz",
+      "integrity": "sha512-si7QWI6zUMq56bESFvagtmzMdGOtoxfR+Sez11Mobfc7tm+VkUckk9bW2UeffTGVUbOksxmSw0AA2gs8g71NCQ==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "ansi-styles": "^6.1.0",
+        "string-width": "^5.0.1",
+        "strip-ansi": "^7.0.1"
+      },
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/wrap-ansi?sponsor=1"
+      }
+    },
+    "node_modules/wrap-ansi-cjs": {
+      "name": "wrap-ansi",
+      "version": "7.0.0",
+      "resolved": "https://registry.npmjs.org/wrap-ansi/-/wrap-ansi-7.0.0.tgz",
+      "integrity": "sha512-YVGIj2kamLSTxw6NsZjoBxfSwsn0ycdesmc4p+Q21c5zPuZ1pl+NfxVdxPtdHvmNVOQ6XSYG4AUtyt/Fi7D16Q==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "ansi-styles": "^4.0.0",
+        "string-width": "^4.1.0",
+        "strip-ansi": "^6.0.0"
+      },
+      "engines": {
+        "node": ">=10"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/wrap-ansi?sponsor=1"
+      }
+    },
+    "node_modules/wrap-ansi-cjs/node_modules/emoji-regex": {
+      "version": "8.0.0",
+      "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-8.0.0.tgz",
+      "integrity": "sha512-MSjYzcWNOA0ewAHpz0MxpYFvwg6yjy1NG3xteoqz644VCo/RPgnr1/GGt+ic3iJTzQ8Eu3TdM14SawnVUmGE6A==",
+      "dev": true,
+      "license": "MIT"
+    },
+    "node_modules/wrap-ansi-cjs/node_modules/string-width": {
+      "version": "4.2.3",
+      "resolved": "https://registry.npmjs.org/string-width/-/string-width-4.2.3.tgz",
+      "integrity": "sha512-wKyQRQpjJ0sIp62ErSZdGsjMJWsap5oRNihHhu6G7JVO/9jIB6UyevL+tXuOqrng8j/cxKTWyWUwvSTriiZz/g==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "emoji-regex": "^8.0.0",
+        "is-fullwidth-code-point": "^3.0.0",
+        "strip-ansi": "^6.0.1"
+      },
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/wrap-ansi/node_modules/ansi-regex": {
+      "version": "6.2.2",
+      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-6.2.2.tgz",
+      "integrity": "sha512-Bq3SmSpyFHaWjPk8If9yc6svM8c56dB5BAtW4Qbw5jHTwwXXcTLoRMkpDJp6VL0XzlWaCHTXrkFURMYmD0sLqg==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/ansi-regex?sponsor=1"
+      }
+    },
+    "node_modules/wrap-ansi/node_modules/ansi-styles": {
+      "version": "6.2.3",
+      "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-6.2.3.tgz",
+      "integrity": "sha512-4Dj6M28JB+oAH8kFkTLUo+a2jwOFkuqb3yucU0CANcRRUbxS0cP0nZYCGjcc3BNXwRIsUVmDGgzawme7zvJHvg==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/ansi-styles?sponsor=1"
+      }
+    },
+    "node_modules/wrap-ansi/node_modules/strip-ansi": {
+      "version": "7.1.2",
+      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-7.1.2.tgz",
+      "integrity": "sha512-gmBGslpoQJtgnMAvOVqGZpEz9dyoKTCzy2nfz/n8aIFhN/jCE/rCmcxabB6jOOHV+0WNnylOxaxBQPSvcWklhA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "ansi-regex": "^6.0.1"
+      },
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/strip-ansi?sponsor=1"
+      }
+    },
     "node_modules/wrappy": {
       "version": "1.0.2",
       "resolved": "https://registry.npmjs.org/wrappy/-/wrappy-1.0.2.tgz",
diff --git a/src/collaboration.ts b/src/collaboration.ts
new file mode 100644
index 0000000..9ed9262
--- /dev/null
+++ b/src/collaboration.ts
@@ -0,0 +1,372 @@
+import { WebSocket, WebSocketServer } from 'ws';
+import { IncomingMessage } from 'http';
+import { Server as HTTPServer } from 'http';
+import { randomUUID } from 'crypto';
+import { DocumentDatabase } from './database.js';
+import { OpComponent, apply, transform, validate } from './ot.js';
+
+interface ClientConnection {
+  id: string;
+  ws: WebSocket;
+  documentId: string;
+}
+
+interface IncomingMessage_WS {
+  type: string;
+  version?: number;
+  ops?: OpComponent[];
+  [key: string]: unknown;
+}
+
+interface DocumentState {
+  content: string;
+  version: number;
+  // History of operations since version 0, indexed by version
+  history: OpComponent[][];
+}
+
+export class CollaborationManager {
+  private wss: WebSocketServer | null = null;
+  private clients: Map<string, ClientConnection> = new Map();
+  private documentStates: Map<string, DocumentState> = new Map();
+  private db: DocumentDatabase;
+
+  constructor(db: DocumentDatabase) {
+    this.db = db;
+  }
+
+  attach(server: HTTPServer): void {
+    this.wss = new WebSocketServer({ server });
+    this.wss.on('connection', (ws: WebSocket, req: IncomingMessage) => {
+      this.handleConnection(ws, req);
+    });
+  }
+
+  private getDocumentState(docId: string): DocumentState | null {
+    let state = this.documentStates.get(docId);
+    if (!state) {
+      const doc = this.db.getDocument(docId);
+      if (!doc) return null;
+      const version = this.db.getLatestVersion(docId);
+      state = {
+        content: doc.content,
+        version,
+        history: [],
+      };
+      // Load version history from DB to reconstruct ops
+      const versions = this.db.getVersionHistory(docId);
+      for (const v of versions) {
+        if (v.operation) {
+          try {
+            state.history[v.version] = JSON.parse(v.operation);
+          } catch {
+            // skip malformed ops
+          }
+        }
+      }
+      this.documentStates.set(docId, state);
+    }
+    return state;
+  }
+
+  private handleConnection(ws: WebSocket, req: IncomingMessage): void {
+    // Extract document ID from URL path: /ws/:docId or /documents/:docId/ws
+    const url = req.url || '';
+    let docId: string | null = null;
+
+    // Try /ws/:docId pattern
+    let match = url.match(/^\/ws\/([^/?]+)/);
+    if (match) {
+      docId = match[1];
+    }
+
+    // Try /documents/:docId/ws pattern
+    if (!docId) {
+      match = url.match(/^\/documents\/([^/?]+)\/ws/);
+      if (match) {
+        docId = match[1];
+      }
+    }
+
+    if (!docId) {
+      ws.send(JSON.stringify({ type: 'error', message: 'No document ID in URL path' }));
+      ws.close(1008, 'No document ID');
+      return;
+    }
+
+    const doc = this.db.getDocument(docId);
+    if (!doc) {
+      ws.send(JSON.stringify({ type: 'error', message: 'Document not found' }));
+      ws.close(1008, 'Document not found');
+      return;
+    }
+
+    const clientId = randomUUID();
+    const client: ClientConnection = { id: clientId, ws, documentId: docId };
+    this.clients.set(clientId, client);
+    this.db.addConnection(clientId, docId);
+
+    const state = this.getDocumentState(docId)!;
+
+    // Send sync message
+    ws.send(JSON.stringify({
+      type: 'sync',
+      documentId: docId,
+      content: state.content,
+      version: state.version,
+      clientId,
+    }));
+
+    // Broadcast join
+    this.broadcastToDocument(docId, {
+      type: 'client_joined',
+      clientId,
+      activeClients: this.getClientCount(docId),
+    }, clientId);
+
+    ws.on('message', (data: Buffer | string) => {
+      try {
+        const rawStr = typeof data === 'string' ? data : data.toString();
+        let message: IncomingMessage_WS;
+        try {
+          message = JSON.parse(rawStr);
+        } catch {
+          ws.send(JSON.stringify({ type: 'error', message: 'Invalid JSON' }));
+          return;
+        }
+
+        this.handleMessage(client, message);
+      } catch (err) {
+        const errMsg = err instanceof Error ? err.message : 'Unknown error';
+        ws.send(JSON.stringify({ type: 'error', message: errMsg }));
+      }
+    });
+
+    ws.on('close', () => {
+      this.clients.delete(clientId);
+      this.db.removeConnection(clientId);
+      this.broadcastToDocument(docId!, {
+        type: 'client_left',
+        clientId,
+        activeClients: this.getClientCount(docId!),
+      });
+    });
+
+    ws.on('error', () => {
+      this.clients.delete(clientId);
+      this.db.removeConnection(clientId);
+    });
+  }
+
+  private handleMessage(client: ClientConnection, message: IncomingMessage_WS): void {
+    switch (message.type) {
+      case 'operation':
+        this.handleOperation(client, message);
+        break;
+      case 'cursor':
+        // Forward cursor position to other clients
+        this.broadcastToDocument(client.documentId, {
+          ...message,
+          type: 'cursor',
+          clientId: client.id,
+        }, client.id);
+        break;
+      default:
+        client.ws.send(JSON.stringify({
+          type: 'error',
+          message: `Unknown message type: ${message.type}`,
+        }));
+    }
+  }
+
+  private handleOperation(client: ClientConnection, message: IncomingMessage_WS): void {
+    const { version, ops } = message;
+
+    if (version === undefined || version === null || typeof version !== 'number') {
+      client.ws.send(JSON.stringify({
+        type: 'error',
+        message: 'Missing or invalid version field',
+      }));
+      return;
+    }
+
+    if (!ops || !Array.isArray(ops)) {
+      client.ws.send(JSON.stringify({
+        type: 'error',
+        message: 'Missing or invalid ops field',
+      }));
+      return;
+    }
+
+    const state = this.getDocumentState(client.documentId);
+    if (!state) {
+      client.ws.send(JSON.stringify({
+        type: 'error',
+        message: 'Document not found',
+      }));
+      return;
+    }
+
+    if (version < 0 || version > state.version) {
+      client.ws.send(JSON.stringify({
+        type: 'error',
+        message: `Invalid version: ${version}. Current version is ${state.version}`,
+      }));
+      return;
+    }
+
+    // Validate the operation components
+    let currentOps: OpComponent[] = ops;
+
+    // Transform against all operations since the client's version
+    const transformDocLen = this.getDocLengthAtVersion(state, version);
+    const validationError = validate(currentOps, transformDocLen);
+    if (validationError) {
+      client.ws.send(JSON.stringify({
+        type: 'error',
+        message: `Invalid operation: ${validationError}`,
+      }));
+      return;
+    }
+
+    // Transform against concurrent operations
+    for (let v = version + 1; v <= state.version; v++) {
+      const serverOp = state.history[v];
+      if (serverOp) {
+        try {
+          const [transformed] = transform(currentOps, serverOp);
+          currentOps = transformed;
+        } catch (err) {
+          const errMsg = err instanceof Error ? err.message : 'Transform error';
+          client.ws.send(JSON.stringify({
+            type: 'error',
+            message: `Transform failed: ${errMsg}`,
+          }));
+          return;
+        }
+      }
+    }
+
+    // Apply the transformed operation
+    let newContent: string;
+    try {
+      newContent = apply(state.content, currentOps);
+    } catch (err) {
+      const errMsg = err instanceof Error ? err.message : 'Apply error';
+      client.ws.send(JSON.stringify({
+        type: 'error',
+        message: `Failed to apply operation: ${errMsg}`,
+      }));
+      return;
+    }
+
+    const newVersion = state.version + 1;
+
+    // Update in-memory state
+    state.content = newContent;
+    state.version = newVersion;
+    state.history[newVersion] = currentOps;
+
+    // Persist to database
+    try {
+      this.db.updateDocumentContent(client.documentId, newContent, currentOps);
+    } catch (err) {
+      // Log but don't fail -- in-memory state is canonical during the session
+      console.error('Failed to persist operation:', err);
+    }
+
+    // Acknowledge to sender
+    client.ws.send(JSON.stringify({
+      type: 'ack',
+      version: newVersion,
+    }));
+
+    // Broadcast to other clients
+    this.broadcastToDocument(client.documentId, {
+      type: 'operation',
+      clientId: client.id,
+      version: newVersion,
+      ops: currentOps,
+    }, client.id);
+  }
+
+  private getDocLengthAtVersion(state: DocumentState, version: number): number {
+    return this.computeDocLengthAtVersion(state, version);
+  }
+
+  private computeDocLengthAtVersion(state: DocumentState, targetVersion: number): number {
+    // Reconstruct the document at targetVersion by replaying from version 0
+    // First find version 0's content length
+    // We need to trace through ops to figure out lengths
+
+    // Quick path: if targetVersion equals current, return current length
+    if (targetVersion === state.version) {
+      return state.content.length;
+    }
+
+    // Compute by walking backwards from current version
+    let length = state.content.length;
+    for (let v = state.version; v > targetVersion; v--) {
+      const ops = state.history[v];
+      if (ops) {
+        // Reverse: output length of these ops is the current length
+        // Input length is what the doc was before
+        let inputLen = 0;
+        let outputLen = 0;
+        for (const op of ops) {
+          if ('retain' in op) { inputLen += op.retain; outputLen += op.retain; }
+          else if ('insert' in op) { outputLen += op.insert.length; }
+          else if ('delete' in op) { inputLen += op.delete; }
+        }
+        // The difference
+        length = length - outputLen + inputLen;
+      }
+    }
+
+    return length;
+  }
+
+  private broadcastToDocument(
+    documentId: string,
+    message: object,
+    excludeClientId?: string
+  ): void {
+    const payload = JSON.stringify(message);
+    for (const [, client] of this.clients) {
+      if (
+        client.documentId === documentId &&
+        client.id !== excludeClientId &&
+        client.ws.readyState === WebSocket.OPEN
+      ) {
+        client.ws.send(payload);
+      }
+    }
+  }
+
+  private getClientCount(documentId: string): number {
+    let count = 0;
+    for (const [, client] of this.clients) {
+      if (client.documentId === documentId && client.ws.readyState === WebSocket.OPEN) {
+        count++;
+      }
+    }
+    return count;
+  }
+
+  /** Refresh in-memory state from database (useful after external updates) */
+  refreshDocument(docId: string): void {
+    this.documentStates.delete(docId);
+  }
+
+  shutdown(): void {
+    for (const [, client] of this.clients) {
+      client.ws.close(1001, 'Server shutting down');
+    }
+    this.clients.clear();
+    this.documentStates.clear();
+    if (this.wss) {
+      this.wss.close();
+      this.wss = null;
+    }
+  }
+}
diff --git a/src/database.ts b/src/database.ts
new file mode 100644
index 0000000..8076194
--- /dev/null
+++ b/src/database.ts
@@ -0,0 +1,179 @@
+import Database from 'better-sqlite3';
+import { randomUUID } from 'crypto';
+import { readFileSync } from 'fs';
+import { join, dirname } from 'path';
+import { fileURLToPath } from 'url';
+
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = dirname(__filename);
+
+export interface Document {
+  id: string;
+  title: string;
+  content: string;
+  created_at: string;
+  updated_at: string;
+}
+
+export interface Version {
+  id: number;
+  document_id: string;
+  version: number;
+  content: string;
+  operation: string | null;
+  created_at: string;
+}
+
+export class DocumentDatabase {
+  private db: Database.Database;
+  private closed = false;
+
+  constructor(dbPath?: string) {
+    this.db = new Database(dbPath || ':memory:');
+    this.db.pragma('journal_mode = WAL');
+    this.db.pragma('foreign_keys = ON');
+    this.initialize();
+  }
+
+  private initialize(): void {
+    const schemaPath = join(__dirname, '..', 'schema.sql');
+    try {
+      const schema = readFileSync(schemaPath, 'utf-8');
+      this.db.exec(schema);
+    } catch {
+      // Fallback: inline schema if file not found
+      this.db.exec(`
+        CREATE TABLE IF NOT EXISTS documents (
+          id TEXT PRIMARY KEY,
+          title TEXT NOT NULL,
+          content TEXT NOT NULL DEFAULT '',
+          created_at TEXT NOT NULL DEFAULT (datetime('now')),
+          updated_at TEXT NOT NULL DEFAULT (datetime('now'))
+        );
+        CREATE TABLE IF NOT EXISTS versions (
+          id INTEGER PRIMARY KEY AUTOINCREMENT,
+          document_id TEXT NOT NULL REFERENCES documents(id) ON DELETE CASCADE,
+          version INTEGER NOT NULL,
+          content TEXT NOT NULL,
+          operation TEXT,
+          created_at TEXT NOT NULL DEFAULT (datetime('now')),
+          UNIQUE(document_id, version)
+        );
+        CREATE TABLE IF NOT EXISTS active_connections (
+          id TEXT PRIMARY KEY,
+          document_id TEXT NOT NULL REFERENCES documents(id) ON DELETE CASCADE,
+          connected_at TEXT NOT NULL DEFAULT (datetime('now'))
+        );
+      `);
+    }
+  }
+
+  createDocument(title: string, content: string = ''): Document {
+    const id = randomUUID();
+    const stmt = this.db.prepare(
+      `INSERT INTO documents (id, title, content) VALUES (?, ?, ?)`
+    );
+    stmt.run(id, title, content);
+
+    // Create initial version
+    this.db.prepare(
+      `INSERT INTO versions (document_id, version, content, operation) VALUES (?, 0, ?, NULL)`
+    ).run(id, content);
+
+    return this.getDocument(id)!;
+  }
+
+  getDocument(id: string): Document | undefined {
+    const stmt = this.db.prepare(`SELECT * FROM documents WHERE id = ?`);
+    return stmt.get(id) as Document | undefined;
+  }
+
+  listDocuments(): Document[] {
+    const stmt = this.db.prepare(`SELECT * FROM documents ORDER BY updated_at DESC`);
+    return stmt.all() as Document[];
+  }
+
+  updateDocument(id: string, updates: { title?: string; content?: string }): Document | undefined {
+    const doc = this.getDocument(id);
+    if (!doc) return undefined;
+
+    const title = updates.title !== undefined ? updates.title : doc.title;
+    const content = updates.content !== undefined ? updates.content : doc.content;
+
+    this.db.prepare(
+      `UPDATE documents SET title = ?, content = ?, updated_at = datetime('now') WHERE id = ?`
+    ).run(title, content, id);
+
+    return this.getDocument(id);
+  }
+
+  deleteDocument(id: string): boolean {
+    const result = this.db.prepare(`DELETE FROM documents WHERE id = ?`).run(id);
+    return result.changes > 0;
+  }
+
+  // Update content and create a version entry
+  updateDocumentContent(id: string, content: string, operation: object): void {
+    const version = this.getLatestVersion(id);
+    const nextVersion = version + 1;
+
+    const update = this.db.transaction(() => {
+      this.db.prepare(
+        `UPDATE documents SET content = ?, updated_at = datetime('now') WHERE id = ?`
+      ).run(content, id);
+
+      this.db.prepare(
+        `INSERT INTO versions (document_id, version, content, operation) VALUES (?, ?, ?, ?)`
+      ).run(id, nextVersion, content, JSON.stringify(operation));
+    });
+
+    update();
+  }
+
+  getLatestVersion(documentId: string): number {
+    const row = this.db.prepare(
+      `SELECT COALESCE(MAX(version), 0) as version FROM versions WHERE document_id = ?`
+    ).get(documentId) as { version: number } | undefined;
+    return row?.version ?? 0;
+  }
+
+  getVersionHistory(documentId: string): Version[] {
+    return this.db.prepare(
+      `SELECT * FROM versions WHERE document_id = ? ORDER BY version ASC`
+    ).all(documentId) as Version[];
+  }
+
+  getVersion(documentId: string, version: number): Version | undefined {
+    return this.db.prepare(
+      `SELECT * FROM versions WHERE document_id = ? AND version = ?`
+    ).get(documentId, version) as Version | undefined;
+  }
+
+  // Connection tracking
+  addConnection(connectionId: string, documentId: string): void {
+    this.db.prepare(
+      `INSERT OR REPLACE INTO active_connections (id, document_id) VALUES (?, ?)`
+    ).run(connectionId, documentId);
+  }
+
+  removeConnection(connectionId: string): void {
+    if (this.closed) return;
+    this.db.prepare(`DELETE FROM active_connections WHERE id = ?`).run(connectionId);
+  }
+
+  getActiveConnections(documentId: string): number {
+    const row = this.db.prepare(
+      `SELECT COUNT(*) as count FROM active_connections WHERE document_id = ?`
+    ).get(documentId) as { count: number };
+    return row.count;
+  }
+
+  clearAllConnections(): void {
+    this.db.prepare(`DELETE FROM active_connections`).run();
+  }
+
+  close(): void {
+    this.closed = true;
+    this.db.close();
+  }
+}
diff --git a/src/index.ts b/src/index.ts
new file mode 100644
index 0000000..5bfb883
--- /dev/null
+++ b/src/index.ts
@@ -0,0 +1,2 @@
+export { createApp } from './server.js';
+export type { AppInstance } from './server.js';
diff --git a/src/ot.ts b/src/ot.ts
new file mode 100644
index 0000000..359fad3
--- /dev/null
+++ b/src/ot.ts
@@ -0,0 +1,276 @@
+/**
+ * Operational Transformation (OT) engine for collaborative text editing.
+ *
+ * Operations are sequences of components:
+ * - { retain: n } -- keep n characters unchanged
+ * - { insert: "text" } -- insert text at current position
+ * - { delete: n } -- delete n characters at current position
+ */
+
+export interface RetainOp {
+  retain: number;
+}
+
+export interface InsertOp {
+  insert: string;
+}
+
+export interface DeleteOp {
+  delete: number;
+}
+
+export type OpComponent = RetainOp | InsertOp | DeleteOp;
+
+export interface Operation {
+  docId: string;
+  version: number; // version this op was based on
+  ops: OpComponent[];
+}
+
+function isRetain(op: OpComponent): op is RetainOp {
+  return 'retain' in op;
+}
+
+function isInsert(op: OpComponent): op is InsertOp {
+  return 'insert' in op;
+}
+
+function isDelete(op: OpComponent): op is DeleteOp {
+  return 'delete' in op;
+}
+
+/** Calculate the input length an operation expects */
+export function inputLength(ops: OpComponent[]): number {
+  let len = 0;
+  for (const op of ops) {
+    if (isRetain(op)) len += op.retain;
+    else if (isDelete(op)) len += op.delete;
+    // inserts don't consume input
+  }
+  return len;
+}
+
+/** Calculate the output length after applying an operation */
+export function outputLength(ops: OpComponent[]): number {
+  let len = 0;
+  for (const op of ops) {
+    if (isRetain(op)) len += op.retain;
+    else if (isInsert(op)) len += op.insert.length;
+    // deletes don't produce output
+  }
+  return len;
+}
+
+/** Apply an operation to a document string */
+export function apply(doc: string, ops: OpComponent[]): string {
+  let result = '';
+  let pos = 0;
+
+  for (const op of ops) {
+    if (isRetain(op)) {
+      if (pos + op.retain > doc.length) {
+        throw new Error(`Retain past end of document: pos=${pos}, retain=${op.retain}, docLen=${doc.length}`);
+      }
+      result += doc.slice(pos, pos + op.retain);
+      pos += op.retain;
+    } else if (isInsert(op)) {
+      result += op.insert;
+    } else if (isDelete(op)) {
+      if (pos + op.delete > doc.length) {
+        throw new Error(`Delete past end of document: pos=${pos}, delete=${op.delete}, docLen=${doc.length}`);
+      }
+      pos += op.delete;
+    }
+  }
+
+  // Append any remaining characters
+  result += doc.slice(pos);
+
+  return result;
+}
+
+/**
+ * Transform two concurrent operations so they can be applied in sequence.
+ * Given ops A and B both based on the same document state,
+ * returns [A', B'] such that apply(apply(doc, A), B') === apply(apply(doc, B), A')
+ */
+export function transform(
+  opsA: OpComponent[],
+  opsB: OpComponent[]
+): [OpComponent[], OpComponent[]] {
+  let indexA = 0;
+  let indexB = 0;
+
+  const aPrime: OpComponent[] = [];
+  const bPrime: OpComponent[] = [];
+
+  // Make copies that we can consume
+  const a = opsA.map(op => ({ ...op }));
+  const b = opsB.map(op => ({ ...op }));
+
+  // Remaining amounts from partially consumed ops
+  let remainA: OpComponent | null = null;
+  let remainB: OpComponent | null = null;
+
+  function nextA(): OpComponent | null {
+    if (remainA) {
+      const r = remainA;
+      remainA = null;
+      return r;
+    }
+    if (indexA < a.length) return a[indexA++];
+    return null;
+  }
+
+  function nextB(): OpComponent | null {
+    if (remainB) {
+      const r = remainB;
+      remainB = null;
+      return r;
+    }
+    if (indexB < b.length) return b[indexB++];
+    return null;
+  }
+
+  for (;;) {
+    const opA = nextA();
+    const opB = nextB();
+
+    if (opA === null && opB === null) break;
+
+    // A inserts: A' gets the insert, B' retains over it
+    if (opA !== null && isInsert(opA)) {
+      aPrime.push({ insert: opA.insert });
+      bPrime.push({ retain: opA.insert.length });
+      // Put opB back
+      if (opB !== null) remainB = opB;
+      continue;
+    }
+
+    // B inserts: B' gets the insert, A' retains over it
+    if (opB !== null && isInsert(opB)) {
+      bPrime.push({ insert: opB.insert });
+      aPrime.push({ retain: opB.insert.length });
+      // Put opA back
+      if (opA !== null) remainA = opA;
+      continue;
+    }
+
+    if (opA === null || opB === null) {
+      throw new Error('Transform: mismatched operation lengths');
+    }
+
+    // Both retain
+    if (isRetain(opA) && isRetain(opB)) {
+      const min = Math.min(opA.retain, opB.retain);
+      aPrime.push({ retain: min });
+      bPrime.push({ retain: min });
+      if (opA.retain > min) remainA = { retain: opA.retain - min };
+      if (opB.retain > min) remainB = { retain: opB.retain - min };
+    }
+    // Both delete
+    else if (isDelete(opA) && isDelete(opB)) {
+      const min = Math.min(opA.delete, opB.delete);
+      // Both deleted the same chars -- neither needs to do anything
+      if (opA.delete > min) remainA = { delete: opA.delete - min };
+      if (opB.delete > min) remainB = { delete: opB.delete - min };
+    }
+    // A deletes, B retains
+    else if (isDelete(opA) && isRetain(opB)) {
+      const min = Math.min(opA.delete, opB.retain);
+      aPrime.push({ delete: min });
+      // B's retain is consumed by A's delete (no output for B')
+      if (opA.delete > min) remainA = { delete: opA.delete - min };
+      if (opB.retain > min) remainB = { retain: opB.retain - min };
+    }
+    // A retains, B deletes
+    else if (isRetain(opA) && isDelete(opB)) {
+      const min = Math.min(opA.retain, opB.delete);
+      bPrime.push({ delete: min });
+      // A's retain is consumed by B's delete (no output for A')
+      if (opA.retain > min) remainA = { retain: opA.retain - min };
+      if (opB.delete > min) remainB = { delete: opB.delete - min };
+    }
+  }
+
+  return [compact(aPrime), compact(bPrime)];
+}
+
+/** Compact an operation by merging adjacent same-type components */
+function compact(ops: OpComponent[]): OpComponent[] {
+  const result: OpComponent[] = [];
+  for (const op of ops) {
+    if (result.length === 0) {
+      result.push(op);
+      continue;
+    }
+    const last = result[result.length - 1];
+    if (isRetain(op) && isRetain(last)) {
+      (last as RetainOp).retain += op.retain;
+    } else if (isInsert(op) && isInsert(last)) {
+      (last as InsertOp).insert += op.insert;
+    } else if (isDelete(op) && isDelete(last)) {
+      (last as DeleteOp).delete += op.delete;
+    } else {
+      result.push(op);
+    }
+  }
+  // Filter out no-ops
+  return result.filter(op => {
+    if (isRetain(op)) return op.retain > 0;
+    if (isInsert(op)) return op.insert.length > 0;
+    if (isDelete(op)) return op.delete > 0;
+    return false;
+  });
+}
+
+/** Validate that an operation is well-formed and applicable to a document of given length */
+export function validate(ops: OpComponent[], docLength: number): string | null {
+  let consumed = 0;
+  for (const op of ops) {
+    if (isRetain(op)) {
+      if (typeof op.retain !== 'number' || op.retain < 0 || !Number.isInteger(op.retain)) {
+        return 'Invalid retain value';
+      }
+      consumed += op.retain;
+    } else if (isInsert(op)) {
+      if (typeof op.insert !== 'string') {
+        return 'Invalid insert value';
+      }
+    } else if (isDelete(op)) {
+      if (typeof op.delete !== 'number' || op.delete < 0 || !Number.isInteger(op.delete)) {
+        return 'Invalid delete value';
+      }
+      consumed += op.delete;
+    } else {
+      return 'Unknown operation component type';
+    }
+  }
+  if (consumed > docLength) {
+    return `Operation spans ${consumed} chars but document is only ${docLength} chars`;
+  }
+  return null;
+}
+
+/**
+ * Helper to create an insert-at-position operation.
+ * Useful for tests and simple clients.
+ */
+export function insertAt(pos: number, text: string, docLength: number): OpComponent[] {
+  const ops: OpComponent[] = [];
+  if (pos > 0) ops.push({ retain: pos });
+  ops.push({ insert: text });
+  if (pos < docLength) ops.push({ retain: docLength - pos });
+  return ops;
+}
+
+/**
+ * Helper to create a delete-at-position operation.
+ */
+export function deleteAt(pos: number, count: number, docLength: number): OpComponent[] {
+  const ops: OpComponent[] = [];
+  if (pos > 0) ops.push({ retain: pos });
+  ops.push({ delete: count });
+  if (pos + count < docLength) ops.push({ retain: docLength - pos - count });
+  return ops;
+}
diff --git a/src/routes.ts b/src/routes.ts
new file mode 100644
index 0000000..30ec74a
--- /dev/null
+++ b/src/routes.ts
@@ -0,0 +1,159 @@
+import { Router, Request, Response } from 'express';
+import { DocumentDatabase } from './database.js';
+import { CollaborationManager } from './collaboration.js';
+
+export function createRoutes(db: DocumentDatabase, collab: CollaborationManager): Router {
+  const router = Router();
+
+  // Create a document
+  router.post('/documents', (req: Request, res: Response) => {
+    try {
+      const { title, content } = req.body;
+      if (!title || typeof title !== 'string') {
+        res.status(400).json({ error: 'Title is required and must be a string' });
+        return;
+      }
+      const doc = db.createDocument(title, content || '');
+      res.status(201).json(doc);
+    } catch (err) {
+      const message = err instanceof Error ? err.message : 'Internal server error';
+      res.status(500).json({ error: message });
+    }
+  });
+
+  // List all documents
+  router.get('/documents', (_req: Request, res: Response) => {
+    try {
+      const docs = db.listDocuments();
+      res.json(docs);
+    } catch (err) {
+      const message = err instanceof Error ? err.message : 'Internal server error';
+      res.status(500).json({ error: message });
+    }
+  });
+
+  // Get a single document
+  router.get('/documents/:id', (req: Request, res: Response) => {
+    try {
+      const doc = db.getDocument(req.params.id);
+      if (!doc) {
+        res.status(404).json({ error: 'Document not found' });
+        return;
+      }
+      res.json(doc);
+    } catch (err) {
+      const message = err instanceof Error ? err.message : 'Internal server error';
+      res.status(500).json({ error: message });
+    }
+  });
+
+  // Update a document
+  router.put('/documents/:id', (req: Request, res: Response) => {
+    try {
+      const { title, content } = req.body;
+      const updates: { title?: string; content?: string } = {};
+      if (title !== undefined) updates.title = title;
+      if (content !== undefined) updates.content = content;
+
+      const doc = db.updateDocument(req.params.id, updates);
+      if (!doc) {
+        res.status(404).json({ error: 'Document not found' });
+        return;
+      }
+
+      // Refresh collaboration state if content changed
+      if (content !== undefined) {
+        collab.refreshDocument(req.params.id);
+      }
+
+      res.json(doc);
+    } catch (err) {
+      const message = err instanceof Error ? err.message : 'Internal server error';
+      res.status(500).json({ error: message });
+    }
+  });
+
+  // Patch a document (partial update)
+  router.patch('/documents/:id', (req: Request, res: Response) => {
+    try {
+      const { title, content } = req.body;
+      const updates: { title?: string; content?: string } = {};
+      if (title !== undefined) updates.title = title;
+      if (content !== undefined) updates.content = content;
+
+      const doc = db.updateDocument(req.params.id, updates);
+      if (!doc) {
+        res.status(404).json({ error: 'Document not found' });
+        return;
+      }
+
+      if (content !== undefined) {
+        collab.refreshDocument(req.params.id);
+      }
+
+      res.json(doc);
+    } catch (err) {
+      const message = err instanceof Error ? err.message : 'Internal server error';
+      res.status(500).json({ error: message });
+    }
+  });
+
+  // Delete a document
+  router.delete('/documents/:id', (req: Request, res: Response) => {
+    try {
+      const deleted = db.deleteDocument(req.params.id);
+      if (!deleted) {
+        res.status(404).json({ error: 'Document not found' });
+        return;
+      }
+      collab.refreshDocument(req.params.id);
+      res.status(204).send();
+    } catch (err) {
+      const message = err instanceof Error ? err.message : 'Internal server error';
+      res.status(500).json({ error: message });
+    }
+  });
+
+  // Get version history for a document
+  router.get('/documents/:id/versions', (req: Request, res: Response) => {
+    try {
+      const doc = db.getDocument(req.params.id);
+      if (!doc) {
+        res.status(404).json({ error: 'Document not found' });
+        return;
+      }
+      const versions = db.getVersionHistory(req.params.id);
+      res.json(versions);
+    } catch (err) {
+      const message = err instanceof Error ? err.message : 'Internal server error';
+      res.status(500).json({ error: message });
+    }
+  });
+
+  // Get a specific version
+  router.get('/documents/:id/versions/:version', (req: Request, res: Response) => {
+    try {
+      const doc = db.getDocument(req.params.id);
+      if (!doc) {
+        res.status(404).json({ error: 'Document not found' });
+        return;
+      }
+      const versionNum = parseInt(req.params.version, 10);
+      if (isNaN(versionNum)) {
+        res.status(400).json({ error: 'Invalid version number' });
+        return;
+      }
+      const version = db.getVersion(req.params.id, versionNum);
+      if (!version) {
+        res.status(404).json({ error: 'Version not found' });
+        return;
+      }
+      res.json(version);
+    } catch (err) {
+      const message = err instanceof Error ? err.message : 'Internal server error';
+      res.status(500).json({ error: message });
+    }
+  });
+
+  return router;
+}
diff --git a/src/server.ts b/src/server.ts
new file mode 100644
index 0000000..edae5d3
--- /dev/null
+++ b/src/server.ts
@@ -0,0 +1,62 @@
+import express from 'express';
+import { createServer, Server as HTTPServer } from 'http';
+import { DocumentDatabase } from './database.js';
+import { CollaborationManager } from './collaboration.js';
+import { createRoutes } from './routes.js';
+
+export interface AppInstance {
+  app: express.Express;
+  start: (port?: number) => Promise<number>;
+  stop: () => Promise<void>;
+}
+
+export function createApp(dbPath?: string): AppInstance {
+  const db = new DocumentDatabase(dbPath);
+  db.clearAllConnections(); // Clean stale connections from previous runs
+
+  const app = express();
+  app.use(express.json());
+
+  const collab = new CollaborationManager(db);
+  const routes = createRoutes(db, collab);
+  app.use(routes);
+
+  let httpServer: HTTPServer | null = null;
+
+  async function start(port?: number): Promise<number> {
+    const listenPort = port ?? 0;
+    httpServer = createServer(app);
+    collab.attach(httpServer);
+
+    return new Promise<number>((resolve, reject) => {
+      httpServer!.listen(listenPort, () => {
+        const addr = httpServer!.address();
+        if (addr && typeof addr === 'object') {
+          resolve(addr.port);
+        } else {
+          reject(new Error('Failed to get server address'));
+        }
+      });
+      httpServer!.on('error', reject);
+    });
+  }
+
+  async function stop(): Promise<void> {
+    collab.shutdown();
+    if (httpServer) {
+      await new Promise<void>((resolve, reject) => {
+        httpServer!.close((err) => {
+          if (err) reject(err);
+          else resolve();
+        });
+      });
+    }
+    // Small delay to let any pending WS close handlers complete before closing DB
+    await new Promise(r => setTimeout(r, 50));
+    db.close();
+  }
+
+  return { app, start, stop };
+}
+
+export default createApp;
diff --git a/tests/server.test.ts b/tests/server.test.ts
new file mode 100644
index 0000000..72e89b2
--- /dev/null
+++ b/tests/server.test.ts
@@ -0,0 +1,931 @@
+import { describe, it, expect, beforeEach, afterEach, afterAll } from 'vitest';
+import request from 'supertest';
+import WebSocket from 'ws';
+import { createApp, AppInstance } from '../src/server.js';
+import { tmpdir } from 'os';
+import { join } from 'path';
+import { randomUUID } from 'crypto';
+import { unlinkSync, existsSync } from 'fs';
+
+/**
+ * Buffered WebSocket client that captures all messages from the moment of
+ * connection, preventing race conditions where messages arrive before a
+ * handler is registered.
+ */
+class WSClient {
+  ws: WebSocket;
+  private messageQueue: any[] = [];
+  private waiters: Array<{ resolve: (msg: any) => void; type?: string; timeout: NodeJS.Timeout }> = [];
+  private _openPromise: Promise<void>;
+
+  constructor(url: string) {
+    this.ws = new WebSocket(url);
+    this.ws.on('message', (data: WebSocket.RawData) => {
+      const msg = JSON.parse(data.toString());
+      const idx = this.waiters.findIndex(w => !w.type || w.type === msg.type);
+      if (idx >= 0) {
+        const waiter = this.waiters.splice(idx, 1)[0];
+        clearTimeout(waiter.timeout);
+        waiter.resolve(msg);
+      } else {
+        this.messageQueue.push(msg);
+      }
+    });
+    this._openPromise = new Promise<void>((resolve, reject) => {
+      this.ws.on('open', () => resolve());
+      this.ws.on('error', reject);
+    });
+  }
+
+  async connected(): Promise<void> {
+    if (this.ws.readyState === WebSocket.OPEN) return;
+    return this._openPromise;
+  }
+
+  waitFor(type?: string, timeoutMs = 5000): Promise<any> {
+    const idx = this.messageQueue.findIndex(m => !type || m.type === type);
+    if (idx >= 0) {
+      return Promise.resolve(this.messageQueue.splice(idx, 1)[0]);
+    }
+    return new Promise((resolve, reject) => {
+      const timeout = setTimeout(() => {
+        const wIdx = this.waiters.findIndex(w => w.timeout === timeout);
+        if (wIdx >= 0) this.waiters.splice(wIdx, 1);
+        reject(new Error(`Timeout waiting for message type: ${type}`));
+      }, timeoutMs);
+      this.waiters.push({ resolve, type, timeout });
+    });
+  }
+
+  send(msg: object): void {
+    this.ws.send(JSON.stringify(msg));
+  }
+
+  async sendOp(version: number, ops: any[]): Promise<any> {
+    const ackPromise = this.waitFor('ack');
+    this.send({ type: 'operation', version, ops });
+    return ackPromise;
+  }
+
+  close(): void {
+    this.ws.close();
+  }
+}
+
+async function connectClient(port: number, docId: string): Promise<WSClient> {
+  const client = new WSClient(`ws://localhost:${port}/ws/${docId}`);
+  await client.connected();
+  return client;
+}
+
+// ============================================================
+// REST CRUD
+// ============================================================
+describe('REST CRUD', () => {
+  let server: AppInstance;
+
+  beforeEach(async () => {
+    server = createApp();
+    await server.start(0);
+  });
+
+  afterEach(async () => {
+    await server.stop();
+  });
+
+  it('should create a document', async () => {
+    const res = await request(server.app)
+      .post('/documents')
+      .send({ title: 'Test Doc' })
+      .expect(201);
+    expect(res.body).toHaveProperty('id');
+    expect(res.body.title).toBe('Test Doc');
+    expect(res.body.content).toBe('');
+  });
+
+  it('should create a document with content', async () => {
+    const res = await request(server.app)
+      .post('/documents')
+      .send({ title: 'Test Doc', content: 'Hello world' })
+      .expect(201);
+    expect(res.body.content).toBe('Hello world');
+  });
+
+  it('should reject creating a document without title', async () => {
+    await request(server.app)
+      .post('/documents')
+      .send({})
+      .expect(400);
+  });
+
+  it('should get a document by id', async () => {
+    const created = await request(server.app)
+      .post('/documents')
+      .send({ title: 'Fetch Me' });
+    const res = await request(server.app)
+      .get(`/documents/${created.body.id}`)
+      .expect(200);
+    expect(res.body.title).toBe('Fetch Me');
+  });
+
+  it('should return 404 for non-existent document', async () => {
+    await request(server.app)
+      .get('/documents/nonexistent-id')
+      .expect(404);
+  });
+
+  it('should list documents', async () => {
+    await request(server.app).post('/documents').send({ title: 'Doc 1' });
+    await request(server.app).post('/documents').send({ title: 'Doc 2' });
+    const res = await request(server.app).get('/documents').expect(200);
+    expect(res.body.length).toBeGreaterThanOrEqual(2);
+  });
+
+  it('should update a document', async () => {
+    const created = await request(server.app)
+      .post('/documents')
+      .send({ title: 'Original' });
+    const res = await request(server.app)
+      .put(`/documents/${created.body.id}`)
+      .send({ title: 'Updated', content: 'New content' })
+      .expect(200);
+    expect(res.body.title).toBe('Updated');
+    expect(res.body.content).toBe('New content');
+  });
+
+  it('should patch a document partially', async () => {
+    const created = await request(server.app)
+      .post('/documents')
+      .send({ title: 'Original', content: 'keep this' });
+    const res = await request(server.app)
+      .patch(`/documents/${created.body.id}`)
+      .send({ title: 'Patched' })
+      .expect(200);
+    expect(res.body.title).toBe('Patched');
+    expect(res.body.content).toBe('keep this');
+  });
+
+  it('should delete a document', async () => {
+    const created = await request(server.app)
+      .post('/documents')
+      .send({ title: 'Delete Me' });
+    await request(server.app)
+      .delete(`/documents/${created.body.id}`)
+      .expect(204);
+    await request(server.app)
+      .get(`/documents/${created.body.id}`)
+      .expect(404);
+  });
+
+  it('should get version history', async () => {
+    const created = await request(server.app)
+      .post('/documents')
+      .send({ title: 'Versioned', content: 'initial' });
+    const res = await request(server.app)
+      .get(`/documents/${created.body.id}/versions`)
+      .expect(200);
+    expect(res.body.length).toBeGreaterThanOrEqual(1);
+    expect(res.body[0].content).toBe('initial');
+  });
+});
+
+// ============================================================
+// WebSocket Lifecycle
+// ============================================================
+describe('WebSocket Lifecycle', () => {
+  let server: AppInstance;
+  let port: number;
+
+  beforeEach(async () => {
+    server = createApp();
+    port = await server.start(0);
+  });
+
+  afterEach(async () => {
+    await server.stop();
+  });
+
+  it('should receive sync message on connect', async () => {
+    const doc = await request(server.app)
+      .post('/documents')
+      .send({ title: 'WS Test', content: 'hello' });
+    const client = await connectClient(port, doc.body.id);
+    const msg = await client.waitFor('sync');
+    expect(msg.type).toBe('sync');
+    expect(msg.content).toBe('hello');
+    expect(msg.version).toBeDefined();
+    expect(msg.documentId).toBe(doc.body.id);
+    client.close();
+  });
+
+  it('should include clientId in sync message', async () => {
+    const doc = await request(server.app)
+      .post('/documents')
+      .send({ title: 'WS Test' });
+    const client = await connectClient(port, doc.body.id);
+    const msg = await client.waitFor('sync');
+    expect(msg.clientId).toBeDefined();
+    expect(typeof msg.clientId).toBe('string');
+    client.close();
+  });
+
+  it('should notify other clients when a new client joins', async () => {
+    const doc = await request(server.app)
+      .post('/documents')
+      .send({ title: 'WS Test' });
+    const c1 = await connectClient(port, doc.body.id);
+    await c1.waitFor('sync');
+    const joinPromise = c1.waitFor('client_joined');
+    const c2 = await connectClient(port, doc.body.id);
+    await c2.waitFor('sync');
+    const joinMsg = await joinPromise;
+    expect(joinMsg.type).toBe('client_joined');
+    expect(joinMsg.activeClients).toBe(2);
+    c1.close();
+    c2.close();
+  });
+
+  it('should notify other clients when a client leaves', async () => {
+    const doc = await request(server.app)
+      .post('/documents')
+      .send({ title: 'WS Test' });
+    const c1 = await connectClient(port, doc.body.id);
+    await c1.waitFor('sync');
+    const c2 = await connectClient(port, doc.body.id);
+    await c2.waitFor('sync');
+    await c1.waitFor('client_joined');
+    const leavePromise = c1.waitFor('client_left');
+    c2.close();
+    const leaveMsg = await leavePromise;
+    expect(leaveMsg.type).toBe('client_left');
+    c1.close();
+  });
+
+  it('should reject connection to non-existent document', async () => {
+    const client = new WSClient(`ws://localhost:${port}/ws/nonexistent-doc`);
+    const msg = await client.waitFor('error');
+    expect(msg.type).toBe('error');
+    await new Promise<void>((resolve) => {
+      client.ws.on('close', () => resolve());
+      if (client.ws.readyState === WebSocket.CLOSED) resolve();
+    });
+  });
+
+  it('should handle connection without document ID', async () => {
+    const ws = new WebSocket(`ws://localhost:${port}/ws/`);
+    await new Promise<void>((resolve) => {
+      ws.on('close', () => resolve());
+      ws.on('error', () => resolve());
+    });
+  });
+
+  it('should handle multiple clients on same document', async () => {
+    const doc = await request(server.app)
+      .post('/documents')
+      .send({ title: 'Multi Client' });
+    const clients: WSClient[] = [];
+    for (let i = 0; i < 3; i++) {
+      const c = await connectClient(port, doc.body.id);
+      await c.waitFor('sync');
+      clients.push(c);
+    }
+    expect(clients.length).toBe(3);
+    for (const c of clients) c.close();
+  });
+
+  it('should work with /documents/:id/ws path', async () => {
+    const doc = await request(server.app)
+      .post('/documents')
+      .send({ title: 'Alt Path', content: 'test' });
+    const client = new WSClient(`ws://localhost:${port}/documents/${doc.body.id}/ws`);
+    await client.connected();
+    const msg = await client.waitFor('sync');
+    expect(msg.content).toBe('test');
+    client.close();
+  });
+});
+
+// ============================================================
+// Single Client Editing
+// ============================================================
+describe('Single Client Editing', () => {
+  let server: AppInstance;
+  let port: number;
+
+  beforeEach(async () => {
+    server = createApp();
+    port = await server.start(0);
+  });
+
+  afterEach(async () => {
+    await server.stop();
+  });
+
+  it('should apply an insert operation', async () => {
+    const doc = await request(server.app)
+      .post('/documents')
+      .send({ title: 'Edit Test', content: '' });
+    const client = await connectClient(port, doc.body.id);
+    const sync = await client.waitFor('sync');
+
+    const ack = await client.sendOp(sync.version, [{ insert: 'Hello' }]);
+    expect(ack.type).toBe('ack');
+    expect(ack.version).toBe(sync.version + 1);
+
+    const res = await request(server.app).get(`/documents/${doc.body.id}`);
+    expect(res.body.content).toBe('Hello');
+    client.close();
+  });
+
+  it('should apply a delete operation', async () => {
+    const doc = await request(server.app)
+      .post('/documents')
+      .send({ title: 'Delete Test', content: 'Hello World' });
+    const client = await connectClient(port, doc.body.id);
+    const sync = await client.waitFor('sync');
+
+    await client.sendOp(sync.version, [{ retain: 6 }, { delete: 5 }]);
+
+    const res = await request(server.app).get(`/documents/${doc.body.id}`);
+    expect(res.body.content).toBe('Hello ');
+    client.close();
+  });
+
+  it('should apply insert at position', async () => {
+    const doc = await request(server.app)
+      .post('/documents')
+      .send({ title: 'Insert At Test', content: 'Hello World' });
+    const client = await connectClient(port, doc.body.id);
+    const sync = await client.waitFor('sync');
+
+    await client.sendOp(sync.version, [{ retain: 5 }, { insert: ' Beautiful' }, { retain: 6 }]);
+
+    const res = await request(server.app).get(`/documents/${doc.body.id}`);
+    expect(res.body.content).toBe('Hello Beautiful World');
+    client.close();
+  });
+
+  it('should apply multiple sequential operations', async () => {
+    const doc = await request(server.app)
+      .post('/documents')
+      .send({ title: 'Sequential Test', content: '' });
+    const client = await connectClient(port, doc.body.id);
+    const sync = await client.waitFor('sync');
+
+    const ack1 = await client.sendOp(sync.version, [{ insert: 'Hello' }]);
+    const ack2 = await client.sendOp(ack1.version, [{ retain: 5 }, { insert: ' World' }]);
+
+    expect(ack2.version).toBe(sync.version + 2);
+
+    const res = await request(server.app).get(`/documents/${doc.body.id}`);
+    expect(res.body.content).toBe('Hello World');
+    client.close();
+  });
+
+  it('should create version history entries', async () => {
+    const doc = await request(server.app)
+      .post('/documents')
+      .send({ title: 'Version Test', content: '' });
+    const client = await connectClient(port, doc.body.id);
+    const sync = await client.waitFor('sync');
+
+    await client.sendOp(sync.version, [{ insert: 'v1' }]);
+    await client.sendOp(sync.version + 1, [{ retain: 2 }, { insert: ' v2' }]);
+
+    const versions = await request(server.app)
+      .get(`/documents/${doc.body.id}/versions`);
+    expect(versions.body.length).toBeGreaterThanOrEqual(3);
+    client.close();
+  });
+
+  it('should handle replace operation (delete + insert)', async () => {
+    const doc = await request(server.app)
+      .post('/documents')
+      .send({ title: 'Replace Test', content: 'Hello World' });
+    const client = await connectClient(port, doc.body.id);
+    const sync = await client.waitFor('sync');
+
+    await client.sendOp(sync.version, [{ retain: 6 }, { delete: 5 }, { insert: 'Vitest' }]);
+
+    const res = await request(server.app).get(`/documents/${doc.body.id}`);
+    expect(res.body.content).toBe('Hello Vitest');
+    client.close();
+  });
+});
+
+// ============================================================
+// Two-Client Convergence
+// ============================================================
+describe('Two-Client Convergence', () => {
+  let server: AppInstance;
+  let port: number;
+
+  beforeEach(async () => {
+    server = createApp();
+    port = await server.start(0);
+  });
+
+  afterEach(async () => {
+    await server.stop();
+  });
+
+  it('should broadcast operations to other clients', async () => {
+    const doc = await request(server.app)
+      .post('/documents')
+      .send({ title: 'Broadcast Test', content: '' });
+    const c1 = await connectClient(port, doc.body.id);
+    const sync1 = await c1.waitFor('sync');
+    const c2 = await connectClient(port, doc.body.id);
+    await c2.waitFor('sync');
+    await c1.waitFor('client_joined');
+
+    const opPromise = c2.waitFor('operation');
+    await c1.sendOp(sync1.version, [{ insert: 'Hello' }]);
+    const opMsg = await opPromise;
+
+    expect(opMsg.type).toBe('operation');
+    expect(opMsg.ops).toBeDefined();
+    c1.close();
+    c2.close();
+  });
+
+  it('should converge with concurrent inserts at different positions', async () => {
+    const doc = await request(server.app)
+      .post('/documents')
+      .send({ title: 'Converge Test', content: 'ABCD' });
+    const c1 = await connectClient(port, doc.body.id);
+    const sync1 = await c1.waitFor('sync');
+    const c2 = await connectClient(port, doc.body.id);
+    const sync2 = await c2.waitFor('sync');
+
+    const ack1Promise = c1.sendOp(sync1.version, [{ retain: 1 }, { insert: '1' }, { retain: 3 }]);
+    const ack2Promise = c2.sendOp(sync2.version, [{ retain: 3 }, { insert: '2' }, { retain: 1 }]);
+
+    await ack1Promise;
+    await ack2Promise;
+
+    await new Promise(r => setTimeout(r, 200));
+
+    const res = await request(server.app).get(`/documents/${doc.body.id}`);
+    expect(res.body.content).toContain('1');
+    expect(res.body.content).toContain('2');
+    expect(res.body.content.length).toBe(6);
+    c1.close();
+    c2.close();
+  });
+
+  it('should converge with concurrent inserts at same position', async () => {
+    const doc = await request(server.app)
+      .post('/documents')
+      .send({ title: 'Same Pos Test', content: '' });
+    const c1 = await connectClient(port, doc.body.id);
+    const sync1 = await c1.waitFor('sync');
+    const c2 = await connectClient(port, doc.body.id);
+    const sync2 = await c2.waitFor('sync');
+
+    await c1.sendOp(sync1.version, [{ insert: 'AAA' }]);
+    await c2.sendOp(sync2.version, [{ insert: 'BBB' }]);
+
+    await new Promise(r => setTimeout(r, 200));
+
+    const res = await request(server.app).get(`/documents/${doc.body.id}`);
+    expect(res.body.content).toContain('AAA');
+    expect(res.body.content).toContain('BBB');
+    expect(res.body.content.length).toBe(6);
+    c1.close();
+    c2.close();
+  });
+
+  it('should converge with insert and delete', async () => {
+    const doc = await request(server.app)
+      .post('/documents')
+      .send({ title: 'Insert Delete Test', content: 'Hello World' });
+    const c1 = await connectClient(port, doc.body.id);
+    const sync1 = await c1.waitFor('sync');
+    const c2 = await connectClient(port, doc.body.id);
+    const sync2 = await c2.waitFor('sync');
+
+    await c1.sendOp(sync1.version, [{ retain: 5 }, { insert: ' Beautiful' }, { retain: 6 }]);
+    await c2.sendOp(sync2.version, [{ retain: 6 }, { delete: 5 }]);
+
+    await new Promise(r => setTimeout(r, 200));
+
+    const res = await request(server.app).get(`/documents/${doc.body.id}`);
+    expect(res.body.content).toContain('Beautiful');
+    c1.close();
+    c2.close();
+  });
+
+  it('should handle rapid sequential edits from two clients', async () => {
+    const doc = await request(server.app)
+      .post('/documents')
+      .send({ title: 'Rapid Test', content: '' });
+    const c1 = await connectClient(port, doc.body.id);
+    const sync1 = await c1.waitFor('sync');
+    const c2 = await connectClient(port, doc.body.id);
+    await c2.waitFor('sync');
+    await c1.waitFor('client_joined');
+
+    let version = sync1.version;
+    for (const char of ['H', 'e', 'l', 'l', 'o']) {
+      const docLen = version - sync1.version;
+      const ack = await c1.sendOp(version, [{ retain: docLen }, { insert: char }]);
+      version = ack.version;
+    }
+
+    await new Promise(r => setTimeout(r, 300));
+
+    const res = await request(server.app).get(`/documents/${doc.body.id}`);
+    expect(res.body.content).toBe('Hello');
+    c1.close();
+    c2.close();
+  });
+
+  it('should produce consistent version numbers', async () => {
+    const doc = await request(server.app)
+      .post('/documents')
+      .send({ title: 'Version Number Test', content: 'AB' });
+    const c1 = await connectClient(port, doc.body.id);
+    const sync1 = await c1.waitFor('sync');
+    const c2 = await connectClient(port, doc.body.id);
+    const sync2 = await c2.waitFor('sync');
+
+    const ack1 = await c1.sendOp(sync1.version, [{ retain: 1 }, { insert: '1' }, { retain: 1 }]);
+    const ack2 = await c2.sendOp(sync2.version, [{ retain: 1 }, { insert: '2' }, { retain: 1 }]);
+
+    expect(ack1.version).toBeGreaterThan(sync1.version);
+    expect(ack2.version).toBeGreaterThan(ack1.version);
+    c1.close();
+    c2.close();
+  });
+
+  it('should handle three-way concurrent edits', async () => {
+    const doc = await request(server.app)
+      .post('/documents')
+      .send({ title: 'Three Way Test', content: 'XYZ' });
+    const c1 = await connectClient(port, doc.body.id);
+    const sync1 = await c1.waitFor('sync');
+    const c2 = await connectClient(port, doc.body.id);
+    const sync2 = await c2.waitFor('sync');
+    const c3 = await connectClient(port, doc.body.id);
+    const sync3 = await c3.waitFor('sync');
+
+    await c1.sendOp(sync1.version, [{ insert: 'A' }, { retain: 3 }]);
+    await c2.sendOp(sync2.version, [{ retain: 1 }, { insert: 'B' }, { retain: 2 }]);
+    await c3.sendOp(sync3.version, [{ retain: 3 }, { insert: 'C' }]);
+
+    await new Promise(r => setTimeout(r, 300));
+
+    const res = await request(server.app).get(`/documents/${doc.body.id}`);
+    expect(res.body.content).toContain('A');
+    expect(res.body.content).toContain('B');
+    expect(res.body.content).toContain('C');
+    expect(res.body.content).toContain('X');
+    expect(res.body.content).toContain('Y');
+    expect(res.body.content).toContain('Z');
+    expect(res.body.content.length).toBe(6);
+    c1.close();
+    c2.close();
+    c3.close();
+  });
+
+  it('should converge after many concurrent operations', async () => {
+    const doc = await request(server.app)
+      .post('/documents')
+      .send({ title: 'Many Ops Test', content: '' });
+    const c1 = await connectClient(port, doc.body.id);
+    const sync1 = await c1.waitFor('sync');
+    const c2 = await connectClient(port, doc.body.id);
+    const sync2 = await c2.waitFor('sync');
+
+    await c1.sendOp(sync1.version, [{ insert: 'FIRST' }]);
+    await c2.sendOp(sync2.version, [{ insert: 'SECOND' }]);
+
+    await new Promise(r => setTimeout(r, 200));
+
+    const res = await request(server.app).get(`/documents/${doc.body.id}`);
+    expect(res.body.content).toContain('FIRST');
+    expect(res.body.content).toContain('SECOND');
+    expect(res.body.content.length).toBe(11);
+    c1.close();
+    c2.close();
+  });
+});
+
+// ============================================================
+// Stress Test
+// ============================================================
+describe('Stress Test', () => {
+  let server: AppInstance;
+  let port: number;
+
+  beforeEach(async () => {
+    server = createApp();
+    port = await server.start(0);
+  });
+
+  afterEach(async () => {
+    await server.stop();
+  });
+
+  it('should handle 10 concurrent clients connecting', async () => {
+    const doc = await request(server.app)
+      .post('/documents')
+      .send({ title: 'Stress Test', content: '' });
+
+    const clients: WSClient[] = [];
+    for (let i = 0; i < 10; i++) {
+      const c = await connectClient(port, doc.body.id);
+      await c.waitFor('sync');
+      clients.push(c);
+    }
+
+    expect(clients.length).toBe(10);
+    for (const c of clients) c.close();
+  });
+
+  it('should handle 10 clients sending sequential operations', async () => {
+    const doc = await request(server.app)
+      .post('/documents')
+      .send({ title: 'Sequential Stress', content: '' });
+
+    const clients: { c: WSClient; version: number }[] = [];
+    for (let i = 0; i < 10; i++) {
+      const c = await connectClient(port, doc.body.id);
+      const sync = await c.waitFor('sync');
+      clients.push({ c, version: sync.version });
+    }
+
+    for (let i = 0; i < 10; i++) {
+      const client = clients[i];
+      const ack = await client.c.sendOp(client.version, [{ insert: `C${i}` }]);
+      for (const cl of clients) cl.version = ack.version;
+    }
+
+    await new Promise(r => setTimeout(r, 300));
+
+    const res = await request(server.app).get(`/documents/${doc.body.id}`);
+    for (let i = 0; i < 10; i++) {
+      expect(res.body.content).toContain(`C${i}`);
+    }
+    for (const cl of clients) cl.c.close();
+  }, 15000);
+
+  it('should handle 10 clients sending concurrent operations', async () => {
+    const doc = await request(server.app)
+      .post('/documents')
+      .send({ title: 'Concurrent Stress', content: '' });
+
+    const clients: { c: WSClient; version: number }[] = [];
+    for (let i = 0; i < 10; i++) {
+      const c = await connectClient(port, doc.body.id);
+      const sync = await c.waitFor('sync');
+      clients.push({ c, version: sync.version });
+    }
+
+    const ackPromises = clients.map((client, i) =>
+      client.c.sendOp(client.version, [{ insert: `X${i}` }])
+    );
+    await Promise.all(ackPromises);
+
+    await new Promise(r => setTimeout(r, 300));
+
+    const res = await request(server.app).get(`/documents/${doc.body.id}`);
+    for (let i = 0; i < 10; i++) {
+      expect(res.body.content).toContain(`X${i}`);
+    }
+    expect(res.body.content.length).toBe(20);
+    for (const cl of clients) cl.c.close();
+  }, 15000);
+
+  it('should not corrupt document under concurrent load', async () => {
+    const doc = await request(server.app)
+      .post('/documents')
+      .send({ title: 'Corruption Test', content: 'BASE' });
+
+    const clients: { c: WSClient; version: number }[] = [];
+    for (let i = 0; i < 10; i++) {
+      const c = await connectClient(port, doc.body.id);
+      const sync = await c.waitFor('sync');
+      clients.push({ c, version: sync.version });
+    }
+
+    const ackPromises = clients.map((client, i) =>
+      client.c.sendOp(client.version, [{ retain: 4 }, { insert: String(i) }])
+    );
+    await Promise.all(ackPromises);
+
+    await new Promise(r => setTimeout(r, 300));
+
+    const res = await request(server.app).get(`/documents/${doc.body.id}`);
+    expect(res.body.content).toContain('BASE');
+    for (let i = 0; i < 10; i++) {
+      expect(res.body.content).toContain(String(i));
+    }
+    for (const cl of clients) cl.c.close();
+  }, 15000);
+
+  it('should maintain document integrity with mixed operations', async () => {
+    const doc = await request(server.app)
+      .post('/documents')
+      .send({ title: 'Mixed Stress', content: 'ABCDEFGHIJ' });
+
+    const clients: { c: WSClient; version: number }[] = [];
+    for (let i = 0; i < 5; i++) {
+      const c = await connectClient(port, doc.body.id);
+      const sync = await c.waitFor('sync');
+      clients.push({ c, version: sync.version });
+    }
+
+    for (let i = 0; i < 5; i++) {
+      const ack = await clients[i].c.sendOp(clients[i].version, [{ insert: `[${i}]` }]);
+      for (const cl of clients) cl.version = ack.version;
+    }
+
+    await new Promise(r => setTimeout(r, 300));
+
+    const res = await request(server.app).get(`/documents/${doc.body.id}`);
+    for (let i = 0; i < 5; i++) {
+      expect(res.body.content).toContain(`[${i}]`);
+    }
+    expect(res.body.content).toContain('ABCDEFGHIJ');
+    for (const cl of clients) cl.c.close();
+  }, 15000);
+});
+
+// ============================================================
+// Error Handling
+// ============================================================
+describe('Error Handling', () => {
+  let server: AppInstance;
+  let port: number;
+
+  beforeEach(async () => {
+    server = createApp();
+    port = await server.start(0);
+  });
+
+  afterEach(async () => {
+    await server.stop();
+  });
+
+  it('should reject invalid JSON messages', async () => {
+    const doc = await request(server.app)
+      .post('/documents')
+      .send({ title: 'Error Test' });
+    const client = await connectClient(port, doc.body.id);
+    await client.waitFor('sync');
+
+    client.ws.send('not valid json{{{');
+    const err = await client.waitFor('error');
+    expect(err.type).toBe('error');
+    expect(err.message).toContain('Invalid JSON');
+    client.close();
+  });
+
+  it('should reject operation without version', async () => {
+    const doc = await request(server.app)
+      .post('/documents')
+      .send({ title: 'Error Test' });
+    const client = await connectClient(port, doc.body.id);
+    await client.waitFor('sync');
+
+    client.send({ type: 'operation', ops: [{ insert: 'x' }] });
+    const err = await client.waitFor('error');
+    expect(err.type).toBe('error');
+    client.close();
+  });
+
+  it('should reject operation without ops', async () => {
+    const doc = await request(server.app)
+      .post('/documents')
+      .send({ title: 'Error Test' });
+    const client = await connectClient(port, doc.body.id);
+    await client.waitFor('sync');
+
+    client.send({ type: 'operation', version: 0 });
+    const err = await client.waitFor('error');
+    expect(err.type).toBe('error');
+    client.close();
+  });
+
+  it('should reject operation with invalid version', async () => {
+    const doc = await request(server.app)
+      .post('/documents')
+      .send({ title: 'Error Test' });
+    const client = await connectClient(port, doc.body.id);
+    await client.waitFor('sync');
+
+    client.send({ type: 'operation', version: 999, ops: [{ insert: 'x' }] });
+    const err = await client.waitFor('error');
+    expect(err.type).toBe('error');
+    client.close();
+  });
+
+  it('should reject operation that spans past document length', async () => {
+    const doc = await request(server.app)
+      .post('/documents')
+      .send({ title: 'Error Test', content: 'AB' });
+    const client = await connectClient(port, doc.body.id);
+    const sync = await client.waitFor('sync');
+
+    client.send({
+      type: 'operation',
+      version: sync.version,
+      ops: [{ retain: 100 }],
+    });
+    const err = await client.waitFor('error');
+    expect(err.type).toBe('error');
+    client.close();
+  });
+});
+
+// ============================================================
+// Persistence
+// ============================================================
+describe('Persistence', () => {
+  const dbPath = join(tmpdir(), `collab-test-${randomUUID()}.db`);
+
+  afterAll(() => {
+    try {
+      if (existsSync(dbPath)) unlinkSync(dbPath);
+      if (existsSync(dbPath + '-wal')) unlinkSync(dbPath + '-wal');
+      if (existsSync(dbPath + '-shm')) unlinkSync(dbPath + '-shm');
+    } catch {
+      // ignore
+    }
+  });
+
+  it('should persist documents across server restarts', async () => {
+    const server1 = createApp(dbPath);
+    await server1.start(0);
+
+    const res = await request(server1.app)
+      .post('/documents')
+      .send({ title: 'Persistent Doc', content: 'saved data' });
+    const docId = res.body.id;
+    await server1.stop();
+
+    const server2 = createApp(dbPath);
+    await server2.start(0);
+
+    const res2 = await request(server2.app)
+      .get(`/documents/${docId}`)
+      .expect(200);
+    expect(res2.body.title).toBe('Persistent Doc');
+    expect(res2.body.content).toBe('saved data');
+    await server2.stop();
+  });
+
+  it('should persist edits made via WebSocket', async () => {
+    const server1 = createApp(dbPath);
+    const port1 = await server1.start(0);
+
+    const res = await request(server1.app)
+      .post('/documents')
+      .send({ title: 'WS Persist', content: '' });
+    const docId = res.body.id;
+
+    const client = await connectClient(port1, docId);
+    const sync = await client.waitFor('sync');
+    await client.sendOp(sync.version, [{ insert: 'persisted via ws' }]);
+    client.close();
+    await new Promise(r => setTimeout(r, 200));
+    await server1.stop();
+
+    const server2 = createApp(dbPath);
+    await server2.start(0);
+
+    const res2 = await request(server2.app)
+      .get(`/documents/${docId}`)
+      .expect(200);
+    expect(res2.body.content).toBe('persisted via ws');
+    await server2.stop();
+  });
+
+  it('should persist version history across restarts', async () => {
+    const server1 = createApp(dbPath);
+    const port1 = await server1.start(0);
+
+    const res = await request(server1.app)
+      .post('/documents')
+      .send({ title: 'Version Persist', content: 'initial' });
+    const docId = res.body.id;
+
+    const client = await connectClient(port1, docId);
+    const sync = await client.waitFor('sync');
+    await client.sendOp(sync.version, [{ retain: 7 }, { insert: ' edit1' }]);
+    client.close();
+    await new Promise(r => setTimeout(r, 200));
+    await server1.stop();
+
+    const server2 = createApp(dbPath);
+    await server2.start(0);
+
+    const versions = await request(server2.app)
+      .get(`/documents/${docId}/versions`)
+      .expect(200);
+    expect(versions.body.length).toBeGreaterThanOrEqual(2);
+    await server2.stop();
+  });
+});
