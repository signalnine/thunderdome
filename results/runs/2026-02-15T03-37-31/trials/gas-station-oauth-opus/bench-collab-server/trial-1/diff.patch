diff --git a/.runtime/agent.lock b/.runtime/agent.lock
new file mode 100644
index 0000000..0c21cc5
--- /dev/null
+++ b/.runtime/agent.lock
@@ -0,0 +1,6 @@
+{
+  "pid": 890,
+  "acquired_at": "2026-02-15T03:37:36.490110655Z",
+  "session_id": "bench/rust",
+  "hostname": "5670e21c230c"
+}
\ No newline at end of file
diff --git a/.thunderdome-metrics.json b/.thunderdome-metrics.json
new file mode 100644
index 0000000..fe77450
--- /dev/null
+++ b/.thunderdome-metrics.json
@@ -0,0 +1,18 @@
+{
+  "input_tokens": 36,
+  "output_tokens": 28720,
+  "cache_read_tokens": 1131814,
+  "cache_creation_tokens": 39534,
+  "turns": 40,
+  "tools_used": [
+    "Task",
+    "Bash",
+    "Glob",
+    "Read",
+    "TodoWrite",
+    "Write",
+    "Edit"
+  ],
+  "duration_ms": 464873,
+  "total_cost_usd": 1.5807432000000001
+}
\ No newline at end of file
diff --git a/package-lock.json b/package-lock.json
index b36b372..6f03430 100644
--- a/package-lock.json
+++ b/package-lock.json
@@ -19,12 +19,84 @@
         "@types/ws": "^8.5.0",
         "@typescript-eslint/eslint-plugin": "^7.0.0",
         "@typescript-eslint/parser": "^7.0.0",
+        "@vitest/coverage-v8": "^2.0.0",
         "eslint": "^8.56.0",
         "supertest": "^7.0.0",
         "typescript": "^5.4.0",
         "vitest": "^2.0.0"
       }
     },
+    "node_modules/@ampproject/remapping": {
+      "version": "2.3.0",
+      "resolved": "https://registry.npmjs.org/@ampproject/remapping/-/remapping-2.3.0.tgz",
+      "integrity": "sha512-30iZtAPgz+LTIYoeivqYo853f02jBYSd5uGnGpkFV0M3xOt9aN73erkgYAmZU43x4VfqcnLxW9Kpg3R5LC4YYw==",
+      "dev": true,
+      "license": "Apache-2.0",
+      "dependencies": {
+        "@jridgewell/gen-mapping": "^0.3.5",
+        "@jridgewell/trace-mapping": "^0.3.24"
+      },
+      "engines": {
+        "node": ">=6.0.0"
+      }
+    },
+    "node_modules/@babel/helper-string-parser": {
+      "version": "7.27.1",
+      "resolved": "https://registry.npmjs.org/@babel/helper-string-parser/-/helper-string-parser-7.27.1.tgz",
+      "integrity": "sha512-qMlSxKbpRlAridDExk92nSobyDdpPijUq2DW6oDnUqd0iOGxmQjyqhMIihI9+zv4LPyZdRje2cavWPbCbWm3eA==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=6.9.0"
+      }
+    },
+    "node_modules/@babel/helper-validator-identifier": {
+      "version": "7.28.5",
+      "resolved": "https://registry.npmjs.org/@babel/helper-validator-identifier/-/helper-validator-identifier-7.28.5.tgz",
+      "integrity": "sha512-qSs4ifwzKJSV39ucNjsvc6WVHs6b7S03sOh2OcHF9UHfVPqWWALUsNUVzhSBiItjRZoLHx7nIarVjqKVusUZ1Q==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=6.9.0"
+      }
+    },
+    "node_modules/@babel/parser": {
+      "version": "7.29.0",
+      "resolved": "https://registry.npmjs.org/@babel/parser/-/parser-7.29.0.tgz",
+      "integrity": "sha512-IyDgFV5GeDUVX4YdF/3CPULtVGSXXMLh1xVIgdCgxApktqnQV0r7/8Nqthg+8YLGaAtdyIlo2qIdZrbCv4+7ww==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@babel/types": "^7.29.0"
+      },
+      "bin": {
+        "parser": "bin/babel-parser.js"
+      },
+      "engines": {
+        "node": ">=6.0.0"
+      }
+    },
+    "node_modules/@babel/types": {
+      "version": "7.29.0",
+      "resolved": "https://registry.npmjs.org/@babel/types/-/types-7.29.0.tgz",
+      "integrity": "sha512-LwdZHpScM4Qz8Xw2iKSzS+cfglZzJGvofQICy7W7v4caru4EaAmyUuO6BGrbyQ2mYV11W0U8j5mBhd14dd3B0A==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@babel/helper-string-parser": "^7.27.1",
+        "@babel/helper-validator-identifier": "^7.28.5"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      }
+    },
+    "node_modules/@bcoe/v8-coverage": {
+      "version": "0.2.3",
+      "resolved": "https://registry.npmjs.org/@bcoe/v8-coverage/-/v8-coverage-0.2.3.tgz",
+      "integrity": "sha512-0hYQ8SB4Db5zvZB4axdMHGwEaQjkZzFjQiN9LVYvIFB2nSUHW9tYpxWriPrWDASIxiaXax83REcLxuSdnGPZtw==",
+      "dev": true,
+      "license": "MIT"
+    },
     "node_modules/@esbuild/aix-ppc64": {
       "version": "0.21.5",
       "resolved": "https://registry.npmjs.org/@esbuild/aix-ppc64/-/aix-ppc64-0.21.5.tgz",
@@ -565,6 +637,84 @@
       "dev": true,
       "license": "BSD-3-Clause"
     },
+    "node_modules/@isaacs/cliui": {
+      "version": "8.0.2",
+      "resolved": "https://registry.npmjs.org/@isaacs/cliui/-/cliui-8.0.2.tgz",
+      "integrity": "sha512-O8jcjabXaleOG9DQ0+ARXWZBTfnP4WNAqzuiJK7ll44AmxGKv/J2M4TPjxjY3znBCfvBXFzucm1twdyFybFqEA==",
+      "dev": true,
+      "license": "ISC",
+      "dependencies": {
+        "string-width": "^5.1.2",
+        "string-width-cjs": "npm:string-width@^4.2.0",
+        "strip-ansi": "^7.0.1",
+        "strip-ansi-cjs": "npm:strip-ansi@^6.0.1",
+        "wrap-ansi": "^8.1.0",
+        "wrap-ansi-cjs": "npm:wrap-ansi@^7.0.0"
+      },
+      "engines": {
+        "node": ">=12"
+      }
+    },
+    "node_modules/@isaacs/cliui/node_modules/ansi-regex": {
+      "version": "6.2.2",
+      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-6.2.2.tgz",
+      "integrity": "sha512-Bq3SmSpyFHaWjPk8If9yc6svM8c56dB5BAtW4Qbw5jHTwwXXcTLoRMkpDJp6VL0XzlWaCHTXrkFURMYmD0sLqg==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/ansi-regex?sponsor=1"
+      }
+    },
+    "node_modules/@isaacs/cliui/node_modules/strip-ansi": {
+      "version": "7.1.2",
+      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-7.1.2.tgz",
+      "integrity": "sha512-gmBGslpoQJtgnMAvOVqGZpEz9dyoKTCzy2nfz/n8aIFhN/jCE/rCmcxabB6jOOHV+0WNnylOxaxBQPSvcWklhA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "ansi-regex": "^6.0.1"
+      },
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/strip-ansi?sponsor=1"
+      }
+    },
+    "node_modules/@istanbuljs/schema": {
+      "version": "0.1.3",
+      "resolved": "https://registry.npmjs.org/@istanbuljs/schema/-/schema-0.1.3.tgz",
+      "integrity": "sha512-ZXRY4jNvVgSVQ8DL3LTcakaAtXwTVUxE81hslsyD2AtoXW/wVob10HkOJ1X/pAlcI7D+2YoZKg5do8G/w6RYgA==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/@jridgewell/gen-mapping": {
+      "version": "0.3.13",
+      "resolved": "https://registry.npmjs.org/@jridgewell/gen-mapping/-/gen-mapping-0.3.13.tgz",
+      "integrity": "sha512-2kkt/7niJ6MgEPxF0bYdQ6etZaA+fQvDcLKckhy1yIQOzaoKjBBjSj63/aLVjYE3qhRt5dvM+uUyfCg6UKCBbA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@jridgewell/sourcemap-codec": "^1.5.0",
+        "@jridgewell/trace-mapping": "^0.3.24"
+      }
+    },
+    "node_modules/@jridgewell/resolve-uri": {
+      "version": "3.1.2",
+      "resolved": "https://registry.npmjs.org/@jridgewell/resolve-uri/-/resolve-uri-3.1.2.tgz",
+      "integrity": "sha512-bRISgCIjP20/tbWSPWMEi54QVPRZExkuD9lJL+UIxUKtwVJA8wW1Trb1jMs1RFXo1CBTNZ/5hpC9QvmKWdopKw==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=6.0.0"
+      }
+    },
     "node_modules/@jridgewell/sourcemap-codec": {
       "version": "1.5.5",
       "resolved": "https://registry.npmjs.org/@jridgewell/sourcemap-codec/-/sourcemap-codec-1.5.5.tgz",
@@ -572,6 +722,17 @@
       "dev": true,
       "license": "MIT"
     },
+    "node_modules/@jridgewell/trace-mapping": {
+      "version": "0.3.31",
+      "resolved": "https://registry.npmjs.org/@jridgewell/trace-mapping/-/trace-mapping-0.3.31.tgz",
+      "integrity": "sha512-zzNR+SdQSDJzc8joaeP8QQoCQr8NuYx2dIIytl1QeBEZHJ9uW6hebsrYgbz8hJwUQao3TWCMtmfV8Nu1twOLAw==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@jridgewell/resolve-uri": "^3.1.0",
+        "@jridgewell/sourcemap-codec": "^1.4.14"
+      }
+    },
     "node_modules/@noble/hashes": {
       "version": "1.8.0",
       "resolved": "https://registry.npmjs.org/@noble/hashes/-/hashes-1.8.0.tgz",
@@ -633,6 +794,17 @@
         "@noble/hashes": "^1.1.5"
       }
     },
+    "node_modules/@pkgjs/parseargs": {
+      "version": "0.11.0",
+      "resolved": "https://registry.npmjs.org/@pkgjs/parseargs/-/parseargs-0.11.0.tgz",
+      "integrity": "sha512-+1VkjdD0QBLPodGrJUeqarH8VAIvQODIbwh9XpP5Syisf7YoQgsJKPNFoqqLQlu+VQ/tVSshMR6loPMn8U+dPg==",
+      "dev": true,
+      "license": "MIT",
+      "optional": true,
+      "engines": {
+        "node": ">=14"
+      }
+    },
     "node_modules/@rollup/rollup-android-arm-eabi": {
       "version": "4.57.1",
       "resolved": "https://registry.npmjs.org/@rollup/rollup-android-arm-eabi/-/rollup-android-arm-eabi-4.57.1.tgz",
@@ -1081,7 +1253,6 @@
       "integrity": "sha512-m0jEgYlYz+mDJZ2+F4v8D1AyQb+QzsNqRuI7xg1VQX/KlKS0qT9r1Mo16yo5F/MtifXFgaofIFsdFMox2SxIbQ==",
       "dev": true,
       "license": "MIT",
-      "peer": true,
       "dependencies": {
         "undici-types": "~7.16.0"
       }
@@ -1207,7 +1378,6 @@
       "integrity": "sha512-4Z+L8I2OqhZV8qA132M4wNL30ypZGYOQVBfMgxDH/K5UX0PNqTu1c6za9ST5r9+tavvHiTWmBnKzpCJ/GlVFtg==",
       "dev": true,
       "license": "BSD-2-Clause",
-      "peer": true,
       "dependencies": {
         "@typescript-eslint/scope-manager": "7.18.0",
         "@typescript-eslint/types": "7.18.0",
@@ -1368,6 +1538,39 @@
       "dev": true,
       "license": "ISC"
     },
+    "node_modules/@vitest/coverage-v8": {
+      "version": "2.1.9",
+      "resolved": "https://registry.npmjs.org/@vitest/coverage-v8/-/coverage-v8-2.1.9.tgz",
+      "integrity": "sha512-Z2cOr0ksM00MpEfyVE8KXIYPEcBFxdbLSs56L8PO0QQMxt/6bDj45uQfxoc96v05KW3clk7vvgP0qfDit9DmfQ==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@ampproject/remapping": "^2.3.0",
+        "@bcoe/v8-coverage": "^0.2.3",
+        "debug": "^4.3.7",
+        "istanbul-lib-coverage": "^3.2.2",
+        "istanbul-lib-report": "^3.0.1",
+        "istanbul-lib-source-maps": "^5.0.6",
+        "istanbul-reports": "^3.1.7",
+        "magic-string": "^0.30.12",
+        "magicast": "^0.3.5",
+        "std-env": "^3.8.0",
+        "test-exclude": "^7.0.1",
+        "tinyrainbow": "^1.2.0"
+      },
+      "funding": {
+        "url": "https://opencollective.com/vitest"
+      },
+      "peerDependencies": {
+        "@vitest/browser": "2.1.9",
+        "vitest": "2.1.9"
+      },
+      "peerDependenciesMeta": {
+        "@vitest/browser": {
+          "optional": true
+        }
+      }
+    },
     "node_modules/@vitest/expect": {
       "version": "2.1.9",
       "resolved": "https://registry.npmjs.org/@vitest/expect/-/expect-2.1.9.tgz",
@@ -1500,7 +1703,6 @@
       "integrity": "sha512-NZyJarBfL7nWwIq+FDL6Zp/yHEhePMNnnJ0y3qfieCrmNvYct8uvtiV41UvlSe6apAfk0fY1FbWx+NwfmpvtTg==",
       "dev": true,
       "license": "MIT",
-      "peer": true,
       "bin": {
         "acorn": "bin/acorn"
       },
@@ -2116,12 +2318,26 @@
         "node": ">= 0.4"
       }
     },
+    "node_modules/eastasianwidth": {
+      "version": "0.2.0",
+      "resolved": "https://registry.npmjs.org/eastasianwidth/-/eastasianwidth-0.2.0.tgz",
+      "integrity": "sha512-I88TYZWc9XiYHRQ4/3c5rjjfgkjhLyW2luGIheGERbNQ6OY7yTybanSpDXZa8y7VUP9YmDcYa+eyq4ca7iLqWA==",
+      "dev": true,
+      "license": "MIT"
+    },
     "node_modules/ee-first": {
       "version": "1.1.1",
       "resolved": "https://registry.npmjs.org/ee-first/-/ee-first-1.1.1.tgz",
       "integrity": "sha512-WMwm9LhRUo+WUaRN+vRuETqG89IgZphVSNkdFgeb6sS/E4OrDIN7t48CAewSHXc6C8lefD8KKfr5vY61brQlow==",
       "license": "MIT"
     },
+    "node_modules/emoji-regex": {
+      "version": "9.2.2",
+      "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-9.2.2.tgz",
+      "integrity": "sha512-L18DaJsXSUk2+42pv8mLs5jJT2hqFkFE4j21wOmgbUqsZ2hL72NsUU785g9RXgo3s0ZNgVl42TiHp3ZtOv/Vyg==",
+      "dev": true,
+      "license": "MIT"
+    },
     "node_modules/encodeurl": {
       "version": "2.0.0",
       "resolved": "https://registry.npmjs.org/encodeurl/-/encodeurl-2.0.0.tgz",
@@ -2258,7 +2474,6 @@
       "deprecated": "This version is no longer supported. Please see https://eslint.org/version-support for other options.",
       "dev": true,
       "license": "MIT",
-      "peer": true,
       "dependencies": {
         "@eslint-community/eslint-utils": "^4.2.0",
         "@eslint-community/regexpp": "^4.6.1",
@@ -2698,6 +2913,23 @@
       "dev": true,
       "license": "ISC"
     },
+    "node_modules/foreground-child": {
+      "version": "3.3.1",
+      "resolved": "https://registry.npmjs.org/foreground-child/-/foreground-child-3.3.1.tgz",
+      "integrity": "sha512-gIXjKqtFuWEgzFRJA9WCQeSJLZDjgJUOMCMzxtvFq/37KojM1BFGufqsCy0r4qSQmYLsZYMeyRqzIWOMup03sw==",
+      "dev": true,
+      "license": "ISC",
+      "dependencies": {
+        "cross-spawn": "^7.0.6",
+        "signal-exit": "^4.0.1"
+      },
+      "engines": {
+        "node": ">=14"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/isaacs"
+      }
+    },
     "node_modules/form-data": {
       "version": "4.0.5",
       "resolved": "https://registry.npmjs.org/form-data/-/form-data-4.0.5.tgz",
@@ -2996,6 +3228,13 @@
         "node": ">= 0.4"
       }
     },
+    "node_modules/html-escaper": {
+      "version": "2.0.2",
+      "resolved": "https://registry.npmjs.org/html-escaper/-/html-escaper-2.0.2.tgz",
+      "integrity": "sha512-H2iMtd0I4Mt5eYiapRdIDjp+XzelXQ0tFE4JS7YFwFevXXMmOp9myNrUvCg0D6ws8iqkRPBfKHgbwig1SmlLfg==",
+      "dev": true,
+      "license": "MIT"
+    },
     "node_modules/http-errors": {
       "version": "2.0.1",
       "resolved": "https://registry.npmjs.org/http-errors/-/http-errors-2.0.1.tgz",
@@ -3128,6 +3367,16 @@
         "node": ">=0.10.0"
       }
     },
+    "node_modules/is-fullwidth-code-point": {
+      "version": "3.0.0",
+      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/is-fullwidth-code-point-3.0.0.tgz",
+      "integrity": "sha512-zymm5+u+sCsSWyD9qNaejV3DFvhCKclKdizYaJUuHA83RLjb7nSuGnddCHGv0hk+KY7BMAlsWeK4Ueg6EV6XQg==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=8"
+      }
+    },
     "node_modules/is-glob": {
       "version": "4.0.3",
       "resolved": "https://registry.npmjs.org/is-glob/-/is-glob-4.0.3.tgz",
@@ -3168,6 +3417,76 @@
       "dev": true,
       "license": "ISC"
     },
+    "node_modules/istanbul-lib-coverage": {
+      "version": "3.2.2",
+      "resolved": "https://registry.npmjs.org/istanbul-lib-coverage/-/istanbul-lib-coverage-3.2.2.tgz",
+      "integrity": "sha512-O8dpsF+r0WV/8MNRKfnmrtCWhuKjxrq2w+jpzBL5UZKTi2LeVWnWOmWRxFlesJONmc+wLAGvKQZEOanko0LFTg==",
+      "dev": true,
+      "license": "BSD-3-Clause",
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/istanbul-lib-report": {
+      "version": "3.0.1",
+      "resolved": "https://registry.npmjs.org/istanbul-lib-report/-/istanbul-lib-report-3.0.1.tgz",
+      "integrity": "sha512-GCfE1mtsHGOELCU8e/Z7YWzpmybrx/+dSTfLrvY8qRmaY6zXTKWn6WQIjaAFw069icm6GVMNkgu0NzI4iPZUNw==",
+      "dev": true,
+      "license": "BSD-3-Clause",
+      "dependencies": {
+        "istanbul-lib-coverage": "^3.0.0",
+        "make-dir": "^4.0.0",
+        "supports-color": "^7.1.0"
+      },
+      "engines": {
+        "node": ">=10"
+      }
+    },
+    "node_modules/istanbul-lib-source-maps": {
+      "version": "5.0.6",
+      "resolved": "https://registry.npmjs.org/istanbul-lib-source-maps/-/istanbul-lib-source-maps-5.0.6.tgz",
+      "integrity": "sha512-yg2d+Em4KizZC5niWhQaIomgf5WlL4vOOjZ5xGCmF8SnPE/mDWWXgvRExdcpCgh9lLRRa1/fSYp2ymmbJ1pI+A==",
+      "dev": true,
+      "license": "BSD-3-Clause",
+      "dependencies": {
+        "@jridgewell/trace-mapping": "^0.3.23",
+        "debug": "^4.1.1",
+        "istanbul-lib-coverage": "^3.0.0"
+      },
+      "engines": {
+        "node": ">=10"
+      }
+    },
+    "node_modules/istanbul-reports": {
+      "version": "3.2.0",
+      "resolved": "https://registry.npmjs.org/istanbul-reports/-/istanbul-reports-3.2.0.tgz",
+      "integrity": "sha512-HGYWWS/ehqTV3xN10i23tkPkpH46MLCIMFNCaaKNavAXTF1RkqxawEPtnjnGZ6XKSInBKkiOA5BKS+aZiY3AvA==",
+      "dev": true,
+      "license": "BSD-3-Clause",
+      "dependencies": {
+        "html-escaper": "^2.0.0",
+        "istanbul-lib-report": "^3.0.0"
+      },
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/jackspeak": {
+      "version": "3.4.3",
+      "resolved": "https://registry.npmjs.org/jackspeak/-/jackspeak-3.4.3.tgz",
+      "integrity": "sha512-OGlZQpz2yfahA/Rd1Y8Cd9SIEsqvXkLVoSw/cgwhnhFMDbsQFeZYoJJ7bIZBS9BcamUW96asq/npPWugM+RQBw==",
+      "dev": true,
+      "license": "BlueOak-1.0.0",
+      "dependencies": {
+        "@isaacs/cliui": "^8.0.2"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/isaacs"
+      },
+      "optionalDependencies": {
+        "@pkgjs/parseargs": "^0.11.0"
+      }
+    },
     "node_modules/js-yaml": {
       "version": "4.1.1",
       "resolved": "https://registry.npmjs.org/js-yaml/-/js-yaml-4.1.1.tgz",
@@ -3256,6 +3575,13 @@
       "dev": true,
       "license": "MIT"
     },
+    "node_modules/lru-cache": {
+      "version": "10.4.3",
+      "resolved": "https://registry.npmjs.org/lru-cache/-/lru-cache-10.4.3.tgz",
+      "integrity": "sha512-JNAzZcXrCt42VGLuYz0zfAzDfAvJWW6AfYlDBQyDV5DClI2m5sAmK+OIO7s59XfsRsWHp02jAJrRadPRGTt6SQ==",
+      "dev": true,
+      "license": "ISC"
+    },
     "node_modules/magic-string": {
       "version": "0.30.21",
       "resolved": "https://registry.npmjs.org/magic-string/-/magic-string-0.30.21.tgz",
@@ -3266,6 +3592,34 @@
         "@jridgewell/sourcemap-codec": "^1.5.5"
       }
     },
+    "node_modules/magicast": {
+      "version": "0.3.5",
+      "resolved": "https://registry.npmjs.org/magicast/-/magicast-0.3.5.tgz",
+      "integrity": "sha512-L0WhttDl+2BOsybvEOLK7fW3UA0OQ0IQ2d6Zl2x/a6vVRs3bAY0ECOSHHeL5jD+SbOpOCUEi0y1DgHEn9Qn1AQ==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@babel/parser": "^7.25.4",
+        "@babel/types": "^7.25.4",
+        "source-map-js": "^1.2.0"
+      }
+    },
+    "node_modules/make-dir": {
+      "version": "4.0.0",
+      "resolved": "https://registry.npmjs.org/make-dir/-/make-dir-4.0.0.tgz",
+      "integrity": "sha512-hXdUTZYIVOt1Ex//jAQi+wTZZpUpwBj/0QsOzqegb3rGMMeJiSEu5xLHnYfBrRV4RH2+OCSOO95Is/7x1WJ4bw==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "semver": "^7.5.3"
+      },
+      "engines": {
+        "node": ">=10"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/sindresorhus"
+      }
+    },
     "node_modules/math-intrinsics": {
       "version": "1.1.0",
       "resolved": "https://registry.npmjs.org/math-intrinsics/-/math-intrinsics-1.1.0.tgz",
@@ -3396,6 +3750,16 @@
         "url": "https://github.com/sponsors/ljharb"
       }
     },
+    "node_modules/minipass": {
+      "version": "7.1.2",
+      "resolved": "https://registry.npmjs.org/minipass/-/minipass-7.1.2.tgz",
+      "integrity": "sha512-qOOzS1cBTWYF4BH8fVePDBOO9iptMnGUEZwNc/cMWnTV2nVLZ7VoNWEPHkYczZA0pdoA7dl6e7FL659nX9S2aw==",
+      "dev": true,
+      "license": "ISC",
+      "engines": {
+        "node": ">=16 || 14 >=14.17"
+      }
+    },
     "node_modules/mkdirp-classic": {
       "version": "0.5.3",
       "resolved": "https://registry.npmjs.org/mkdirp-classic/-/mkdirp-classic-0.5.3.tgz",
@@ -3544,6 +3908,13 @@
         "url": "https://github.com/sponsors/sindresorhus"
       }
     },
+    "node_modules/package-json-from-dist": {
+      "version": "1.0.1",
+      "resolved": "https://registry.npmjs.org/package-json-from-dist/-/package-json-from-dist-1.0.1.tgz",
+      "integrity": "sha512-UEZIS3/by4OC8vL3P2dTXRETpebLI2NiI5vIrjaD/5UtrkFX/tNbwjTSRAGC/+7CAo2pIcBaRgWmcBBHcsaCIw==",
+      "dev": true,
+      "license": "BlueOak-1.0.0"
+    },
     "node_modules/parent-module": {
       "version": "1.0.1",
       "resolved": "https://registry.npmjs.org/parent-module/-/parent-module-1.0.1.tgz",
@@ -3596,6 +3967,23 @@
         "node": ">=8"
       }
     },
+    "node_modules/path-scurry": {
+      "version": "1.11.1",
+      "resolved": "https://registry.npmjs.org/path-scurry/-/path-scurry-1.11.1.tgz",
+      "integrity": "sha512-Xa4Nw17FS9ApQFJ9umLiJS4orGjm7ZzwUrwamcGQuHSzDyth9boKDaycYdDcZDuqYATXw4HFXgaqWTctW/v1HA==",
+      "dev": true,
+      "license": "BlueOak-1.0.0",
+      "dependencies": {
+        "lru-cache": "^10.2.0",
+        "minipass": "^5.0.0 || ^6.0.2 || ^7.0.0"
+      },
+      "engines": {
+        "node": ">=16 || 14 >=14.18"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/isaacs"
+      }
+    },
     "node_modules/path-to-regexp": {
       "version": "0.1.12",
       "resolved": "https://registry.npmjs.org/path-to-regexp/-/path-to-regexp-0.1.12.tgz",
@@ -4152,6 +4540,19 @@
       "dev": true,
       "license": "ISC"
     },
+    "node_modules/signal-exit": {
+      "version": "4.1.0",
+      "resolved": "https://registry.npmjs.org/signal-exit/-/signal-exit-4.1.0.tgz",
+      "integrity": "sha512-bzyZ1e88w9O1iNJbKnOlvYTrWPDl46O1bG0D3XInv+9tkPrxrN8jUUTiFlDkkmKWgn1M6CfIA13SuGqOa9Korw==",
+      "dev": true,
+      "license": "ISC",
+      "engines": {
+        "node": ">=14"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/isaacs"
+      }
+    },
     "node_modules/simple-concat": {
       "version": "1.0.1",
       "resolved": "https://registry.npmjs.org/simple-concat/-/simple-concat-1.0.1.tgz",
@@ -4249,6 +4650,76 @@
         "safe-buffer": "~5.2.0"
       }
     },
+    "node_modules/string-width": {
+      "version": "5.1.2",
+      "resolved": "https://registry.npmjs.org/string-width/-/string-width-5.1.2.tgz",
+      "integrity": "sha512-HnLOCR3vjcY8beoNLtcjZ5/nxn2afmME6lhrDrebokqMap+XbeW8n9TXpPDOqdGK5qcI3oT0GKTW6wC7EMiVqA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "eastasianwidth": "^0.2.0",
+        "emoji-regex": "^9.2.2",
+        "strip-ansi": "^7.0.1"
+      },
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/sindresorhus"
+      }
+    },
+    "node_modules/string-width-cjs": {
+      "name": "string-width",
+      "version": "4.2.3",
+      "resolved": "https://registry.npmjs.org/string-width/-/string-width-4.2.3.tgz",
+      "integrity": "sha512-wKyQRQpjJ0sIp62ErSZdGsjMJWsap5oRNihHhu6G7JVO/9jIB6UyevL+tXuOqrng8j/cxKTWyWUwvSTriiZz/g==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "emoji-regex": "^8.0.0",
+        "is-fullwidth-code-point": "^3.0.0",
+        "strip-ansi": "^6.0.1"
+      },
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/string-width-cjs/node_modules/emoji-regex": {
+      "version": "8.0.0",
+      "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-8.0.0.tgz",
+      "integrity": "sha512-MSjYzcWNOA0ewAHpz0MxpYFvwg6yjy1NG3xteoqz644VCo/RPgnr1/GGt+ic3iJTzQ8Eu3TdM14SawnVUmGE6A==",
+      "dev": true,
+      "license": "MIT"
+    },
+    "node_modules/string-width/node_modules/ansi-regex": {
+      "version": "6.2.2",
+      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-6.2.2.tgz",
+      "integrity": "sha512-Bq3SmSpyFHaWjPk8If9yc6svM8c56dB5BAtW4Qbw5jHTwwXXcTLoRMkpDJp6VL0XzlWaCHTXrkFURMYmD0sLqg==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/ansi-regex?sponsor=1"
+      }
+    },
+    "node_modules/string-width/node_modules/strip-ansi": {
+      "version": "7.1.2",
+      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-7.1.2.tgz",
+      "integrity": "sha512-gmBGslpoQJtgnMAvOVqGZpEz9dyoKTCzy2nfz/n8aIFhN/jCE/rCmcxabB6jOOHV+0WNnylOxaxBQPSvcWklhA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "ansi-regex": "^6.0.1"
+      },
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/strip-ansi?sponsor=1"
+      }
+    },
     "node_modules/strip-ansi": {
       "version": "6.0.1",
       "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-6.0.1.tgz",
@@ -4262,6 +4733,20 @@
         "node": ">=8"
       }
     },
+    "node_modules/strip-ansi-cjs": {
+      "name": "strip-ansi",
+      "version": "6.0.1",
+      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-6.0.1.tgz",
+      "integrity": "sha512-Y38VPSHcqkFrCpFnQ9vuSXmquuv5oXOKpGeT6aGrr3o3Gc9AlVa6JBfUSOCnbxGGZF+/0ooI7KrPuUSztUdU5A==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "ansi-regex": "^5.0.1"
+      },
+      "engines": {
+        "node": ">=8"
+      }
+    },
     "node_modules/strip-json-comments": {
       "version": "3.1.1",
       "resolved": "https://registry.npmjs.org/strip-json-comments/-/strip-json-comments-3.1.1.tgz",
@@ -4375,6 +4860,43 @@
         "node": ">=6"
       }
     },
+    "node_modules/test-exclude": {
+      "version": "7.0.1",
+      "resolved": "https://registry.npmjs.org/test-exclude/-/test-exclude-7.0.1.tgz",
+      "integrity": "sha512-pFYqmTw68LXVjeWJMST4+borgQP2AyMNbg1BpZh9LbyhUeNkeaPF9gzfPGUAnSMV3qPYdWUwDIjjCLiSDOl7vg==",
+      "dev": true,
+      "license": "ISC",
+      "dependencies": {
+        "@istanbuljs/schema": "^0.1.2",
+        "glob": "^10.4.1",
+        "minimatch": "^9.0.4"
+      },
+      "engines": {
+        "node": ">=18"
+      }
+    },
+    "node_modules/test-exclude/node_modules/glob": {
+      "version": "10.5.0",
+      "resolved": "https://registry.npmjs.org/glob/-/glob-10.5.0.tgz",
+      "integrity": "sha512-DfXN8DfhJ7NH3Oe7cFmu3NCu1wKbkReJ8TorzSAFbSKrlNaQSKfIzqYqVY8zlbs2NLBbWpRiU52GX2PbaBVNkg==",
+      "deprecated": "Old versions of glob are not supported, and contain widely publicized security vulnerabilities, which have been fixed in the current version. Please update. Support for old versions may be purchased (at exorbitant rates) by contacting i@izs.me",
+      "dev": true,
+      "license": "ISC",
+      "dependencies": {
+        "foreground-child": "^3.1.0",
+        "jackspeak": "^3.1.2",
+        "minimatch": "^9.0.4",
+        "minipass": "^7.1.2",
+        "package-json-from-dist": "^1.0.0",
+        "path-scurry": "^1.11.1"
+      },
+      "bin": {
+        "glob": "dist/esm/bin.mjs"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/isaacs"
+      }
+    },
     "node_modules/text-table": {
       "version": "0.2.0",
       "resolved": "https://registry.npmjs.org/text-table/-/text-table-0.2.0.tgz",
@@ -4518,7 +5040,6 @@
       "integrity": "sha512-jl1vZzPDinLr9eUt3J/t7V6FgNEw9QjvBPdysz9KfQDD41fQrC2Y4vKQdiaUpFT4bXlb1RHhLpp8wtm6M5TgSw==",
       "dev": true,
       "license": "Apache-2.0",
-      "peer": true,
       "bin": {
         "tsc": "bin/tsc",
         "tsserver": "bin/tsserver"
@@ -4769,6 +5290,107 @@
         "node": ">=0.10.0"
       }
     },
+    "node_modules/wrap-ansi": {
+      "version": "8.1.0",
+      "resolved": "https://registry.npmjs.org/wrap-ansi/-/wrap-ansi-8.1.0.tgz",
+      "integrity": "sha512-si7QWI6zUMq56bESFvagtmzMdGOtoxfR+Sez11Mobfc7tm+VkUckk9bW2UeffTGVUbOksxmSw0AA2gs8g71NCQ==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "ansi-styles": "^6.1.0",
+        "string-width": "^5.0.1",
+        "strip-ansi": "^7.0.1"
+      },
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/wrap-ansi?sponsor=1"
+      }
+    },
+    "node_modules/wrap-ansi-cjs": {
+      "name": "wrap-ansi",
+      "version": "7.0.0",
+      "resolved": "https://registry.npmjs.org/wrap-ansi/-/wrap-ansi-7.0.0.tgz",
+      "integrity": "sha512-YVGIj2kamLSTxw6NsZjoBxfSwsn0ycdesmc4p+Q21c5zPuZ1pl+NfxVdxPtdHvmNVOQ6XSYG4AUtyt/Fi7D16Q==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "ansi-styles": "^4.0.0",
+        "string-width": "^4.1.0",
+        "strip-ansi": "^6.0.0"
+      },
+      "engines": {
+        "node": ">=10"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/wrap-ansi?sponsor=1"
+      }
+    },
+    "node_modules/wrap-ansi-cjs/node_modules/emoji-regex": {
+      "version": "8.0.0",
+      "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-8.0.0.tgz",
+      "integrity": "sha512-MSjYzcWNOA0ewAHpz0MxpYFvwg6yjy1NG3xteoqz644VCo/RPgnr1/GGt+ic3iJTzQ8Eu3TdM14SawnVUmGE6A==",
+      "dev": true,
+      "license": "MIT"
+    },
+    "node_modules/wrap-ansi-cjs/node_modules/string-width": {
+      "version": "4.2.3",
+      "resolved": "https://registry.npmjs.org/string-width/-/string-width-4.2.3.tgz",
+      "integrity": "sha512-wKyQRQpjJ0sIp62ErSZdGsjMJWsap5oRNihHhu6G7JVO/9jIB6UyevL+tXuOqrng8j/cxKTWyWUwvSTriiZz/g==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "emoji-regex": "^8.0.0",
+        "is-fullwidth-code-point": "^3.0.0",
+        "strip-ansi": "^6.0.1"
+      },
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/wrap-ansi/node_modules/ansi-regex": {
+      "version": "6.2.2",
+      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-6.2.2.tgz",
+      "integrity": "sha512-Bq3SmSpyFHaWjPk8If9yc6svM8c56dB5BAtW4Qbw5jHTwwXXcTLoRMkpDJp6VL0XzlWaCHTXrkFURMYmD0sLqg==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/ansi-regex?sponsor=1"
+      }
+    },
+    "node_modules/wrap-ansi/node_modules/ansi-styles": {
+      "version": "6.2.3",
+      "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-6.2.3.tgz",
+      "integrity": "sha512-4Dj6M28JB+oAH8kFkTLUo+a2jwOFkuqb3yucU0CANcRRUbxS0cP0nZYCGjcc3BNXwRIsUVmDGgzawme7zvJHvg==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/ansi-styles?sponsor=1"
+      }
+    },
+    "node_modules/wrap-ansi/node_modules/strip-ansi": {
+      "version": "7.1.2",
+      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-7.1.2.tgz",
+      "integrity": "sha512-gmBGslpoQJtgnMAvOVqGZpEz9dyoKTCzy2nfz/n8aIFhN/jCE/rCmcxabB6jOOHV+0WNnylOxaxBQPSvcWklhA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "ansi-regex": "^6.0.1"
+      },
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/strip-ansi?sponsor=1"
+      }
+    },
     "node_modules/wrappy": {
       "version": "1.0.2",
       "resolved": "https://registry.npmjs.org/wrappy/-/wrappy-1.0.2.tgz",
diff --git a/src/db.ts b/src/db.ts
new file mode 100644
index 0000000..d30fd49
--- /dev/null
+++ b/src/db.ts
@@ -0,0 +1,158 @@
+import Database from 'better-sqlite3';
+import { readFileSync } from 'fs';
+import { join, dirname } from 'path';
+import { fileURLToPath } from 'url';
+import crypto from 'crypto';
+
+export interface Document {
+  id: string;
+  title: string;
+  content: string;
+  created_at: string;
+  updated_at: string;
+}
+
+export interface Version {
+  id: number;
+  document_id: string;
+  version: number;
+  content: string;
+  operation: string | null;
+  created_at: string;
+}
+
+export class DocumentDB {
+  private db: Database.Database;
+
+  constructor(dbPath?: string) {
+    this.db = new Database(dbPath || ':memory:');
+    this.db.pragma('journal_mode = WAL');
+    this.db.pragma('foreign_keys = ON');
+    this.init();
+  }
+
+  private init(): void {
+    const __dirname = dirname(fileURLToPath(import.meta.url));
+    const schemaPath = join(__dirname, '..', 'schema.sql');
+    let schema: string;
+    try {
+      schema = readFileSync(schemaPath, 'utf-8');
+    } catch {
+      // Fallback inline schema if file not found
+      schema = `
+        CREATE TABLE IF NOT EXISTS documents (
+          id TEXT PRIMARY KEY,
+          title TEXT NOT NULL,
+          content TEXT NOT NULL DEFAULT '',
+          created_at TEXT NOT NULL DEFAULT (datetime('now')),
+          updated_at TEXT NOT NULL DEFAULT (datetime('now'))
+        );
+        CREATE TABLE IF NOT EXISTS versions (
+          id INTEGER PRIMARY KEY AUTOINCREMENT,
+          document_id TEXT NOT NULL REFERENCES documents(id) ON DELETE CASCADE,
+          version INTEGER NOT NULL,
+          content TEXT NOT NULL,
+          operation TEXT,
+          created_at TEXT NOT NULL DEFAULT (datetime('now')),
+          UNIQUE(document_id, version)
+        );
+        CREATE TABLE IF NOT EXISTS active_connections (
+          id TEXT PRIMARY KEY,
+          document_id TEXT NOT NULL REFERENCES documents(id) ON DELETE CASCADE,
+          connected_at TEXT NOT NULL DEFAULT (datetime('now'))
+        );
+      `;
+    }
+    this.db.exec(schema);
+  }
+
+  createDocument(title: string, content: string = ''): Document {
+    const id = crypto.randomUUID();
+    const stmt = this.db.prepare(
+      'INSERT INTO documents (id, title, content) VALUES (?, ?, ?)'
+    );
+    stmt.run(id, title, content);
+
+    // Create initial version
+    this.db.prepare(
+      'INSERT INTO versions (document_id, version, content, operation) VALUES (?, ?, ?, ?)'
+    ).run(id, 1, content, null);
+
+    return this.getDocument(id)!;
+  }
+
+  getDocument(id: string): Document | undefined {
+    const stmt = this.db.prepare('SELECT * FROM documents WHERE id = ?');
+    return stmt.get(id) as Document | undefined;
+  }
+
+  listDocuments(): Document[] {
+    const stmt = this.db.prepare('SELECT * FROM documents ORDER BY updated_at DESC');
+    return stmt.all() as Document[];
+  }
+
+  updateDocument(id: string, updates: { title?: string; content?: string }): Document | undefined {
+    const doc = this.getDocument(id);
+    if (!doc) return undefined;
+
+    const title = updates.title ?? doc.title;
+    const content = updates.content ?? doc.content;
+    this.db.prepare(
+      "UPDATE documents SET title = ?, content = ?, updated_at = datetime('now') WHERE id = ?"
+    ).run(title, content, id);
+
+    return this.getDocument(id);
+  }
+
+  deleteDocument(id: string): boolean {
+    const result = this.db.prepare('DELETE FROM documents WHERE id = ?').run(id);
+    return result.changes > 0;
+  }
+
+  // Version management
+  getLatestVersion(documentId: string): number {
+    const row = this.db.prepare(
+      'SELECT MAX(version) as maxVersion FROM versions WHERE document_id = ?'
+    ).get(documentId) as { maxVersion: number | null } | undefined;
+    return row?.maxVersion ?? 0;
+  }
+
+  addVersion(documentId: string, content: string, operation?: string): Version {
+    const nextVersion = this.getLatestVersion(documentId) + 1;
+    this.db.prepare(
+      'INSERT INTO versions (document_id, version, content, operation) VALUES (?, ?, ?, ?)'
+    ).run(documentId, nextVersion, content, operation || null);
+
+    // Update document content
+    this.db.prepare(
+      "UPDATE documents SET content = ?, updated_at = datetime('now') WHERE id = ?"
+    ).run(content, documentId);
+
+    return this.db.prepare(
+      'SELECT * FROM versions WHERE document_id = ? AND version = ?'
+    ).get(documentId, nextVersion) as Version;
+  }
+
+  getVersions(documentId: string): Version[] {
+    return this.db.prepare(
+      'SELECT * FROM versions WHERE document_id = ? ORDER BY version ASC'
+    ).all(documentId) as Version[];
+  }
+
+  getVersion(documentId: string, version: number): Version | undefined {
+    return this.db.prepare(
+      'SELECT * FROM versions WHERE document_id = ? AND version = ?'
+    ).get(documentId, version) as Version | undefined;
+  }
+
+  // Update document content directly (used by OT engine)
+  setDocumentContent(id: string, content: string): void {
+    this.db.prepare(
+      "UPDATE documents SET content = ?, updated_at = datetime('now') WHERE id = ?"
+    ).run(content, id);
+  }
+
+  close(): void {
+    this.db.close();
+  }
+}
diff --git a/src/index.ts b/src/index.ts
new file mode 100644
index 0000000..5f259ea
--- /dev/null
+++ b/src/index.ts
@@ -0,0 +1,7 @@
+export { createApp } from './server.js';
+export type { AppInstance } from './server.js';
+export { DocumentDB } from './db.js';
+export type { Document, Version } from './db.js';
+export { CollaborationManager } from './ws.js';
+export type { Operation, InsertOp, DeleteOp, ClientOperation } from './ot.js';
+export { applyOperation, validateOperation, transformOperation, transformAgainstHistory } from './ot.js';
diff --git a/src/ot.ts b/src/ot.ts
new file mode 100644
index 0000000..c849dd4
--- /dev/null
+++ b/src/ot.ts
@@ -0,0 +1,195 @@
+/**
+ * Operational Transform (OT) engine for collaborative text editing.
+ *
+ * Operations are either:
+ *  - insert: { type: 'insert', position: number, text: string }
+ *  - delete: { type: 'delete', position: number, length: number }
+ *
+ * Each operation is associated with a base version (the document version
+ * the client was viewing when they created the operation). The server
+ * transforms operations against any concurrent operations that have been
+ * applied since that base version.
+ */
+
+export interface InsertOp {
+  type: 'insert';
+  position: number;
+  text: string;
+}
+
+export interface DeleteOp {
+  type: 'delete';
+  position: number;
+  length: number;
+}
+
+export type Operation = InsertOp | DeleteOp;
+
+export interface ClientOperation {
+  type: 'operation';
+  docId: string;
+  operation: Operation;
+  baseVersion: number;
+}
+
+/**
+ * Validate that an operation is well-formed and within bounds of the document.
+ */
+export function validateOperation(op: Operation, docLength: number): string | null {
+  if (!op || typeof op !== 'object') {
+    return 'Operation must be an object';
+  }
+
+  if (op.type === 'insert') {
+    if (typeof op.position !== 'number' || op.position < 0) {
+      return 'Insert position must be a non-negative number';
+    }
+    if (op.position > docLength) {
+      return `Insert position ${op.position} is out of bounds (document length: ${docLength})`;
+    }
+    if (typeof op.text !== 'string' || op.text.length === 0) {
+      return 'Insert text must be a non-empty string';
+    }
+    return null;
+  }
+
+  if (op.type === 'delete') {
+    if (typeof op.position !== 'number' || op.position < 0) {
+      return 'Delete position must be a non-negative number';
+    }
+    if (typeof op.length !== 'number' || op.length <= 0) {
+      return 'Delete length must be a positive number';
+    }
+    if (op.position + op.length > docLength) {
+      return `Delete range [${op.position}, ${op.position + op.length}) is out of bounds (document length: ${docLength})`;
+    }
+    return null;
+  }
+
+  return `Unknown operation type: ${(op as Record<string, unknown>).type}`;
+}
+
+/**
+ * Apply an operation to a document string, returning the new document.
+ */
+export function applyOperation(doc: string, op: Operation): string {
+  if (op.type === 'insert') {
+    return doc.slice(0, op.position) + op.text + doc.slice(op.position);
+  }
+  if (op.type === 'delete') {
+    return doc.slice(0, op.position) + doc.slice(op.position + op.length);
+  }
+  throw new Error(`Unknown operation type`);
+}
+
+/**
+ * Transform operation `op` against a concurrent operation `other`.
+ * Both operations were intended to apply to the same document state.
+ * Returns the transformed version of `op` that should be applied after `other`.
+ *
+ * This implements the standard OT transform function where `op` is transformed
+ * against `other` (which has already been applied).
+ */
+export function transformOperation(op: Operation, other: Operation): Operation {
+  if (op.type === 'insert' && other.type === 'insert') {
+    // Both inserts: if op's position is after other's insert point,
+    // shift op forward by the length of other's text.
+    // Tie-break: if same position, the one that arrived first (other) goes first.
+    if (op.position > other.position) {
+      return { ...op, position: op.position + other.text.length };
+    }
+    if (op.position < other.position) {
+      return { ...op };
+    }
+    // Same position: keep op after other (other was applied first)
+    return { ...op, position: op.position + other.text.length };
+  }
+
+  if (op.type === 'insert' && other.type === 'delete') {
+    // Insert vs Delete: if insert is within or after deleted range, adjust
+    if (op.position <= other.position) {
+      return { ...op };
+    }
+    if (op.position >= other.position + other.length) {
+      return { ...op, position: op.position - other.length };
+    }
+    // Insert is inside the deleted range; place it at the deletion point
+    return { ...op, position: other.position };
+  }
+
+  if (op.type === 'delete' && other.type === 'insert') {
+    // Delete vs Insert: if insert is before or within the delete range
+    if (other.position <= op.position) {
+      return { ...op, position: op.position + other.text.length };
+    }
+    if (other.position >= op.position + op.length) {
+      return { ...op };
+    }
+    // Insert is inside the delete range; split delete around the inserted text
+    // Delete the parts before and after the insert, but preserve the insert
+    // Insert is inside the delete range.
+    // After other's insert is applied, the text that was in our delete range
+    // now has other.text spliced into the middle of it. We expand the delete
+    // to cover the entire range (including the newly inserted text) so the
+    // originally-targeted characters are all removed. The insert-vs-delete
+    // transform (above) ensures the other side's insert position is adjusted
+    // to the delete boundary, maintaining convergence.
+    return { ...op, position: op.position, length: op.length + other.text.length };
+  }
+
+  if (op.type === 'delete' && other.type === 'delete') {
+    // Both deletes on the same document state
+    const opEnd = op.position + op.length;
+    const otherEnd = other.position + other.length;
+
+    // No overlap cases
+    if (opEnd <= other.position) {
+      // op is entirely before other
+      return { ...op };
+    }
+    if (op.position >= otherEnd) {
+      // op is entirely after other
+      return { ...op, position: op.position - other.length };
+    }
+
+    // Overlap cases
+    if (op.position >= other.position && opEnd <= otherEnd) {
+      // op is entirely within other (already deleted)
+      return { type: 'delete', position: other.position, length: 0 };
+    }
+
+    if (op.position <= other.position && opEnd >= otherEnd) {
+      // op entirely contains other
+      return { ...op, length: op.length - other.length };
+    }
+
+    if (op.position < other.position) {
+      // op starts before other but overlaps
+      const newLength = other.position - op.position;
+      return { ...op, length: newLength };
+    }
+
+    // op starts inside other but extends beyond
+    const newLength = opEnd - otherEnd;
+    return { type: 'delete', position: other.position, length: newLength };
+  }
+
+  // Fallback (shouldn't reach here)
+  return { ...op };
+}
+
+/**
+ * Transform an operation against a sequence of operations that have been
+ * applied since the operation's base version.
+ */
+export function transformAgainstHistory(op: Operation, history: Operation[]): Operation {
+  let transformed = op;
+  for (const pastOp of history) {
+    transformed = transformOperation(transformed, pastOp);
+    // Skip no-op deletes
+    if (transformed.type === 'delete' && transformed.length <= 0) {
+      return { type: 'delete', position: 0, length: 0 };
+    }
+  }
+  return transformed;
+}
diff --git a/src/routes.ts b/src/routes.ts
new file mode 100644
index 0000000..fac46ef
--- /dev/null
+++ b/src/routes.ts
@@ -0,0 +1,107 @@
+import { Router, Request, Response } from 'express';
+import { DocumentDB } from './db.js';
+
+export function createRouter(db: DocumentDB): Router {
+  const router = Router();
+
+  // Create a document
+  router.post('/documents', (req: Request, res: Response) => {
+    const { title, content } = req.body;
+
+    if (!title || typeof title !== 'string') {
+      res.status(400).json({ error: 'Title is required and must be a string' });
+      return;
+    }
+
+    const doc = db.createDocument(title, typeof content === 'string' ? content : '');
+    res.status(201).json(doc);
+  });
+
+  // List all documents
+  router.get('/documents', (_req: Request, res: Response) => {
+    const docs = db.listDocuments();
+    res.json(docs);
+  });
+
+  // Get a specific document
+  router.get('/documents/:id', (req: Request, res: Response) => {
+    const doc = db.getDocument(req.params.id);
+    if (!doc) {
+      res.status(404).json({ error: 'Document not found' });
+      return;
+    }
+    res.json(doc);
+  });
+
+  // Update a document
+  router.put('/documents/:id', (req: Request, res: Response) => {
+    const { title, content } = req.body;
+
+    if (title !== undefined && typeof title !== 'string') {
+      res.status(400).json({ error: 'Title must be a string' });
+      return;
+    }
+
+    if (content !== undefined && typeof content !== 'string') {
+      res.status(400).json({ error: 'Content must be a string' });
+      return;
+    }
+
+    const doc = db.updateDocument(req.params.id, { title, content });
+    if (!doc) {
+      res.status(404).json({ error: 'Document not found' });
+      return;
+    }
+    res.json(doc);
+  });
+
+  // Patch a document (partial update)
+  router.patch('/documents/:id', (req: Request, res: Response) => {
+    const { title, content } = req.body;
+
+    const doc = db.updateDocument(req.params.id, { title, content });
+    if (!doc) {
+      res.status(404).json({ error: 'Document not found' });
+      return;
+    }
+    res.json(doc);
+  });
+
+  // Delete a document
+  router.delete('/documents/:id', (req: Request, res: Response) => {
+    const deleted = db.deleteDocument(req.params.id);
+    if (!deleted) {
+      res.status(404).json({ error: 'Document not found' });
+      return;
+    }
+    res.status(204).send();
+  });
+
+  // Get document version history
+  router.get('/documents/:id/versions', (req: Request, res: Response) => {
+    const doc = db.getDocument(req.params.id);
+    if (!doc) {
+      res.status(404).json({ error: 'Document not found' });
+      return;
+    }
+    const versions = db.getVersions(req.params.id);
+    res.json(versions);
+  });
+
+  // Get a specific version
+  router.get('/documents/:id/versions/:version', (req: Request, res: Response) => {
+    const doc = db.getDocument(req.params.id);
+    if (!doc) {
+      res.status(404).json({ error: 'Document not found' });
+      return;
+    }
+    const version = db.getVersion(req.params.id, parseInt(req.params.version, 10));
+    if (!version) {
+      res.status(404).json({ error: 'Version not found' });
+      return;
+    }
+    res.json(version);
+  });
+
+  return router;
+}
diff --git a/src/server.ts b/src/server.ts
new file mode 100644
index 0000000..54290d9
--- /dev/null
+++ b/src/server.ts
@@ -0,0 +1,60 @@
+import express from 'express';
+import { createServer, Server as HttpServer } from 'http';
+import { DocumentDB } from './db.js';
+import { createRouter } from './routes.js';
+import { CollaborationManager } from './ws.js';
+import { AddressInfo } from 'net';
+
+export interface AppInstance {
+  app: express.Express;
+  server: HttpServer;
+  db: DocumentDB;
+  collaborationManager: CollaborationManager;
+  start: (port?: number) => Promise<number>;
+  stop: () => Promise<void>;
+}
+
+export function createApp(dbPath?: string): AppInstance {
+  const app = express();
+  const db = new DocumentDB(dbPath);
+  const collaborationManager = new CollaborationManager(db);
+
+  app.use(express.json());
+  app.use('/api', createRouter(db));
+  // Also mount at root for flexibility
+  app.use('/', createRouter(db));
+
+  const server = createServer(app);
+  collaborationManager.attach(server);
+
+  const start = (port?: number): Promise<number> => {
+    return new Promise((resolve) => {
+      server.listen(port || 0, () => {
+        const addr = server.address() as AddressInfo;
+        resolve(addr.port);
+      });
+    });
+  };
+
+  const stop = (): Promise<void> => {
+    return new Promise((resolve, reject) => {
+      collaborationManager.closeAll();
+      server.close((err) => {
+        db.close();
+        if (err) reject(err);
+        else resolve();
+      });
+    });
+  };
+
+  return {
+    app,
+    server,
+    db,
+    collaborationManager,
+    start,
+    stop,
+  };
+}
+
+export default createApp;
diff --git a/src/ws.ts b/src/ws.ts
new file mode 100644
index 0000000..5177faa
--- /dev/null
+++ b/src/ws.ts
@@ -0,0 +1,303 @@
+import { WebSocketServer, WebSocket } from 'ws';
+import { IncomingMessage } from 'http';
+import { Server as HttpServer } from 'http';
+import { DocumentDB } from './db.js';
+import {
+  Operation,
+  validateOperation,
+  applyOperation,
+  transformAgainstHistory,
+} from './ot.js';
+import crypto from 'crypto';
+
+interface DocumentSession {
+  docId: string;
+  clients: Map<string, WebSocket>;
+  /** Operations applied since initial version, in order. Each entry stores the op and the version it produced. */
+  operationLog: { op: Operation; version: number }[];
+  /** Current document content in memory */
+  content: string;
+  /** Current version number */
+  version: number;
+}
+
+export interface WSMessage {
+  type: string;
+  [key: string]: unknown;
+}
+
+export interface SyncMessage {
+  type: 'sync';
+  docId: string;
+  content: string;
+  version: number;
+}
+
+export interface OperationMessage {
+  type: 'operation';
+  docId: string;
+  operation: Operation;
+  version: number;
+}
+
+export interface AckMessage {
+  type: 'ack';
+  version: number;
+}
+
+export interface ErrorMessage {
+  type: 'error';
+  message: string;
+}
+
+export class CollaborationManager {
+  private sessions: Map<string, DocumentSession> = new Map();
+  private wss: WebSocketServer | null = null;
+  private db: DocumentDB;
+
+  constructor(db: DocumentDB) {
+    this.db = db;
+  }
+
+  attach(server: HttpServer): void {
+    this.wss = new WebSocketServer({ server });
+
+    this.wss.on('connection', (ws: WebSocket, req: IncomingMessage) => {
+      this.handleConnection(ws, req);
+    });
+  }
+
+  private getDocIdFromUrl(url: string | undefined): string | null {
+    if (!url) return null;
+
+    // Support paths like /ws/documents/:id or /documents/:id/ws or /ws/:id
+    const patterns = [
+      /^\/ws\/documents\/([^/?]+)/,
+      /^\/documents\/([^/?]+)\/ws/,
+      /^\/ws\/([^/?]+)/,
+    ];
+
+    for (const pattern of patterns) {
+      const match = url.match(pattern);
+      if (match) return match[1];
+    }
+
+    return null;
+  }
+
+  private handleConnection(ws: WebSocket, req: IncomingMessage): void {
+    const docId = this.getDocIdFromUrl(req.url);
+
+    if (!docId) {
+      const errMsg: ErrorMessage = { type: 'error', message: 'No document ID in connection URL' };
+      ws.send(JSON.stringify(errMsg));
+      ws.close();
+      return;
+    }
+
+    // Check if document exists
+    const doc = this.db.getDocument(docId);
+    if (!doc) {
+      const errMsg: ErrorMessage = { type: 'error', message: 'Document not found' };
+      ws.send(JSON.stringify(errMsg));
+      ws.close();
+      return;
+    }
+
+    // Get or create session
+    let session = this.sessions.get(docId);
+    if (!session) {
+      const currentVersion = this.db.getLatestVersion(docId);
+      session = {
+        docId,
+        clients: new Map(),
+        operationLog: [],
+        content: doc.content,
+        version: currentVersion,
+      };
+      this.sessions.set(docId, session);
+    }
+
+    const clientId = crypto.randomUUID();
+    session.clients.set(clientId, ws);
+
+    // Send sync message with current state
+    const syncMsg: SyncMessage = {
+      type: 'sync',
+      docId,
+      content: session.content,
+      version: session.version,
+    };
+    ws.send(JSON.stringify(syncMsg));
+
+    ws.on('message', (data) => {
+      try {
+        const rawMessage = data.toString();
+        let message: WSMessage;
+        try {
+          message = JSON.parse(rawMessage);
+        } catch {
+          const errMsg: ErrorMessage = { type: 'error', message: 'Invalid JSON' };
+          ws.send(JSON.stringify(errMsg));
+          return;
+        }
+
+        if (!message || typeof message !== 'object') {
+          const errMsg: ErrorMessage = { type: 'error', message: 'Message must be an object' };
+          ws.send(JSON.stringify(errMsg));
+          return;
+        }
+
+        this.handleMessage(ws, clientId, docId, message);
+      } catch (err) {
+        const errMsg: ErrorMessage = {
+          type: 'error',
+          message: err instanceof Error ? err.message : 'Internal error',
+        };
+        ws.send(JSON.stringify(errMsg));
+      }
+    });
+
+    ws.on('close', () => {
+      const s = this.sessions.get(docId);
+      if (s) {
+        s.clients.delete(clientId);
+        if (s.clients.size === 0) {
+          // Persist final state and clean up session
+          this.db.setDocumentContent(docId, s.content);
+          this.sessions.delete(docId);
+        }
+      }
+    });
+
+    ws.on('error', () => {
+      const s = this.sessions.get(docId);
+      if (s) {
+        s.clients.delete(clientId);
+      }
+    });
+  }
+
+  private handleMessage(ws: WebSocket, clientId: string, docId: string, message: WSMessage): void {
+    const session = this.sessions.get(docId);
+    if (!session) {
+      const errMsg: ErrorMessage = { type: 'error', message: 'Session not found' };
+      ws.send(JSON.stringify(errMsg));
+      return;
+    }
+
+    if (message.type === 'operation') {
+      this.handleOperation(ws, clientId, session, message);
+    } else {
+      const errMsg: ErrorMessage = { type: 'error', message: `Unknown message type: ${message.type}` };
+      ws.send(JSON.stringify(errMsg));
+    }
+  }
+
+  private handleOperation(
+    ws: WebSocket,
+    clientId: string,
+    session: DocumentSession,
+    message: WSMessage
+  ): void {
+    const op = message.operation as Operation;
+    const baseVersion = message.baseVersion as number;
+
+    if (!op || typeof op !== 'object') {
+      const errMsg: ErrorMessage = { type: 'error', message: 'Operation is required' };
+      ws.send(JSON.stringify(errMsg));
+      return;
+    }
+
+    if (typeof baseVersion !== 'number' || baseVersion < 0) {
+      const errMsg: ErrorMessage = { type: 'error', message: 'baseVersion must be a non-negative number' };
+      ws.send(JSON.stringify(errMsg));
+      return;
+    }
+
+    if (baseVersion > session.version) {
+      const errMsg: ErrorMessage = { type: 'error', message: 'baseVersion is ahead of server version' };
+      ws.send(JSON.stringify(errMsg));
+      return;
+    }
+
+    // Get operations that happened since the client's base version
+    const concurrentOps = session.operationLog
+      .filter((entry) => entry.version > baseVersion)
+      .map((entry) => entry.op);
+
+    // Transform the incoming operation against concurrent ops
+    let transformedOp = op;
+    if (concurrentOps.length > 0) {
+      transformedOp = transformAgainstHistory(op, concurrentOps);
+    }
+
+    // Skip no-op deletes
+    if (transformedOp.type === 'delete' && transformedOp.length <= 0) {
+      // The operation was transformed into a no-op; ack the client
+      const ackMsg: AckMessage = { type: 'ack', version: session.version };
+      ws.send(JSON.stringify(ackMsg));
+      return;
+    }
+
+    // Validate the transformed operation against current document
+    const validationError = validateOperation(transformedOp, session.content.length);
+    if (validationError) {
+      const errMsg: ErrorMessage = { type: 'error', message: validationError };
+      ws.send(JSON.stringify(errMsg));
+      return;
+    }
+
+    // Apply the operation
+    session.content = applyOperation(session.content, transformedOp);
+    session.version++;
+
+    // Record in operation log
+    session.operationLog.push({ op: transformedOp, version: session.version });
+
+    // Persist to database
+    this.db.addVersion(
+      session.docId,
+      session.content,
+      JSON.stringify(transformedOp)
+    );
+
+    // Send ack to the sender
+    const ackMsg: AckMessage = { type: 'ack', version: session.version };
+    ws.send(JSON.stringify(ackMsg));
+
+    // Broadcast to other clients
+    const broadcastMsg: OperationMessage = {
+      type: 'operation',
+      docId: session.docId,
+      operation: transformedOp,
+      version: session.version,
+    };
+
+    for (const [cid, client] of session.clients) {
+      if (cid !== clientId && client.readyState === WebSocket.OPEN) {
+        client.send(JSON.stringify(broadcastMsg));
+      }
+    }
+  }
+
+  closeAll(): void {
+    // Persist all session content before closing
+    for (const [docId, session] of this.sessions) {
+      this.db.setDocumentContent(docId, session.content);
+      for (const [, client] of session.clients) {
+        client.close();
+      }
+      this.sessions.delete(docId);
+    }
+
+    if (this.wss) {
+      this.wss.close();
+      this.wss = null;
+    }
+  }
+
+  getSession(docId: string): DocumentSession | undefined {
+    return this.sessions.get(docId);
+  }
+}
diff --git a/tests/server.test.ts b/tests/server.test.ts
new file mode 100644
index 0000000..d04545f
--- /dev/null
+++ b/tests/server.test.ts
@@ -0,0 +1,1047 @@
+import { describe, it, expect, beforeEach, afterEach, beforeAll, afterAll } from 'vitest';
+import request from 'supertest';
+import WebSocket from 'ws';
+import { createApp, AppInstance } from '../src/server.js';
+import { applyOperation, Operation } from '../src/ot.js';
+
+//  Helpers 
+
+let app: AppInstance;
+let port: number;
+
+function wsUrl(docId: string): string {
+  return `ws://localhost:${port}/ws/documents/${docId}`;
+}
+
+function connectWs(docId: string): Promise<{ ws: WebSocket; syncMsg: { type: string; content: string; version: number; docId: string } }> {
+  return new Promise((resolve, reject) => {
+    const ws = new WebSocket(wsUrl(docId));
+    ws.on('message', (data) => {
+      const msg = JSON.parse(data.toString());
+      if (msg.type === 'sync') {
+        resolve({ ws, syncMsg: msg });
+      }
+    });
+    ws.on('error', reject);
+    const timeout = setTimeout(() => reject(new Error('WS connection timeout')), 5000);
+    ws.on('open', () => clearTimeout(timeout));
+  });
+}
+
+function sendOp(ws: WebSocket, docId: string, operation: Operation, baseVersion: number): void {
+  ws.send(JSON.stringify({
+    type: 'operation',
+    docId,
+    operation,
+    baseVersion,
+  }));
+}
+
+function waitForMessage(ws: WebSocket, type?: string): Promise<Record<string, unknown>> {
+  return new Promise((resolve, reject) => {
+    const timeout = setTimeout(() => reject(new Error('Timeout waiting for message')), 5000);
+    const handler = (data: WebSocket.Data) => {
+      const msg = JSON.parse(data.toString());
+      if (!type || msg.type === type) {
+        clearTimeout(timeout);
+        ws.removeListener('message', handler);
+        resolve(msg);
+      }
+    };
+    ws.on('message', handler);
+  });
+}
+
+function waitForAck(ws: WebSocket): Promise<{ type: string; version: number }> {
+  return waitForMessage(ws, 'ack') as Promise<{ type: string; version: number }>;
+}
+
+function waitForOperation(ws: WebSocket): Promise<{ type: string; operation: Operation; version: number; docId: string }> {
+  return waitForMessage(ws, 'operation') as Promise<{ type: string; operation: Operation; version: number; docId: string }>;
+}
+
+async function createDoc(title: string, content: string = ''): Promise<{ id: string; title: string; content: string }> {
+  const res = await request(app.app).post('/documents').send({ title, content });
+  return res.body;
+}
+
+function closeWs(ws: WebSocket): Promise<void> {
+  return new Promise((resolve) => {
+    if (ws.readyState === WebSocket.CLOSED) {
+      resolve();
+      return;
+    }
+    ws.on('close', () => resolve());
+    ws.close();
+  });
+}
+
+//  REST CRUD 
+
+describe('REST CRUD', () => {
+  beforeEach(async () => {
+    app = createApp();
+    port = await app.start();
+  });
+
+  afterEach(async () => {
+    await app.stop();
+  });
+
+  it('should create a document', async () => {
+    const res = await request(app.app)
+      .post('/documents')
+      .send({ title: 'Test Doc', content: 'Hello World' });
+
+    expect(res.status).toBe(201);
+    expect(res.body).toHaveProperty('id');
+    expect(res.body.title).toBe('Test Doc');
+    expect(res.body.content).toBe('Hello World');
+    expect(res.body).toHaveProperty('created_at');
+    expect(res.body).toHaveProperty('updated_at');
+  });
+
+  it('should create a document with empty content by default', async () => {
+    const res = await request(app.app)
+      .post('/documents')
+      .send({ title: 'Empty Doc' });
+
+    expect(res.status).toBe(201);
+    expect(res.body.content).toBe('');
+  });
+
+  it('should reject document creation without title', async () => {
+    const res = await request(app.app)
+      .post('/documents')
+      .send({ content: 'No title' });
+
+    expect(res.status).toBe(400);
+  });
+
+  it('should get a document by id', async () => {
+    const created = await createDoc('Get Test', 'content here');
+    const res = await request(app.app).get(`/documents/${created.id}`);
+
+    expect(res.status).toBe(200);
+    expect(res.body.id).toBe(created.id);
+    expect(res.body.title).toBe('Get Test');
+    expect(res.body.content).toBe('content here');
+  });
+
+  it('should return 404 for non-existent document', async () => {
+    const res = await request(app.app).get('/documents/nonexistent-id');
+    expect(res.status).toBe(404);
+  });
+
+  it('should list all documents', async () => {
+    await createDoc('Doc 1');
+    await createDoc('Doc 2');
+    await createDoc('Doc 3');
+
+    const res = await request(app.app).get('/documents');
+
+    expect(res.status).toBe(200);
+    expect(Array.isArray(res.body)).toBe(true);
+    expect(res.body.length).toBeGreaterThanOrEqual(3);
+  });
+
+  it('should update a document', async () => {
+    const created = await createDoc('Original Title', 'original content');
+
+    const res = await request(app.app)
+      .put(`/documents/${created.id}`)
+      .send({ title: 'Updated Title', content: 'updated content' });
+
+    expect(res.status).toBe(200);
+    expect(res.body.title).toBe('Updated Title');
+    expect(res.body.content).toBe('updated content');
+  });
+
+  it('should partially update a document with PATCH', async () => {
+    const created = await createDoc('Patch Title', 'patch content');
+
+    const res = await request(app.app)
+      .patch(`/documents/${created.id}`)
+      .send({ title: 'New Title' });
+
+    expect(res.status).toBe(200);
+    expect(res.body.title).toBe('New Title');
+    expect(res.body.content).toBe('patch content');
+  });
+
+  it('should delete a document', async () => {
+    const created = await createDoc('Delete Me');
+
+    const deleteRes = await request(app.app).delete(`/documents/${created.id}`);
+    expect(deleteRes.status).toBe(204);
+
+    const getRes = await request(app.app).get(`/documents/${created.id}`);
+    expect(getRes.status).toBe(404);
+  });
+
+  it('should get document version history', async () => {
+    const created = await createDoc('Versioned Doc', 'initial content');
+
+    const res = await request(app.app).get(`/documents/${created.id}/versions`);
+
+    expect(res.status).toBe(200);
+    expect(Array.isArray(res.body)).toBe(true);
+    expect(res.body.length).toBeGreaterThanOrEqual(1);
+    expect(res.body[0].version).toBe(1);
+    expect(res.body[0].content).toBe('initial content');
+  });
+});
+
+//  WebSocket Lifecycle 
+
+describe('WebSocket Lifecycle', () => {
+  beforeEach(async () => {
+    app = createApp();
+    port = await app.start();
+  });
+
+  afterEach(async () => {
+    await app.stop();
+  });
+
+  it('should connect to a document via WebSocket', async () => {
+    const doc = await createDoc('WS Doc', 'hello');
+    const { ws, syncMsg } = await connectWs(doc.id);
+
+    expect(syncMsg.type).toBe('sync');
+    expect(syncMsg.content).toBe('hello');
+    expect(syncMsg.version).toBeGreaterThanOrEqual(1);
+
+    await closeWs(ws);
+  });
+
+  it('should receive sync message with current content', async () => {
+    const doc = await createDoc('Sync Doc', 'initial state');
+    const { ws, syncMsg } = await connectWs(doc.id);
+
+    expect(syncMsg.content).toBe('initial state');
+    expect(syncMsg.docId).toBe(doc.id);
+
+    await closeWs(ws);
+  });
+
+  it('should reject connection to non-existent document', async () => {
+    const ws = new WebSocket(wsUrl('nonexistent-doc-id'));
+
+    const msg = await new Promise<Record<string, unknown>>((resolve) => {
+      ws.on('message', (data) => {
+        resolve(JSON.parse(data.toString()));
+      });
+    });
+
+    expect(msg.type).toBe('error');
+    await closeWs(ws);
+  });
+
+  it('should handle multiple clients connecting to the same document', async () => {
+    const doc = await createDoc('Multi Client', 'shared content');
+
+    const client1 = await connectWs(doc.id);
+    const client2 = await connectWs(doc.id);
+
+    expect(client1.syncMsg.content).toBe('shared content');
+    expect(client2.syncMsg.content).toBe('shared content');
+
+    await closeWs(client1.ws);
+    await closeWs(client2.ws);
+  });
+
+  it('should handle client disconnect gracefully', async () => {
+    const doc = await createDoc('Disconnect Doc', 'test');
+    const { ws } = await connectWs(doc.id);
+
+    await closeWs(ws);
+
+    // Should be able to reconnect
+    const { ws: ws2, syncMsg } = await connectWs(doc.id);
+    expect(syncMsg.content).toBe('test');
+    await closeWs(ws2);
+  });
+
+  it('should reject connection without document ID', async () => {
+    const ws = new WebSocket(`ws://localhost:${port}/ws/`);
+
+    const msg = await new Promise<Record<string, unknown>>((resolve, reject) => {
+      const timeout = setTimeout(() => reject(new Error('timeout')), 3000);
+      ws.on('message', (data) => {
+        clearTimeout(timeout);
+        resolve(JSON.parse(data.toString()));
+      });
+      ws.on('close', () => {
+        clearTimeout(timeout);
+        resolve({ type: 'error', message: 'connection closed' });
+      });
+    });
+
+    expect(msg.type).toBe('error');
+    await closeWs(ws);
+  });
+
+  it('should handle invalid JSON messages', async () => {
+    const doc = await createDoc('Invalid JSON Doc', '');
+    const { ws } = await connectWs(doc.id);
+
+    ws.send('not valid json!!!');
+    const errMsg = await waitForMessage(ws, 'error');
+    expect(errMsg.type).toBe('error');
+
+    await closeWs(ws);
+  });
+
+  it('should handle unknown message types', async () => {
+    const doc = await createDoc('Unknown Type Doc', '');
+    const { ws } = await connectWs(doc.id);
+
+    ws.send(JSON.stringify({ type: 'unknown_type' }));
+    const errMsg = await waitForMessage(ws, 'error');
+    expect(errMsg.type).toBe('error');
+
+    await closeWs(ws);
+  });
+});
+
+//  Single Client Editing 
+
+describe('Single Client Editing', () => {
+  beforeEach(async () => {
+    app = createApp();
+    port = await app.start();
+  });
+
+  afterEach(async () => {
+    await app.stop();
+  });
+
+  it('should insert text at the beginning', async () => {
+    const doc = await createDoc('Insert Doc', 'world');
+    const { ws, syncMsg } = await connectWs(doc.id);
+
+    sendOp(ws, doc.id, { type: 'insert', position: 0, text: 'hello ' }, syncMsg.version);
+    const ack = await waitForAck(ws);
+    expect(ack.version).toBeGreaterThan(syncMsg.version);
+
+    // Verify via REST
+    const res = await request(app.app).get(`/documents/${doc.id}`);
+    expect(res.body.content).toBe('hello world');
+
+    await closeWs(ws);
+  });
+
+  it('should insert text at the end', async () => {
+    const doc = await createDoc('Append Doc', 'hello');
+    const { ws, syncMsg } = await connectWs(doc.id);
+
+    sendOp(ws, doc.id, { type: 'insert', position: 5, text: ' world' }, syncMsg.version);
+    await waitForAck(ws);
+
+    const res = await request(app.app).get(`/documents/${doc.id}`);
+    expect(res.body.content).toBe('hello world');
+
+    await closeWs(ws);
+  });
+
+  it('should insert text in the middle', async () => {
+    const doc = await createDoc('Middle Doc', 'helloworld');
+    const { ws, syncMsg } = await connectWs(doc.id);
+
+    sendOp(ws, doc.id, { type: 'insert', position: 5, text: ' ' }, syncMsg.version);
+    await waitForAck(ws);
+
+    const res = await request(app.app).get(`/documents/${doc.id}`);
+    expect(res.body.content).toBe('hello world');
+
+    await closeWs(ws);
+  });
+
+  it('should delete text', async () => {
+    const doc = await createDoc('Delete Doc', 'hello world');
+    const { ws, syncMsg } = await connectWs(doc.id);
+
+    sendOp(ws, doc.id, { type: 'delete', position: 5, length: 6 }, syncMsg.version);
+    await waitForAck(ws);
+
+    const res = await request(app.app).get(`/documents/${doc.id}`);
+    expect(res.body.content).toBe('hello');
+
+    await closeWs(ws);
+  });
+
+  it('should handle sequential operations', async () => {
+    const doc = await createDoc('Sequential Doc', '');
+    const { ws, syncMsg } = await connectWs(doc.id);
+
+    // Type "hello"
+    sendOp(ws, doc.id, { type: 'insert', position: 0, text: 'hello' }, syncMsg.version);
+    const ack1 = await waitForAck(ws);
+
+    // Type " world"
+    sendOp(ws, doc.id, { type: 'insert', position: 5, text: ' world' }, ack1.version);
+    await waitForAck(ws);
+
+    const res = await request(app.app).get(`/documents/${doc.id}`);
+    expect(res.body.content).toBe('hello world');
+
+    await closeWs(ws);
+  });
+
+  it('should persist versions for each operation', async () => {
+    const doc = await createDoc('Version Doc', 'start');
+    const { ws, syncMsg } = await connectWs(doc.id);
+
+    sendOp(ws, doc.id, { type: 'insert', position: 5, text: ' middle' }, syncMsg.version);
+    const ack = await waitForAck(ws);
+
+    sendOp(ws, doc.id, { type: 'insert', position: 12, text: ' end' }, ack.version);
+    await waitForAck(ws);
+
+    await closeWs(ws);
+
+    const versionsRes = await request(app.app).get(`/documents/${doc.id}/versions`);
+    expect(versionsRes.body.length).toBeGreaterThanOrEqual(3); // initial + 2 ops
+  });
+});
+
+//  Two-Client Convergence 
+
+describe('Two-Client Convergence', () => {
+  beforeEach(async () => {
+    app = createApp();
+    port = await app.start();
+  });
+
+  afterEach(async () => {
+    await app.stop();
+  });
+
+  it('should broadcast operations to other clients', async () => {
+    const doc = await createDoc('Broadcast Doc', 'hello');
+    const client1 = await connectWs(doc.id);
+    const client2 = await connectWs(doc.id);
+
+    // Client 1 sends an insert
+    const opPromise = waitForOperation(client2.ws);
+    sendOp(client1.ws, doc.id, { type: 'insert', position: 5, text: ' world' }, client1.syncMsg.version);
+
+    const broadcastedOp = await opPromise;
+    expect(broadcastedOp.type).toBe('operation');
+    expect(broadcastedOp.operation.type).toBe('insert');
+
+    await closeWs(client1.ws);
+    await closeWs(client2.ws);
+  });
+
+  it('should handle concurrent inserts at different positions', async () => {
+    const doc = await createDoc('Concurrent Doc', 'hello world');
+    const client1 = await connectWs(doc.id);
+    const client2 = await connectWs(doc.id);
+
+    const baseVersion = client1.syncMsg.version;
+
+    // Both clients insert at different positions concurrently
+    const ack1Promise = waitForAck(client1.ws);
+    const op2Promise = waitForMessage(client2.ws); // Will get the broadcast
+
+    sendOp(client1.ws, doc.id, { type: 'insert', position: 0, text: 'A' }, baseVersion);
+    const ack1 = await ack1Promise;
+    await op2Promise;
+
+    // Client 2 sends op based on the same base version
+    const ack2Promise = waitForAck(client2.ws);
+    sendOp(client2.ws, doc.id, { type: 'insert', position: 11, text: 'B' }, baseVersion);
+    await ack2Promise;
+
+    // Verify convergence
+    const res = await request(app.app).get(`/documents/${doc.id}`);
+    // Both A and B should be present
+    expect(res.body.content).toContain('A');
+    expect(res.body.content).toContain('B');
+    expect(res.body.content).toContain('hello world');
+
+    await closeWs(client1.ws);
+    await closeWs(client2.ws);
+  });
+
+  it('should handle concurrent inserts at the same position', async () => {
+    const doc = await createDoc('Same Pos Doc', 'hello');
+    const client1 = await connectWs(doc.id);
+    const client2 = await connectWs(doc.id);
+
+    const baseVersion = client1.syncMsg.version;
+
+    // Both clients insert at position 5
+    const ack1Promise = waitForAck(client1.ws);
+    sendOp(client1.ws, doc.id, { type: 'insert', position: 5, text: 'A' }, baseVersion);
+    await ack1Promise;
+
+    // Client 2 also inserts at position 5 based on same version
+    const ack2Promise = waitForAck(client2.ws);
+    sendOp(client2.ws, doc.id, { type: 'insert', position: 5, text: 'B' }, baseVersion);
+    await ack2Promise;
+
+    // Both inserts should be preserved
+    const res = await request(app.app).get(`/documents/${doc.id}`);
+    expect(res.body.content).toContain('A');
+    expect(res.body.content).toContain('B');
+    expect(res.body.content).toContain('hello');
+
+    await closeWs(client1.ws);
+    await closeWs(client2.ws);
+  });
+
+  it('should converge when one client inserts and another deletes', async () => {
+    const doc = await createDoc('Insert Delete Doc', 'hello world');
+    const client1 = await connectWs(doc.id);
+    const client2 = await connectWs(doc.id);
+
+    const baseVersion = client1.syncMsg.version;
+
+    // Client 1: insert "!" at end
+    const ack1Promise = waitForAck(client1.ws);
+    sendOp(client1.ws, doc.id, { type: 'insert', position: 11, text: '!' }, baseVersion);
+    await ack1Promise;
+
+    // Client 2: delete "world" based on same version
+    const ack2Promise = waitForAck(client2.ws);
+    sendOp(client2.ws, doc.id, { type: 'delete', position: 6, length: 5 }, baseVersion);
+    await ack2Promise;
+
+    // The document should be consistent
+    const res = await request(app.app).get(`/documents/${doc.id}`);
+    expect(res.body.content).toContain('hello');
+
+    await closeWs(client1.ws);
+    await closeWs(client2.ws);
+  });
+
+  it('should handle rapid sequential edits from two clients', async () => {
+    const doc = await createDoc('Rapid Doc', '');
+    const client1 = await connectWs(doc.id);
+    const client2 = await connectWs(doc.id);
+
+    let version = client1.syncMsg.version;
+
+    // Client 1 types "abc"
+    sendOp(client1.ws, doc.id, { type: 'insert', position: 0, text: 'a' }, version);
+    const ack1 = await waitForAck(client1.ws);
+    version = ack1.version;
+
+    sendOp(client1.ws, doc.id, { type: 'insert', position: 1, text: 'b' }, version);
+    const ack2 = await waitForAck(client1.ws);
+    version = ack2.version;
+
+    sendOp(client1.ws, doc.id, { type: 'insert', position: 2, text: 'c' }, version);
+    const ack3 = await waitForAck(client1.ws);
+    version = ack3.version;
+
+    // Client 2 types "xyz" using latest version
+    sendOp(client2.ws, doc.id, { type: 'insert', position: 3, text: 'x' }, version);
+    const ack4 = await waitForAck(client2.ws);
+    version = ack4.version;
+
+    sendOp(client2.ws, doc.id, { type: 'insert', position: 4, text: 'y' }, version);
+    const ack5 = await waitForAck(client2.ws);
+    version = ack5.version;
+
+    sendOp(client2.ws, doc.id, { type: 'insert', position: 5, text: 'z' }, version);
+    await waitForAck(client2.ws);
+
+    const res = await request(app.app).get(`/documents/${doc.id}`);
+    expect(res.body.content).toBe('abcxyz');
+
+    await closeWs(client1.ws);
+    await closeWs(client2.ws);
+  });
+
+  it('should handle concurrent deletes', async () => {
+    const doc = await createDoc('Concurrent Delete Doc', 'abcdefgh');
+    const client1 = await connectWs(doc.id);
+    const client2 = await connectWs(doc.id);
+
+    const baseVersion = client1.syncMsg.version;
+
+    // Client 1 deletes "cd" (pos 2, len 2)
+    const ack1Promise = waitForAck(client1.ws);
+    sendOp(client1.ws, doc.id, { type: 'delete', position: 2, length: 2 }, baseVersion);
+    await ack1Promise;
+
+    // Client 2 deletes "ef" (pos 4, len 2) based on same version
+    const ack2Promise = waitForAck(client2.ws);
+    sendOp(client2.ws, doc.id, { type: 'delete', position: 4, length: 2 }, baseVersion);
+    await ack2Promise;
+
+    const res = await request(app.app).get(`/documents/${doc.id}`);
+    // Both "cd" and "ef" should be removed: "abgh"
+    expect(res.body.content).toBe('abgh');
+
+    await closeWs(client1.ws);
+    await closeWs(client2.ws);
+  });
+
+  it('should handle overlapping deletes', async () => {
+    const doc = await createDoc('Overlap Delete Doc', 'abcdefgh');
+    const client1 = await connectWs(doc.id);
+    const client2 = await connectWs(doc.id);
+
+    const baseVersion = client1.syncMsg.version;
+
+    // Client 1 deletes "cde" (pos 2, len 3)
+    const ack1Promise = waitForAck(client1.ws);
+    sendOp(client1.ws, doc.id, { type: 'delete', position: 2, length: 3 }, baseVersion);
+    await ack1Promise;
+
+    // Client 2 deletes "defg" (pos 3, len 4) based on same version
+    const ack2Promise = waitForAck(client2.ws);
+    sendOp(client2.ws, doc.id, { type: 'delete', position: 3, length: 4 }, baseVersion);
+    await ack2Promise;
+
+    const res = await request(app.app).get(`/documents/${doc.id}`);
+    // "cdefg" union should be deleted: "abh"
+    expect(res.body.content).toBe('abh');
+
+    await closeWs(client1.ws);
+    await closeWs(client2.ws);
+  });
+
+  it('should maintain version consistency across clients', async () => {
+    const doc = await createDoc('Version Sync Doc', 'test');
+    const client1 = await connectWs(doc.id);
+    const client2 = await connectWs(doc.id);
+
+    expect(client1.syncMsg.version).toBe(client2.syncMsg.version);
+
+    sendOp(client1.ws, doc.id, { type: 'insert', position: 4, text: '!' }, client1.syncMsg.version);
+    const ack = await waitForAck(client1.ws);
+    const broadcast = await waitForOperation(client2.ws);
+
+    expect(ack.version).toBe(broadcast.version);
+
+    await closeWs(client1.ws);
+    await closeWs(client2.ws);
+  });
+});
+
+//  Stress Test 
+
+describe('Stress Test', () => {
+  let stressApp: AppInstance;
+  let stressPort: number;
+
+  beforeAll(async () => {
+    stressApp = createApp();
+    stressPort = await stressApp.start();
+  });
+
+  afterAll(async () => {
+    await stressApp.stop();
+  });
+
+  it('should handle 10 concurrent clients on the same document', async () => {
+    const doc = await request(stressApp.app)
+      .post('/documents')
+      .send({ title: 'Stress Doc', content: '' });
+
+    const docId = doc.body.id;
+    const clients: { ws: WebSocket; syncMsg: { version: number } }[] = [];
+
+    // Connect 10 clients
+    for (let i = 0; i < 10; i++) {
+      const client = await new Promise<{ ws: WebSocket; syncMsg: { version: number } }>((resolve, reject) => {
+        const ws = new WebSocket(`ws://localhost:${stressPort}/ws/documents/${docId}`);
+        ws.on('message', (data) => {
+          const msg = JSON.parse(data.toString());
+          if (msg.type === 'sync') {
+            resolve({ ws, syncMsg: msg });
+          }
+        });
+        ws.on('error', reject);
+      });
+      clients.push(client);
+    }
+
+    expect(clients.length).toBe(10);
+
+    // Close all clients
+    await Promise.all(clients.map((c) => closeWs(c.ws)));
+  }, 15000);
+
+  it('should handle 10 clients sending operations sequentially', async () => {
+    const doc = await request(stressApp.app)
+      .post('/documents')
+      .send({ title: 'Sequential Stress', content: '' });
+
+    const docId = doc.body.id;
+    const clients: { ws: WebSocket; syncMsg: { version: number } }[] = [];
+
+    for (let i = 0; i < 10; i++) {
+      const client = await new Promise<{ ws: WebSocket; syncMsg: { version: number } }>((resolve, reject) => {
+        const ws = new WebSocket(`ws://localhost:${stressPort}/ws/documents/${docId}`);
+        ws.on('message', (data) => {
+          const msg = JSON.parse(data.toString());
+          if (msg.type === 'sync') {
+            resolve({ ws, syncMsg: msg });
+          }
+        });
+        ws.on('error', reject);
+      });
+      clients.push(client);
+    }
+
+    // Each client sends one insert
+    let version = clients[0].syncMsg.version;
+    for (let i = 0; i < 10; i++) {
+      const ws = clients[i].ws;
+      sendOp(ws, docId, { type: 'insert', position: i, text: String(i) }, version);
+      const ack = await waitForAck(ws);
+      version = ack.version;
+    }
+
+    // Verify document
+    const res = await request(stressApp.app).get(`/documents/${docId}`);
+    expect(res.body.content).toBe('0123456789');
+
+    await Promise.all(clients.map((c) => closeWs(c.ws)));
+  }, 15000);
+
+  it('should handle concurrent operations from 10 clients', async () => {
+    const doc = await request(stressApp.app)
+      .post('/documents')
+      .send({ title: 'Concurrent Stress', content: '' });
+
+    const docId = doc.body.id;
+    const clients: { ws: WebSocket; syncMsg: { version: number } }[] = [];
+
+    for (let i = 0; i < 10; i++) {
+      const client = await new Promise<{ ws: WebSocket; syncMsg: { version: number } }>((resolve, reject) => {
+        const ws = new WebSocket(`ws://localhost:${stressPort}/ws/documents/${docId}`);
+        ws.on('message', (data) => {
+          const msg = JSON.parse(data.toString());
+          if (msg.type === 'sync') {
+            resolve({ ws, syncMsg: msg });
+          }
+        });
+        ws.on('error', reject);
+      });
+      clients.push(client);
+    }
+
+    const baseVersion = clients[0].syncMsg.version;
+
+    // All clients send inserts at position 0 concurrently
+    const ackPromises = clients.map((client, i) => {
+      sendOp(client.ws, docId, { type: 'insert', position: 0, text: String.fromCharCode(65 + i) }, baseVersion);
+      return waitForAck(client.ws);
+    });
+
+    await Promise.all(ackPromises);
+
+    // All characters should be present
+    const res = await request(stressApp.app).get(`/documents/${docId}`);
+    for (let i = 0; i < 10; i++) {
+      expect(res.body.content).toContain(String.fromCharCode(65 + i));
+    }
+    expect(res.body.content.length).toBe(10);
+
+    await Promise.all(clients.map((c) => closeWs(c.ws)));
+  }, 15000);
+
+  it('should not corrupt document under rapid concurrent edits', async () => {
+    const initial = 'The quick brown fox jumps over the lazy dog';
+    const doc = await request(stressApp.app)
+      .post('/documents')
+      .send({ title: 'Corruption Test', content: initial });
+
+    const docId = doc.body.id;
+    const clients: { ws: WebSocket; syncMsg: { version: number; content: string } }[] = [];
+
+    for (let i = 0; i < 5; i++) {
+      const client = await new Promise<{ ws: WebSocket; syncMsg: { version: number; content: string } }>((resolve, reject) => {
+        const ws = new WebSocket(`ws://localhost:${stressPort}/ws/documents/${docId}`);
+        ws.on('message', (data) => {
+          const msg = JSON.parse(data.toString());
+          if (msg.type === 'sync') {
+            resolve({ ws, syncMsg: msg });
+          }
+        });
+        ws.on('error', reject);
+      });
+      clients.push(client);
+    }
+
+    // Each client appends their character
+    const acks = [];
+    for (let i = 0; i < 5; i++) {
+      sendOp(clients[i].ws, docId,
+        { type: 'insert', position: initial.length, text: String(i) },
+        clients[i].syncMsg.version
+      );
+      acks.push(waitForAck(clients[i].ws));
+    }
+    await Promise.all(acks);
+
+    const res = await request(stressApp.app).get(`/documents/${docId}`);
+    // All digits should be present
+    for (let i = 0; i < 5; i++) {
+      expect(res.body.content).toContain(String(i));
+    }
+    // Original content should still be there
+    expect(res.body.content).toContain('The quick brown fox');
+
+    await Promise.all(clients.map((c) => closeWs(c.ws)));
+  }, 15000);
+
+  it('should handle rapid connect/disconnect cycles', async () => {
+    const doc = await request(stressApp.app)
+      .post('/documents')
+      .send({ title: 'Connect Cycle', content: 'stable' });
+
+    const docId = doc.body.id;
+
+    for (let i = 0; i < 10; i++) {
+      const { ws, syncMsg } = await new Promise<{ ws: WebSocket; syncMsg: Record<string, unknown> }>((resolve, reject) => {
+        const ws = new WebSocket(`ws://localhost:${stressPort}/ws/documents/${docId}`);
+        ws.on('message', (data) => {
+          const msg = JSON.parse(data.toString());
+          if (msg.type === 'sync') {
+            resolve({ ws, syncMsg: msg });
+          }
+        });
+        ws.on('error', reject);
+      });
+
+      expect(syncMsg.content).toBe('stable');
+      await closeWs(ws);
+    }
+
+    // Document should still be intact
+    const res = await request(stressApp.app).get(`/documents/${docId}`);
+    expect(res.body.content).toBe('stable');
+  }, 15000);
+});
+
+//  Error Handling 
+
+describe('Error Handling', () => {
+  beforeEach(async () => {
+    app = createApp();
+    port = await app.start();
+  });
+
+  afterEach(async () => {
+    await app.stop();
+  });
+
+  it('should reject insert with out-of-bounds position', async () => {
+    const doc = await createDoc('OOB Doc', 'hello');
+    const { ws, syncMsg } = await connectWs(doc.id);
+
+    sendOp(ws, doc.id, { type: 'insert', position: 100, text: 'x' }, syncMsg.version);
+    const errMsg = await waitForMessage(ws, 'error');
+    expect(errMsg.type).toBe('error');
+
+    await closeWs(ws);
+  });
+
+  it('should reject delete with out-of-bounds range', async () => {
+    const doc = await createDoc('OOB Delete Doc', 'hello');
+    const { ws, syncMsg } = await connectWs(doc.id);
+
+    sendOp(ws, doc.id, { type: 'delete', position: 0, length: 100 }, syncMsg.version);
+    const errMsg = await waitForMessage(ws, 'error');
+    expect(errMsg.type).toBe('error');
+
+    await closeWs(ws);
+  });
+
+  it('should reject operations with invalid baseVersion', async () => {
+    const doc = await createDoc('Bad Version Doc', 'hello');
+    const { ws } = await connectWs(doc.id);
+
+    sendOp(ws, doc.id, { type: 'insert', position: 0, text: 'x' }, 9999);
+    const errMsg = await waitForMessage(ws, 'error');
+    expect(errMsg.type).toBe('error');
+
+    await closeWs(ws);
+  });
+
+  it('should reject operations with missing fields', async () => {
+    const doc = await createDoc('Missing Fields Doc', 'hello');
+    const { ws, syncMsg } = await connectWs(doc.id);
+
+    ws.send(JSON.stringify({
+      type: 'operation',
+      docId: doc.id,
+      baseVersion: syncMsg.version,
+      // Missing operation field
+    }));
+    const errMsg = await waitForMessage(ws, 'error');
+    expect(errMsg.type).toBe('error');
+
+    await closeWs(ws);
+  });
+
+  it('should not crash on malformed operations', async () => {
+    const doc = await createDoc('Malformed Doc', 'hello');
+    const { ws, syncMsg } = await connectWs(doc.id);
+
+    // Send various malformed data
+    ws.send(JSON.stringify({
+      type: 'operation',
+      docId: doc.id,
+      operation: { type: 'invalid_op_type' },
+      baseVersion: syncMsg.version,
+    }));
+    const errMsg = await waitForMessage(ws, 'error');
+    expect(errMsg.type).toBe('error');
+
+    // The connection should still work after errors
+    sendOp(ws, doc.id, { type: 'insert', position: 0, text: 'x' }, syncMsg.version);
+    const ack = await waitForAck(ws);
+    expect(ack.type).toBe('ack');
+
+    await closeWs(ws);
+  });
+});
+
+//  Persistence 
+
+describe('Persistence', () => {
+  const dbPath = '/tmp/test-persistence-collab.db';
+
+  it('should persist documents across server restarts', async () => {
+    // Start server 1
+    const app1 = createApp(dbPath);
+    const port1 = await app1.start();
+
+    // Create a document
+    const res = await request(app1.app)
+      .post('/documents')
+      .send({ title: 'Persistent Doc', content: 'persist me' });
+
+    const docId = res.body.id;
+    await app1.stop();
+
+    // Start server 2 with same db
+    const app2 = createApp(dbPath);
+    await app2.start();
+
+    // Document should still exist
+    const res2 = await request(app2.app).get(`/documents/${docId}`);
+    expect(res2.status).toBe(200);
+    expect(res2.body.title).toBe('Persistent Doc');
+    expect(res2.body.content).toBe('persist me');
+
+    await app2.stop();
+
+    // Clean up
+    try {
+      const { unlinkSync } = await import('fs');
+      unlinkSync(dbPath);
+      unlinkSync(dbPath + '-wal');
+      unlinkSync(dbPath + '-shm');
+    } catch {
+      // Ignore cleanup errors
+    }
+  });
+
+  it('should persist edits made via WebSocket across restarts', async () => {
+    const dbPath2 = '/tmp/test-persistence-ws.db';
+
+    // Start server 1
+    const app1 = createApp(dbPath2);
+    const port1 = await app1.start();
+
+    // Create document and edit via WS
+    const doc = await request(app1.app)
+      .post('/documents')
+      .send({ title: 'WS Persist', content: 'initial' });
+    const docId = doc.body.id;
+
+    const { ws, syncMsg } = await new Promise<{ ws: WebSocket; syncMsg: { version: number } }>((resolve, reject) => {
+      const ws = new WebSocket(`ws://localhost:${port1}/ws/documents/${docId}`);
+      ws.on('message', (data) => {
+        const msg = JSON.parse(data.toString());
+        if (msg.type === 'sync') {
+          resolve({ ws, syncMsg: msg });
+        }
+      });
+      ws.on('error', reject);
+    });
+
+    sendOp(ws, docId, { type: 'insert', position: 7, text: ' edited' }, syncMsg.version);
+    await waitForAck(ws);
+    await closeWs(ws);
+    await app1.stop();
+
+    // Start server 2
+    const app2 = createApp(dbPath2);
+    await app2.start();
+
+    const res2 = await request(app2.app).get(`/documents/${docId}`);
+    expect(res2.status).toBe(200);
+    expect(res2.body.content).toBe('initial edited');
+
+    await app2.stop();
+
+    try {
+      const { unlinkSync } = await import('fs');
+      unlinkSync(dbPath2);
+      unlinkSync(dbPath2 + '-wal');
+      unlinkSync(dbPath2 + '-shm');
+    } catch {
+      // Ignore
+    }
+  });
+
+  it('should persist version history across restarts', async () => {
+    const dbPath3 = '/tmp/test-persistence-versions.db';
+
+    const app1 = createApp(dbPath3);
+    const port1 = await app1.start();
+
+    const doc = await request(app1.app)
+      .post('/documents')
+      .send({ title: 'Version Persist', content: 'v1' });
+    const docId = doc.body.id;
+
+    // Add some versions via WS
+    const { ws, syncMsg } = await new Promise<{ ws: WebSocket; syncMsg: { version: number } }>((resolve, reject) => {
+      const ws = new WebSocket(`ws://localhost:${port1}/ws/documents/${docId}`);
+      ws.on('message', (data) => {
+        const msg = JSON.parse(data.toString());
+        if (msg.type === 'sync') {
+          resolve({ ws, syncMsg: msg });
+        }
+      });
+      ws.on('error', reject);
+    });
+
+    sendOp(ws, docId, { type: 'insert', position: 2, text: '-updated' }, syncMsg.version);
+    await waitForAck(ws);
+    await closeWs(ws);
+    await app1.stop();
+
+    // Restart
+    const app2 = createApp(dbPath3);
+    await app2.start();
+
+    const versionsRes = await request(app2.app).get(`/documents/${docId}/versions`);
+    expect(versionsRes.status).toBe(200);
+    expect(versionsRes.body.length).toBeGreaterThanOrEqual(2);
+
+    await app2.stop();
+
+    try {
+      const { unlinkSync } = await import('fs');
+      unlinkSync(dbPath3);
+      unlinkSync(dbPath3 + '-wal');
+      unlinkSync(dbPath3 + '-shm');
+    } catch {
+      // Ignore
+    }
+  });
+});
