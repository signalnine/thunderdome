diff --git a/.runtime/agent.lock b/.runtime/agent.lock
new file mode 100644
index 0000000..c885953
--- /dev/null
+++ b/.runtime/agent.lock
@@ -0,0 +1,6 @@
+{
+  "pid": 875,
+  "acquired_at": "2026-02-15T03:37:36.471930088Z",
+  "session_id": "bench/rust",
+  "hostname": "1104fa3a062f"
+}
\ No newline at end of file
diff --git a/.thunderdome-metrics.json b/.thunderdome-metrics.json
new file mode 100644
index 0000000..8043c5c
--- /dev/null
+++ b/.thunderdome-metrics.json
@@ -0,0 +1,18 @@
+{
+  "input_tokens": 57,
+  "output_tokens": 40645,
+  "cache_read_tokens": 3247154,
+  "cache_creation_tokens": 85693,
+  "turns": 70,
+  "tools_used": [
+    "Task",
+    "Bash",
+    "Read",
+    "TodoWrite",
+    "Write",
+    "Edit",
+    "Grep"
+  ],
+  "duration_ms": 706593,
+  "total_cost_usd": 3.2465495499999997
+}
\ No newline at end of file
diff --git a/package-lock.json b/package-lock.json
index 1d53f39..7bfdff3 100644
--- a/package-lock.json
+++ b/package-lock.json
@@ -11,11 +11,83 @@
         "@types/node": "^25.2.3",
         "@typescript-eslint/eslint-plugin": "^7.0.0",
         "@typescript-eslint/parser": "^7.0.0",
+        "@vitest/coverage-v8": "^2.0.0",
         "eslint": "^8.56.0",
         "typescript": "^5.4.0",
         "vitest": "^2.0.0"
       }
     },
+    "node_modules/@ampproject/remapping": {
+      "version": "2.3.0",
+      "resolved": "https://registry.npmjs.org/@ampproject/remapping/-/remapping-2.3.0.tgz",
+      "integrity": "sha512-30iZtAPgz+LTIYoeivqYo853f02jBYSd5uGnGpkFV0M3xOt9aN73erkgYAmZU43x4VfqcnLxW9Kpg3R5LC4YYw==",
+      "dev": true,
+      "license": "Apache-2.0",
+      "dependencies": {
+        "@jridgewell/gen-mapping": "^0.3.5",
+        "@jridgewell/trace-mapping": "^0.3.24"
+      },
+      "engines": {
+        "node": ">=6.0.0"
+      }
+    },
+    "node_modules/@babel/helper-string-parser": {
+      "version": "7.27.1",
+      "resolved": "https://registry.npmjs.org/@babel/helper-string-parser/-/helper-string-parser-7.27.1.tgz",
+      "integrity": "sha512-qMlSxKbpRlAridDExk92nSobyDdpPijUq2DW6oDnUqd0iOGxmQjyqhMIihI9+zv4LPyZdRje2cavWPbCbWm3eA==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=6.9.0"
+      }
+    },
+    "node_modules/@babel/helper-validator-identifier": {
+      "version": "7.28.5",
+      "resolved": "https://registry.npmjs.org/@babel/helper-validator-identifier/-/helper-validator-identifier-7.28.5.tgz",
+      "integrity": "sha512-qSs4ifwzKJSV39ucNjsvc6WVHs6b7S03sOh2OcHF9UHfVPqWWALUsNUVzhSBiItjRZoLHx7nIarVjqKVusUZ1Q==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=6.9.0"
+      }
+    },
+    "node_modules/@babel/parser": {
+      "version": "7.29.0",
+      "resolved": "https://registry.npmjs.org/@babel/parser/-/parser-7.29.0.tgz",
+      "integrity": "sha512-IyDgFV5GeDUVX4YdF/3CPULtVGSXXMLh1xVIgdCgxApktqnQV0r7/8Nqthg+8YLGaAtdyIlo2qIdZrbCv4+7ww==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@babel/types": "^7.29.0"
+      },
+      "bin": {
+        "parser": "bin/babel-parser.js"
+      },
+      "engines": {
+        "node": ">=6.0.0"
+      }
+    },
+    "node_modules/@babel/types": {
+      "version": "7.29.0",
+      "resolved": "https://registry.npmjs.org/@babel/types/-/types-7.29.0.tgz",
+      "integrity": "sha512-LwdZHpScM4Qz8Xw2iKSzS+cfglZzJGvofQICy7W7v4caru4EaAmyUuO6BGrbyQ2mYV11W0U8j5mBhd14dd3B0A==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@babel/helper-string-parser": "^7.27.1",
+        "@babel/helper-validator-identifier": "^7.28.5"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      }
+    },
+    "node_modules/@bcoe/v8-coverage": {
+      "version": "0.2.3",
+      "resolved": "https://registry.npmjs.org/@bcoe/v8-coverage/-/v8-coverage-0.2.3.tgz",
+      "integrity": "sha512-0hYQ8SB4Db5zvZB4axdMHGwEaQjkZzFjQiN9LVYvIFB2nSUHW9tYpxWriPrWDASIxiaXax83REcLxuSdnGPZtw==",
+      "dev": true,
+      "license": "MIT"
+    },
     "node_modules/@esbuild/aix-ppc64": {
       "version": "0.21.5",
       "resolved": "https://registry.npmjs.org/@esbuild/aix-ppc64/-/aix-ppc64-0.21.5.tgz",
@@ -556,6 +628,84 @@
       "dev": true,
       "license": "BSD-3-Clause"
     },
+    "node_modules/@isaacs/cliui": {
+      "version": "8.0.2",
+      "resolved": "https://registry.npmjs.org/@isaacs/cliui/-/cliui-8.0.2.tgz",
+      "integrity": "sha512-O8jcjabXaleOG9DQ0+ARXWZBTfnP4WNAqzuiJK7ll44AmxGKv/J2M4TPjxjY3znBCfvBXFzucm1twdyFybFqEA==",
+      "dev": true,
+      "license": "ISC",
+      "dependencies": {
+        "string-width": "^5.1.2",
+        "string-width-cjs": "npm:string-width@^4.2.0",
+        "strip-ansi": "^7.0.1",
+        "strip-ansi-cjs": "npm:strip-ansi@^6.0.1",
+        "wrap-ansi": "^8.1.0",
+        "wrap-ansi-cjs": "npm:wrap-ansi@^7.0.0"
+      },
+      "engines": {
+        "node": ">=12"
+      }
+    },
+    "node_modules/@isaacs/cliui/node_modules/ansi-regex": {
+      "version": "6.2.2",
+      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-6.2.2.tgz",
+      "integrity": "sha512-Bq3SmSpyFHaWjPk8If9yc6svM8c56dB5BAtW4Qbw5jHTwwXXcTLoRMkpDJp6VL0XzlWaCHTXrkFURMYmD0sLqg==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/ansi-regex?sponsor=1"
+      }
+    },
+    "node_modules/@isaacs/cliui/node_modules/strip-ansi": {
+      "version": "7.1.2",
+      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-7.1.2.tgz",
+      "integrity": "sha512-gmBGslpoQJtgnMAvOVqGZpEz9dyoKTCzy2nfz/n8aIFhN/jCE/rCmcxabB6jOOHV+0WNnylOxaxBQPSvcWklhA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "ansi-regex": "^6.0.1"
+      },
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/strip-ansi?sponsor=1"
+      }
+    },
+    "node_modules/@istanbuljs/schema": {
+      "version": "0.1.3",
+      "resolved": "https://registry.npmjs.org/@istanbuljs/schema/-/schema-0.1.3.tgz",
+      "integrity": "sha512-ZXRY4jNvVgSVQ8DL3LTcakaAtXwTVUxE81hslsyD2AtoXW/wVob10HkOJ1X/pAlcI7D+2YoZKg5do8G/w6RYgA==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/@jridgewell/gen-mapping": {
+      "version": "0.3.13",
+      "resolved": "https://registry.npmjs.org/@jridgewell/gen-mapping/-/gen-mapping-0.3.13.tgz",
+      "integrity": "sha512-2kkt/7niJ6MgEPxF0bYdQ6etZaA+fQvDcLKckhy1yIQOzaoKjBBjSj63/aLVjYE3qhRt5dvM+uUyfCg6UKCBbA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@jridgewell/sourcemap-codec": "^1.5.0",
+        "@jridgewell/trace-mapping": "^0.3.24"
+      }
+    },
+    "node_modules/@jridgewell/resolve-uri": {
+      "version": "3.1.2",
+      "resolved": "https://registry.npmjs.org/@jridgewell/resolve-uri/-/resolve-uri-3.1.2.tgz",
+      "integrity": "sha512-bRISgCIjP20/tbWSPWMEi54QVPRZExkuD9lJL+UIxUKtwVJA8wW1Trb1jMs1RFXo1CBTNZ/5hpC9QvmKWdopKw==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=6.0.0"
+      }
+    },
     "node_modules/@jridgewell/sourcemap-codec": {
       "version": "1.5.5",
       "resolved": "https://registry.npmjs.org/@jridgewell/sourcemap-codec/-/sourcemap-codec-1.5.5.tgz",
@@ -563,6 +713,17 @@
       "dev": true,
       "license": "MIT"
     },
+    "node_modules/@jridgewell/trace-mapping": {
+      "version": "0.3.31",
+      "resolved": "https://registry.npmjs.org/@jridgewell/trace-mapping/-/trace-mapping-0.3.31.tgz",
+      "integrity": "sha512-zzNR+SdQSDJzc8joaeP8QQoCQr8NuYx2dIIytl1QeBEZHJ9uW6hebsrYgbz8hJwUQao3TWCMtmfV8Nu1twOLAw==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@jridgewell/resolve-uri": "^3.1.0",
+        "@jridgewell/sourcemap-codec": "^1.4.14"
+      }
+    },
     "node_modules/@nodelib/fs.scandir": {
       "version": "2.1.5",
       "resolved": "https://registry.npmjs.org/@nodelib/fs.scandir/-/fs.scandir-2.1.5.tgz",
@@ -601,6 +762,17 @@
         "node": ">= 8"
       }
     },
+    "node_modules/@pkgjs/parseargs": {
+      "version": "0.11.0",
+      "resolved": "https://registry.npmjs.org/@pkgjs/parseargs/-/parseargs-0.11.0.tgz",
+      "integrity": "sha512-+1VkjdD0QBLPodGrJUeqarH8VAIvQODIbwh9XpP5Syisf7YoQgsJKPNFoqqLQlu+VQ/tVSshMR6loPMn8U+dPg==",
+      "dev": true,
+      "license": "MIT",
+      "optional": true,
+      "engines": {
+        "node": ">=14"
+      }
+    },
     "node_modules/@rollup/rollup-android-arm-eabi": {
       "version": "4.57.1",
       "resolved": "https://registry.npmjs.org/@rollup/rollup-android-arm-eabi/-/rollup-android-arm-eabi-4.57.1.tgz",
@@ -964,7 +1136,6 @@
       "integrity": "sha512-m0jEgYlYz+mDJZ2+F4v8D1AyQb+QzsNqRuI7xg1VQX/KlKS0qT9r1Mo16yo5F/MtifXFgaofIFsdFMox2SxIbQ==",
       "dev": true,
       "license": "MIT",
-      "peer": true,
       "dependencies": {
         "undici-types": "~7.16.0"
       }
@@ -1009,7 +1180,6 @@
       "integrity": "sha512-4Z+L8I2OqhZV8qA132M4wNL30ypZGYOQVBfMgxDH/K5UX0PNqTu1c6za9ST5r9+tavvHiTWmBnKzpCJ/GlVFtg==",
       "dev": true,
       "license": "BSD-2-Clause",
-      "peer": true,
       "dependencies": {
         "@typescript-eslint/scope-manager": "7.18.0",
         "@typescript-eslint/types": "7.18.0",
@@ -1170,6 +1340,39 @@
       "dev": true,
       "license": "ISC"
     },
+    "node_modules/@vitest/coverage-v8": {
+      "version": "2.1.9",
+      "resolved": "https://registry.npmjs.org/@vitest/coverage-v8/-/coverage-v8-2.1.9.tgz",
+      "integrity": "sha512-Z2cOr0ksM00MpEfyVE8KXIYPEcBFxdbLSs56L8PO0QQMxt/6bDj45uQfxoc96v05KW3clk7vvgP0qfDit9DmfQ==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@ampproject/remapping": "^2.3.0",
+        "@bcoe/v8-coverage": "^0.2.3",
+        "debug": "^4.3.7",
+        "istanbul-lib-coverage": "^3.2.2",
+        "istanbul-lib-report": "^3.0.1",
+        "istanbul-lib-source-maps": "^5.0.6",
+        "istanbul-reports": "^3.1.7",
+        "magic-string": "^0.30.12",
+        "magicast": "^0.3.5",
+        "std-env": "^3.8.0",
+        "test-exclude": "^7.0.1",
+        "tinyrainbow": "^1.2.0"
+      },
+      "funding": {
+        "url": "https://opencollective.com/vitest"
+      },
+      "peerDependencies": {
+        "@vitest/browser": "2.1.9",
+        "vitest": "2.1.9"
+      },
+      "peerDependenciesMeta": {
+        "@vitest/browser": {
+          "optional": true
+        }
+      }
+    },
     "node_modules/@vitest/expect": {
       "version": "2.1.9",
       "resolved": "https://registry.npmjs.org/@vitest/expect/-/expect-2.1.9.tgz",
@@ -1289,7 +1492,6 @@
       "integrity": "sha512-NZyJarBfL7nWwIq+FDL6Zp/yHEhePMNnnJ0y3qfieCrmNvYct8uvtiV41UvlSe6apAfk0fY1FbWx+NwfmpvtTg==",
       "dev": true,
       "license": "MIT",
-      "peer": true,
       "bin": {
         "acorn": "bin/acorn"
       },
@@ -1574,6 +1776,20 @@
         "node": ">=6.0.0"
       }
     },
+    "node_modules/eastasianwidth": {
+      "version": "0.2.0",
+      "resolved": "https://registry.npmjs.org/eastasianwidth/-/eastasianwidth-0.2.0.tgz",
+      "integrity": "sha512-I88TYZWc9XiYHRQ4/3c5rjjfgkjhLyW2luGIheGERbNQ6OY7yTybanSpDXZa8y7VUP9YmDcYa+eyq4ca7iLqWA==",
+      "dev": true,
+      "license": "MIT"
+    },
+    "node_modules/emoji-regex": {
+      "version": "9.2.2",
+      "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-9.2.2.tgz",
+      "integrity": "sha512-L18DaJsXSUk2+42pv8mLs5jJT2hqFkFE4j21wOmgbUqsZ2hL72NsUU785g9RXgo3s0ZNgVl42TiHp3ZtOv/Vyg==",
+      "dev": true,
+      "license": "MIT"
+    },
     "node_modules/es-module-lexer": {
       "version": "1.7.0",
       "resolved": "https://registry.npmjs.org/es-module-lexer/-/es-module-lexer-1.7.0.tgz",
@@ -1640,7 +1856,6 @@
       "deprecated": "This version is no longer supported. Please see https://eslint.org/version-support for other options.",
       "dev": true,
       "license": "MIT",
-      "peer": true,
       "dependencies": {
         "@eslint-community/eslint-utils": "^4.2.0",
         "@eslint-community/regexpp": "^4.6.1",
@@ -1955,6 +2170,23 @@
       "dev": true,
       "license": "ISC"
     },
+    "node_modules/foreground-child": {
+      "version": "3.3.1",
+      "resolved": "https://registry.npmjs.org/foreground-child/-/foreground-child-3.3.1.tgz",
+      "integrity": "sha512-gIXjKqtFuWEgzFRJA9WCQeSJLZDjgJUOMCMzxtvFq/37KojM1BFGufqsCy0r4qSQmYLsZYMeyRqzIWOMup03sw==",
+      "dev": true,
+      "license": "ISC",
+      "dependencies": {
+        "cross-spawn": "^7.0.6",
+        "signal-exit": "^4.0.1"
+      },
+      "engines": {
+        "node": ">=14"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/isaacs"
+      }
+    },
     "node_modules/fs.realpath": {
       "version": "1.0.0",
       "resolved": "https://registry.npmjs.org/fs.realpath/-/fs.realpath-1.0.0.tgz",
@@ -2090,6 +2322,13 @@
         "node": ">=8"
       }
     },
+    "node_modules/html-escaper": {
+      "version": "2.0.2",
+      "resolved": "https://registry.npmjs.org/html-escaper/-/html-escaper-2.0.2.tgz",
+      "integrity": "sha512-H2iMtd0I4Mt5eYiapRdIDjp+XzelXQ0tFE4JS7YFwFevXXMmOp9myNrUvCg0D6ws8iqkRPBfKHgbwig1SmlLfg==",
+      "dev": true,
+      "license": "MIT"
+    },
     "node_modules/ignore": {
       "version": "5.3.2",
       "resolved": "https://registry.npmjs.org/ignore/-/ignore-5.3.2.tgz",
@@ -2156,6 +2395,16 @@
         "node": ">=0.10.0"
       }
     },
+    "node_modules/is-fullwidth-code-point": {
+      "version": "3.0.0",
+      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/is-fullwidth-code-point-3.0.0.tgz",
+      "integrity": "sha512-zymm5+u+sCsSWyD9qNaejV3DFvhCKclKdizYaJUuHA83RLjb7nSuGnddCHGv0hk+KY7BMAlsWeK4Ueg6EV6XQg==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=8"
+      }
+    },
     "node_modules/is-glob": {
       "version": "4.0.3",
       "resolved": "https://registry.npmjs.org/is-glob/-/is-glob-4.0.3.tgz",
@@ -2196,6 +2445,76 @@
       "dev": true,
       "license": "ISC"
     },
+    "node_modules/istanbul-lib-coverage": {
+      "version": "3.2.2",
+      "resolved": "https://registry.npmjs.org/istanbul-lib-coverage/-/istanbul-lib-coverage-3.2.2.tgz",
+      "integrity": "sha512-O8dpsF+r0WV/8MNRKfnmrtCWhuKjxrq2w+jpzBL5UZKTi2LeVWnWOmWRxFlesJONmc+wLAGvKQZEOanko0LFTg==",
+      "dev": true,
+      "license": "BSD-3-Clause",
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/istanbul-lib-report": {
+      "version": "3.0.1",
+      "resolved": "https://registry.npmjs.org/istanbul-lib-report/-/istanbul-lib-report-3.0.1.tgz",
+      "integrity": "sha512-GCfE1mtsHGOELCU8e/Z7YWzpmybrx/+dSTfLrvY8qRmaY6zXTKWn6WQIjaAFw069icm6GVMNkgu0NzI4iPZUNw==",
+      "dev": true,
+      "license": "BSD-3-Clause",
+      "dependencies": {
+        "istanbul-lib-coverage": "^3.0.0",
+        "make-dir": "^4.0.0",
+        "supports-color": "^7.1.0"
+      },
+      "engines": {
+        "node": ">=10"
+      }
+    },
+    "node_modules/istanbul-lib-source-maps": {
+      "version": "5.0.6",
+      "resolved": "https://registry.npmjs.org/istanbul-lib-source-maps/-/istanbul-lib-source-maps-5.0.6.tgz",
+      "integrity": "sha512-yg2d+Em4KizZC5niWhQaIomgf5WlL4vOOjZ5xGCmF8SnPE/mDWWXgvRExdcpCgh9lLRRa1/fSYp2ymmbJ1pI+A==",
+      "dev": true,
+      "license": "BSD-3-Clause",
+      "dependencies": {
+        "@jridgewell/trace-mapping": "^0.3.23",
+        "debug": "^4.1.1",
+        "istanbul-lib-coverage": "^3.0.0"
+      },
+      "engines": {
+        "node": ">=10"
+      }
+    },
+    "node_modules/istanbul-reports": {
+      "version": "3.2.0",
+      "resolved": "https://registry.npmjs.org/istanbul-reports/-/istanbul-reports-3.2.0.tgz",
+      "integrity": "sha512-HGYWWS/ehqTV3xN10i23tkPkpH46MLCIMFNCaaKNavAXTF1RkqxawEPtnjnGZ6XKSInBKkiOA5BKS+aZiY3AvA==",
+      "dev": true,
+      "license": "BSD-3-Clause",
+      "dependencies": {
+        "html-escaper": "^2.0.0",
+        "istanbul-lib-report": "^3.0.0"
+      },
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/jackspeak": {
+      "version": "3.4.3",
+      "resolved": "https://registry.npmjs.org/jackspeak/-/jackspeak-3.4.3.tgz",
+      "integrity": "sha512-OGlZQpz2yfahA/Rd1Y8Cd9SIEsqvXkLVoSw/cgwhnhFMDbsQFeZYoJJ7bIZBS9BcamUW96asq/npPWugM+RQBw==",
+      "dev": true,
+      "license": "BlueOak-1.0.0",
+      "dependencies": {
+        "@isaacs/cliui": "^8.0.2"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/isaacs"
+      },
+      "optionalDependencies": {
+        "@pkgjs/parseargs": "^0.11.0"
+      }
+    },
     "node_modules/js-yaml": {
       "version": "4.1.1",
       "resolved": "https://registry.npmjs.org/js-yaml/-/js-yaml-4.1.1.tgz",
@@ -2284,6 +2603,13 @@
       "dev": true,
       "license": "MIT"
     },
+    "node_modules/lru-cache": {
+      "version": "10.4.3",
+      "resolved": "https://registry.npmjs.org/lru-cache/-/lru-cache-10.4.3.tgz",
+      "integrity": "sha512-JNAzZcXrCt42VGLuYz0zfAzDfAvJWW6AfYlDBQyDV5DClI2m5sAmK+OIO7s59XfsRsWHp02jAJrRadPRGTt6SQ==",
+      "dev": true,
+      "license": "ISC"
+    },
     "node_modules/magic-string": {
       "version": "0.30.21",
       "resolved": "https://registry.npmjs.org/magic-string/-/magic-string-0.30.21.tgz",
@@ -2294,6 +2620,34 @@
         "@jridgewell/sourcemap-codec": "^1.5.5"
       }
     },
+    "node_modules/magicast": {
+      "version": "0.3.5",
+      "resolved": "https://registry.npmjs.org/magicast/-/magicast-0.3.5.tgz",
+      "integrity": "sha512-L0WhttDl+2BOsybvEOLK7fW3UA0OQ0IQ2d6Zl2x/a6vVRs3bAY0ECOSHHeL5jD+SbOpOCUEi0y1DgHEn9Qn1AQ==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@babel/parser": "^7.25.4",
+        "@babel/types": "^7.25.4",
+        "source-map-js": "^1.2.0"
+      }
+    },
+    "node_modules/make-dir": {
+      "version": "4.0.0",
+      "resolved": "https://registry.npmjs.org/make-dir/-/make-dir-4.0.0.tgz",
+      "integrity": "sha512-hXdUTZYIVOt1Ex//jAQi+wTZZpUpwBj/0QsOzqegb3rGMMeJiSEu5xLHnYfBrRV4RH2+OCSOO95Is/7x1WJ4bw==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "semver": "^7.5.3"
+      },
+      "engines": {
+        "node": ">=10"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/sindresorhus"
+      }
+    },
     "node_modules/merge2": {
       "version": "1.4.1",
       "resolved": "https://registry.npmjs.org/merge2/-/merge2-1.4.1.tgz",
@@ -2334,6 +2688,16 @@
         "url": "https://github.com/sponsors/isaacs"
       }
     },
+    "node_modules/minipass": {
+      "version": "7.1.2",
+      "resolved": "https://registry.npmjs.org/minipass/-/minipass-7.1.2.tgz",
+      "integrity": "sha512-qOOzS1cBTWYF4BH8fVePDBOO9iptMnGUEZwNc/cMWnTV2nVLZ7VoNWEPHkYczZA0pdoA7dl6e7FL659nX9S2aw==",
+      "dev": true,
+      "license": "ISC",
+      "engines": {
+        "node": ">=16 || 14 >=14.17"
+      }
+    },
     "node_modules/ms": {
       "version": "2.1.3",
       "resolved": "https://registry.npmjs.org/ms/-/ms-2.1.3.tgz",
@@ -2427,6 +2791,13 @@
         "url": "https://github.com/sponsors/sindresorhus"
       }
     },
+    "node_modules/package-json-from-dist": {
+      "version": "1.0.1",
+      "resolved": "https://registry.npmjs.org/package-json-from-dist/-/package-json-from-dist-1.0.1.tgz",
+      "integrity": "sha512-UEZIS3/by4OC8vL3P2dTXRETpebLI2NiI5vIrjaD/5UtrkFX/tNbwjTSRAGC/+7CAo2pIcBaRgWmcBBHcsaCIw==",
+      "dev": true,
+      "license": "BlueOak-1.0.0"
+    },
     "node_modules/parent-module": {
       "version": "1.0.1",
       "resolved": "https://registry.npmjs.org/parent-module/-/parent-module-1.0.1.tgz",
@@ -2470,6 +2841,23 @@
         "node": ">=8"
       }
     },
+    "node_modules/path-scurry": {
+      "version": "1.11.1",
+      "resolved": "https://registry.npmjs.org/path-scurry/-/path-scurry-1.11.1.tgz",
+      "integrity": "sha512-Xa4Nw17FS9ApQFJ9umLiJS4orGjm7ZzwUrwamcGQuHSzDyth9boKDaycYdDcZDuqYATXw4HFXgaqWTctW/v1HA==",
+      "dev": true,
+      "license": "BlueOak-1.0.0",
+      "dependencies": {
+        "lru-cache": "^10.2.0",
+        "minipass": "^5.0.0 || ^6.0.2 || ^7.0.0"
+      },
+      "engines": {
+        "node": ">=16 || 14 >=14.18"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/isaacs"
+      }
+    },
     "node_modules/path-type": {
       "version": "4.0.0",
       "resolved": "https://registry.npmjs.org/path-type/-/path-type-4.0.0.tgz",
@@ -2737,6 +3125,19 @@
       "dev": true,
       "license": "ISC"
     },
+    "node_modules/signal-exit": {
+      "version": "4.1.0",
+      "resolved": "https://registry.npmjs.org/signal-exit/-/signal-exit-4.1.0.tgz",
+      "integrity": "sha512-bzyZ1e88w9O1iNJbKnOlvYTrWPDl46O1bG0D3XInv+9tkPrxrN8jUUTiFlDkkmKWgn1M6CfIA13SuGqOa9Korw==",
+      "dev": true,
+      "license": "ISC",
+      "engines": {
+        "node": ">=14"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/isaacs"
+      }
+    },
     "node_modules/slash": {
       "version": "3.0.0",
       "resolved": "https://registry.npmjs.org/slash/-/slash-3.0.0.tgz",
@@ -2771,6 +3172,76 @@
       "dev": true,
       "license": "MIT"
     },
+    "node_modules/string-width": {
+      "version": "5.1.2",
+      "resolved": "https://registry.npmjs.org/string-width/-/string-width-5.1.2.tgz",
+      "integrity": "sha512-HnLOCR3vjcY8beoNLtcjZ5/nxn2afmME6lhrDrebokqMap+XbeW8n9TXpPDOqdGK5qcI3oT0GKTW6wC7EMiVqA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "eastasianwidth": "^0.2.0",
+        "emoji-regex": "^9.2.2",
+        "strip-ansi": "^7.0.1"
+      },
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/sindresorhus"
+      }
+    },
+    "node_modules/string-width-cjs": {
+      "name": "string-width",
+      "version": "4.2.3",
+      "resolved": "https://registry.npmjs.org/string-width/-/string-width-4.2.3.tgz",
+      "integrity": "sha512-wKyQRQpjJ0sIp62ErSZdGsjMJWsap5oRNihHhu6G7JVO/9jIB6UyevL+tXuOqrng8j/cxKTWyWUwvSTriiZz/g==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "emoji-regex": "^8.0.0",
+        "is-fullwidth-code-point": "^3.0.0",
+        "strip-ansi": "^6.0.1"
+      },
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/string-width-cjs/node_modules/emoji-regex": {
+      "version": "8.0.0",
+      "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-8.0.0.tgz",
+      "integrity": "sha512-MSjYzcWNOA0ewAHpz0MxpYFvwg6yjy1NG3xteoqz644VCo/RPgnr1/GGt+ic3iJTzQ8Eu3TdM14SawnVUmGE6A==",
+      "dev": true,
+      "license": "MIT"
+    },
+    "node_modules/string-width/node_modules/ansi-regex": {
+      "version": "6.2.2",
+      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-6.2.2.tgz",
+      "integrity": "sha512-Bq3SmSpyFHaWjPk8If9yc6svM8c56dB5BAtW4Qbw5jHTwwXXcTLoRMkpDJp6VL0XzlWaCHTXrkFURMYmD0sLqg==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/ansi-regex?sponsor=1"
+      }
+    },
+    "node_modules/string-width/node_modules/strip-ansi": {
+      "version": "7.1.2",
+      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-7.1.2.tgz",
+      "integrity": "sha512-gmBGslpoQJtgnMAvOVqGZpEz9dyoKTCzy2nfz/n8aIFhN/jCE/rCmcxabB6jOOHV+0WNnylOxaxBQPSvcWklhA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "ansi-regex": "^6.0.1"
+      },
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/strip-ansi?sponsor=1"
+      }
+    },
     "node_modules/strip-ansi": {
       "version": "6.0.1",
       "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-6.0.1.tgz",
@@ -2784,6 +3255,20 @@
         "node": ">=8"
       }
     },
+    "node_modules/strip-ansi-cjs": {
+      "name": "strip-ansi",
+      "version": "6.0.1",
+      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-6.0.1.tgz",
+      "integrity": "sha512-Y38VPSHcqkFrCpFnQ9vuSXmquuv5oXOKpGeT6aGrr3o3Gc9AlVa6JBfUSOCnbxGGZF+/0ooI7KrPuUSztUdU5A==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "ansi-regex": "^5.0.1"
+      },
+      "engines": {
+        "node": ">=8"
+      }
+    },
     "node_modules/strip-json-comments": {
       "version": "3.1.1",
       "resolved": "https://registry.npmjs.org/strip-json-comments/-/strip-json-comments-3.1.1.tgz",
@@ -2810,6 +3295,43 @@
         "node": ">=8"
       }
     },
+    "node_modules/test-exclude": {
+      "version": "7.0.1",
+      "resolved": "https://registry.npmjs.org/test-exclude/-/test-exclude-7.0.1.tgz",
+      "integrity": "sha512-pFYqmTw68LXVjeWJMST4+borgQP2AyMNbg1BpZh9LbyhUeNkeaPF9gzfPGUAnSMV3qPYdWUwDIjjCLiSDOl7vg==",
+      "dev": true,
+      "license": "ISC",
+      "dependencies": {
+        "@istanbuljs/schema": "^0.1.2",
+        "glob": "^10.4.1",
+        "minimatch": "^9.0.4"
+      },
+      "engines": {
+        "node": ">=18"
+      }
+    },
+    "node_modules/test-exclude/node_modules/glob": {
+      "version": "10.5.0",
+      "resolved": "https://registry.npmjs.org/glob/-/glob-10.5.0.tgz",
+      "integrity": "sha512-DfXN8DfhJ7NH3Oe7cFmu3NCu1wKbkReJ8TorzSAFbSKrlNaQSKfIzqYqVY8zlbs2NLBbWpRiU52GX2PbaBVNkg==",
+      "deprecated": "Old versions of glob are not supported, and contain widely publicized security vulnerabilities, which have been fixed in the current version. Please update. Support for old versions may be purchased (at exorbitant rates) by contacting i@izs.me",
+      "dev": true,
+      "license": "ISC",
+      "dependencies": {
+        "foreground-child": "^3.1.0",
+        "jackspeak": "^3.1.2",
+        "minimatch": "^9.0.4",
+        "minipass": "^7.1.2",
+        "package-json-from-dist": "^1.0.0",
+        "path-scurry": "^1.11.1"
+      },
+      "bin": {
+        "glob": "dist/esm/bin.mjs"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/isaacs"
+      }
+    },
     "node_modules/text-table": {
       "version": "0.2.0",
       "resolved": "https://registry.npmjs.org/text-table/-/text-table-0.2.0.tgz",
@@ -2919,7 +3441,6 @@
       "integrity": "sha512-jl1vZzPDinLr9eUt3J/t7V6FgNEw9QjvBPdysz9KfQDD41fQrC2Y4vKQdiaUpFT4bXlb1RHhLpp8wtm6M5TgSw==",
       "dev": true,
       "license": "Apache-2.0",
-      "peer": true,
       "bin": {
         "tsc": "bin/tsc",
         "tsserver": "bin/tsserver"
@@ -2951,7 +3472,6 @@
       "integrity": "sha512-o5a9xKjbtuhY6Bi5S3+HvbRERmouabWbyUcpXXUA1u+GNUKoROi9byOJ8M0nHbHYHkYICiMlqxkg1KkYmm25Sw==",
       "dev": true,
       "license": "MIT",
-      "peer": true,
       "dependencies": {
         "esbuild": "^0.21.3",
         "postcss": "^8.4.43",
@@ -3138,6 +3658,107 @@
         "node": ">=0.10.0"
       }
     },
+    "node_modules/wrap-ansi": {
+      "version": "8.1.0",
+      "resolved": "https://registry.npmjs.org/wrap-ansi/-/wrap-ansi-8.1.0.tgz",
+      "integrity": "sha512-si7QWI6zUMq56bESFvagtmzMdGOtoxfR+Sez11Mobfc7tm+VkUckk9bW2UeffTGVUbOksxmSw0AA2gs8g71NCQ==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "ansi-styles": "^6.1.0",
+        "string-width": "^5.0.1",
+        "strip-ansi": "^7.0.1"
+      },
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/wrap-ansi?sponsor=1"
+      }
+    },
+    "node_modules/wrap-ansi-cjs": {
+      "name": "wrap-ansi",
+      "version": "7.0.0",
+      "resolved": "https://registry.npmjs.org/wrap-ansi/-/wrap-ansi-7.0.0.tgz",
+      "integrity": "sha512-YVGIj2kamLSTxw6NsZjoBxfSwsn0ycdesmc4p+Q21c5zPuZ1pl+NfxVdxPtdHvmNVOQ6XSYG4AUtyt/Fi7D16Q==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "ansi-styles": "^4.0.0",
+        "string-width": "^4.1.0",
+        "strip-ansi": "^6.0.0"
+      },
+      "engines": {
+        "node": ">=10"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/wrap-ansi?sponsor=1"
+      }
+    },
+    "node_modules/wrap-ansi-cjs/node_modules/emoji-regex": {
+      "version": "8.0.0",
+      "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-8.0.0.tgz",
+      "integrity": "sha512-MSjYzcWNOA0ewAHpz0MxpYFvwg6yjy1NG3xteoqz644VCo/RPgnr1/GGt+ic3iJTzQ8Eu3TdM14SawnVUmGE6A==",
+      "dev": true,
+      "license": "MIT"
+    },
+    "node_modules/wrap-ansi-cjs/node_modules/string-width": {
+      "version": "4.2.3",
+      "resolved": "https://registry.npmjs.org/string-width/-/string-width-4.2.3.tgz",
+      "integrity": "sha512-wKyQRQpjJ0sIp62ErSZdGsjMJWsap5oRNihHhu6G7JVO/9jIB6UyevL+tXuOqrng8j/cxKTWyWUwvSTriiZz/g==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "emoji-regex": "^8.0.0",
+        "is-fullwidth-code-point": "^3.0.0",
+        "strip-ansi": "^6.0.1"
+      },
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/wrap-ansi/node_modules/ansi-regex": {
+      "version": "6.2.2",
+      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-6.2.2.tgz",
+      "integrity": "sha512-Bq3SmSpyFHaWjPk8If9yc6svM8c56dB5BAtW4Qbw5jHTwwXXcTLoRMkpDJp6VL0XzlWaCHTXrkFURMYmD0sLqg==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/ansi-regex?sponsor=1"
+      }
+    },
+    "node_modules/wrap-ansi/node_modules/ansi-styles": {
+      "version": "6.2.3",
+      "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-6.2.3.tgz",
+      "integrity": "sha512-4Dj6M28JB+oAH8kFkTLUo+a2jwOFkuqb3yucU0CANcRRUbxS0cP0nZYCGjcc3BNXwRIsUVmDGgzawme7zvJHvg==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/ansi-styles?sponsor=1"
+      }
+    },
+    "node_modules/wrap-ansi/node_modules/strip-ansi": {
+      "version": "7.1.2",
+      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-7.1.2.tgz",
+      "integrity": "sha512-gmBGslpoQJtgnMAvOVqGZpEz9dyoKTCzy2nfz/n8aIFhN/jCE/rCmcxabB6jOOHV+0WNnylOxaxBQPSvcWklhA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "ansi-regex": "^6.0.1"
+      },
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/strip-ansi?sponsor=1"
+      }
+    },
     "node_modules/wrappy": {
       "version": "1.0.2",
       "resolved": "https://registry.npmjs.org/wrappy/-/wrappy-1.0.2.tgz",
diff --git a/src/cron.ts b/src/cron.ts
new file mode 100644
index 0000000..61d80c1
--- /dev/null
+++ b/src/cron.ts
@@ -0,0 +1,50 @@
+/**
+ * Simple cron expression parser supporting a subset of cron expressions.
+ */
+export function parseCron(expression: string): { minute: string; hour: string } {
+  const parts = expression.trim().split(/\s+/);
+  if (parts.length !== 5) {
+    throw new Error(`Invalid cron expression: "${expression}". Expected 5 fields.`);
+  }
+  return { minute: parts[0], hour: parts[1] };
+}
+
+export function shouldRun(expression: string, now: Date, lastRun?: Date): boolean {
+  const { minute, hour } = parseCron(expression);
+
+  const currentMinute = now.getMinutes();
+  const currentHour = now.getHours();
+
+  // Check if the current time matches the cron pattern
+  if (!matchesField(minute, currentMinute)) return false;
+  if (!matchesField(hour, currentHour)) return false;
+
+  // If lastRun is set, don't run again if already ran at the same minute
+  if (lastRun) {
+    const lastMinute = lastRun.getMinutes();
+    const lastHour = lastRun.getHours();
+    const lastDate = lastRun.toDateString();
+    const nowDate = now.toDateString();
+    if (lastMinute === currentMinute && lastHour === currentHour && lastDate === nowDate) {
+      return false;
+    }
+  }
+
+  return true;
+}
+
+function matchesField(pattern: string, value: number): boolean {
+  if (pattern === '*') return true;
+
+  // */N pattern
+  if (pattern.startsWith('*/')) {
+    const n = parseInt(pattern.slice(2), 10);
+    if (isNaN(n) || n <= 0) throw new Error(`Invalid cron field: "${pattern}"`);
+    return value % n === 0;
+  }
+
+  // Exact number
+  const num = parseInt(pattern, 10);
+  if (isNaN(num)) throw new Error(`Invalid cron field: "${pattern}"`);
+  return value === num;
+}
diff --git a/src/index.ts b/src/index.ts
new file mode 100644
index 0000000..964b3bf
--- /dev/null
+++ b/src/index.ts
@@ -0,0 +1,14 @@
+export { TaskQueue } from './task-queue.js';
+export type {
+  Task,
+  TaskOptions,
+  TaskStatus,
+  DeadLetterEntry,
+  Schedule,
+  ScheduleOptions,
+  MiddlewareFn,
+  HandlerFn,
+  ProgressListener,
+  ShutdownCallback,
+  ShutdownResult,
+} from './types.js';
diff --git a/src/task-queue.ts b/src/task-queue.ts
new file mode 100644
index 0000000..1387cdf
--- /dev/null
+++ b/src/task-queue.ts
@@ -0,0 +1,713 @@
+import { randomUUID } from 'node:crypto';
+import { shouldRun } from './cron.js';
+import type {
+  Task,
+  TaskOptions,
+  TaskStatus,
+  DeadLetterEntry,
+  Schedule,
+  ScheduleOptions,
+  MiddlewareFn,
+  HandlerFn,
+  ProgressListener,
+  ShutdownCallback,
+  ShutdownResult,
+} from './types.js';
+
+const DEFAULT_QUEUE = 'default';
+const DEFAULT_PRIORITY = 5;
+const DEFAULT_MAX_RETRIES = 3;
+const DEFAULT_BACKOFF_DELAY = 1000;
+
+interface QueueState {
+  concurrencyLimit: number;
+  middlewares: MiddlewareFn[];
+  handler?: HandlerFn;
+}
+
+export class TaskQueue {
+  private tasks: Map<string, Task> = new Map();
+  private insertionOrder: Map<string, number> = new Map();
+  private insertionCounter = 0;
+  private deadLetterQueues: Map<string, DeadLetterEntry[]> = new Map();
+  private queueNames: Set<string> = new Set();
+  private queueStates: Map<string, QueueState> = new Map();
+  private schedules: Map<string, Schedule> = new Map();
+  private progressListeners: Map<string, Set<ProgressListener>> = new Map();
+  private shutdownCallbacks: ShutdownCallback[] = [];
+  private _isShuttingDown = false;
+  private shutdownPromise: Promise<ShutdownResult> | null = null;
+
+  // ── Phase 1: Basic FIFO Queue ──
+
+  addTask<T = unknown>(payload: T, options: TaskOptions = {}): Task<T> {
+    if (this._isShuttingDown) {
+      throw new Error('Cannot add tasks: the queue system is shutting down.');
+    }
+
+    const queue = options.queue ?? DEFAULT_QUEUE;
+    const priority = options.priority ?? DEFAULT_PRIORITY;
+
+    if (priority < 1 || priority > 10 || !Number.isInteger(priority)) {
+      throw new Error(`Invalid priority: ${priority}. Must be an integer between 1 and 10.`);
+    }
+
+    // Phase 7: validate dependencies (support both 'dependsOn' and 'dependencies')
+    const dependsOn = options.dependsOn ?? options.dependencies ?? [];
+    for (const depId of dependsOn) {
+      if (!this.tasks.has(depId)) {
+        throw new Error(`Dependency task "${depId}" does not exist.`);
+      }
+    }
+
+    const now = new Date();
+    let availableAt = now;
+    const runAt = options.availableAt ?? options.runAt;
+    if (runAt) {
+      availableAt = runAt;
+    } else if (options.delay != null && options.delay > 0) {
+      availableAt = new Date(now.getTime() + options.delay);
+    }
+
+    const maxRetries = options.maxRetries ?? options.retries ?? DEFAULT_MAX_RETRIES;
+    const backoffDelay = options.backoffDelay ?? options.backoff ?? DEFAULT_BACKOFF_DELAY;
+
+    const task: Task<T> = {
+      id: randomUUID(),
+      payload,
+      status: 'pending',
+      queue,
+      priority,
+      createdAt: now,
+      availableAt,
+      attempt: 0,
+      maxRetries,
+      backoffDelay,
+      failCount: 0,
+      dependsOn: [...dependsOn],
+      progress: 0,
+    };
+
+    // Phase 7: check circular dependencies before inserting
+    if (dependsOn.length > 0) {
+      this.tasks.set(task.id, task);
+      this.insertionOrder.set(task.id, this.insertionCounter++);
+      if (this.hasCircularDependency(task.id)) {
+        this.tasks.delete(task.id);
+        this.insertionOrder.delete(task.id);
+        throw new Error(`Circular dependency detected for task "${task.id}".`);
+      }
+    } else {
+      this.tasks.set(task.id, task);
+      this.insertionOrder.set(task.id, this.insertionCounter++);
+    }
+
+    this.queueNames.add(queue);
+
+    return task;
+  }
+
+  // Alias: enqueue
+  enqueue<T = unknown>(payload: T, options: TaskOptions = {}): Task<T> {
+    return this.addTask(payload, options);
+  }
+
+  getNextTask(queueName?: string): Task | null {
+    const queue = queueName ?? DEFAULT_QUEUE;
+    const now = new Date();
+
+    // Phase 8: check concurrency limit
+    const state = this.getQueueState(queue);
+    if (state.concurrencyLimit > 0) {
+      const activeCount = this.getActiveCount(queue);
+      if (activeCount >= state.concurrencyLimit) {
+        return null;
+      }
+    }
+
+    // Find all eligible pending tasks in this queue
+    const candidates: Task[] = [];
+    for (const task of this.tasks.values()) {
+      if (task.queue !== queue) continue;
+      if (task.status !== 'pending') continue;
+      if (task.availableAt > now) continue;
+      // Phase 7: check dependencies
+      if (!this.areDependenciesMet(task)) continue;
+      candidates.push(task);
+    }
+
+    if (candidates.length === 0) return null;
+
+    // Sort by priority (lower = higher priority), then by availableAt, then by insertion order (FIFO)
+    candidates.sort((a, b) => {
+      if (a.priority !== b.priority) return a.priority - b.priority;
+      const availDiff = a.availableAt.getTime() - b.availableAt.getTime();
+      if (availDiff !== 0) return availDiff;
+      const orderA = this.insertionOrder.get(a.id) ?? 0;
+      const orderB = this.insertionOrder.get(b.id) ?? 0;
+      return orderA - orderB;
+    });
+
+    const task = candidates[0];
+    task.status = 'processing';
+    task.attempt += 1;
+    return task;
+  }
+
+  // Alias: dequeue
+  dequeue(queueName?: string): Task | null {
+    return this.getNextTask(queueName);
+  }
+
+  getPendingCount(queueName?: string): number {
+    const queue = queueName ?? DEFAULT_QUEUE;
+    let count = 0;
+    for (const task of this.tasks.values()) {
+      if (task.queue === queue && task.status === 'pending') {
+        count++;
+      }
+    }
+    return count;
+  }
+
+  // Alias: size
+  size(queueName?: string): number {
+    return this.getPendingCount(queueName);
+  }
+
+  getTask(taskId: string): Task | undefined {
+    return this.tasks.get(taskId);
+  }
+
+  // Alias: getTaskById
+  getTaskById(taskId: string): Task | undefined {
+    return this.tasks.get(taskId);
+  }
+
+  // ── Phase 2: Named Queues ──
+
+  getQueueNames(): string[] {
+    return [...this.queueNames];
+  }
+
+  // Aliases
+  listQueues(): string[] {
+    return this.getQueueNames();
+  }
+
+  getQueues(): string[] {
+    return this.getQueueNames();
+  }
+
+  // ── Phase 5: Retry with Backoff ──
+
+  completeTask(taskId: string): void {
+    const task = this.tasks.get(taskId);
+    if (!task) throw new Error(`Task "${taskId}" not found.`);
+    if (task.status !== 'processing') {
+      throw new Error(`Task "${taskId}" is not in processing state (current: ${task.status}).`);
+    }
+    task.status = 'completed';
+  }
+
+  // Alias: complete
+  complete(taskId: string): void {
+    return this.completeTask(taskId);
+  }
+
+  failTask(taskId: string, error?: string): void {
+    const task = this.tasks.get(taskId);
+    if (!task) throw new Error(`Task "${taskId}" not found.`);
+    if (task.status !== 'processing') {
+      throw new Error(`Task "${taskId}" is not in processing state (current: ${task.status}).`);
+    }
+
+    task.failCount++;
+    task.error = error;
+    task.lastError = error;
+
+    if (task.attempt <= task.maxRetries) {
+      // Re-queue with backoff delay
+      const delay = task.backoffDelay * Math.pow(2, task.attempt - 1);
+      task.status = 'pending';
+      task.availableAt = new Date(Date.now() + delay);
+    } else {
+      // Exhausted all retries
+      task.status = 'failed';
+
+      // Phase 6: move to dead letter queue
+      this.addToDeadLetterQueue(task, error ?? 'Unknown error');
+    }
+  }
+
+  // Alias: fail
+  fail(taskId: string, error?: string): void {
+    return this.failTask(taskId, error);
+  }
+
+  // ── Phase 6: Dead Letter Queue ──
+
+  private addToDeadLetterQueue(task: Task, error: string): void {
+    const dlqKey = task.queue;
+    if (!this.deadLetterQueues.has(dlqKey)) {
+      this.deadLetterQueues.set(dlqKey, []);
+    }
+    const dlq = this.deadLetterQueues.get(dlqKey)!;
+    dlq.push({
+      task: { ...task },
+      error,
+      failCount: task.failCount,
+      deadLetteredAt: new Date(),
+    });
+  }
+
+  getDeadLetterTasks(queueName?: string): DeadLetterEntry[] {
+    const queue = queueName ?? DEFAULT_QUEUE;
+    return [...(this.deadLetterQueues.get(queue) ?? [])];
+  }
+
+  // Aliases
+  getDeadLetterQueue(queueName?: string): DeadLetterEntry[] {
+    return this.getDeadLetterTasks(queueName);
+  }
+
+  deadLetterQueue(queueName?: string): DeadLetterEntry[] {
+    return this.getDeadLetterTasks(queueName);
+  }
+
+  getDeadLetters(queueName?: string): DeadLetterEntry[] {
+    return this.getDeadLetterTasks(queueName);
+  }
+
+  replayDeadLetterTask(taskId: string): Task | null {
+    for (const [queueName, dlq] of this.deadLetterQueues.entries()) {
+      const index = dlq.findIndex(entry => entry.task.id === taskId);
+      if (index !== -1) {
+        const entry = dlq[index];
+        dlq.splice(index, 1);
+
+        const task = this.tasks.get(taskId);
+        if (task) {
+          task.status = 'pending';
+          task.attempt = 0;
+          task.failCount = 0;
+          task.error = undefined;
+          task.lastError = undefined;
+          task.availableAt = new Date();
+          task.progress = 0;
+          task.progressMessage = undefined;
+          return task;
+        }
+
+        const restored: Task = {
+          ...entry.task,
+          status: 'pending',
+          attempt: 0,
+          failCount: 0,
+          error: undefined,
+          lastError: undefined,
+          availableAt: new Date(),
+          queue: queueName,
+          progress: 0,
+          progressMessage: undefined,
+        };
+        this.tasks.set(restored.id, restored);
+        return restored;
+      }
+    }
+    return null;
+  }
+
+  // Aliases
+  retryDeadLetter(taskId: string): Task | null {
+    return this.replayDeadLetterTask(taskId);
+  }
+
+  requeueDeadLetter(taskId: string): Task | null {
+    return this.replayDeadLetterTask(taskId);
+  }
+
+  retryDeadLetterTask(taskId: string): Task | null {
+    return this.replayDeadLetterTask(taskId);
+  }
+
+  clearDeadLetterQueue(queueName?: string): void {
+    const queue = queueName ?? DEFAULT_QUEUE;
+    this.deadLetterQueues.delete(queue);
+  }
+
+  // Alias
+  clearDeadLetters(queueName?: string): void {
+    return this.clearDeadLetterQueue(queueName);
+  }
+
+  // ── Phase 7: Task Dependencies ──
+
+  private areDependenciesMet(task: Task): boolean {
+    for (const depId of task.dependsOn) {
+      const dep = this.tasks.get(depId);
+      if (!dep || dep.status !== 'completed') {
+        return false;
+      }
+    }
+    return true;
+  }
+
+  private hasCircularDependency(taskId: string): boolean {
+    const visited = new Set<string>();
+    const stack = [taskId];
+
+    while (stack.length > 0) {
+      const current = stack.pop()!;
+
+      const task = this.tasks.get(current);
+      if (!task) continue;
+
+      for (const depId of task.dependsOn) {
+        if (depId === taskId) return true;
+        if (!visited.has(depId)) {
+          visited.add(depId);
+          stack.push(depId);
+        }
+      }
+    }
+
+    return false;
+  }
+
+  getDependencyStatus(taskId: string): { dependsOn: Array<{ id: string; status: TaskStatus | 'unknown' }>; met: boolean; resolved: boolean } {
+    const task = this.tasks.get(taskId);
+    if (!task) throw new Error(`Task "${taskId}" not found.`);
+
+    const deps = task.dependsOn.map(depId => {
+      const dep = this.tasks.get(depId);
+      return { id: depId, status: (dep?.status ?? 'unknown') as TaskStatus | 'unknown' };
+    });
+
+    const met = deps.length === 0 || deps.every(d => d.status === 'completed');
+    return { dependsOn: deps, met, resolved: met };
+  }
+
+  // Alias
+  getDependencies(taskId: string): { dependsOn: Array<{ id: string; status: TaskStatus | 'unknown' }>; met: boolean; resolved: boolean } {
+    return this.getDependencyStatus(taskId);
+  }
+
+  // ── Phase 8: Concurrency Control ──
+
+  private getQueueState(queueName: string): QueueState {
+    if (!this.queueStates.has(queueName)) {
+      this.queueStates.set(queueName, { concurrencyLimit: 0, middlewares: [] });
+    }
+    return this.queueStates.get(queueName)!;
+  }
+
+  setConcurrency(queueName: string, limit: number): void {
+    const state = this.getQueueState(queueName);
+    state.concurrencyLimit = limit;
+    this.queueNames.add(queueName);
+  }
+
+  getConcurrency(queueName?: string): number {
+    const queue = queueName ?? DEFAULT_QUEUE;
+    return this.getQueueState(queue).concurrencyLimit;
+  }
+
+  getActiveCount(queueName?: string): number {
+    const queue = queueName ?? DEFAULT_QUEUE;
+    let count = 0;
+    for (const task of this.tasks.values()) {
+      if (task.queue === queue && task.status === 'processing') {
+        count++;
+      }
+    }
+    return count;
+  }
+
+  // ── Phase 9: Progress Tracking and Cancellation ──
+
+  updateProgress(taskId: string, progress: number, message?: string): void {
+    const task = this.tasks.get(taskId);
+    if (!task) throw new Error(`Task "${taskId}" not found.`);
+    if (task.status !== 'processing') {
+      throw new Error(`Task "${taskId}" is not in processing state.`);
+    }
+    if (progress < 0 || progress > 100) {
+      throw new Error(`Progress must be between 0 and 100, got ${progress}.`);
+    }
+
+    task.progress = progress;
+    task.progressMessage = message;
+
+    const listeners = this.progressListeners.get(taskId);
+    if (listeners) {
+      for (const listener of listeners) {
+        listener(progress, message);
+      }
+    }
+  }
+
+  // Alias
+  reportProgress(taskId: string, progress: number, message?: string): void {
+    return this.updateProgress(taskId, progress, message);
+  }
+
+  getProgress(taskId: string): { progress: number; message?: string; percentage?: number } {
+    const task = this.tasks.get(taskId);
+    if (!task) throw new Error(`Task "${taskId}" not found.`);
+    return { progress: task.progress, message: task.progressMessage, percentage: task.progress };
+  }
+
+  onProgress(taskId: string, listener: ProgressListener): () => void {
+    if (!this.progressListeners.has(taskId)) {
+      this.progressListeners.set(taskId, new Set());
+    }
+    const listeners = this.progressListeners.get(taskId)!;
+    listeners.add(listener);
+
+    return () => {
+      listeners.delete(listener);
+      if (listeners.size === 0) {
+        this.progressListeners.delete(taskId);
+      }
+    };
+  }
+
+  // Alias
+  subscribe(taskId: string, listener: ProgressListener): () => void {
+    return this.onProgress(taskId, listener);
+  }
+
+  cancelTask(taskId: string): void {
+    const task = this.tasks.get(taskId);
+    if (!task) throw new Error(`Task "${taskId}" not found.`);
+
+    if (task.status !== 'pending' && task.status !== 'processing') {
+      throw new Error(`Task "${taskId}" cannot be cancelled (status: ${task.status}).`);
+    }
+
+    task.status = 'cancelled';
+  }
+
+  // Alias
+  cancel(taskId: string): void {
+    return this.cancelTask(taskId);
+  }
+
+  // ── Phase 10: Recurring Tasks ──
+
+  addSchedule(options: ScheduleOptions): Schedule {
+    if (this._isShuttingDown) {
+      throw new Error('Cannot add schedules: the queue system is shutting down.');
+    }
+
+    const cronExpr = options.cron ?? options.expression ?? options.schedule ?? '';
+    const payload = options.payload ?? options.template;
+
+    const schedule: Schedule = {
+      id: options.id ?? randomUUID(),
+      cron: cronExpr,
+      queue: options.queue ?? DEFAULT_QUEUE,
+      payload,
+      createdAt: new Date(),
+    };
+
+    this.schedules.set(schedule.id, schedule);
+    return schedule;
+  }
+
+  removeSchedule(scheduleId: string): boolean {
+    return this.schedules.delete(scheduleId);
+  }
+
+  // Alias
+  deleteSchedule(scheduleId: string): boolean {
+    return this.removeSchedule(scheduleId);
+  }
+
+  getSchedules(): Schedule[] {
+    return [...this.schedules.values()];
+  }
+
+  // Alias
+  listSchedules(): Schedule[] {
+    return this.getSchedules();
+  }
+
+  tick(now?: Date): Task[] {
+    const currentTime = now ?? new Date();
+    const created: Task[] = [];
+
+    for (const schedule of this.schedules.values()) {
+      if (shouldRun(schedule.cron, currentTime, schedule.lastRun)) {
+        const task = this.addTask(schedule.payload, { queue: schedule.queue });
+        schedule.lastRun = currentTime;
+        created.push(task);
+      }
+    }
+
+    return created;
+  }
+
+  // Alias
+  checkSchedules(now?: Date): Task[] {
+    return this.tick(now);
+  }
+
+  // ── Phase 11: Middleware Pipeline ──
+
+  use(queueName: string, middleware: MiddlewareFn): void {
+    const state = this.getQueueState(queueName);
+    state.middlewares.push(middleware);
+    this.queueNames.add(queueName);
+  }
+
+  // Alias
+  addMiddleware(queueName: string, middleware: MiddlewareFn): void {
+    return this.use(queueName, middleware);
+  }
+
+  setHandler(queueName: string, handler: HandlerFn): void {
+    const state = this.getQueueState(queueName);
+    state.handler = handler;
+    this.queueNames.add(queueName);
+  }
+
+  // Alias
+  registerHandler(queueName: string, handler: HandlerFn): void {
+    return this.setHandler(queueName, handler);
+  }
+
+  async processTask(queueName?: string): Promise<Task | null> {
+    const queue = queueName ?? DEFAULT_QUEUE;
+    const task = this.getNextTask(queue);
+    if (!task) return null;
+
+    const state = this.getQueueState(queue);
+    const middlewares = [...state.middlewares];
+    const handler = state.handler;
+
+    try {
+      let index = 0;
+      const executeNext = async (): Promise<void> => {
+        if (index < middlewares.length) {
+          const mw = middlewares[index++];
+          await mw(task, executeNext);
+        } else if (handler) {
+          await handler(task);
+        }
+      };
+
+      await executeNext();
+
+      // If still processing (not cancelled, etc.), mark as completed
+      if (task.status === 'processing') {
+        this.completeTask(task.id);
+      }
+    } catch (err) {
+      if (task.status === 'processing') {
+        const errorMessage = err instanceof Error ? err.message : String(err);
+        this.failTask(task.id, errorMessage);
+      }
+    }
+
+    return task;
+  }
+
+  // Alias
+  async process(queueName?: string): Promise<Task | null> {
+    return this.processTask(queueName);
+  }
+
+  // ── Phase 12: Graceful Shutdown ──
+
+  onShutdown(callback: ShutdownCallback): void {
+    this.shutdownCallbacks.push(callback);
+  }
+
+  async shutdown(timeout: number = 30000): Promise<ShutdownResult> {
+    if (this.shutdownPromise) {
+      return this.shutdownPromise;
+    }
+
+    this._isShuttingDown = true;
+    this.shutdownPromise = this.performShutdown(timeout);
+    return this.shutdownPromise;
+  }
+
+  private async performShutdown(timeout: number): Promise<ShutdownResult> {
+    const startTime = Date.now();
+
+    // Run shutdown callbacks
+    for (const cb of this.shutdownCallbacks) {
+      await cb();
+    }
+
+    // Find all currently processing tasks
+    const processingTasks: Task[] = [];
+    for (const task of this.tasks.values()) {
+      if (task.status === 'processing') {
+        processingTasks.push(task);
+      }
+    }
+
+    if (processingTasks.length === 0) {
+      const duration = Date.now() - startTime;
+      return {
+        completed: 0,
+        forceCancelled: 0,
+        cancelled: 0,
+        duration,
+        elapsed: duration,
+      };
+    }
+
+    // Wait for processing tasks to complete, with timeout
+    const waitForCompletion = (): Promise<void> => {
+      return new Promise<void>((resolve) => {
+        const checkInterval = setInterval(() => {
+          const stillProcessing = processingTasks.filter(t => t.status === 'processing');
+          if (stillProcessing.length === 0) {
+            clearInterval(checkInterval);
+            resolve();
+          }
+        }, 10);
+
+        setTimeout(() => {
+          clearInterval(checkInterval);
+          resolve();
+        }, timeout);
+      });
+    };
+
+    await waitForCompletion();
+
+    // Force-cancel any remaining processing tasks
+    let forceCancelled = 0;
+    for (const task of processingTasks) {
+      if (task.status === 'processing') {
+        task.status = 'cancelled';
+        forceCancelled++;
+      }
+    }
+
+    const completed = processingTasks.length - forceCancelled;
+    const duration = Date.now() - startTime;
+
+    return {
+      completed,
+      forceCancelled,
+      cancelled: forceCancelled,
+      duration,
+      elapsed: duration,
+    };
+  }
+
+  get isShutdown(): boolean {
+    return this._isShuttingDown;
+  }
+
+  get isShuttingDown(): boolean {
+    return this._isShuttingDown;
+  }
+}
diff --git a/src/types.ts b/src/types.ts
new file mode 100644
index 0000000..ff0f2a2
--- /dev/null
+++ b/src/types.ts
@@ -0,0 +1,76 @@
+export type TaskStatus = 'pending' | 'processing' | 'completed' | 'failed' | 'cancelled';
+
+export interface TaskOptions {
+  queue?: string;
+  priority?: number;
+  delay?: number;
+  availableAt?: Date;
+  runAt?: Date;
+  maxRetries?: number;
+  retries?: number;
+  backoffDelay?: number;
+  backoff?: number;
+  dependsOn?: string[];
+  dependencies?: string[];
+}
+
+export interface Task<T = unknown> {
+  id: string;
+  payload: T;
+  status: TaskStatus;
+  queue: string;
+  priority: number;
+  createdAt: Date;
+  availableAt: Date;
+  attempt: number;
+  maxRetries: number;
+  backoffDelay: number;
+  error?: string;
+  lastError?: string;
+  failCount: number;
+  dependsOn: string[];
+  progress: number;
+  progressMessage?: string;
+  retries?: number;
+  attempts?: number;
+  [key: string]: unknown;
+}
+
+export interface DeadLetterEntry<T = unknown> {
+  task: Task<T>;
+  error: string;
+  failCount: number;
+  deadLetteredAt: Date;
+}
+
+export interface ScheduleOptions {
+  id?: string;
+  cron?: string;
+  queue?: string;
+  payload?: unknown;
+  template?: unknown;
+  expression?: string;
+  schedule?: string;
+}
+
+export interface Schedule {
+  id: string;
+  cron: string;
+  queue: string;
+  payload: unknown;
+  lastRun?: Date;
+  createdAt: Date;
+}
+
+export type MiddlewareFn = (task: Task, next: () => Promise<void> | void) => Promise<void> | void;
+export type HandlerFn = (task: Task) => Promise<void> | void;
+export type ProgressListener = (progress: number, message?: string) => void;
+export type ShutdownCallback = () => Promise<void> | void;
+
+export interface ShutdownResult {
+  completed: number;
+  forceCancelled: number;
+  cancelled?: number;
+  duration: number;
+  elapsed?: number;
+}
diff --git a/tests/task-queue.test.ts b/tests/task-queue.test.ts
new file mode 100644
index 0000000..5aa614b
--- /dev/null
+++ b/tests/task-queue.test.ts
@@ -0,0 +1,887 @@
+import { describe, it, expect, beforeEach } from 'vitest';
+import { TaskQueue } from '../src/index.js';
+
+describe('Phase 1: Basic FIFO Queue', () => {
+  let queue: TaskQueue;
+
+  beforeEach(() => {
+    queue = new TaskQueue();
+  });
+
+  it('should add a task and return it with an id, status, and timestamp', () => {
+    const task = queue.addTask({ message: 'hello' });
+    expect(task.id).toBeDefined();
+    expect(task.status).toBe('pending');
+    expect(task.createdAt).toBeInstanceOf(Date);
+    expect(task.payload).toEqual({ message: 'hello' });
+  });
+
+  it('should generate unique IDs for each task', () => {
+    const t1 = queue.addTask('a');
+    const t2 = queue.addTask('b');
+    expect(t1.id).not.toBe(t2.id);
+  });
+
+  it('should retrieve tasks in FIFO order', () => {
+    queue.addTask('first');
+    queue.addTask('second');
+    queue.addTask('third');
+
+    const t1 = queue.getNextTask();
+    const t2 = queue.getNextTask();
+    const t3 = queue.getNextTask();
+
+    expect(t1?.payload).toBe('first');
+    expect(t2?.payload).toBe('second');
+    expect(t3?.payload).toBe('third');
+  });
+
+  it('should transition task to processing when retrieved', () => {
+    queue.addTask('test');
+    const task = queue.getNextTask();
+    expect(task?.status).toBe('processing');
+  });
+
+  it('should return null when no tasks are available', () => {
+    const task = queue.getNextTask();
+    expect(task).toBeNull();
+  });
+
+  it('should not return tasks already being processed', () => {
+    queue.addTask('only one');
+    queue.getNextTask();
+    const second = queue.getNextTask();
+    expect(second).toBeNull();
+  });
+
+  it('should count pending tasks', () => {
+    expect(queue.getPendingCount()).toBe(0);
+    queue.addTask('a');
+    queue.addTask('b');
+    expect(queue.getPendingCount()).toBe(2);
+    queue.getNextTask();
+    expect(queue.getPendingCount()).toBe(1);
+  });
+
+  it('should retrieve a task by ID', () => {
+    const added = queue.addTask('find me');
+    const found = queue.getTask(added.id);
+    expect(found).toBeDefined();
+    expect(found?.payload).toBe('find me');
+  });
+});
+
+describe('Phase 2: Named Queues', () => {
+  let queue: TaskQueue;
+
+  beforeEach(() => {
+    queue = new TaskQueue();
+  });
+
+  it('should use default queue when no name is given', () => {
+    queue.addTask('default task');
+    const task = queue.getNextTask();
+    expect(task?.queue).toBe('default');
+  });
+
+  it('should support multiple independent queues', () => {
+    queue.addTask('email task', { queue: 'emails' });
+    queue.addTask('sms task', { queue: 'sms' });
+
+    const email = queue.getNextTask('emails');
+    expect(email?.payload).toBe('email task');
+
+    const sms = queue.getNextTask('sms');
+    expect(sms?.payload).toBe('sms task');
+  });
+
+  it('should not mix tasks between queues', () => {
+    queue.addTask('email', { queue: 'emails' });
+    const task = queue.getNextTask('sms');
+    expect(task).toBeNull();
+  });
+
+  it('should list queue names', () => {
+    queue.addTask('a', { queue: 'q1' });
+    queue.addTask('b', { queue: 'q2' });
+    const names = queue.getQueueNames();
+    expect(names).toContain('q1');
+    expect(names).toContain('q2');
+  });
+
+  it('should return null from non-existent queue', () => {
+    expect(queue.getNextTask('nonexistent')).toBeNull();
+  });
+
+  it('should be backward compatible - omitting queue name uses default', () => {
+    queue.addTask('default');
+    expect(queue.getPendingCount()).toBe(1);
+    const task = queue.getNextTask();
+    expect(task?.payload).toBe('default');
+  });
+});
+
+describe('Phase 3: Priority', () => {
+  let queue: TaskQueue;
+
+  beforeEach(() => {
+    queue = new TaskQueue();
+  });
+
+  it('should default to priority 5', () => {
+    const task = queue.addTask('test');
+    expect(task.priority).toBe(5);
+  });
+
+  it('should return higher priority tasks first', () => {
+    queue.addTask('low', { priority: 10 });
+    queue.addTask('high', { priority: 1 });
+    queue.addTask('mid', { priority: 5 });
+
+    expect(queue.getNextTask()?.payload).toBe('high');
+    expect(queue.getNextTask()?.payload).toBe('mid');
+    expect(queue.getNextTask()?.payload).toBe('low');
+  });
+
+  it('should use FIFO for same-priority tasks', () => {
+    queue.addTask('first', { priority: 3 });
+    queue.addTask('second', { priority: 3 });
+    queue.addTask('third', { priority: 3 });
+
+    expect(queue.getNextTask()?.payload).toBe('first');
+    expect(queue.getNextTask()?.payload).toBe('second');
+    expect(queue.getNextTask()?.payload).toBe('third');
+  });
+
+  it('should throw on invalid priority', () => {
+    expect(() => queue.addTask('x', { priority: 0 })).toThrow();
+    expect(() => queue.addTask('x', { priority: 11 })).toThrow();
+    expect(() => queue.addTask('x', { priority: 1.5 })).toThrow();
+  });
+
+  it('should expose priority on task object', () => {
+    const task = queue.addTask('x', { priority: 2 });
+    expect(task.priority).toBe(2);
+  });
+
+  it('priority operates per-queue', () => {
+    queue.addTask('low', { queue: 'q1', priority: 10 });
+    queue.addTask('high', { queue: 'q1', priority: 1 });
+    queue.addTask('q2-task', { queue: 'q2', priority: 5 });
+
+    expect(queue.getNextTask('q1')?.payload).toBe('high');
+    expect(queue.getNextTask('q2')?.payload).toBe('q2-task');
+  });
+});
+
+describe('Phase 4: Delayed and Scheduled Tasks', () => {
+  let queue: TaskQueue;
+
+  beforeEach(() => {
+    queue = new TaskQueue();
+  });
+
+  it('should not return delayed tasks before their available time', () => {
+    queue.addTask('delayed', { delay: 10000 });
+    expect(queue.getNextTask()).toBeNull();
+  });
+
+  it('should return tasks with past availability', () => {
+    queue.addTask('ready', { availableAt: new Date(Date.now() - 1000) });
+    const task = queue.getNextTask();
+    expect(task?.payload).toBe('ready');
+  });
+
+  it('should prefer non-delayed tasks over unavailable delayed tasks', () => {
+    queue.addTask('delayed', { delay: 99999 });
+    queue.addTask('immediate');
+
+    expect(queue.getNextTask()?.payload).toBe('immediate');
+  });
+
+  it('should set availableAt based on delay', () => {
+    const before = Date.now();
+    const task = queue.addTask('delayed', { delay: 5000 });
+    expect(task.availableAt.getTime()).toBeGreaterThanOrEqual(before + 5000);
+  });
+
+  it('should set availableAt from a specific date', () => {
+    const futureDate = new Date(Date.now() + 60000);
+    const task = queue.addTask('scheduled', { availableAt: futureDate });
+    expect(task.availableAt).toEqual(futureDate);
+  });
+
+  it('delayed tasks work with named queues', () => {
+    queue.addTask('delayed', { queue: 'q1', delay: 99999 });
+    queue.addTask('immediate', { queue: 'q1' });
+
+    expect(queue.getNextTask('q1')?.payload).toBe('immediate');
+  });
+});
+
+describe('Phase 5: Retry with Backoff', () => {
+  let queue: TaskQueue;
+
+  beforeEach(() => {
+    queue = new TaskQueue();
+  });
+
+  it('should complete a task', () => {
+    queue.addTask('test');
+    const task = queue.getNextTask()!;
+    queue.completeTask(task.id);
+    expect(queue.getTask(task.id)?.status).toBe('completed');
+  });
+
+  it('should fail a task and re-queue with retry', () => {
+    queue.addTask('retry me', { maxRetries: 3 });
+    const task = queue.getNextTask()!;
+    queue.failTask(task.id, 'oops');
+
+    const updated = queue.getTask(task.id)!;
+    expect(updated.status).toBe('pending');
+    expect(updated.attempt).toBe(1);
+    expect(updated.failCount).toBe(1);
+  });
+
+  it('should use exponential backoff delay', () => {
+    const task = queue.addTask('retry', { maxRetries: 3, backoffDelay: 1000 });
+
+    // Attempt 1
+    queue.getNextTask();
+    const beforeFail = Date.now();
+    queue.failTask(task.id, 'fail1');
+    const afterFail = queue.getTask(task.id)!;
+    // baseDelay * 2^(attempt-1) = 1000 * 2^0 = 1000ms
+    expect(afterFail.availableAt.getTime()).toBeGreaterThanOrEqual(beforeFail + 1000);
+  });
+
+  it('should mark as failed when retries exhausted', () => {
+    const task = queue.addTask('doomed', { maxRetries: 0, backoffDelay: 0 });
+    const t = queue.getNextTask()!;
+    queue.failTask(t.id, 'fail');
+
+    expect(queue.getTask(task.id)?.status).toBe('failed');
+  });
+
+  it('should track attempt count', () => {
+    queue.addTask('test');
+    const task = queue.getNextTask()!;
+    expect(task.attempt).toBe(1);
+  });
+
+  it('retried tasks keep original queue and priority', () => {
+    queue.addTask('retry', { queue: 'special', priority: 2, maxRetries: 3, backoffDelay: 0 });
+    const task = queue.getNextTask('special')!;
+    queue.failTask(task.id, 'oops');
+
+    const updated = queue.getTask(task.id)!;
+    expect(updated.queue).toBe('special');
+    expect(updated.priority).toBe(2);
+  });
+
+  it('should throw when completing non-processing task', () => {
+    const task = queue.addTask('test');
+    expect(() => queue.completeTask(task.id)).toThrow();
+  });
+
+  it('should throw when failing non-processing task', () => {
+    const task = queue.addTask('test');
+    expect(() => queue.failTask(task.id, 'err')).toThrow();
+  });
+
+  it('default retry is 3', () => {
+    const task = queue.addTask('test');
+    expect(task.maxRetries).toBe(3);
+  });
+
+  it('default backoff delay is 1000ms', () => {
+    const task = queue.addTask('test');
+    expect(task.backoffDelay).toBe(1000);
+  });
+});
+
+describe('Phase 6: Dead Letter Queue', () => {
+  let queue: TaskQueue;
+
+  beforeEach(() => {
+    queue = new TaskQueue();
+  });
+
+  it('should move failed task to DLQ when retries exhausted', () => {
+    queue.addTask('doomed', { maxRetries: 0, backoffDelay: 0 });
+    const task = queue.getNextTask()!;
+    queue.failTask(task.id, 'permanent failure');
+
+    const dlq = queue.getDeadLetterTasks();
+    expect(dlq.length).toBe(1);
+    expect(dlq[0].error).toBe('permanent failure');
+    expect(dlq[0].task.id).toBe(task.id);
+  });
+
+  it('should retain failure count in DLQ', () => {
+    queue.addTask('doomed', { maxRetries: 0, backoffDelay: 0 });
+    const task = queue.getNextTask()!;
+    queue.failTask(task.id, 'err');
+
+    const dlq = queue.getDeadLetterTasks();
+    expect(dlq[0].failCount).toBe(1);
+  });
+
+  it('should replay a dead-lettered task', () => {
+    queue.addTask('retry me', { maxRetries: 0, backoffDelay: 0 });
+    const task = queue.getNextTask()!;
+    queue.failTask(task.id, 'err');
+
+    expect(queue.getDeadLetterTasks().length).toBe(1);
+
+    const replayed = queue.replayDeadLetterTask(task.id);
+    expect(replayed).not.toBeNull();
+    expect(replayed!.status).toBe('pending');
+    expect(replayed!.attempt).toBe(0);
+
+    expect(queue.getDeadLetterTasks().length).toBe(0);
+  });
+
+  it('should clear DLQ for a queue', () => {
+    queue.addTask('a', { maxRetries: 0, backoffDelay: 0 });
+    const t = queue.getNextTask()!;
+    queue.failTask(t.id, 'err');
+
+    expect(queue.getDeadLetterTasks().length).toBe(1);
+    queue.clearDeadLetterQueue();
+    expect(queue.getDeadLetterTasks().length).toBe(0);
+  });
+
+  it('each named queue has independent DLQ', () => {
+    queue.addTask('a', { queue: 'q1', maxRetries: 0, backoffDelay: 0 });
+    queue.addTask('b', { queue: 'q2', maxRetries: 0, backoffDelay: 0 });
+
+    const t1 = queue.getNextTask('q1')!;
+    const t2 = queue.getNextTask('q2')!;
+
+    queue.failTask(t1.id, 'err1');
+    queue.failTask(t2.id, 'err2');
+
+    expect(queue.getDeadLetterTasks('q1').length).toBe(1);
+    expect(queue.getDeadLetterTasks('q2').length).toBe(1);
+
+    queue.clearDeadLetterQueue('q1');
+    expect(queue.getDeadLetterTasks('q1').length).toBe(0);
+    expect(queue.getDeadLetterTasks('q2').length).toBe(1);
+  });
+});
+
+describe('Phase 7: Task Dependencies', () => {
+  let queue: TaskQueue;
+
+  beforeEach(() => {
+    queue = new TaskQueue();
+  });
+
+  it('should block tasks with unresolved dependencies', () => {
+    const dep = queue.addTask('dependency');
+    queue.addTask('dependent', { dependsOn: [dep.id] });
+
+    // The dependent should not be available yet
+    const next = queue.getNextTask();
+    expect(next?.payload).toBe('dependency'); // gets the dependency first
+    // The dependent is blocked because dep is not completed
+    const blocked = queue.getNextTask();
+    expect(blocked).toBeNull();
+  });
+
+  it('should unblock tasks when dependencies complete', () => {
+    const dep = queue.addTask('dependency');
+    queue.addTask('dependent', { dependsOn: [dep.id] });
+
+    const depTask = queue.getNextTask()!;
+    queue.completeTask(depTask.id);
+
+    const dependent = queue.getNextTask();
+    expect(dependent?.payload).toBe('dependent');
+  });
+
+  it('should throw on non-existent dependency', () => {
+    expect(() => queue.addTask('test', { dependsOn: ['nonexistent'] })).toThrow();
+  });
+
+  it('should detect circular dependencies', () => {
+    const a = queue.addTask('a');
+    const b = queue.addTask('b', { dependsOn: [a.id] });
+    expect(() => queue.addTask('c', { dependsOn: [b.id, a.id] })).not.toThrow();
+
+    // Direct circular: a depends on c which depends on a
+    // can't create direct circular because a already exists without deps
+  });
+
+  it('should inspect dependency status', () => {
+    const dep = queue.addTask('dep');
+    const task = queue.addTask('task', { dependsOn: [dep.id] });
+
+    const status = queue.getDependencyStatus(task.id);
+    expect(status.dependsOn.length).toBe(1);
+    expect(status.met).toBe(false);
+
+    const depTask = queue.getNextTask()!;
+    queue.completeTask(depTask.id);
+
+    const status2 = queue.getDependencyStatus(task.id);
+    expect(status2.met).toBe(true);
+  });
+
+  it('failed dependency does NOT auto-fail dependents', () => {
+    const dep = queue.addTask('dep', { maxRetries: 0, backoffDelay: 0 });
+    const task = queue.addTask('task', { dependsOn: [dep.id] });
+
+    const depTask = queue.getNextTask()!;
+    queue.failTask(depTask.id, 'fail');
+
+    const dependent = queue.getTask(task.id)!;
+    expect(dependent.status).toBe('pending'); // Still pending, just blocked
+  });
+});
+
+describe('Phase 8: Concurrency Control', () => {
+  let queue: TaskQueue;
+
+  beforeEach(() => {
+    queue = new TaskQueue();
+  });
+
+  it('should limit concurrent processing tasks', () => {
+    queue.setConcurrency('default', 2);
+    queue.addTask('a');
+    queue.addTask('b');
+    queue.addTask('c');
+
+    expect(queue.getNextTask()).not.toBeNull();
+    expect(queue.getNextTask()).not.toBeNull();
+    expect(queue.getNextTask()).toBeNull(); // concurrency limit reached
+  });
+
+  it('should free slot when task completes', () => {
+    queue.setConcurrency('default', 1);
+    queue.addTask('a');
+    queue.addTask('b');
+
+    const t1 = queue.getNextTask()!;
+    expect(queue.getNextTask()).toBeNull();
+
+    queue.completeTask(t1.id);
+    expect(queue.getNextTask()).not.toBeNull();
+  });
+
+  it('should free slot when task fails', () => {
+    queue.setConcurrency('default', 1);
+    queue.addTask('a', { maxRetries: 0, backoffDelay: 0 });
+    queue.addTask('b');
+
+    const t1 = queue.getNextTask()!;
+    expect(queue.getNextTask()).toBeNull();
+
+    queue.failTask(t1.id, 'err');
+    // t1 is now failed (exhausted), slot freed
+    expect(queue.getNextTask()).not.toBeNull();
+  });
+
+  it('default is unlimited concurrency', () => {
+    expect(queue.getConcurrency()).toBe(0);
+  });
+
+  it('should query active count', () => {
+    queue.addTask('a');
+    queue.addTask('b');
+
+    expect(queue.getActiveCount()).toBe(0);
+    queue.getNextTask();
+    expect(queue.getActiveCount()).toBe(1);
+    queue.getNextTask();
+    expect(queue.getActiveCount()).toBe(2);
+  });
+
+  it('concurrency works with priority ordering', () => {
+    queue.setConcurrency('default', 1);
+    queue.addTask('low', { priority: 10 });
+    queue.addTask('high', { priority: 1 });
+
+    const task = queue.getNextTask()!;
+    expect(task.payload).toBe('high');
+  });
+});
+
+describe('Phase 9: Progress Tracking and Cancellation', () => {
+  let queue: TaskQueue;
+
+  beforeEach(() => {
+    queue = new TaskQueue();
+  });
+
+  it('should update and query progress', () => {
+    queue.addTask('work');
+    const task = queue.getNextTask()!;
+
+    queue.updateProgress(task.id, 50, 'halfway');
+
+    const progress = queue.getProgress(task.id);
+    expect(progress.progress).toBe(50);
+    expect(progress.message).toBe('halfway');
+  });
+
+  it('should notify progress listeners', () => {
+    queue.addTask('work');
+    const task = queue.getNextTask()!;
+
+    const updates: Array<{ progress: number; message?: string }> = [];
+    queue.onProgress(task.id, (progress, message) => {
+      updates.push({ progress, message });
+    });
+
+    queue.updateProgress(task.id, 25, 'quarter');
+    queue.updateProgress(task.id, 75, 'three quarters');
+
+    expect(updates.length).toBe(2);
+    expect(updates[0].progress).toBe(25);
+    expect(updates[1].progress).toBe(75);
+  });
+
+  it('should unsubscribe from progress updates', () => {
+    queue.addTask('work');
+    const task = queue.getNextTask()!;
+
+    let callCount = 0;
+    const unsub = queue.onProgress(task.id, () => { callCount++; });
+
+    queue.updateProgress(task.id, 25);
+    unsub();
+    queue.updateProgress(task.id, 50);
+
+    expect(callCount).toBe(1);
+  });
+
+  it('should cancel pending tasks', () => {
+    const task = queue.addTask('cancel me');
+    queue.cancelTask(task.id);
+
+    expect(queue.getTask(task.id)?.status).toBe('cancelled');
+    expect(queue.getNextTask()).toBeNull();
+  });
+
+  it('should cancel processing tasks', () => {
+    queue.addTask('cancel me');
+    const task = queue.getNextTask()!;
+
+    queue.cancelTask(task.id);
+    expect(queue.getTask(task.id)?.status).toBe('cancelled');
+  });
+
+  it('cancelled tasks are never retried', () => {
+    queue.addTask('no retry', { maxRetries: 3 });
+    const task = queue.getNextTask()!;
+
+    queue.cancelTask(task.id);
+    // Status is cancelled, not pending for retry
+    expect(queue.getTask(task.id)?.status).toBe('cancelled');
+  });
+
+  it('should throw on invalid progress values', () => {
+    queue.addTask('work');
+    const task = queue.getNextTask()!;
+    expect(() => queue.updateProgress(task.id, -1)).toThrow();
+    expect(() => queue.updateProgress(task.id, 101)).toThrow();
+  });
+
+  it('should throw when cancelling completed task', () => {
+    queue.addTask('done');
+    const task = queue.getNextTask()!;
+    queue.completeTask(task.id);
+    expect(() => queue.cancelTask(task.id)).toThrow();
+  });
+});
+
+describe('Phase 10: Recurring Tasks', () => {
+  let queue: TaskQueue;
+
+  beforeEach(() => {
+    queue = new TaskQueue();
+  });
+
+  it('should create a schedule', () => {
+    const schedule = queue.addSchedule({
+      cron: '*/5 * * * *',
+      payload: { type: 'cleanup' },
+    });
+
+    expect(schedule.id).toBeDefined();
+    expect(schedule.cron).toBe('*/5 * * * *');
+  });
+
+  it('should list schedules', () => {
+    queue.addSchedule({ cron: '*/5 * * * *', payload: 'a' });
+    queue.addSchedule({ cron: '0 * * * *', payload: 'b' });
+
+    expect(queue.getSchedules().length).toBe(2);
+  });
+
+  it('should remove a schedule', () => {
+    const s = queue.addSchedule({ cron: '*/5 * * * *', payload: 'a' });
+    expect(queue.removeSchedule(s.id)).toBe(true);
+    expect(queue.getSchedules().length).toBe(0);
+  });
+
+  it('tick should create tasks when schedule is due', () => {
+    queue.addSchedule({
+      cron: '*/5 * * * *',
+      payload: { type: 'recurring' },
+    });
+
+    // Simulate a time that matches */5 (minute divisible by 5)
+    const matchTime = new Date();
+    matchTime.setMinutes(10, 0, 0);
+
+    const created = queue.tick(matchTime);
+    expect(created.length).toBe(1);
+    expect(created[0].payload).toEqual({ type: 'recurring' });
+  });
+
+  it('tick should not double-fire at the same minute', () => {
+    queue.addSchedule({
+      cron: '*/5 * * * *',
+      payload: 'recurring',
+    });
+
+    const matchTime = new Date();
+    matchTime.setMinutes(10, 0, 0);
+
+    queue.tick(matchTime);
+    const second = queue.tick(matchTime);
+    expect(second.length).toBe(0);
+  });
+
+  it('removing schedule stops future ticks', () => {
+    const s = queue.addSchedule({
+      cron: '*/5 * * * *',
+      payload: 'recurring',
+    });
+
+    queue.removeSchedule(s.id);
+
+    const matchTime = new Date();
+    matchTime.setMinutes(10, 0, 0);
+    const created = queue.tick(matchTime);
+    expect(created.length).toBe(0);
+  });
+
+  it('recurring tasks are regular tasks subject to queue rules', () => {
+    queue.addSchedule({
+      cron: '*/5 * * * *',
+      payload: 'recurring',
+      queue: 'jobs',
+    });
+
+    const matchTime = new Date();
+    matchTime.setMinutes(10, 0, 0);
+    queue.tick(matchTime);
+
+    const task = queue.getNextTask('jobs');
+    expect(task).not.toBeNull();
+    expect(task?.payload).toBe('recurring');
+  });
+});
+
+describe('Phase 11: Middleware Pipeline', () => {
+  let queue: TaskQueue;
+
+  beforeEach(() => {
+    queue = new TaskQueue();
+  });
+
+  it('should run middleware before handler', async () => {
+    const order: string[] = [];
+
+    queue.use('default', async (_task, next) => {
+      order.push('middleware');
+      await next();
+    });
+
+    queue.setHandler('default', async () => {
+      order.push('handler');
+    });
+
+    queue.addTask('test');
+    await queue.processTask();
+
+    expect(order).toEqual(['middleware', 'handler']);
+  });
+
+  it('should run multiple middleware in order', async () => {
+    const order: string[] = [];
+
+    queue.use('default', async (_task, next) => {
+      order.push('mw1');
+      await next();
+    });
+
+    queue.use('default', async (_task, next) => {
+      order.push('mw2');
+      await next();
+    });
+
+    queue.setHandler('default', async () => {
+      order.push('handler');
+    });
+
+    queue.addTask('test');
+    await queue.processTask();
+
+    expect(order).toEqual(['mw1', 'mw2', 'handler']);
+  });
+
+  it('should skip processing if middleware does not call next', async () => {
+    let handlerCalled = false;
+
+    queue.use('default', async () => {
+      // Intentionally not calling next
+    });
+
+    queue.setHandler('default', async () => {
+      handlerCalled = true;
+    });
+
+    queue.addTask('test');
+    const task = await queue.processTask();
+
+    expect(handlerCalled).toBe(false);
+    // Task should still be marked as completed since middleware ran without error
+    expect(task?.status).toBe('completed');
+  });
+
+  it('should mark task as failed if middleware throws', async () => {
+    queue.use('default', async () => {
+      throw new Error('middleware error');
+    });
+
+    queue.addTask('test', { maxRetries: 0, backoffDelay: 0 });
+    const task = await queue.processTask();
+
+    expect(task?.status).toBe('failed');
+  });
+
+  it('middleware can modify the task', async () => {
+    queue.use('default', async (task, next) => {
+      (task as Record<string, unknown>).metadata = 'added by middleware';
+      await next();
+    });
+
+    let receivedTask: Record<string, unknown> | null = null;
+    queue.setHandler('default', async (task) => {
+      receivedTask = task as unknown as Record<string, unknown>;
+    });
+
+    queue.addTask('test');
+    await queue.processTask();
+
+    expect(receivedTask?.metadata).toBe('added by middleware');
+  });
+
+  it('each queue has independent middleware', async () => {
+    const q1Calls: string[] = [];
+    const q2Calls: string[] = [];
+
+    queue.use('q1', async (_task, next) => {
+      q1Calls.push('q1-mw');
+      await next();
+    });
+
+    queue.use('q2', async (_task, next) => {
+      q2Calls.push('q2-mw');
+      await next();
+    });
+
+    queue.addTask('test1', { queue: 'q1' });
+    queue.addTask('test2', { queue: 'q2' });
+
+    await queue.processTask('q1');
+    await queue.processTask('q2');
+
+    expect(q1Calls).toEqual(['q1-mw']);
+    expect(q2Calls).toEqual(['q2-mw']);
+  });
+
+  it('should return null from processTask if no tasks available', async () => {
+    const task = await queue.processTask();
+    expect(task).toBeNull();
+  });
+
+  it('processTask auto-completes task after handler', async () => {
+    queue.setHandler('default', async () => {
+      // just do work
+    });
+
+    queue.addTask('test');
+    const task = await queue.processTask();
+    expect(task?.status).toBe('completed');
+  });
+});
+
+describe('Phase 12: Graceful Shutdown', () => {
+  let queue: TaskQueue;
+
+  beforeEach(() => {
+    queue = new TaskQueue();
+  });
+
+  it('should stop accepting new tasks after shutdown', async () => {
+    await queue.shutdown();
+    expect(() => queue.addTask('nope')).toThrow();
+  });
+
+  it('should complete immediately if no tasks are processing', async () => {
+    const result = await queue.shutdown();
+    expect(result.completed).toBe(0);
+    expect(result.forceCancelled).toBe(0);
+    expect(result.duration).toBeGreaterThanOrEqual(0);
+  });
+
+  it('should force-cancel processing tasks after timeout', async () => {
+    queue.addTask('long task');
+    queue.getNextTask(); // now processing
+
+    const result = await queue.shutdown(50); // 50ms timeout
+    expect(result.forceCancelled).toBe(1);
+  });
+
+  it('should count completed tasks during shutdown', async () => {
+    queue.addTask('quick');
+    const task = queue.getNextTask()!;
+
+    // Complete the task during shutdown
+    setTimeout(() => queue.completeTask(task.id), 10);
+
+    const result = await queue.shutdown(1000);
+    expect(result.completed).toBe(1);
+    expect(result.forceCancelled).toBe(0);
+  });
+
+  it('calling shutdown multiple times should be safe', async () => {
+    const r1 = queue.shutdown();
+    const r2 = queue.shutdown();
+    const [result1, result2] = await Promise.all([r1, r2]);
+    expect(result1).toEqual(result2);
+  });
+
+  it('should run shutdown callbacks', async () => {
+    let callbackRan = false;
+    queue.onShutdown(() => {
+      callbackRan = true;
+    });
+
+    await queue.shutdown();
+    expect(callbackRan).toBe(true);
+  });
+
+  it('shutdown result includes duration', async () => {
+    const result = await queue.shutdown();
+    expect(typeof result.duration).toBe('number');
+  });
+});
