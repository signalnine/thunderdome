diff --git a/.thunderdome-metrics.json b/.thunderdome-metrics.json
new file mode 100644
index 0000000..f0761b3
--- /dev/null
+++ b/.thunderdome-metrics.json
@@ -0,0 +1,11 @@
+{
+  "input_tokens": 0,
+  "output_tokens": 0,
+  "cache_read_tokens": 0,
+  "cache_creation_tokens": 0,
+  "turns": 0,
+  "tools_used": [],
+  "duration_ms": 0,
+  "total_cost_usd": 0,
+  "note": "interactive-mode-metrics-approximate"
+}
\ No newline at end of file
diff --git a/package-lock.json b/package-lock.json
index fb449ee..1a20967 100644
--- a/package-lock.json
+++ b/package-lock.json
@@ -16,11 +16,83 @@
         "@types/semver": "^7.5.0",
         "@typescript-eslint/eslint-plugin": "^7.0.0",
         "@typescript-eslint/parser": "^7.0.0",
+        "@vitest/coverage-v8": "^2.0.0",
         "eslint": "^8.56.0",
         "typescript": "^5.4.0",
         "vitest": "^2.0.0"
       }
     },
+    "node_modules/@ampproject/remapping": {
+      "version": "2.3.0",
+      "resolved": "https://registry.npmjs.org/@ampproject/remapping/-/remapping-2.3.0.tgz",
+      "integrity": "sha512-30iZtAPgz+LTIYoeivqYo853f02jBYSd5uGnGpkFV0M3xOt9aN73erkgYAmZU43x4VfqcnLxW9Kpg3R5LC4YYw==",
+      "dev": true,
+      "license": "Apache-2.0",
+      "dependencies": {
+        "@jridgewell/gen-mapping": "^0.3.5",
+        "@jridgewell/trace-mapping": "^0.3.24"
+      },
+      "engines": {
+        "node": ">=6.0.0"
+      }
+    },
+    "node_modules/@babel/helper-string-parser": {
+      "version": "7.27.1",
+      "resolved": "https://registry.npmjs.org/@babel/helper-string-parser/-/helper-string-parser-7.27.1.tgz",
+      "integrity": "sha512-qMlSxKbpRlAridDExk92nSobyDdpPijUq2DW6oDnUqd0iOGxmQjyqhMIihI9+zv4LPyZdRje2cavWPbCbWm3eA==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=6.9.0"
+      }
+    },
+    "node_modules/@babel/helper-validator-identifier": {
+      "version": "7.28.5",
+      "resolved": "https://registry.npmjs.org/@babel/helper-validator-identifier/-/helper-validator-identifier-7.28.5.tgz",
+      "integrity": "sha512-qSs4ifwzKJSV39ucNjsvc6WVHs6b7S03sOh2OcHF9UHfVPqWWALUsNUVzhSBiItjRZoLHx7nIarVjqKVusUZ1Q==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=6.9.0"
+      }
+    },
+    "node_modules/@babel/parser": {
+      "version": "7.29.0",
+      "resolved": "https://registry.npmjs.org/@babel/parser/-/parser-7.29.0.tgz",
+      "integrity": "sha512-IyDgFV5GeDUVX4YdF/3CPULtVGSXXMLh1xVIgdCgxApktqnQV0r7/8Nqthg+8YLGaAtdyIlo2qIdZrbCv4+7ww==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@babel/types": "^7.29.0"
+      },
+      "bin": {
+        "parser": "bin/babel-parser.js"
+      },
+      "engines": {
+        "node": ">=6.0.0"
+      }
+    },
+    "node_modules/@babel/types": {
+      "version": "7.29.0",
+      "resolved": "https://registry.npmjs.org/@babel/types/-/types-7.29.0.tgz",
+      "integrity": "sha512-LwdZHpScM4Qz8Xw2iKSzS+cfglZzJGvofQICy7W7v4caru4EaAmyUuO6BGrbyQ2mYV11W0U8j5mBhd14dd3B0A==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@babel/helper-string-parser": "^7.27.1",
+        "@babel/helper-validator-identifier": "^7.28.5"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      }
+    },
+    "node_modules/@bcoe/v8-coverage": {
+      "version": "0.2.3",
+      "resolved": "https://registry.npmjs.org/@bcoe/v8-coverage/-/v8-coverage-0.2.3.tgz",
+      "integrity": "sha512-0hYQ8SB4Db5zvZB4axdMHGwEaQjkZzFjQiN9LVYvIFB2nSUHW9tYpxWriPrWDASIxiaXax83REcLxuSdnGPZtw==",
+      "dev": true,
+      "license": "MIT"
+    },
     "node_modules/@esbuild/aix-ppc64": {
       "version": "0.21.5",
       "resolved": "https://registry.npmjs.org/@esbuild/aix-ppc64/-/aix-ppc64-0.21.5.tgz",
@@ -561,6 +633,84 @@
       "dev": true,
       "license": "BSD-3-Clause"
     },
+    "node_modules/@isaacs/cliui": {
+      "version": "8.0.2",
+      "resolved": "https://registry.npmjs.org/@isaacs/cliui/-/cliui-8.0.2.tgz",
+      "integrity": "sha512-O8jcjabXaleOG9DQ0+ARXWZBTfnP4WNAqzuiJK7ll44AmxGKv/J2M4TPjxjY3znBCfvBXFzucm1twdyFybFqEA==",
+      "dev": true,
+      "license": "ISC",
+      "dependencies": {
+        "string-width": "^5.1.2",
+        "string-width-cjs": "npm:string-width@^4.2.0",
+        "strip-ansi": "^7.0.1",
+        "strip-ansi-cjs": "npm:strip-ansi@^6.0.1",
+        "wrap-ansi": "^8.1.0",
+        "wrap-ansi-cjs": "npm:wrap-ansi@^7.0.0"
+      },
+      "engines": {
+        "node": ">=12"
+      }
+    },
+    "node_modules/@isaacs/cliui/node_modules/ansi-regex": {
+      "version": "6.2.2",
+      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-6.2.2.tgz",
+      "integrity": "sha512-Bq3SmSpyFHaWjPk8If9yc6svM8c56dB5BAtW4Qbw5jHTwwXXcTLoRMkpDJp6VL0XzlWaCHTXrkFURMYmD0sLqg==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/ansi-regex?sponsor=1"
+      }
+    },
+    "node_modules/@isaacs/cliui/node_modules/strip-ansi": {
+      "version": "7.1.2",
+      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-7.1.2.tgz",
+      "integrity": "sha512-gmBGslpoQJtgnMAvOVqGZpEz9dyoKTCzy2nfz/n8aIFhN/jCE/rCmcxabB6jOOHV+0WNnylOxaxBQPSvcWklhA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "ansi-regex": "^6.0.1"
+      },
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/strip-ansi?sponsor=1"
+      }
+    },
+    "node_modules/@istanbuljs/schema": {
+      "version": "0.1.3",
+      "resolved": "https://registry.npmjs.org/@istanbuljs/schema/-/schema-0.1.3.tgz",
+      "integrity": "sha512-ZXRY4jNvVgSVQ8DL3LTcakaAtXwTVUxE81hslsyD2AtoXW/wVob10HkOJ1X/pAlcI7D+2YoZKg5do8G/w6RYgA==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/@jridgewell/gen-mapping": {
+      "version": "0.3.13",
+      "resolved": "https://registry.npmjs.org/@jridgewell/gen-mapping/-/gen-mapping-0.3.13.tgz",
+      "integrity": "sha512-2kkt/7niJ6MgEPxF0bYdQ6etZaA+fQvDcLKckhy1yIQOzaoKjBBjSj63/aLVjYE3qhRt5dvM+uUyfCg6UKCBbA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@jridgewell/sourcemap-codec": "^1.5.0",
+        "@jridgewell/trace-mapping": "^0.3.24"
+      }
+    },
+    "node_modules/@jridgewell/resolve-uri": {
+      "version": "3.1.2",
+      "resolved": "https://registry.npmjs.org/@jridgewell/resolve-uri/-/resolve-uri-3.1.2.tgz",
+      "integrity": "sha512-bRISgCIjP20/tbWSPWMEi54QVPRZExkuD9lJL+UIxUKtwVJA8wW1Trb1jMs1RFXo1CBTNZ/5hpC9QvmKWdopKw==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=6.0.0"
+      }
+    },
     "node_modules/@jridgewell/sourcemap-codec": {
       "version": "1.5.5",
       "resolved": "https://registry.npmjs.org/@jridgewell/sourcemap-codec/-/sourcemap-codec-1.5.5.tgz",
@@ -568,6 +718,17 @@
       "dev": true,
       "license": "MIT"
     },
+    "node_modules/@jridgewell/trace-mapping": {
+      "version": "0.3.31",
+      "resolved": "https://registry.npmjs.org/@jridgewell/trace-mapping/-/trace-mapping-0.3.31.tgz",
+      "integrity": "sha512-zzNR+SdQSDJzc8joaeP8QQoCQr8NuYx2dIIytl1QeBEZHJ9uW6hebsrYgbz8hJwUQao3TWCMtmfV8Nu1twOLAw==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@jridgewell/resolve-uri": "^3.1.0",
+        "@jridgewell/sourcemap-codec": "^1.4.14"
+      }
+    },
     "node_modules/@nodelib/fs.scandir": {
       "version": "2.1.5",
       "resolved": "https://registry.npmjs.org/@nodelib/fs.scandir/-/fs.scandir-2.1.5.tgz",
@@ -606,6 +767,17 @@
         "node": ">= 8"
       }
     },
+    "node_modules/@pkgjs/parseargs": {
+      "version": "0.11.0",
+      "resolved": "https://registry.npmjs.org/@pkgjs/parseargs/-/parseargs-0.11.0.tgz",
+      "integrity": "sha512-+1VkjdD0QBLPodGrJUeqarH8VAIvQODIbwh9XpP5Syisf7YoQgsJKPNFoqqLQlu+VQ/tVSshMR6loPMn8U+dPg==",
+      "dev": true,
+      "license": "MIT",
+      "optional": true,
+      "engines": {
+        "node": ">=14"
+      }
+    },
     "node_modules/@rollup/rollup-android-arm-eabi": {
       "version": "4.57.1",
       "resolved": "https://registry.npmjs.org/@rollup/rollup-android-arm-eabi/-/rollup-android-arm-eabi-4.57.1.tgz",
@@ -979,7 +1151,6 @@
       "integrity": "sha512-m0jEgYlYz+mDJZ2+F4v8D1AyQb+QzsNqRuI7xg1VQX/KlKS0qT9r1Mo16yo5F/MtifXFgaofIFsdFMox2SxIbQ==",
       "dev": true,
       "license": "MIT",
-      "peer": true,
       "dependencies": {
         "undici-types": "~7.16.0"
       }
@@ -1031,7 +1202,6 @@
       "integrity": "sha512-4Z+L8I2OqhZV8qA132M4wNL30ypZGYOQVBfMgxDH/K5UX0PNqTu1c6za9ST5r9+tavvHiTWmBnKzpCJ/GlVFtg==",
       "dev": true,
       "license": "BSD-2-Clause",
-      "peer": true,
       "dependencies": {
         "@typescript-eslint/scope-manager": "7.18.0",
         "@typescript-eslint/types": "7.18.0",
@@ -1192,6 +1362,39 @@
       "dev": true,
       "license": "ISC"
     },
+    "node_modules/@vitest/coverage-v8": {
+      "version": "2.1.9",
+      "resolved": "https://registry.npmjs.org/@vitest/coverage-v8/-/coverage-v8-2.1.9.tgz",
+      "integrity": "sha512-Z2cOr0ksM00MpEfyVE8KXIYPEcBFxdbLSs56L8PO0QQMxt/6bDj45uQfxoc96v05KW3clk7vvgP0qfDit9DmfQ==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@ampproject/remapping": "^2.3.0",
+        "@bcoe/v8-coverage": "^0.2.3",
+        "debug": "^4.3.7",
+        "istanbul-lib-coverage": "^3.2.2",
+        "istanbul-lib-report": "^3.0.1",
+        "istanbul-lib-source-maps": "^5.0.6",
+        "istanbul-reports": "^3.1.7",
+        "magic-string": "^0.30.12",
+        "magicast": "^0.3.5",
+        "std-env": "^3.8.0",
+        "test-exclude": "^7.0.1",
+        "tinyrainbow": "^1.2.0"
+      },
+      "funding": {
+        "url": "https://opencollective.com/vitest"
+      },
+      "peerDependencies": {
+        "@vitest/browser": "2.1.9",
+        "vitest": "2.1.9"
+      },
+      "peerDependenciesMeta": {
+        "@vitest/browser": {
+          "optional": true
+        }
+      }
+    },
     "node_modules/@vitest/expect": {
       "version": "2.1.9",
       "resolved": "https://registry.npmjs.org/@vitest/expect/-/expect-2.1.9.tgz",
@@ -1311,7 +1514,6 @@
       "integrity": "sha512-NZyJarBfL7nWwIq+FDL6Zp/yHEhePMNnnJ0y3qfieCrmNvYct8uvtiV41UvlSe6apAfk0fY1FbWx+NwfmpvtTg==",
       "dev": true,
       "license": "MIT",
-      "peer": true,
       "bin": {
         "acorn": "bin/acorn"
       },
@@ -1710,6 +1912,20 @@
         "node": ">=6.0.0"
       }
     },
+    "node_modules/eastasianwidth": {
+      "version": "0.2.0",
+      "resolved": "https://registry.npmjs.org/eastasianwidth/-/eastasianwidth-0.2.0.tgz",
+      "integrity": "sha512-I88TYZWc9XiYHRQ4/3c5rjjfgkjhLyW2luGIheGERbNQ6OY7yTybanSpDXZa8y7VUP9YmDcYa+eyq4ca7iLqWA==",
+      "dev": true,
+      "license": "MIT"
+    },
+    "node_modules/emoji-regex": {
+      "version": "9.2.2",
+      "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-9.2.2.tgz",
+      "integrity": "sha512-L18DaJsXSUk2+42pv8mLs5jJT2hqFkFE4j21wOmgbUqsZ2hL72NsUU785g9RXgo3s0ZNgVl42TiHp3ZtOv/Vyg==",
+      "dev": true,
+      "license": "MIT"
+    },
     "node_modules/end-of-stream": {
       "version": "1.4.5",
       "resolved": "https://registry.npmjs.org/end-of-stream/-/end-of-stream-1.4.5.tgz",
@@ -1785,7 +2001,6 @@
       "deprecated": "This version is no longer supported. Please see https://eslint.org/version-support for other options.",
       "dev": true,
       "license": "MIT",
-      "peer": true,
       "dependencies": {
         "@eslint-community/eslint-utils": "^4.2.0",
         "@eslint-community/regexpp": "^4.6.1",
@@ -2115,6 +2330,23 @@
       "dev": true,
       "license": "ISC"
     },
+    "node_modules/foreground-child": {
+      "version": "3.3.1",
+      "resolved": "https://registry.npmjs.org/foreground-child/-/foreground-child-3.3.1.tgz",
+      "integrity": "sha512-gIXjKqtFuWEgzFRJA9WCQeSJLZDjgJUOMCMzxtvFq/37KojM1BFGufqsCy0r4qSQmYLsZYMeyRqzIWOMup03sw==",
+      "dev": true,
+      "license": "ISC",
+      "dependencies": {
+        "cross-spawn": "^7.0.6",
+        "signal-exit": "^4.0.1"
+      },
+      "engines": {
+        "node": ">=14"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/isaacs"
+      }
+    },
     "node_modules/fs-constants": {
       "version": "1.0.0",
       "resolved": "https://registry.npmjs.org/fs-constants/-/fs-constants-1.0.0.tgz",
@@ -2262,6 +2494,13 @@
         "node": ">=8"
       }
     },
+    "node_modules/html-escaper": {
+      "version": "2.0.2",
+      "resolved": "https://registry.npmjs.org/html-escaper/-/html-escaper-2.0.2.tgz",
+      "integrity": "sha512-H2iMtd0I4Mt5eYiapRdIDjp+XzelXQ0tFE4JS7YFwFevXXMmOp9myNrUvCg0D6ws8iqkRPBfKHgbwig1SmlLfg==",
+      "dev": true,
+      "license": "MIT"
+    },
     "node_modules/ieee754": {
       "version": "1.2.1",
       "resolved": "https://registry.npmjs.org/ieee754/-/ieee754-1.2.1.tgz",
@@ -2353,6 +2592,16 @@
         "node": ">=0.10.0"
       }
     },
+    "node_modules/is-fullwidth-code-point": {
+      "version": "3.0.0",
+      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/is-fullwidth-code-point-3.0.0.tgz",
+      "integrity": "sha512-zymm5+u+sCsSWyD9qNaejV3DFvhCKclKdizYaJUuHA83RLjb7nSuGnddCHGv0hk+KY7BMAlsWeK4Ueg6EV6XQg==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=8"
+      }
+    },
     "node_modules/is-glob": {
       "version": "4.0.3",
       "resolved": "https://registry.npmjs.org/is-glob/-/is-glob-4.0.3.tgz",
@@ -2393,6 +2642,76 @@
       "dev": true,
       "license": "ISC"
     },
+    "node_modules/istanbul-lib-coverage": {
+      "version": "3.2.2",
+      "resolved": "https://registry.npmjs.org/istanbul-lib-coverage/-/istanbul-lib-coverage-3.2.2.tgz",
+      "integrity": "sha512-O8dpsF+r0WV/8MNRKfnmrtCWhuKjxrq2w+jpzBL5UZKTi2LeVWnWOmWRxFlesJONmc+wLAGvKQZEOanko0LFTg==",
+      "dev": true,
+      "license": "BSD-3-Clause",
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/istanbul-lib-report": {
+      "version": "3.0.1",
+      "resolved": "https://registry.npmjs.org/istanbul-lib-report/-/istanbul-lib-report-3.0.1.tgz",
+      "integrity": "sha512-GCfE1mtsHGOELCU8e/Z7YWzpmybrx/+dSTfLrvY8qRmaY6zXTKWn6WQIjaAFw069icm6GVMNkgu0NzI4iPZUNw==",
+      "dev": true,
+      "license": "BSD-3-Clause",
+      "dependencies": {
+        "istanbul-lib-coverage": "^3.0.0",
+        "make-dir": "^4.0.0",
+        "supports-color": "^7.1.0"
+      },
+      "engines": {
+        "node": ">=10"
+      }
+    },
+    "node_modules/istanbul-lib-source-maps": {
+      "version": "5.0.6",
+      "resolved": "https://registry.npmjs.org/istanbul-lib-source-maps/-/istanbul-lib-source-maps-5.0.6.tgz",
+      "integrity": "sha512-yg2d+Em4KizZC5niWhQaIomgf5WlL4vOOjZ5xGCmF8SnPE/mDWWXgvRExdcpCgh9lLRRa1/fSYp2ymmbJ1pI+A==",
+      "dev": true,
+      "license": "BSD-3-Clause",
+      "dependencies": {
+        "@jridgewell/trace-mapping": "^0.3.23",
+        "debug": "^4.1.1",
+        "istanbul-lib-coverage": "^3.0.0"
+      },
+      "engines": {
+        "node": ">=10"
+      }
+    },
+    "node_modules/istanbul-reports": {
+      "version": "3.2.0",
+      "resolved": "https://registry.npmjs.org/istanbul-reports/-/istanbul-reports-3.2.0.tgz",
+      "integrity": "sha512-HGYWWS/ehqTV3xN10i23tkPkpH46MLCIMFNCaaKNavAXTF1RkqxawEPtnjnGZ6XKSInBKkiOA5BKS+aZiY3AvA==",
+      "dev": true,
+      "license": "BSD-3-Clause",
+      "dependencies": {
+        "html-escaper": "^2.0.0",
+        "istanbul-lib-report": "^3.0.0"
+      },
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/jackspeak": {
+      "version": "3.4.3",
+      "resolved": "https://registry.npmjs.org/jackspeak/-/jackspeak-3.4.3.tgz",
+      "integrity": "sha512-OGlZQpz2yfahA/Rd1Y8Cd9SIEsqvXkLVoSw/cgwhnhFMDbsQFeZYoJJ7bIZBS9BcamUW96asq/npPWugM+RQBw==",
+      "dev": true,
+      "license": "BlueOak-1.0.0",
+      "dependencies": {
+        "@isaacs/cliui": "^8.0.2"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/isaacs"
+      },
+      "optionalDependencies": {
+        "@pkgjs/parseargs": "^0.11.0"
+      }
+    },
     "node_modules/js-yaml": {
       "version": "4.1.1",
       "resolved": "https://registry.npmjs.org/js-yaml/-/js-yaml-4.1.1.tgz",
@@ -2481,6 +2800,13 @@
       "dev": true,
       "license": "MIT"
     },
+    "node_modules/lru-cache": {
+      "version": "10.4.3",
+      "resolved": "https://registry.npmjs.org/lru-cache/-/lru-cache-10.4.3.tgz",
+      "integrity": "sha512-JNAzZcXrCt42VGLuYz0zfAzDfAvJWW6AfYlDBQyDV5DClI2m5sAmK+OIO7s59XfsRsWHp02jAJrRadPRGTt6SQ==",
+      "dev": true,
+      "license": "ISC"
+    },
     "node_modules/magic-string": {
       "version": "0.30.21",
       "resolved": "https://registry.npmjs.org/magic-string/-/magic-string-0.30.21.tgz",
@@ -2491,6 +2817,34 @@
         "@jridgewell/sourcemap-codec": "^1.5.5"
       }
     },
+    "node_modules/magicast": {
+      "version": "0.3.5",
+      "resolved": "https://registry.npmjs.org/magicast/-/magicast-0.3.5.tgz",
+      "integrity": "sha512-L0WhttDl+2BOsybvEOLK7fW3UA0OQ0IQ2d6Zl2x/a6vVRs3bAY0ECOSHHeL5jD+SbOpOCUEi0y1DgHEn9Qn1AQ==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@babel/parser": "^7.25.4",
+        "@babel/types": "^7.25.4",
+        "source-map-js": "^1.2.0"
+      }
+    },
+    "node_modules/make-dir": {
+      "version": "4.0.0",
+      "resolved": "https://registry.npmjs.org/make-dir/-/make-dir-4.0.0.tgz",
+      "integrity": "sha512-hXdUTZYIVOt1Ex//jAQi+wTZZpUpwBj/0QsOzqegb3rGMMeJiSEu5xLHnYfBrRV4RH2+OCSOO95Is/7x1WJ4bw==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "semver": "^7.5.3"
+      },
+      "engines": {
+        "node": ">=10"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/sindresorhus"
+      }
+    },
     "node_modules/merge2": {
       "version": "1.4.1",
       "resolved": "https://registry.npmjs.org/merge2/-/merge2-1.4.1.tgz",
@@ -2552,6 +2906,16 @@
         "url": "https://github.com/sponsors/ljharb"
       }
     },
+    "node_modules/minipass": {
+      "version": "7.1.2",
+      "resolved": "https://registry.npmjs.org/minipass/-/minipass-7.1.2.tgz",
+      "integrity": "sha512-qOOzS1cBTWYF4BH8fVePDBOO9iptMnGUEZwNc/cMWnTV2nVLZ7VoNWEPHkYczZA0pdoA7dl6e7FL659nX9S2aw==",
+      "dev": true,
+      "license": "ISC",
+      "engines": {
+        "node": ">=16 || 14 >=14.17"
+      }
+    },
     "node_modules/mkdirp-classic": {
       "version": "0.5.3",
       "resolved": "https://registry.npmjs.org/mkdirp-classic/-/mkdirp-classic-0.5.3.tgz",
@@ -2668,6 +3032,13 @@
         "url": "https://github.com/sponsors/sindresorhus"
       }
     },
+    "node_modules/package-json-from-dist": {
+      "version": "1.0.1",
+      "resolved": "https://registry.npmjs.org/package-json-from-dist/-/package-json-from-dist-1.0.1.tgz",
+      "integrity": "sha512-UEZIS3/by4OC8vL3P2dTXRETpebLI2NiI5vIrjaD/5UtrkFX/tNbwjTSRAGC/+7CAo2pIcBaRgWmcBBHcsaCIw==",
+      "dev": true,
+      "license": "BlueOak-1.0.0"
+    },
     "node_modules/parent-module": {
       "version": "1.0.1",
       "resolved": "https://registry.npmjs.org/parent-module/-/parent-module-1.0.1.tgz",
@@ -2711,6 +3082,23 @@
         "node": ">=8"
       }
     },
+    "node_modules/path-scurry": {
+      "version": "1.11.1",
+      "resolved": "https://registry.npmjs.org/path-scurry/-/path-scurry-1.11.1.tgz",
+      "integrity": "sha512-Xa4Nw17FS9ApQFJ9umLiJS4orGjm7ZzwUrwamcGQuHSzDyth9boKDaycYdDcZDuqYATXw4HFXgaqWTctW/v1HA==",
+      "dev": true,
+      "license": "BlueOak-1.0.0",
+      "dependencies": {
+        "lru-cache": "^10.2.0",
+        "minipass": "^5.0.0 || ^6.0.2 || ^7.0.0"
+      },
+      "engines": {
+        "node": ">=16 || 14 >=14.18"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/isaacs"
+      }
+    },
     "node_modules/path-type": {
       "version": "4.0.0",
       "resolved": "https://registry.npmjs.org/path-type/-/path-type-4.0.0.tgz",
@@ -3071,6 +3459,19 @@
       "dev": true,
       "license": "ISC"
     },
+    "node_modules/signal-exit": {
+      "version": "4.1.0",
+      "resolved": "https://registry.npmjs.org/signal-exit/-/signal-exit-4.1.0.tgz",
+      "integrity": "sha512-bzyZ1e88w9O1iNJbKnOlvYTrWPDl46O1bG0D3XInv+9tkPrxrN8jUUTiFlDkkmKWgn1M6CfIA13SuGqOa9Korw==",
+      "dev": true,
+      "license": "ISC",
+      "engines": {
+        "node": ">=14"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/isaacs"
+      }
+    },
     "node_modules/simple-concat": {
       "version": "1.0.1",
       "resolved": "https://registry.npmjs.org/simple-concat/-/simple-concat-1.0.1.tgz",
@@ -3159,6 +3560,76 @@
         "safe-buffer": "~5.2.0"
       }
     },
+    "node_modules/string-width": {
+      "version": "5.1.2",
+      "resolved": "https://registry.npmjs.org/string-width/-/string-width-5.1.2.tgz",
+      "integrity": "sha512-HnLOCR3vjcY8beoNLtcjZ5/nxn2afmME6lhrDrebokqMap+XbeW8n9TXpPDOqdGK5qcI3oT0GKTW6wC7EMiVqA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "eastasianwidth": "^0.2.0",
+        "emoji-regex": "^9.2.2",
+        "strip-ansi": "^7.0.1"
+      },
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/sindresorhus"
+      }
+    },
+    "node_modules/string-width-cjs": {
+      "name": "string-width",
+      "version": "4.2.3",
+      "resolved": "https://registry.npmjs.org/string-width/-/string-width-4.2.3.tgz",
+      "integrity": "sha512-wKyQRQpjJ0sIp62ErSZdGsjMJWsap5oRNihHhu6G7JVO/9jIB6UyevL+tXuOqrng8j/cxKTWyWUwvSTriiZz/g==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "emoji-regex": "^8.0.0",
+        "is-fullwidth-code-point": "^3.0.0",
+        "strip-ansi": "^6.0.1"
+      },
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/string-width-cjs/node_modules/emoji-regex": {
+      "version": "8.0.0",
+      "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-8.0.0.tgz",
+      "integrity": "sha512-MSjYzcWNOA0ewAHpz0MxpYFvwg6yjy1NG3xteoqz644VCo/RPgnr1/GGt+ic3iJTzQ8Eu3TdM14SawnVUmGE6A==",
+      "dev": true,
+      "license": "MIT"
+    },
+    "node_modules/string-width/node_modules/ansi-regex": {
+      "version": "6.2.2",
+      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-6.2.2.tgz",
+      "integrity": "sha512-Bq3SmSpyFHaWjPk8If9yc6svM8c56dB5BAtW4Qbw5jHTwwXXcTLoRMkpDJp6VL0XzlWaCHTXrkFURMYmD0sLqg==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/ansi-regex?sponsor=1"
+      }
+    },
+    "node_modules/string-width/node_modules/strip-ansi": {
+      "version": "7.1.2",
+      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-7.1.2.tgz",
+      "integrity": "sha512-gmBGslpoQJtgnMAvOVqGZpEz9dyoKTCzy2nfz/n8aIFhN/jCE/rCmcxabB6jOOHV+0WNnylOxaxBQPSvcWklhA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "ansi-regex": "^6.0.1"
+      },
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/strip-ansi?sponsor=1"
+      }
+    },
     "node_modules/strip-ansi": {
       "version": "6.0.1",
       "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-6.0.1.tgz",
@@ -3172,6 +3643,20 @@
         "node": ">=8"
       }
     },
+    "node_modules/strip-ansi-cjs": {
+      "name": "strip-ansi",
+      "version": "6.0.1",
+      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-6.0.1.tgz",
+      "integrity": "sha512-Y38VPSHcqkFrCpFnQ9vuSXmquuv5oXOKpGeT6aGrr3o3Gc9AlVa6JBfUSOCnbxGGZF+/0ooI7KrPuUSztUdU5A==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "ansi-regex": "^5.0.1"
+      },
+      "engines": {
+        "node": ">=8"
+      }
+    },
     "node_modules/strip-json-comments": {
       "version": "3.1.1",
       "resolved": "https://registry.npmjs.org/strip-json-comments/-/strip-json-comments-3.1.1.tgz",
@@ -3226,6 +3711,43 @@
         "node": ">=6"
       }
     },
+    "node_modules/test-exclude": {
+      "version": "7.0.1",
+      "resolved": "https://registry.npmjs.org/test-exclude/-/test-exclude-7.0.1.tgz",
+      "integrity": "sha512-pFYqmTw68LXVjeWJMST4+borgQP2AyMNbg1BpZh9LbyhUeNkeaPF9gzfPGUAnSMV3qPYdWUwDIjjCLiSDOl7vg==",
+      "dev": true,
+      "license": "ISC",
+      "dependencies": {
+        "@istanbuljs/schema": "^0.1.2",
+        "glob": "^10.4.1",
+        "minimatch": "^9.0.4"
+      },
+      "engines": {
+        "node": ">=18"
+      }
+    },
+    "node_modules/test-exclude/node_modules/glob": {
+      "version": "10.5.0",
+      "resolved": "https://registry.npmjs.org/glob/-/glob-10.5.0.tgz",
+      "integrity": "sha512-DfXN8DfhJ7NH3Oe7cFmu3NCu1wKbkReJ8TorzSAFbSKrlNaQSKfIzqYqVY8zlbs2NLBbWpRiU52GX2PbaBVNkg==",
+      "deprecated": "Old versions of glob are not supported, and contain widely publicized security vulnerabilities, which have been fixed in the current version. Please update. Support for old versions may be purchased (at exorbitant rates) by contacting i@izs.me",
+      "dev": true,
+      "license": "ISC",
+      "dependencies": {
+        "foreground-child": "^3.1.0",
+        "jackspeak": "^3.1.2",
+        "minimatch": "^9.0.4",
+        "minipass": "^7.1.2",
+        "package-json-from-dist": "^1.0.0",
+        "path-scurry": "^1.11.1"
+      },
+      "bin": {
+        "glob": "dist/esm/bin.mjs"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/isaacs"
+      }
+    },
     "node_modules/text-table": {
       "version": "0.2.0",
       "resolved": "https://registry.npmjs.org/text-table/-/text-table-0.2.0.tgz",
@@ -3347,7 +3869,6 @@
       "integrity": "sha512-jl1vZzPDinLr9eUt3J/t7V6FgNEw9QjvBPdysz9KfQDD41fQrC2Y4vKQdiaUpFT4bXlb1RHhLpp8wtm6M5TgSw==",
       "dev": true,
       "license": "Apache-2.0",
-      "peer": true,
       "bin": {
         "tsc": "bin/tsc",
         "tsserver": "bin/tsserver"
@@ -3571,6 +4092,107 @@
         "node": ">=0.10.0"
       }
     },
+    "node_modules/wrap-ansi": {
+      "version": "8.1.0",
+      "resolved": "https://registry.npmjs.org/wrap-ansi/-/wrap-ansi-8.1.0.tgz",
+      "integrity": "sha512-si7QWI6zUMq56bESFvagtmzMdGOtoxfR+Sez11Mobfc7tm+VkUckk9bW2UeffTGVUbOksxmSw0AA2gs8g71NCQ==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "ansi-styles": "^6.1.0",
+        "string-width": "^5.0.1",
+        "strip-ansi": "^7.0.1"
+      },
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/wrap-ansi?sponsor=1"
+      }
+    },
+    "node_modules/wrap-ansi-cjs": {
+      "name": "wrap-ansi",
+      "version": "7.0.0",
+      "resolved": "https://registry.npmjs.org/wrap-ansi/-/wrap-ansi-7.0.0.tgz",
+      "integrity": "sha512-YVGIj2kamLSTxw6NsZjoBxfSwsn0ycdesmc4p+Q21c5zPuZ1pl+NfxVdxPtdHvmNVOQ6XSYG4AUtyt/Fi7D16Q==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "ansi-styles": "^4.0.0",
+        "string-width": "^4.1.0",
+        "strip-ansi": "^6.0.0"
+      },
+      "engines": {
+        "node": ">=10"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/wrap-ansi?sponsor=1"
+      }
+    },
+    "node_modules/wrap-ansi-cjs/node_modules/emoji-regex": {
+      "version": "8.0.0",
+      "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-8.0.0.tgz",
+      "integrity": "sha512-MSjYzcWNOA0ewAHpz0MxpYFvwg6yjy1NG3xteoqz644VCo/RPgnr1/GGt+ic3iJTzQ8Eu3TdM14SawnVUmGE6A==",
+      "dev": true,
+      "license": "MIT"
+    },
+    "node_modules/wrap-ansi-cjs/node_modules/string-width": {
+      "version": "4.2.3",
+      "resolved": "https://registry.npmjs.org/string-width/-/string-width-4.2.3.tgz",
+      "integrity": "sha512-wKyQRQpjJ0sIp62ErSZdGsjMJWsap5oRNihHhu6G7JVO/9jIB6UyevL+tXuOqrng8j/cxKTWyWUwvSTriiZz/g==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "emoji-regex": "^8.0.0",
+        "is-fullwidth-code-point": "^3.0.0",
+        "strip-ansi": "^6.0.1"
+      },
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/wrap-ansi/node_modules/ansi-regex": {
+      "version": "6.2.2",
+      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-6.2.2.tgz",
+      "integrity": "sha512-Bq3SmSpyFHaWjPk8If9yc6svM8c56dB5BAtW4Qbw5jHTwwXXcTLoRMkpDJp6VL0XzlWaCHTXrkFURMYmD0sLqg==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/ansi-regex?sponsor=1"
+      }
+    },
+    "node_modules/wrap-ansi/node_modules/ansi-styles": {
+      "version": "6.2.3",
+      "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-6.2.3.tgz",
+      "integrity": "sha512-4Dj6M28JB+oAH8kFkTLUo+a2jwOFkuqb3yucU0CANcRRUbxS0cP0nZYCGjcc3BNXwRIsUVmDGgzawme7zvJHvg==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/ansi-styles?sponsor=1"
+      }
+    },
+    "node_modules/wrap-ansi/node_modules/strip-ansi": {
+      "version": "7.1.2",
+      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-7.1.2.tgz",
+      "integrity": "sha512-gmBGslpoQJtgnMAvOVqGZpEz9dyoKTCzy2nfz/n8aIFhN/jCE/rCmcxabB6jOOHV+0WNnylOxaxBQPSvcWklhA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "ansi-regex": "^6.0.1"
+      },
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/strip-ansi?sponsor=1"
+      }
+    },
     "node_modules/wrappy": {
       "version": "1.0.2",
       "resolved": "https://registry.npmjs.org/wrappy/-/wrappy-1.0.2.tgz",
diff --git a/src/deps/index.ts b/src/deps/index.ts
new file mode 100644
index 0000000..3b4bd7c
--- /dev/null
+++ b/src/deps/index.ts
@@ -0,0 +1,119 @@
+import type { DependencyNode, DepsService, RegistryService } from '../types.js';
+
+export function createDepsService(): DepsService {
+  function buildTree(name: string, registry: RegistryService, visited: Set<string> = new Set()): DependencyNode {
+    const plugin = registry.get(name);
+    if (!plugin) {
+      return { name, version: 'unknown', dependencies: [] };
+    }
+
+    if (visited.has(name)) {
+      return { name, version: plugin.version, dependencies: [] };
+    }
+
+    visited.add(name);
+
+    const deps: DependencyNode[] = [];
+    for (const depName of Object.keys(plugin.dependencies)) {
+      deps.push(buildTree(depName, registry, new Set(visited)));
+    }
+
+    return {
+      name: plugin.name,
+      version: plugin.version,
+      dependencies: deps,
+    };
+  }
+
+  function detectCycles(name: string, registry: RegistryService): string[][] | null {
+    const cycles: string[][] = [];
+
+    function dfs(current: string, path: string[], visited: Set<string>): void {
+      if (path.includes(current)) {
+        const cycleStart = path.indexOf(current);
+        cycles.push([...path.slice(cycleStart), current]);
+        return;
+      }
+
+      if (visited.has(current)) {
+        return;
+      }
+
+      visited.add(current);
+      path.push(current);
+
+      const plugin = registry.get(current);
+      if (plugin) {
+        for (const depName of Object.keys(plugin.dependencies)) {
+          dfs(depName, [...path], visited);
+        }
+      }
+
+      path.pop();
+    }
+
+    dfs(name, [], new Set());
+    return cycles.length > 0 ? cycles : null;
+  }
+
+  function topologicalSort(name: string, registry: RegistryService): string[] {
+    const result: string[] = [];
+    const visited = new Set<string>();
+    const visiting = new Set<string>();
+
+    function visit(current: string): void {
+      if (visited.has(current)) return;
+      if (visiting.has(current)) {
+        throw new Error(`Circular dependency detected involving ${current}`);
+      }
+
+      visiting.add(current);
+
+      const plugin = registry.get(current);
+      if (plugin) {
+        for (const depName of Object.keys(plugin.dependencies)) {
+          visit(depName);
+        }
+      }
+
+      visiting.delete(current);
+      visited.add(current);
+      result.push(current);
+    }
+
+    visit(name);
+    return result;
+  }
+
+  function flattenDependencies(name: string, registry: RegistryService): string[] {
+    const deps = new Set<string>();
+
+    function collect(current: string, visited: Set<string>): void {
+      const plugin = registry.get(current);
+      if (!plugin) return;
+
+      for (const depName of Object.keys(plugin.dependencies)) {
+        if (!visited.has(depName)) {
+          visited.add(depName);
+          deps.add(depName);
+          collect(depName, visited);
+        }
+      }
+    }
+
+    collect(name, new Set([name]));
+    return [...deps];
+  }
+
+  function hasCircularDependency(name: string, registry: RegistryService): boolean {
+    return detectCycles(name, registry) !== null;
+  }
+
+  return {
+    buildTree: (name, registry) => buildTree(name, registry),
+    detectCycles,
+    topologicalSort,
+    flattenDependencies,
+    hasCircularDependency,
+  };
+}
diff --git a/src/index.ts b/src/index.ts
new file mode 100644
index 0000000..7e212d6
--- /dev/null
+++ b/src/index.ts
@@ -0,0 +1,98 @@
+import type {
+  PluginManifest,
+  RegistryService,
+  ResolverService,
+  RunnerService,
+  ReviewService,
+  DepsService,
+  ResolvedVersion,
+  SandboxResult,
+} from './types.js';
+
+import { createRegistry } from './registry/index.js';
+import { createResolver } from './resolver/index.js';
+import { createRunner } from './runner/index.js';
+import { createReviewService } from './reviews/index.js';
+import { createDepsService } from './deps/index.js';
+
+export interface InstallResult {
+  resolvedDependencies: ResolvedVersion[];
+  executionResult: SandboxResult;
+}
+
+export interface Marketplace {
+  registry: RegistryService;
+  resolver: ResolverService;
+  runner: RunnerService;
+  reviews: ReviewService;
+  deps: DepsService;
+  installPlugin(manifest: PluginManifest): Promise<InstallResult>;
+}
+
+export function createMarketplace(dbPath?: string): Marketplace {
+  const registry = createRegistry(dbPath);
+  const resolver = createResolver();
+  const runner = createRunner();
+  const reviews = createReviewService(dbPath);
+  const deps = createDepsService();
+
+  async function installPlugin(manifest: PluginManifest): Promise<InstallResult> {
+    // Validate required fields
+    if (!manifest.name || typeof manifest.name !== 'string') {
+      throw new Error('Plugin manifest must have a valid name');
+    }
+    if (!manifest.version || typeof manifest.version !== 'string') {
+      throw new Error('Plugin manifest must have a valid version');
+    }
+    if (!manifest.entryPoint || typeof manifest.entryPoint !== 'string') {
+      throw new Error('Plugin manifest must have a valid entryPoint');
+    }
+
+    // Register the plugin
+    registry.register(manifest);
+
+    // Resolve dependency versions
+    let resolvedDependencies: ResolvedVersion[] = [];
+    const depEntries = Object.entries(manifest.dependencies || {});
+
+    if (depEntries.length > 0) {
+      const constraints = depEntries.map(([name, range]) => ({ name, range }));
+      const available: Record<string, string[]> = {};
+      for (const [name] of depEntries) {
+        available[name] = registry.listVersions(name);
+      }
+
+      resolvedDependencies = resolver.resolve(constraints, available);
+
+      // Check for circular dependencies
+      if (deps.hasCircularDependency(manifest.name, registry)) {
+        // Remove the plugin since it has circular deps
+        registry.remove(manifest.name, manifest.version);
+        throw new Error(`Circular dependency detected for plugin ${manifest.name}`);
+      }
+    }
+
+    // Execute the plugin's entry point in sandbox
+    const executionResult = await runner.execute(manifest.entryPoint);
+
+    return {
+      resolvedDependencies,
+      executionResult,
+    };
+  }
+
+  return {
+    registry,
+    resolver,
+    runner,
+    reviews,
+    deps,
+    installPlugin,
+  };
+}
+
+export { createRegistry } from './registry/index.js';
+export { createResolver } from './resolver/index.js';
+export { createRunner } from './runner/index.js';
+export { createReviewService } from './reviews/index.js';
+export { createDepsService } from './deps/index.js';
diff --git a/src/registry/index.ts b/src/registry/index.ts
new file mode 100644
index 0000000..5d921dd
--- /dev/null
+++ b/src/registry/index.ts
@@ -0,0 +1,107 @@
+import Database from 'better-sqlite3';
+import type { PluginManifest, RegistryService } from '../types.js';
+
+export function createRegistry(dbPath: string = ':memory:'): RegistryService {
+  const db = new Database(dbPath);
+  db.pragma('journal_mode = WAL');
+
+  db.exec(`
+    CREATE TABLE IF NOT EXISTS plugins (
+      name TEXT NOT NULL,
+      version TEXT NOT NULL,
+      description TEXT NOT NULL,
+      author TEXT NOT NULL,
+      dependencies TEXT NOT NULL,
+      entryPoint TEXT NOT NULL,
+      permissions TEXT NOT NULL,
+      PRIMARY KEY (name, version)
+    )
+  `);
+
+  const insertStmt = db.prepare(`
+    INSERT OR REPLACE INTO plugins (name, version, description, author, dependencies, entryPoint, permissions)
+    VALUES (@name, @version, @description, @author, @dependencies, @entryPoint, @permissions)
+  `);
+
+  const getStmt = db.prepare(`SELECT * FROM plugins WHERE name = ? ORDER BY version DESC LIMIT 1`);
+  const getVersionStmt = db.prepare(`SELECT * FROM plugins WHERE name = ? AND version = ?`);
+  const listStmt = db.prepare(`SELECT * FROM plugins`);
+  const searchStmt = db.prepare(`SELECT * FROM plugins WHERE name LIKE ? OR description LIKE ? OR author LIKE ?`);
+  const removeStmt = db.prepare(`DELETE FROM plugins WHERE name = ? AND version = ?`);
+  const listVersionsStmt = db.prepare(`SELECT version FROM plugins WHERE name = ? ORDER BY version`);
+  const updateStmt = db.prepare(`
+    UPDATE plugins SET description = @description, author = @author, dependencies = @dependencies,
+    entryPoint = @entryPoint, permissions = @permissions WHERE name = @name AND version = @version
+  `);
+
+  function rowToManifest(row: Record<string, unknown>): PluginManifest {
+    return {
+      name: row.name as string,
+      version: row.version as string,
+      description: row.description as string,
+      author: row.author as string,
+      dependencies: JSON.parse(row.dependencies as string) as Record<string, string>,
+      entryPoint: row.entryPoint as string,
+      permissions: JSON.parse(row.permissions as string) as string[],
+    };
+  }
+
+  function manifestToRow(manifest: PluginManifest) {
+    return {
+      name: manifest.name,
+      version: manifest.version,
+      description: manifest.description,
+      author: manifest.author,
+      dependencies: JSON.stringify(manifest.dependencies),
+      entryPoint: manifest.entryPoint,
+      permissions: JSON.stringify(manifest.permissions),
+    };
+  }
+
+  return {
+    register(manifest: PluginManifest): void {
+      insertStmt.run(manifestToRow(manifest));
+    },
+
+    get(name: string): PluginManifest | null {
+      const row = getStmt.get(name) as Record<string, unknown> | undefined;
+      return row ? rowToManifest(row) : null;
+    },
+
+    getVersion(name: string, version: string): PluginManifest | null {
+      const row = getVersionStmt.get(name, version) as Record<string, unknown> | undefined;
+      return row ? rowToManifest(row) : null;
+    },
+
+    list(): PluginManifest[] {
+      const rows = listStmt.all() as Record<string, unknown>[];
+      return rows.map(rowToManifest);
+    },
+
+    search(query: string): PluginManifest[] {
+      const pattern = `%${query}%`;
+      const rows = searchStmt.all(pattern, pattern, pattern) as Record<string, unknown>[];
+      return rows.map(rowToManifest);
+    },
+
+    remove(name: string, version: string): boolean {
+      const result = removeStmt.run(name, version);
+      return result.changes > 0;
+    },
+
+    listVersions(name: string): string[] {
+      const rows = listVersionsStmt.all(name) as Array<{ version: string }>;
+      return rows.map(r => r.version);
+    },
+
+    update(name: string, version: string, updates: Partial<PluginManifest>): void {
+      const existing = getVersionStmt.get(name, version) as Record<string, unknown> | undefined;
+      if (!existing) {
+        throw new Error(`Plugin ${name}@${version} not found`);
+      }
+      const current = rowToManifest(existing);
+      const updated = { ...current, ...updates, name, version };
+      updateStmt.run(manifestToRow(updated));
+    },
+  };
+}
diff --git a/src/resolver/index.ts b/src/resolver/index.ts
new file mode 100644
index 0000000..b537eca
--- /dev/null
+++ b/src/resolver/index.ts
@@ -0,0 +1,42 @@
+import semver from 'semver';
+import type { VersionConstraint, ResolvedVersion, ResolverService } from '../types.js';
+
+export function createResolver(): ResolverService {
+  return {
+    resolve(constraints: VersionConstraint[], available: Record<string, string[]>): ResolvedVersion[] {
+      const resolved: ResolvedVersion[] = [];
+
+      for (const constraint of constraints) {
+        const versions = available[constraint.name];
+        if (!versions || versions.length === 0) {
+          throw new Error(`No versions available for ${constraint.name}`);
+        }
+
+        const best = semver.maxSatisfying(versions, constraint.range);
+        if (!best) {
+          throw new Error(`No version of ${constraint.name} satisfies ${constraint.range}`);
+        }
+
+        resolved.push({
+          name: constraint.name,
+          version: best,
+          satisfies: constraint.range,
+        });
+      }
+
+      return resolved;
+    },
+
+    satisfies(version: string, range: string): boolean {
+      return semver.satisfies(version, range);
+    },
+
+    maxSatisfying(versions: string[], range: string): string | null {
+      return semver.maxSatisfying(versions, range);
+    },
+
+    validRange(range: string): boolean {
+      return semver.validRange(range) !== null;
+    },
+  };
+}
diff --git a/src/reviews/index.ts b/src/reviews/index.ts
new file mode 100644
index 0000000..2a47d9f
--- /dev/null
+++ b/src/reviews/index.ts
@@ -0,0 +1,100 @@
+import Database from 'better-sqlite3';
+import type { Review, ReviewService } from '../types.js';
+
+export function createReviewService(dbPath: string = ':memory:'): ReviewService {
+  const db = new Database(dbPath);
+  db.pragma('journal_mode = WAL');
+
+  db.exec(`
+    CREATE TABLE IF NOT EXISTS reviews (
+      id INTEGER PRIMARY KEY AUTOINCREMENT,
+      pluginName TEXT NOT NULL,
+      pluginVersion TEXT NOT NULL,
+      userId TEXT NOT NULL,
+      rating INTEGER NOT NULL CHECK(rating >= 1 AND rating <= 5),
+      comment TEXT NOT NULL,
+      flagged INTEGER NOT NULL DEFAULT 0,
+      createdAt TEXT NOT NULL
+    )
+  `);
+
+  const insertStmt = db.prepare(`
+    INSERT INTO reviews (pluginName, pluginVersion, userId, rating, comment, flagged, createdAt)
+    VALUES (@pluginName, @pluginVersion, @userId, @rating, @comment, 0, @createdAt)
+  `);
+
+  const getByPluginStmt = db.prepare(`SELECT * FROM reviews WHERE pluginName = ?`);
+  const avgRatingStmt = db.prepare(`SELECT AVG(rating) as avg FROM reviews WHERE pluginName = ? AND flagged = 0`);
+  const flagStmt = db.prepare(`UPDATE reviews SET flagged = 1 WHERE id = ?`);
+  const getFlaggedStmt = db.prepare(`SELECT * FROM reviews WHERE flagged = 1`);
+  const removeStmt = db.prepare(`DELETE FROM reviews WHERE id = ?`);
+  const getByUserStmt = db.prepare(`SELECT * FROM reviews WHERE userId = ?`);
+  const countStmt = db.prepare(`SELECT COUNT(*) as count FROM reviews WHERE pluginName = ?`);
+
+  function rowToReview(row: Record<string, unknown>): Review {
+    return {
+      id: row.id as number,
+      pluginName: row.pluginName as string,
+      pluginVersion: row.pluginVersion as string,
+      userId: row.userId as string,
+      rating: row.rating as number,
+      comment: row.comment as string,
+      flagged: (row.flagged as number) === 1,
+      createdAt: row.createdAt as string,
+    };
+  }
+
+  return {
+    addReview(review: Omit<Review, 'id' | 'createdAt' | 'flagged'>): Review {
+      const createdAt = new Date().toISOString();
+      const result = insertStmt.run({
+        pluginName: review.pluginName,
+        pluginVersion: review.pluginVersion,
+        userId: review.userId,
+        rating: review.rating,
+        comment: review.comment,
+        createdAt,
+      });
+      return {
+        ...review,
+        id: Number(result.lastInsertRowid),
+        flagged: false,
+        createdAt,
+      };
+    },
+
+    getReviews(pluginName: string): Review[] {
+      const rows = getByPluginStmt.all(pluginName) as Record<string, unknown>[];
+      return rows.map(rowToReview);
+    },
+
+    getAverageRating(pluginName: string): number {
+      const row = avgRatingStmt.get(pluginName) as { avg: number | null };
+      return row.avg ?? 0;
+    },
+
+    flagReview(reviewId: number): void {
+      flagStmt.run(reviewId);
+    },
+
+    getFlaggedReviews(): Review[] {
+      const rows = getFlaggedStmt.all() as Record<string, unknown>[];
+      return rows.map(rowToReview);
+    },
+
+    removeReview(reviewId: number): boolean {
+      const result = removeStmt.run(reviewId);
+      return result.changes > 0;
+    },
+
+    getReviewsByUser(userId: string): Review[] {
+      const rows = getByUserStmt.all(userId) as Record<string, unknown>[];
+      return rows.map(rowToReview);
+    },
+
+    getReviewCount(pluginName: string): number {
+      const row = countStmt.get(pluginName) as { count: number };
+      return row.count;
+    },
+  };
+}
diff --git a/src/runner/index.ts b/src/runner/index.ts
new file mode 100644
index 0000000..b85f9da
--- /dev/null
+++ b/src/runner/index.ts
@@ -0,0 +1,67 @@
+import vm from 'node:vm';
+import type { SandboxResult, RunnerService } from '../types.js';
+
+export function createRunner(): RunnerService {
+  async function runInSandbox(
+    code: string,
+    timeoutMs: number,
+    context: Record<string, unknown> = {}
+  ): Promise<SandboxResult> {
+    const startTime = performance.now();
+    const startMemory = process.memoryUsage().heapUsed;
+
+    try {
+      const sandbox: Record<string, unknown> = {
+        ...context,
+        console: {
+          log: (...args: unknown[]) => {
+            sandbox.__output = args.length === 1 ? args[0] : args;
+          },
+        },
+        __output: undefined,
+      };
+
+      vm.createContext(sandbox);
+
+      const script = new vm.Script(code, { filename: 'plugin.js' });
+      const result = script.runInContext(sandbox, { timeout: timeoutMs });
+
+      const duration = performance.now() - startTime;
+      const memoryUsed = Math.max(0, process.memoryUsage().heapUsed - startMemory);
+
+      const output = sandbox.__output !== undefined ? sandbox.__output : result;
+
+      return {
+        success: true,
+        output,
+        duration,
+        memoryUsed,
+      };
+    } catch (err: unknown) {
+      const duration = performance.now() - startTime;
+      const memoryUsed = Math.max(0, process.memoryUsage().heapUsed - startMemory);
+      const errObj = err as Record<string, unknown>;
+      const error = (typeof errObj === 'object' && errObj !== null && 'message' in errObj)
+        ? String(errObj.message)
+        : String(err);
+
+      return {
+        success: false,
+        output: null,
+        duration,
+        memoryUsed,
+        error,
+      };
+    }
+  }
+
+  return {
+    async execute(code: string, context?: Record<string, unknown>): Promise<SandboxResult> {
+      return runInSandbox(code, 5000, context);
+    },
+
+    async executeWithTimeout(code: string, timeoutMs: number, context?: Record<string, unknown>): Promise<SandboxResult> {
+      return runInSandbox(code, timeoutMs, context);
+    },
+  };
+}
diff --git a/tests/deps.test.ts b/tests/deps.test.ts
new file mode 100644
index 0000000..de1a823
--- /dev/null
+++ b/tests/deps.test.ts
@@ -0,0 +1,148 @@
+import { describe, it, expect } from 'vitest';
+import { createDepsService } from '../src/deps/index.js';
+import { createRegistry } from '../src/registry/index.js';
+import type { PluginManifest } from '../src/types.js';
+
+function makeManifest(name: string, deps: Record<string, string> = {}): PluginManifest {
+  return {
+    name,
+    version: '1.0.0',
+    description: `Plugin ${name}`,
+    author: 'tester',
+    dependencies: deps,
+    entryPoint: 'true',
+    permissions: [],
+  };
+}
+
+describe('DependencyGraph', () => {
+  const depsService = createDepsService();
+
+  it('should build a dependency tree', () => {
+    const registry = createRegistry();
+    registry.register(makeManifest('a', { b: '^1.0.0', c: '^1.0.0' }));
+    registry.register(makeManifest('b', { d: '^1.0.0' }));
+    registry.register(makeManifest('c'));
+    registry.register(makeManifest('d'));
+
+    const tree = depsService.buildTree('a', registry);
+    expect(tree.name).toBe('a');
+    expect(tree.dependencies.length).toBe(2);
+    const bNode = tree.dependencies.find(d => d.name === 'b');
+    expect(bNode).toBeDefined();
+    expect(bNode!.dependencies.length).toBe(1);
+    expect(bNode!.dependencies[0].name).toBe('d');
+  });
+
+  it('should handle plugin with no dependencies', () => {
+    const registry = createRegistry();
+    registry.register(makeManifest('solo'));
+
+    const tree = depsService.buildTree('solo', registry);
+    expect(tree.name).toBe('solo');
+    expect(tree.dependencies.length).toBe(0);
+  });
+
+  it('should handle unknown plugins in tree', () => {
+    const registry = createRegistry();
+    const tree = depsService.buildTree('nonexistent', registry);
+    expect(tree.name).toBe('nonexistent');
+    expect(tree.version).toBe('unknown');
+  });
+
+  it('should detect circular dependencies', () => {
+    const registry = createRegistry();
+    registry.register(makeManifest('a', { b: '^1.0.0' }));
+    registry.register(makeManifest('b', { a: '^1.0.0' }));
+
+    const cycles = depsService.detectCycles('a', registry);
+    expect(cycles).not.toBeNull();
+    expect(cycles!.length).toBeGreaterThan(0);
+  });
+
+  it('should return null when no cycles', () => {
+    const registry = createRegistry();
+    registry.register(makeManifest('a', { b: '^1.0.0' }));
+    registry.register(makeManifest('b'));
+
+    const cycles = depsService.detectCycles('a', registry);
+    expect(cycles).toBeNull();
+  });
+
+  it('should detect hasCircularDependency', () => {
+    const registry = createRegistry();
+    registry.register(makeManifest('x', { y: '^1.0.0' }));
+    registry.register(makeManifest('y', { x: '^1.0.0' }));
+
+    expect(depsService.hasCircularDependency('x', registry)).toBe(true);
+  });
+
+  it('should return false for no circular dependency', () => {
+    const registry = createRegistry();
+    registry.register(makeManifest('x', { y: '^1.0.0' }));
+    registry.register(makeManifest('y'));
+
+    expect(depsService.hasCircularDependency('x', registry)).toBe(false);
+  });
+
+  it('should produce topological sort', () => {
+    const registry = createRegistry();
+    registry.register(makeManifest('a', { b: '^1.0.0', c: '^1.0.0' }));
+    registry.register(makeManifest('b', { d: '^1.0.0' }));
+    registry.register(makeManifest('c'));
+    registry.register(makeManifest('d'));
+
+    const sorted = depsService.topologicalSort('a', registry);
+    expect(sorted.indexOf('d')).toBeLessThan(sorted.indexOf('b'));
+    expect(sorted.indexOf('b')).toBeLessThan(sorted.indexOf('a'));
+    expect(sorted.indexOf('c')).toBeLessThan(sorted.indexOf('a'));
+    expect(sorted).toContain('a');
+  });
+
+  it('should throw on topological sort with cycle', () => {
+    const registry = createRegistry();
+    registry.register(makeManifest('a', { b: '^1.0.0' }));
+    registry.register(makeManifest('b', { a: '^1.0.0' }));
+
+    expect(() => depsService.topologicalSort('a', registry)).toThrow('Circular dependency');
+  });
+
+  it('should flatten dependencies', () => {
+    const registry = createRegistry();
+    registry.register(makeManifest('a', { b: '^1.0.0', c: '^1.0.0' }));
+    registry.register(makeManifest('b', { d: '^1.0.0' }));
+    registry.register(makeManifest('c'));
+    registry.register(makeManifest('d'));
+
+    const flat = depsService.flattenDependencies('a', registry);
+    expect(flat).toContain('b');
+    expect(flat).toContain('c');
+    expect(flat).toContain('d');
+    expect(flat).not.toContain('a');
+  });
+
+  it('should handle deep dependency chains', () => {
+    const registry = createRegistry();
+    registry.register(makeManifest('a', { b: '^1.0.0' }));
+    registry.register(makeManifest('b', { c: '^1.0.0' }));
+    registry.register(makeManifest('c', { d: '^1.0.0' }));
+    registry.register(makeManifest('d'));
+
+    const flat = depsService.flattenDependencies('a', registry);
+    expect(flat).toEqual(expect.arrayContaining(['b', 'c', 'd']));
+    expect(flat.length).toBe(3);
+  });
+
+  it('should handle diamond dependencies', () => {
+    const registry = createRegistry();
+    registry.register(makeManifest('a', { b: '^1.0.0', c: '^1.0.0' }));
+    registry.register(makeManifest('b', { d: '^1.0.0' }));
+    registry.register(makeManifest('c', { d: '^1.0.0' }));
+    registry.register(makeManifest('d'));
+
+    const flat = depsService.flattenDependencies('a', registry);
+    expect(flat).toContain('d');
+    // d should only appear once
+    expect(flat.filter(x => x === 'd').length).toBe(1);
+  });
+});
diff --git a/tests/marketplace.test.ts b/tests/marketplace.test.ts
new file mode 100644
index 0000000..569bbca
--- /dev/null
+++ b/tests/marketplace.test.ts
@@ -0,0 +1,116 @@
+import { describe, it, expect } from 'vitest';
+import { createMarketplace } from '../src/index.js';
+import type { PluginManifest } from '../src/types.js';
+
+function makeManifest(overrides: Partial<PluginManifest> = {}): PluginManifest {
+  return {
+    name: 'test-plugin',
+    version: '1.0.0',
+    description: 'A test plugin',
+    author: 'tester',
+    dependencies: {},
+    entryPoint: '2 + 2',
+    permissions: [],
+    ...overrides,
+  };
+}
+
+describe('createMarketplace', () => {
+  it('should expose all services', () => {
+    const mp = createMarketplace();
+    expect(mp.registry).toBeDefined();
+    expect(mp.resolver).toBeDefined();
+    expect(mp.runner).toBeDefined();
+    expect(mp.reviews).toBeDefined();
+    expect(mp.deps).toBeDefined();
+    expect(mp.installPlugin).toBeDefined();
+  });
+
+  describe('installPlugin', () => {
+    it('should install a simple plugin with no dependencies', async () => {
+      const mp = createMarketplace();
+      const manifest = makeManifest({ entryPoint: '40 + 2' });
+      const result = await mp.installPlugin(manifest);
+
+      expect(result.executionResult.success).toBe(true);
+      expect(result.executionResult.output).toBe(42);
+      expect(result.resolvedDependencies).toEqual([]);
+
+      // Plugin should be registered
+      const registered = mp.registry.get('test-plugin');
+      expect(registered).not.toBeNull();
+    });
+
+    it('should install a plugin with dependencies', async () => {
+      const mp = createMarketplace();
+
+      // Register dependency first
+      mp.registry.register(makeManifest({ name: 'dep-a', version: '1.0.0' }));
+      mp.registry.register(makeManifest({ name: 'dep-a', version: '1.5.0' }));
+
+      const manifest = makeManifest({
+        dependencies: { 'dep-a': '^1.0.0' },
+        entryPoint: '"installed"',
+      });
+
+      const result = await mp.installPlugin(manifest);
+      expect(result.executionResult.success).toBe(true);
+      expect(result.resolvedDependencies.length).toBe(1);
+      expect(result.resolvedDependencies[0].name).toBe('dep-a');
+      expect(result.resolvedDependencies[0].version).toBe('1.5.0');
+    });
+
+    it('should reject plugin with missing name', async () => {
+      const mp = createMarketplace();
+      const manifest = makeManifest({ name: '' });
+      await expect(mp.installPlugin(manifest)).rejects.toThrow('name');
+    });
+
+    it('should reject plugin with missing version', async () => {
+      const mp = createMarketplace();
+      const manifest = makeManifest({ version: '' });
+      await expect(mp.installPlugin(manifest)).rejects.toThrow('version');
+    });
+
+    it('should reject plugin with missing entryPoint', async () => {
+      const mp = createMarketplace();
+      const manifest = makeManifest({ entryPoint: '' });
+      await expect(mp.installPlugin(manifest)).rejects.toThrow('entryPoint');
+    });
+
+    it('should reject plugin with circular dependencies', async () => {
+      const mp = createMarketplace();
+
+      // Create circular: a -> b -> a
+      mp.registry.register(makeManifest({
+        name: 'b',
+        version: '1.0.0',
+        dependencies: { 'test-plugin': '^1.0.0' },
+      }));
+
+      const manifest = makeManifest({
+        dependencies: { b: '^1.0.0' },
+      });
+
+      await expect(mp.installPlugin(manifest)).rejects.toThrow('Circular dependency');
+      // Plugin should be removed from registry after circular dep detection
+      expect(mp.registry.get('test-plugin')).toBeNull();
+    });
+
+    it('should handle plugin execution failure', async () => {
+      const mp = createMarketplace();
+      const manifest = makeManifest({ entryPoint: 'throw new Error("fail")' });
+      const result = await mp.installPlugin(manifest);
+      expect(result.executionResult.success).toBe(false);
+      expect(result.executionResult.error).toBe('fail');
+    });
+
+    it('should handle unresolvable dependencies', async () => {
+      const mp = createMarketplace();
+      const manifest = makeManifest({
+        dependencies: { 'nonexistent': '^1.0.0' },
+      });
+      await expect(mp.installPlugin(manifest)).rejects.toThrow();
+    });
+  });
+});
diff --git a/tests/registry.test.ts b/tests/registry.test.ts
new file mode 100644
index 0000000..304b270
--- /dev/null
+++ b/tests/registry.test.ts
@@ -0,0 +1,125 @@
+import { describe, it, expect, beforeEach } from 'vitest';
+import { createRegistry } from '../src/registry/index.js';
+import type { PluginManifest, RegistryService } from '../src/types.js';
+
+function makeManifest(overrides: Partial<PluginManifest> = {}): PluginManifest {
+  return {
+    name: 'test-plugin',
+    version: '1.0.0',
+    description: 'A test plugin',
+    author: 'tester',
+    dependencies: {},
+    entryPoint: 'console.log("hello")',
+    permissions: ['read'],
+    ...overrides,
+  };
+}
+
+describe('PluginRegistry', () => {
+  let registry: RegistryService;
+
+  beforeEach(() => {
+    registry = createRegistry();
+  });
+
+  it('should register and retrieve a plugin', () => {
+    const manifest = makeManifest();
+    registry.register(manifest);
+    const result = registry.get('test-plugin');
+    expect(result).not.toBeNull();
+    expect(result!.name).toBe('test-plugin');
+    expect(result!.version).toBe('1.0.0');
+  });
+
+  it('should return null for non-existent plugin', () => {
+    expect(registry.get('nope')).toBeNull();
+  });
+
+  it('should get a specific version', () => {
+    registry.register(makeManifest({ version: '1.0.0' }));
+    registry.register(makeManifest({ version: '2.0.0' }));
+    const v1 = registry.getVersion('test-plugin', '1.0.0');
+    expect(v1).not.toBeNull();
+    expect(v1!.version).toBe('1.0.0');
+    const v2 = registry.getVersion('test-plugin', '2.0.0');
+    expect(v2).not.toBeNull();
+    expect(v2!.version).toBe('2.0.0');
+  });
+
+  it('should return null for non-existent version', () => {
+    registry.register(makeManifest());
+    expect(registry.getVersion('test-plugin', '9.9.9')).toBeNull();
+  });
+
+  it('should list all plugins', () => {
+    registry.register(makeManifest({ name: 'a', version: '1.0.0' }));
+    registry.register(makeManifest({ name: 'b', version: '1.0.0' }));
+    const all = registry.list();
+    expect(all.length).toBe(2);
+  });
+
+  it('should search plugins by name, description, or author', () => {
+    registry.register(makeManifest({ name: 'auth-plugin', description: 'Handles authentication' }));
+    registry.register(makeManifest({ name: 'logger', description: 'Logging utility' }));
+
+    expect(registry.search('auth').length).toBe(1);
+    expect(registry.search('Logging').length).toBe(1);
+    expect(registry.search('tester').length).toBe(2); // author matches both
+  });
+
+  it('should remove a specific version', () => {
+    registry.register(makeManifest({ version: '1.0.0' }));
+    registry.register(makeManifest({ version: '2.0.0' }));
+    const removed = registry.remove('test-plugin', '1.0.0');
+    expect(removed).toBe(true);
+    expect(registry.getVersion('test-plugin', '1.0.0')).toBeNull();
+    expect(registry.getVersion('test-plugin', '2.0.0')).not.toBeNull();
+  });
+
+  it('should return false when removing non-existent plugin', () => {
+    expect(registry.remove('nope', '1.0.0')).toBe(false);
+  });
+
+  it('should list versions of a plugin', () => {
+    registry.register(makeManifest({ version: '1.0.0' }));
+    registry.register(makeManifest({ version: '2.0.0' }));
+    registry.register(makeManifest({ version: '1.5.0' }));
+    const versions = registry.listVersions('test-plugin');
+    expect(versions).toContain('1.0.0');
+    expect(versions).toContain('1.5.0');
+    expect(versions).toContain('2.0.0');
+    expect(versions.length).toBe(3);
+  });
+
+  it('should update a plugin', () => {
+    registry.register(makeManifest());
+    registry.update('test-plugin', '1.0.0', { description: 'Updated!' });
+    const updated = registry.getVersion('test-plugin', '1.0.0');
+    expect(updated!.description).toBe('Updated!');
+  });
+
+  it('should throw when updating non-existent plugin', () => {
+    expect(() => registry.update('nope', '1.0.0', { description: 'x' })).toThrow();
+  });
+
+  it('should handle multiple plugins with multiple versions', () => {
+    registry.register(makeManifest({ name: 'a', version: '1.0.0' }));
+    registry.register(makeManifest({ name: 'a', version: '2.0.0' }));
+    registry.register(makeManifest({ name: 'b', version: '1.0.0' }));
+    expect(registry.list().length).toBe(3);
+    expect(registry.listVersions('a').length).toBe(2);
+    expect(registry.listVersions('b').length).toBe(1);
+  });
+
+  it('should store and retrieve dependencies correctly', () => {
+    registry.register(makeManifest({ dependencies: { 'dep-a': '^1.0.0', 'dep-b': '~2.0.0' } }));
+    const plugin = registry.get('test-plugin');
+    expect(plugin!.dependencies).toEqual({ 'dep-a': '^1.0.0', 'dep-b': '~2.0.0' });
+  });
+
+  it('should store and retrieve permissions correctly', () => {
+    registry.register(makeManifest({ permissions: ['read', 'write', 'network'] }));
+    const plugin = registry.get('test-plugin');
+    expect(plugin!.permissions).toEqual(['read', 'write', 'network']);
+  });
+});
diff --git a/tests/resolver.test.ts b/tests/resolver.test.ts
new file mode 100644
index 0000000..2ab1bea
--- /dev/null
+++ b/tests/resolver.test.ts
@@ -0,0 +1,83 @@
+import { describe, it, expect } from 'vitest';
+import { createResolver } from '../src/resolver/index.js';
+
+describe('VersionResolver', () => {
+  const resolver = createResolver();
+
+  describe('resolve', () => {
+    it('should resolve constraints against available versions', () => {
+      const constraints = [
+        { name: 'foo', range: '^1.0.0' },
+        { name: 'bar', range: '~2.1.0' },
+      ];
+      const available = {
+        foo: ['1.0.0', '1.2.0', '1.5.0', '2.0.0'],
+        bar: ['2.0.0', '2.1.0', '2.1.5', '2.2.0'],
+      };
+      const result = resolver.resolve(constraints, available);
+      expect(result.length).toBe(2);
+
+      const foo = result.find(r => r.name === 'foo');
+      expect(foo).toBeDefined();
+      expect(foo!.version).toBe('1.5.0'); // highest matching ^1.0.0
+      expect(foo!.satisfies).toBe('^1.0.0');
+
+      const bar = result.find(r => r.name === 'bar');
+      expect(bar).toBeDefined();
+      expect(bar!.version).toBe('2.1.5'); // highest matching ~2.1.0
+    });
+
+    it('should throw when no versions available', () => {
+      expect(() =>
+        resolver.resolve([{ name: 'missing', range: '^1.0.0' }], {})
+      ).toThrow('No versions available for missing');
+    });
+
+    it('should throw when no version satisfies constraint', () => {
+      expect(() =>
+        resolver.resolve(
+          [{ name: 'foo', range: '^3.0.0' }],
+          { foo: ['1.0.0', '2.0.0'] }
+        )
+      ).toThrow('No version of foo satisfies ^3.0.0');
+    });
+  });
+
+  describe('satisfies', () => {
+    it('should return true for matching version', () => {
+      expect(resolver.satisfies('1.5.0', '^1.0.0')).toBe(true);
+    });
+
+    it('should return false for non-matching version', () => {
+      expect(resolver.satisfies('2.0.0', '^1.0.0')).toBe(false);
+    });
+
+    it('should handle tilde ranges', () => {
+      expect(resolver.satisfies('1.2.3', '~1.2.0')).toBe(true);
+      expect(resolver.satisfies('1.3.0', '~1.2.0')).toBe(false);
+    });
+  });
+
+  describe('maxSatisfying', () => {
+    it('should find the highest matching version', () => {
+      expect(resolver.maxSatisfying(['1.0.0', '1.5.0', '2.0.0'], '^1.0.0')).toBe('1.5.0');
+    });
+
+    it('should return null when nothing matches', () => {
+      expect(resolver.maxSatisfying(['1.0.0'], '^2.0.0')).toBeNull();
+    });
+  });
+
+  describe('validRange', () => {
+    it('should return true for valid ranges', () => {
+      expect(resolver.validRange('^1.0.0')).toBe(true);
+      expect(resolver.validRange('~2.0.0')).toBe(true);
+      expect(resolver.validRange('>=1.0.0 <3.0.0')).toBe(true);
+      expect(resolver.validRange('*')).toBe(true);
+    });
+
+    it('should return false for invalid ranges', () => {
+      expect(resolver.validRange('not-a-range')).toBe(false);
+    });
+  });
+});
diff --git a/tests/reviews.test.ts b/tests/reviews.test.ts
new file mode 100644
index 0000000..18c9600
--- /dev/null
+++ b/tests/reviews.test.ts
@@ -0,0 +1,106 @@
+import { describe, it, expect, beforeEach } from 'vitest';
+import { createReviewService } from '../src/reviews/index.js';
+import type { ReviewService } from '../src/types.js';
+
+describe('ReviewService', () => {
+  let reviews: ReviewService;
+
+  beforeEach(() => {
+    reviews = createReviewService();
+  });
+
+  it('should add a review', () => {
+    const review = reviews.addReview({
+      pluginName: 'test-plugin',
+      pluginVersion: '1.0.0',
+      userId: 'user1',
+      rating: 5,
+      comment: 'Great plugin!',
+    });
+    expect(review.id).toBeDefined();
+    expect(review.pluginName).toBe('test-plugin');
+    expect(review.rating).toBe(5);
+    expect(review.flagged).toBe(false);
+    expect(review.createdAt).toBeDefined();
+  });
+
+  it('should get reviews by plugin', () => {
+    reviews.addReview({ pluginName: 'a', pluginVersion: '1.0.0', userId: 'u1', rating: 4, comment: 'ok' });
+    reviews.addReview({ pluginName: 'a', pluginVersion: '1.0.0', userId: 'u2', rating: 5, comment: 'great' });
+    reviews.addReview({ pluginName: 'b', pluginVersion: '1.0.0', userId: 'u1', rating: 3, comment: 'meh' });
+
+    const aReviews = reviews.getReviews('a');
+    expect(aReviews.length).toBe(2);
+    const bReviews = reviews.getReviews('b');
+    expect(bReviews.length).toBe(1);
+  });
+
+  it('should calculate average rating excluding flagged', () => {
+    reviews.addReview({ pluginName: 'p', pluginVersion: '1.0.0', userId: 'u1', rating: 4, comment: '' });
+    reviews.addReview({ pluginName: 'p', pluginVersion: '1.0.0', userId: 'u2', rating: 2, comment: '' });
+    const bad = reviews.addReview({ pluginName: 'p', pluginVersion: '1.0.0', userId: 'u3', rating: 1, comment: 'spam' });
+
+    // Average of 4 + 2 + 1 = 7/3 ~2.33
+    expect(reviews.getAverageRating('p')).toBeCloseTo(7 / 3, 1);
+
+    // Flag the spam review
+    reviews.flagReview(bad.id);
+
+    // Average should now be (4 + 2) / 2 = 3
+    expect(reviews.getAverageRating('p')).toBe(3);
+  });
+
+  it('should return 0 average for plugin with no reviews', () => {
+    expect(reviews.getAverageRating('nonexistent')).toBe(0);
+  });
+
+  it('should flag a review', () => {
+    const review = reviews.addReview({
+      pluginName: 'p', pluginVersion: '1.0.0', userId: 'u1', rating: 1, comment: 'bad',
+    });
+    reviews.flagReview(review.id);
+    const flagged = reviews.getFlaggedReviews();
+    expect(flagged.length).toBe(1);
+    expect(flagged[0].id).toBe(review.id);
+    expect(flagged[0].flagged).toBe(true);
+  });
+
+  it('should get flagged reviews', () => {
+    const r1 = reviews.addReview({ pluginName: 'p', pluginVersion: '1.0.0', userId: 'u1', rating: 1, comment: 'spam' });
+    reviews.addReview({ pluginName: 'p', pluginVersion: '1.0.0', userId: 'u2', rating: 5, comment: 'good' });
+    reviews.flagReview(r1.id);
+
+    const flagged = reviews.getFlaggedReviews();
+    expect(flagged.length).toBe(1);
+  });
+
+  it('should remove a review', () => {
+    const review = reviews.addReview({
+      pluginName: 'p', pluginVersion: '1.0.0', userId: 'u1', rating: 3, comment: 'ok',
+    });
+    expect(reviews.removeReview(review.id)).toBe(true);
+    expect(reviews.getReviews('p').length).toBe(0);
+  });
+
+  it('should return false when removing non-existent review', () => {
+    expect(reviews.removeReview(999)).toBe(false);
+  });
+
+  it('should get reviews by user', () => {
+    reviews.addReview({ pluginName: 'a', pluginVersion: '1.0.0', userId: 'user1', rating: 5, comment: '' });
+    reviews.addReview({ pluginName: 'b', pluginVersion: '1.0.0', userId: 'user1', rating: 4, comment: '' });
+    reviews.addReview({ pluginName: 'a', pluginVersion: '1.0.0', userId: 'user2', rating: 3, comment: '' });
+
+    const user1Reviews = reviews.getReviewsByUser('user1');
+    expect(user1Reviews.length).toBe(2);
+    const user2Reviews = reviews.getReviewsByUser('user2');
+    expect(user2Reviews.length).toBe(1);
+  });
+
+  it('should count reviews for a plugin', () => {
+    reviews.addReview({ pluginName: 'p', pluginVersion: '1.0.0', userId: 'u1', rating: 5, comment: '' });
+    reviews.addReview({ pluginName: 'p', pluginVersion: '1.0.0', userId: 'u2', rating: 4, comment: '' });
+    expect(reviews.getReviewCount('p')).toBe(2);
+    expect(reviews.getReviewCount('other')).toBe(0);
+  });
+});
diff --git a/tests/runner.test.ts b/tests/runner.test.ts
new file mode 100644
index 0000000..9a677f1
--- /dev/null
+++ b/tests/runner.test.ts
@@ -0,0 +1,75 @@
+import { describe, it, expect } from 'vitest';
+import { createRunner } from '../src/runner/index.js';
+
+describe('SandboxedRunner', () => {
+  const runner = createRunner();
+
+  it('should execute simple code and return result', async () => {
+    const result = await runner.execute('2 + 2');
+    expect(result.success).toBe(true);
+    expect(result.output).toBe(4);
+    expect(result.duration).toBeGreaterThanOrEqual(0);
+    expect(result.memoryUsed).toBeDefined();
+  });
+
+  it('should capture console.log output', async () => {
+    const result = await runner.execute('console.log("hello world")');
+    expect(result.success).toBe(true);
+    expect(result.output).toBe('hello world');
+  });
+
+  it('should pass context variables into sandbox', async () => {
+    const result = await runner.execute('x + y', { x: 10, y: 20 });
+    expect(result.success).toBe(true);
+    expect(result.output).toBe(30);
+  });
+
+  it('should handle errors gracefully', async () => {
+    const result = await runner.execute('throw new Error("boom")');
+    expect(result.success).toBe(false);
+    expect(result.error).toBe('boom');
+    expect(result.output).toBeNull();
+  });
+
+  it('should handle syntax errors', async () => {
+    const result = await runner.execute('function {{{ invalid');
+    expect(result.success).toBe(false);
+    expect(result.error).toBeDefined();
+  });
+
+  it('should enforce timeouts', async () => {
+    const result = await runner.executeWithTimeout('while(true) {}', 100);
+    expect(result.success).toBe(false);
+    expect(result.error).toBeDefined();
+  });
+
+  it('should handle undefined result', async () => {
+    const result = await runner.execute('undefined');
+    expect(result.success).toBe(true);
+  });
+
+  it('should isolate executions', async () => {
+    await runner.execute('var isolated = 42');
+    const result = await runner.execute('typeof isolated');
+    expect(result.success).toBe(true);
+    expect(result.output).toBe('undefined');
+  });
+
+  it('should not have access to Node.js APIs', async () => {
+    const result = await runner.execute('typeof require');
+    expect(result.success).toBe(true);
+    expect(result.output).toBe('undefined');
+  });
+
+  it('should handle complex return values', async () => {
+    const result = await runner.execute('({ a: 1, b: [2, 3] })');
+    expect(result.success).toBe(true);
+    expect(result.output).toEqual({ a: 1, b: [2, 3] });
+  });
+
+  it('should executeWithTimeout with sufficient time', async () => {
+    const result = await runner.executeWithTimeout('1 + 1', 5000);
+    expect(result.success).toBe(true);
+    expect(result.output).toBe(2);
+  });
+});
