diff --git a/.gemini-output.json b/.gemini-output.json
new file mode 100644
index 0000000..8ab5a3a
--- /dev/null
+++ b/.gemini-output.json
@@ -0,0 +1,134 @@
+{
+  "session_id": "cafbac5d-a7c1-4dd2-b015-66b80ac863a6",
+  "response": "I have implemented the 8 plugins for the SSG toolkit, ensuring they adhere to the specified requirements and dependency structure. All 60 new tests and 15 existing core tests passed, and the codebase successfully compiles and passes linting.\n\n- **markdown-ext**: Implemented Markdown to HTML conversion with support for footnotes and admonition containers using `marked`.\n- **asset-pipeline**: Implemented rewriting of relative asset URLs and generation of an asset manifest.\n- **syntax-highlight**: Implemented automatic addition of language classes and data attributes to code blocks.\n- **taxonomy**: Implemented tag index building and generation of tag-specific listing pages.\n- **rss-feed**: Implemented RSS 2.0 feed generation, utilizing data from `markdown-ext` and `taxonomy`.\n- **search-index**: Implemented a JSON search index generator that strips HTML while preserving searchable text.\n- **sitemap**: Implemented XML sitemap generation including content, taxonomy, and feed URLs.\n- **dev-server**: Implemented development server configuration generation, integrating asset and search index paths.\n\nAll plugins export the required `createXxxPlugin()` factory functions and implement the `Plugin` interface correctly.",
+  "stats": {
+    "models": {
+      "gemini-2.5-flash-lite": {
+        "api": {
+          "totalRequests": 1,
+          "totalErrors": 0,
+          "totalLatencyMs": 2280
+        },
+        "tokens": {
+          "input": 1466,
+          "prompt": 1466,
+          "candidates": 98,
+          "total": 1916,
+          "cached": 0,
+          "thoughts": 352,
+          "tool": 0
+        }
+      },
+      "gemini-3-flash-preview": {
+        "api": {
+          "totalRequests": 37,
+          "totalErrors": 1,
+          "totalLatencyMs": 120268
+        },
+        "tokens": {
+          "input": 115913,
+          "prompt": 623753,
+          "candidates": 4843,
+          "total": 636136,
+          "cached": 507840,
+          "thoughts": 7540,
+          "tool": 0
+        }
+      },
+      "gemini-2.5-flash": {
+        "api": {
+          "totalRequests": 1,
+          "totalErrors": 0,
+          "totalLatencyMs": 2697
+        },
+        "tokens": {
+          "input": 9940,
+          "prompt": 9940,
+          "candidates": 102,
+          "total": 10252,
+          "cached": 0,
+          "thoughts": 210,
+          "tool": 0
+        }
+      }
+    },
+    "tools": {
+      "totalCalls": 42,
+      "totalSuccess": 42,
+      "totalFail": 0,
+      "totalDurationMs": 333650,
+      "totalDecisions": {
+        "accept": 42,
+        "reject": 0,
+        "modify": 0,
+        "auto_accept": 0
+      },
+      "byName": {
+        "list_directory": {
+          "count": 2,
+          "success": 2,
+          "fail": 0,
+          "durationMs": 11,
+          "decisions": {
+            "accept": 2,
+            "reject": 0,
+            "modify": 0,
+            "auto_accept": 0
+          }
+        },
+        "read_file": {
+          "count": 11,
+          "success": 11,
+          "fail": 0,
+          "durationMs": 31,
+          "decisions": {
+            "accept": 11,
+            "reject": 0,
+            "modify": 0,
+            "auto_accept": 0
+          }
+        },
+        "write_file": {
+          "count": 8,
+          "success": 8,
+          "fail": 0,
+          "durationMs": 19,
+          "decisions": {
+            "accept": 8,
+            "reject": 0,
+            "modify": 0,
+            "auto_accept": 0
+          }
+        },
+        "run_shell_command": {
+          "count": 18,
+          "success": 18,
+          "fail": 0,
+          "durationMs": 333579,
+          "decisions": {
+            "accept": 18,
+            "reject": 0,
+            "modify": 0,
+            "auto_accept": 0
+          }
+        },
+        "replace": {
+          "count": 3,
+          "success": 3,
+          "fail": 0,
+          "durationMs": 10,
+          "decisions": {
+            "accept": 3,
+            "reject": 0,
+            "modify": 0,
+            "auto_accept": 0
+          }
+        }
+      }
+    },
+    "files": {
+      "totalLinesAdded": 307,
+      "totalLinesRemoved": 15
+    }
+  }
+}
\ No newline at end of file
diff --git a/.thunderdome-metrics.json b/.thunderdome-metrics.json
new file mode 100644
index 0000000..e886fcc
--- /dev/null
+++ b/.thunderdome-metrics.json
@@ -0,0 +1,10 @@
+{
+  "input_tokens": 127319,
+  "output_tokens": 5043,
+  "cache_read_tokens": 507840,
+  "cache_creation_tokens": 0,
+  "thought_tokens": 8102,
+  "turns": 42,
+  "total_cost_usd": -0.223303,
+  "note": "google-one-oauth-no-actual-cost"
+}
\ No newline at end of file
diff --git a/.thunderdome-stderr.log b/.thunderdome-stderr.log
new file mode 100644
index 0000000..620eecb
--- /dev/null
+++ b/.thunderdome-stderr.log
@@ -0,0 +1,6 @@
+YOLO mode is enabled. All tool calls will be automatically approved.
+Loaded cached credentials.
+YOLO mode is enabled. All tool calls will be automatically approved.
+Hook registry initialized with 0 hook entries
+missing pgrep output
+Attempt 1 failed: You have exhausted your capacity on this model. Your quota will reset after 0s.. Retrying after 225.405646ms...
diff --git a/package-lock.json b/package-lock.json
index 1ad5780..9aa4811 100644
--- a/package-lock.json
+++ b/package-lock.json
@@ -1098,7 +1098,6 @@
       "integrity": "sha512-4Z+L8I2OqhZV8qA132M4wNL30ypZGYOQVBfMgxDH/K5UX0PNqTu1c6za9ST5r9+tavvHiTWmBnKzpCJ/GlVFtg==",
       "dev": true,
       "license": "BSD-2-Clause",
-      "peer": true,
       "dependencies": {
         "@typescript-eslint/scope-manager": "7.18.0",
         "@typescript-eslint/types": "7.18.0",
@@ -1391,7 +1390,6 @@
       "integrity": "sha512-NZyJarBfL7nWwIq+FDL6Zp/yHEhePMNnnJ0y3qfieCrmNvYct8uvtiV41UvlSe6apAfk0fY1FbWx+NwfmpvtTg==",
       "dev": true,
       "license": "MIT",
-      "peer": true,
       "bin": {
         "acorn": "bin/acorn"
       },
@@ -1917,7 +1915,6 @@
       "deprecated": "This version is no longer supported. Please see https://eslint.org/version-support for other options.",
       "dev": true,
       "license": "MIT",
-      "peer": true,
       "dependencies": {
         "@eslint-community/eslint-utils": "^4.2.0",
         "@eslint-community/regexpp": "^4.6.1",
@@ -3765,7 +3762,6 @@
       "integrity": "sha512-jl1vZzPDinLr9eUt3J/t7V6FgNEw9QjvBPdysz9KfQDD41fQrC2Y4vKQdiaUpFT4bXlb1RHhLpp8wtm6M5TgSw==",
       "dev": true,
       "license": "Apache-2.0",
-      "peer": true,
       "bin": {
         "tsc": "bin/tsc",
         "tsserver": "bin/tsserver"
@@ -3814,7 +3810,6 @@
       "integrity": "sha512-o5a9xKjbtuhY6Bi5S3+HvbRERmouabWbyUcpXXUA1u+GNUKoROi9byOJ8M0nHbHYHkYICiMlqxkg1KkYmm25Sw==",
       "dev": true,
       "license": "MIT",
-      "peer": true,
       "dependencies": {
         "esbuild": "^0.21.3",
         "postcss": "^8.4.43",
diff --git a/src/plugins/asset-pipeline.ts b/src/plugins/asset-pipeline.ts
new file mode 100644
index 0000000..6b75b1c
--- /dev/null
+++ b/src/plugins/asset-pipeline.ts
@@ -0,0 +1,34 @@
+import { Plugin, ContentFile, BuildContext } from '../core/types.js';
+
+export function createAssetPipelinePlugin(): Plugin {
+  return {
+    name: 'asset-pipeline',
+    version: '1.0.0',
+    dependencies: [],
+    hooks: {
+      transformContent: async (file: ContentFile, ctx: BuildContext): Promise<ContentFile> => {
+        let content = file.content;
+        
+        let manifest = ctx.data.get('asset-manifest') as { assets: string[] };
+        if (!manifest) {
+          manifest = { assets: [] };
+          ctx.data.set('asset-manifest', manifest);
+        }
+        
+        const assetsSet = new Set(manifest.assets);
+
+        content = content.replace(/(src|href)="(\.\/([^"]+))"/g, (_match, attr, _fullUrl, assetName) => {
+          assetsSet.add(assetName);
+          return `${attr}="/assets/${assetName}"`;
+        });
+
+        manifest.assets = Array.from(assetsSet);
+
+        return {
+          ...file,
+          content,
+        };
+      }
+    }
+  };
+}
diff --git a/src/plugins/dev-server.ts b/src/plugins/dev-server.ts
new file mode 100644
index 0000000..b4c119c
--- /dev/null
+++ b/src/plugins/dev-server.ts
@@ -0,0 +1,38 @@
+import { Plugin, BuildContext } from '../core/types.js';
+
+export function createDevServerPlugin(): Plugin {
+  return {
+    name: 'dev-server',
+    version: '1.0.0',
+    dependencies: ['asset-pipeline', 'search-index'],
+    hooks: {
+      afterBuild: async (ctx: BuildContext): Promise<void> => {
+        const assetManifest = ctx.data.get('asset-manifest') as { assets: string[] } || { assets: [] };
+        const assetPaths = assetManifest.assets;
+        
+        const routes: { path: string, handler: 'asset' | 'static' }[] = [];
+        
+        // Asset routes
+        for (const asset of assetPaths) {
+          routes.push({ path: `/assets/${asset}`, handler: 'asset' });
+        }
+        
+        // Content routes
+        for (const path of ctx.output.keys()) {
+          if (path.endsWith('.html')) {
+            routes.push({ path: `/${path}`, handler: 'static' });
+          }
+        }
+        
+        const config = {
+          port: 3000,
+          routes,
+          assetPaths,
+          searchIndexPath: '/search-index.json',
+        };
+        
+        ctx.data.set('dev-server-config', config);
+      }
+    }
+  };
+}
diff --git a/src/plugins/markdown-ext.ts b/src/plugins/markdown-ext.ts
new file mode 100644
index 0000000..4645079
--- /dev/null
+++ b/src/plugins/markdown-ext.ts
@@ -0,0 +1,56 @@
+import { marked } from 'marked';
+import { Plugin, ContentFile, BuildContext } from '../core/types.js';
+
+export function createMarkdownExtPlugin(): Plugin {
+  return {
+    name: 'markdown-ext',
+    version: '1.0.0',
+    dependencies: [],
+    hooks: {
+      transformContent: async (file: ContentFile, _ctx: BuildContext): Promise<ContentFile> => {
+        let content = file.content;
+
+        // Handle admonitions :::note etc
+        content = content.replace(/:::(note|warning|tip)\n([\s\S]*?)\n:::/g, (_match, type, inner) => {
+          return `<div class="admonition admonition-${type}">\n${inner}\n</div>`;
+        });
+
+        // Extract footnotes [^1]: content
+        const footnotes: { id: string, text: string }[] = [];
+        const footnoteDefRegex = /^\[\^([^\]]+)\]: (.*)$/gm;
+        content = content.replace(footnoteDefRegex, (_match, id, text) => {
+          footnotes.push({ id, text });
+          return '';
+        });
+
+        // Replace footnote references [^1]
+        // We do this before marked so it's treated as HTML or just kept as is
+        content = content.replace(/\[\^([^\]]+)\]/g, (match, id) => {
+          const index = footnotes.findIndex(f => f.id === id);
+          if (index !== -1) {
+            return `<sup><a href="#fn-${id}">${index + 1}</a></sup>`;
+          }
+          return match;
+        });
+
+        // Convert to HTML
+        let html = await marked.parse(content);
+
+        // Append footnotes section if any
+        if (footnotes.length > 0) {
+          let footnotesHtml = '\n<section class="footnotes">\n<ol>\n';
+          for (const fn of footnotes) {
+            footnotesHtml += `<li id="fn-${fn.id}">${fn.text}</li>\n`;
+          }
+          footnotesHtml += '</ol>\n</section>';
+          html += footnotesHtml;
+        }
+
+        return {
+          ...file,
+          content: html.trim(),
+        };
+      }
+    }
+  };
+}
diff --git a/src/plugins/rss-feed.ts b/src/plugins/rss-feed.ts
new file mode 100644
index 0000000..2c6f18a
--- /dev/null
+++ b/src/plugins/rss-feed.ts
@@ -0,0 +1,61 @@
+import { Plugin, BuildContext } from '../core/types.js';
+
+export function createRssFeedPlugin(): Plugin {
+  return {
+    name: 'rss-feed',
+    version: '1.0.0',
+    dependencies: ['markdown-ext', 'taxonomy'],
+    hooks: {
+      afterBuild: async (ctx: BuildContext): Promise<void> => {
+        const { config, files } = ctx;
+        
+        const sortedFiles = [...files].sort((a, b) => {
+          if (a.date && b.date) {
+            return new Date(b.date).getTime() - new Date(a.date).getTime();
+          }
+          if (a.date) return -1;
+          if (b.date) return 1;
+          return 0;
+        });
+
+        let itemsHtml = '';
+        for (const file of sortedFiles) {
+          const url = `${config.baseUrl}/${file.slug}.html`;
+          itemsHtml += `    <item>
+`;
+          itemsHtml += `      <title>${file.title}</title>
+`;
+          itemsHtml += `      <link>${url}</link>
+`;
+          itemsHtml += `      <guid>${url}</guid>
+`;
+          if (file.date) {
+            itemsHtml += `      <pubDate>${new Date(file.date).toUTCString()}</pubDate>
+`;
+          }
+          itemsHtml += `      <description><![CDATA[${file.content}]]></description>
+`;
+          if (file.tags) {
+            for (const tag of file.tags) {
+              itemsHtml += `      <category>${tag.toLowerCase()}</category>
+`;
+            }
+          }
+          itemsHtml += `    </item>
+`;
+        }
+
+        const rss = `<?xml version="1.0" encoding="UTF-8" ?>
+<rss version="2.0">
+  <channel>
+    <title>${config.title}</title>
+    <link>${config.baseUrl}</link>
+    <description>${config.title} RSS Feed</description>
+${itemsHtml}  </channel>
+</rss>`;
+
+        ctx.output.set('feed.xml', rss);
+      }
+    }
+  };
+}
diff --git a/src/plugins/search-index.ts b/src/plugins/search-index.ts
new file mode 100644
index 0000000..d9977c8
--- /dev/null
+++ b/src/plugins/search-index.ts
@@ -0,0 +1,29 @@
+import { Plugin, BuildContext } from '../core/types.js';
+
+export function createSearchIndexPlugin(): Plugin {
+  return {
+    name: 'search-index',
+    version: '1.0.0',
+    dependencies: ['markdown-ext', 'syntax-highlight'],
+    hooks: {
+      afterBuild: async (ctx: BuildContext): Promise<void> => {
+        const index = ctx.files.map(file => {
+          // Strip HTML tags and normalize whitespace
+          const strippedContent = file.content
+            .replace(/<[^>]*>/g, ' ')
+            .replace(/\s+/g, ' ')
+            .trim();
+          
+          return {
+            slug: file.slug,
+            title: file.title,
+            content: strippedContent,
+            tags: file.tags,
+          };
+        });
+
+        ctx.output.set('search-index.json', JSON.stringify(index, null, 2));
+      }
+    }
+  };
+}
diff --git a/src/plugins/sitemap.ts b/src/plugins/sitemap.ts
new file mode 100644
index 0000000..8ce9fe1
--- /dev/null
+++ b/src/plugins/sitemap.ts
@@ -0,0 +1,31 @@
+import { Plugin, BuildContext } from '../core/types.js';
+
+export function createSitemapPlugin(): Plugin {
+  return {
+    name: 'sitemap',
+    version: '1.0.0',
+    dependencies: ['taxonomy', 'rss-feed'],
+    hooks: {
+      afterBuild: async (ctx: BuildContext): Promise<void> => {
+        const { config, output } = ctx;
+        let urlsHtml = '';
+
+        for (const path of output.keys()) {
+          if (path.endsWith('.html') || path === 'feed.xml') {
+            const url = `${config.baseUrl}/${path}`;
+            urlsHtml += `  <url>
+    <loc>${url}</loc>
+  </url>
+`;
+          }
+        }
+
+        const sitemap = `<?xml version="1.0" encoding="UTF-8"?>
+<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
+${urlsHtml}</urlset>`;
+
+        ctx.output.set('sitemap.xml', sitemap);
+      }
+    }
+  };
+}
diff --git a/src/plugins/syntax-highlight.ts b/src/plugins/syntax-highlight.ts
new file mode 100644
index 0000000..f22bb28
--- /dev/null
+++ b/src/plugins/syntax-highlight.ts
@@ -0,0 +1,24 @@
+import { Plugin, ContentFile, BuildContext } from '../core/types.js';
+
+export function createSyntaxHighlightPlugin(): Plugin {
+  return {
+    name: 'syntax-highlight',
+    version: '1.0.0',
+    dependencies: [],
+    hooks: {
+      transformContent: async (file: ContentFile, _ctx: BuildContext): Promise<ContentFile> => {
+        let content = file.content;
+
+        // Match <pre><code class="language-xxx">...</code></pre>
+        content = content.replace(/<pre><code class="language-([^"]+)">([\s\S]*?)<\/code><\/pre>/g, (_match, lang, code) => {
+          return `<pre data-language="${lang}"><code class="language-${lang} highlighted">${code}</code></pre>`;
+        });
+
+        return {
+          ...file,
+          content,
+        };
+      }
+    }
+  };
+}
diff --git a/src/plugins/taxonomy.ts b/src/plugins/taxonomy.ts
new file mode 100644
index 0000000..372ea12
--- /dev/null
+++ b/src/plugins/taxonomy.ts
@@ -0,0 +1,42 @@
+import { Plugin, ContentFile, BuildContext } from '../core/types.js';
+
+export function createTaxonomyPlugin(): Plugin {
+  return {
+    name: 'taxonomy',
+    version: '1.0.0',
+    dependencies: [],
+    hooks: {
+      beforeBuild: async (ctx: BuildContext): Promise<void> => {
+        const tagMap = new Map<string, ContentFile[]>();
+        for (const file of ctx.files) {
+          if (file.tags) {
+            for (const tag of file.tags) {
+              const normalizedTag = tag.toLowerCase();
+              if (!tagMap.has(normalizedTag)) {
+                tagMap.set(normalizedTag, []);
+              }
+              tagMap.get(normalizedTag)!.push(file);
+            }
+          }
+        }
+        ctx.data.set('taxonomy-tags', tagMap);
+      },
+      afterBuild: async (ctx: BuildContext): Promise<void> => {
+        const tagMap = ctx.data.get('taxonomy-tags') as Map<string, ContentFile[]>;
+        if (!tagMap) return;
+
+        for (const [tag, files] of tagMap.entries()) {
+          let html = `<h1>Tag: ${tag}</h1>
+<ul>
+`;
+          for (const file of files) {
+            html += `  <li><a href="/${file.slug}.html">${file.title}</a></li>
+`;
+          }
+          html += '</ul>';
+          ctx.output.set(`tags/${tag}.html`, html);
+        }
+      }
+    }
+  };
+}
