diff --git a/.thunderdome-metrics.json b/.thunderdome-metrics.json
new file mode 100644
index 0000000..6fe01a7
--- /dev/null
+++ b/.thunderdome-metrics.json
@@ -0,0 +1,160 @@
+{
+  "input_tokens": 179,
+  "output_tokens": 105244,
+  "cache_read_tokens": 6597325,
+  "cache_creation_tokens": 361280,
+  "turns": 244,
+  "tools_used": [
+    "Read",
+    "Glob",
+    "TodoWrite",
+    "Write",
+    "Edit",
+    "Bash"
+  ],
+  "duration_ms": 1020000,
+  "total_cost_usd": 8.27,
+  "gastown_meta": {
+    "strategy": "parallel",
+    "polecat_count": 4,
+    "roles": {
+      "mayor": {
+        "input_tokens": 3,
+        "output_tokens": 1674,
+        "cache_read_tokens": 7687,
+        "cache_creation_tokens": 1041,
+        "turns": 1,
+        "tools_used": [],
+        "duration_ms": 30868,
+        "total_cost_usd": 0.05221475
+      },
+      "polecat-0": {
+        "input_tokens": 29,
+        "output_tokens": 11989,
+        "cache_read_tokens": 735437,
+        "cache_creation_tokens": 22009,
+        "turns": 43,
+        "tools_used": [
+          "Read",
+          "Glob",
+          "TodoWrite",
+          "Write",
+          "Edit",
+          "Bash"
+        ],
+        "duration_ms": 203356,
+        "total_cost_usd": 0.82133775
+      },
+      "polecat-1": {
+        "input_tokens": 39,
+        "output_tokens": 23239,
+        "cache_read_tokens": 1262572,
+        "cache_creation_tokens": 43832,
+        "turns": 50,
+        "tools_used": [
+          "TodoWrite",
+          "Read",
+          "Glob",
+          "Write",
+          "Bash",
+          "Edit"
+        ],
+        "duration_ms": 359322,
+        "total_cost_usd": 1.503759
+      },
+      "polecat-2": {
+        "input_tokens": 29,
+        "output_tokens": 17267,
+        "cache_read_tokens": 822102,
+        "cache_creation_tokens": 27942,
+        "turns": 45,
+        "tools_used": [
+          "Read",
+          "Bash",
+          "Glob",
+          "TodoWrite",
+          "Write",
+          "Edit"
+        ],
+        "duration_ms": 273549,
+        "total_cost_usd": 1.0344744999999997
+      },
+      "polecat-3": {
+        "input_tokens": 28,
+        "output_tokens": 16909,
+        "cache_read_tokens": 730443,
+        "cache_creation_tokens": 25380,
+        "turns": 44,
+        "tools_used": [
+          "TodoWrite",
+          "Read",
+          "Glob",
+          "Write",
+          "Bash"
+        ],
+        "duration_ms": 255328,
+        "total_cost_usd": 0.9650134999999999
+      },
+      "refinery-fixup": {
+        "input_tokens": 30,
+        "output_tokens": 28939,
+        "cache_read_tokens": 2450214,
+        "cache_creation_tokens": 107706,
+        "turns": 43,
+        "tools_used": [
+          "Bash",
+          "Glob",
+          "Read",
+          "TodoWrite",
+          "Write",
+          "Edit"
+        ],
+        "duration_ms": 502943,
+        "total_cost_usd": 2.631776500000001
+      },
+      "refinery-merge-1": {
+        "input_tokens": 7,
+        "output_tokens": 1857,
+        "cache_read_tokens": 193222,
+        "cache_creation_tokens": 41355,
+        "turns": 6,
+        "tools_used": [
+          "Read",
+          "TodoWrite",
+          "Write"
+        ],
+        "duration_ms": 34151,
+        "total_cost_usd": 0.40243375000000003
+      },
+      "refinery-merge-2": {
+        "input_tokens": 7,
+        "output_tokens": 1989,
+        "cache_read_tokens": 180535,
+        "cache_creation_tokens": 32465,
+        "turns": 6,
+        "tools_used": [
+          "Read",
+          "Glob",
+          "TodoWrite",
+          "Write"
+        ],
+        "duration_ms": 40172,
+        "total_cost_usd": 0.34367775
+      },
+      "refinery-merge-3": {
+        "input_tokens": 7,
+        "output_tokens": 1381,
+        "cache_read_tokens": 215113,
+        "cache_creation_tokens": 59550,
+        "turns": 6,
+        "tools_used": [
+          "Read",
+          "Glob",
+          "TodoWrite"
+        ],
+        "duration_ms": 28202,
+        "total_cost_usd": 0.5151830000000001
+      }
+    }
+  }
+}
\ No newline at end of file
diff --git a/package-lock.json b/package-lock.json
index 1d53f39..7bfdff3 100644
--- a/package-lock.json
+++ b/package-lock.json
@@ -11,11 +11,83 @@
         "@types/node": "^25.2.3",
         "@typescript-eslint/eslint-plugin": "^7.0.0",
         "@typescript-eslint/parser": "^7.0.0",
+        "@vitest/coverage-v8": "^2.0.0",
         "eslint": "^8.56.0",
         "typescript": "^5.4.0",
         "vitest": "^2.0.0"
       }
     },
+    "node_modules/@ampproject/remapping": {
+      "version": "2.3.0",
+      "resolved": "https://registry.npmjs.org/@ampproject/remapping/-/remapping-2.3.0.tgz",
+      "integrity": "sha512-30iZtAPgz+LTIYoeivqYo853f02jBYSd5uGnGpkFV0M3xOt9aN73erkgYAmZU43x4VfqcnLxW9Kpg3R5LC4YYw==",
+      "dev": true,
+      "license": "Apache-2.0",
+      "dependencies": {
+        "@jridgewell/gen-mapping": "^0.3.5",
+        "@jridgewell/trace-mapping": "^0.3.24"
+      },
+      "engines": {
+        "node": ">=6.0.0"
+      }
+    },
+    "node_modules/@babel/helper-string-parser": {
+      "version": "7.27.1",
+      "resolved": "https://registry.npmjs.org/@babel/helper-string-parser/-/helper-string-parser-7.27.1.tgz",
+      "integrity": "sha512-qMlSxKbpRlAridDExk92nSobyDdpPijUq2DW6oDnUqd0iOGxmQjyqhMIihI9+zv4LPyZdRje2cavWPbCbWm3eA==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=6.9.0"
+      }
+    },
+    "node_modules/@babel/helper-validator-identifier": {
+      "version": "7.28.5",
+      "resolved": "https://registry.npmjs.org/@babel/helper-validator-identifier/-/helper-validator-identifier-7.28.5.tgz",
+      "integrity": "sha512-qSs4ifwzKJSV39ucNjsvc6WVHs6b7S03sOh2OcHF9UHfVPqWWALUsNUVzhSBiItjRZoLHx7nIarVjqKVusUZ1Q==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=6.9.0"
+      }
+    },
+    "node_modules/@babel/parser": {
+      "version": "7.29.0",
+      "resolved": "https://registry.npmjs.org/@babel/parser/-/parser-7.29.0.tgz",
+      "integrity": "sha512-IyDgFV5GeDUVX4YdF/3CPULtVGSXXMLh1xVIgdCgxApktqnQV0r7/8Nqthg+8YLGaAtdyIlo2qIdZrbCv4+7ww==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@babel/types": "^7.29.0"
+      },
+      "bin": {
+        "parser": "bin/babel-parser.js"
+      },
+      "engines": {
+        "node": ">=6.0.0"
+      }
+    },
+    "node_modules/@babel/types": {
+      "version": "7.29.0",
+      "resolved": "https://registry.npmjs.org/@babel/types/-/types-7.29.0.tgz",
+      "integrity": "sha512-LwdZHpScM4Qz8Xw2iKSzS+cfglZzJGvofQICy7W7v4caru4EaAmyUuO6BGrbyQ2mYV11W0U8j5mBhd14dd3B0A==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@babel/helper-string-parser": "^7.27.1",
+        "@babel/helper-validator-identifier": "^7.28.5"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      }
+    },
+    "node_modules/@bcoe/v8-coverage": {
+      "version": "0.2.3",
+      "resolved": "https://registry.npmjs.org/@bcoe/v8-coverage/-/v8-coverage-0.2.3.tgz",
+      "integrity": "sha512-0hYQ8SB4Db5zvZB4axdMHGwEaQjkZzFjQiN9LVYvIFB2nSUHW9tYpxWriPrWDASIxiaXax83REcLxuSdnGPZtw==",
+      "dev": true,
+      "license": "MIT"
+    },
     "node_modules/@esbuild/aix-ppc64": {
       "version": "0.21.5",
       "resolved": "https://registry.npmjs.org/@esbuild/aix-ppc64/-/aix-ppc64-0.21.5.tgz",
@@ -556,6 +628,84 @@
       "dev": true,
       "license": "BSD-3-Clause"
     },
+    "node_modules/@isaacs/cliui": {
+      "version": "8.0.2",
+      "resolved": "https://registry.npmjs.org/@isaacs/cliui/-/cliui-8.0.2.tgz",
+      "integrity": "sha512-O8jcjabXaleOG9DQ0+ARXWZBTfnP4WNAqzuiJK7ll44AmxGKv/J2M4TPjxjY3znBCfvBXFzucm1twdyFybFqEA==",
+      "dev": true,
+      "license": "ISC",
+      "dependencies": {
+        "string-width": "^5.1.2",
+        "string-width-cjs": "npm:string-width@^4.2.0",
+        "strip-ansi": "^7.0.1",
+        "strip-ansi-cjs": "npm:strip-ansi@^6.0.1",
+        "wrap-ansi": "^8.1.0",
+        "wrap-ansi-cjs": "npm:wrap-ansi@^7.0.0"
+      },
+      "engines": {
+        "node": ">=12"
+      }
+    },
+    "node_modules/@isaacs/cliui/node_modules/ansi-regex": {
+      "version": "6.2.2",
+      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-6.2.2.tgz",
+      "integrity": "sha512-Bq3SmSpyFHaWjPk8If9yc6svM8c56dB5BAtW4Qbw5jHTwwXXcTLoRMkpDJp6VL0XzlWaCHTXrkFURMYmD0sLqg==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/ansi-regex?sponsor=1"
+      }
+    },
+    "node_modules/@isaacs/cliui/node_modules/strip-ansi": {
+      "version": "7.1.2",
+      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-7.1.2.tgz",
+      "integrity": "sha512-gmBGslpoQJtgnMAvOVqGZpEz9dyoKTCzy2nfz/n8aIFhN/jCE/rCmcxabB6jOOHV+0WNnylOxaxBQPSvcWklhA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "ansi-regex": "^6.0.1"
+      },
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/strip-ansi?sponsor=1"
+      }
+    },
+    "node_modules/@istanbuljs/schema": {
+      "version": "0.1.3",
+      "resolved": "https://registry.npmjs.org/@istanbuljs/schema/-/schema-0.1.3.tgz",
+      "integrity": "sha512-ZXRY4jNvVgSVQ8DL3LTcakaAtXwTVUxE81hslsyD2AtoXW/wVob10HkOJ1X/pAlcI7D+2YoZKg5do8G/w6RYgA==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/@jridgewell/gen-mapping": {
+      "version": "0.3.13",
+      "resolved": "https://registry.npmjs.org/@jridgewell/gen-mapping/-/gen-mapping-0.3.13.tgz",
+      "integrity": "sha512-2kkt/7niJ6MgEPxF0bYdQ6etZaA+fQvDcLKckhy1yIQOzaoKjBBjSj63/aLVjYE3qhRt5dvM+uUyfCg6UKCBbA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@jridgewell/sourcemap-codec": "^1.5.0",
+        "@jridgewell/trace-mapping": "^0.3.24"
+      }
+    },
+    "node_modules/@jridgewell/resolve-uri": {
+      "version": "3.1.2",
+      "resolved": "https://registry.npmjs.org/@jridgewell/resolve-uri/-/resolve-uri-3.1.2.tgz",
+      "integrity": "sha512-bRISgCIjP20/tbWSPWMEi54QVPRZExkuD9lJL+UIxUKtwVJA8wW1Trb1jMs1RFXo1CBTNZ/5hpC9QvmKWdopKw==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=6.0.0"
+      }
+    },
     "node_modules/@jridgewell/sourcemap-codec": {
       "version": "1.5.5",
       "resolved": "https://registry.npmjs.org/@jridgewell/sourcemap-codec/-/sourcemap-codec-1.5.5.tgz",
@@ -563,6 +713,17 @@
       "dev": true,
       "license": "MIT"
     },
+    "node_modules/@jridgewell/trace-mapping": {
+      "version": "0.3.31",
+      "resolved": "https://registry.npmjs.org/@jridgewell/trace-mapping/-/trace-mapping-0.3.31.tgz",
+      "integrity": "sha512-zzNR+SdQSDJzc8joaeP8QQoCQr8NuYx2dIIytl1QeBEZHJ9uW6hebsrYgbz8hJwUQao3TWCMtmfV8Nu1twOLAw==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@jridgewell/resolve-uri": "^3.1.0",
+        "@jridgewell/sourcemap-codec": "^1.4.14"
+      }
+    },
     "node_modules/@nodelib/fs.scandir": {
       "version": "2.1.5",
       "resolved": "https://registry.npmjs.org/@nodelib/fs.scandir/-/fs.scandir-2.1.5.tgz",
@@ -601,6 +762,17 @@
         "node": ">= 8"
       }
     },
+    "node_modules/@pkgjs/parseargs": {
+      "version": "0.11.0",
+      "resolved": "https://registry.npmjs.org/@pkgjs/parseargs/-/parseargs-0.11.0.tgz",
+      "integrity": "sha512-+1VkjdD0QBLPodGrJUeqarH8VAIvQODIbwh9XpP5Syisf7YoQgsJKPNFoqqLQlu+VQ/tVSshMR6loPMn8U+dPg==",
+      "dev": true,
+      "license": "MIT",
+      "optional": true,
+      "engines": {
+        "node": ">=14"
+      }
+    },
     "node_modules/@rollup/rollup-android-arm-eabi": {
       "version": "4.57.1",
       "resolved": "https://registry.npmjs.org/@rollup/rollup-android-arm-eabi/-/rollup-android-arm-eabi-4.57.1.tgz",
@@ -964,7 +1136,6 @@
       "integrity": "sha512-m0jEgYlYz+mDJZ2+F4v8D1AyQb+QzsNqRuI7xg1VQX/KlKS0qT9r1Mo16yo5F/MtifXFgaofIFsdFMox2SxIbQ==",
       "dev": true,
       "license": "MIT",
-      "peer": true,
       "dependencies": {
         "undici-types": "~7.16.0"
       }
@@ -1009,7 +1180,6 @@
       "integrity": "sha512-4Z+L8I2OqhZV8qA132M4wNL30ypZGYOQVBfMgxDH/K5UX0PNqTu1c6za9ST5r9+tavvHiTWmBnKzpCJ/GlVFtg==",
       "dev": true,
       "license": "BSD-2-Clause",
-      "peer": true,
       "dependencies": {
         "@typescript-eslint/scope-manager": "7.18.0",
         "@typescript-eslint/types": "7.18.0",
@@ -1170,6 +1340,39 @@
       "dev": true,
       "license": "ISC"
     },
+    "node_modules/@vitest/coverage-v8": {
+      "version": "2.1.9",
+      "resolved": "https://registry.npmjs.org/@vitest/coverage-v8/-/coverage-v8-2.1.9.tgz",
+      "integrity": "sha512-Z2cOr0ksM00MpEfyVE8KXIYPEcBFxdbLSs56L8PO0QQMxt/6bDj45uQfxoc96v05KW3clk7vvgP0qfDit9DmfQ==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@ampproject/remapping": "^2.3.0",
+        "@bcoe/v8-coverage": "^0.2.3",
+        "debug": "^4.3.7",
+        "istanbul-lib-coverage": "^3.2.2",
+        "istanbul-lib-report": "^3.0.1",
+        "istanbul-lib-source-maps": "^5.0.6",
+        "istanbul-reports": "^3.1.7",
+        "magic-string": "^0.30.12",
+        "magicast": "^0.3.5",
+        "std-env": "^3.8.0",
+        "test-exclude": "^7.0.1",
+        "tinyrainbow": "^1.2.0"
+      },
+      "funding": {
+        "url": "https://opencollective.com/vitest"
+      },
+      "peerDependencies": {
+        "@vitest/browser": "2.1.9",
+        "vitest": "2.1.9"
+      },
+      "peerDependenciesMeta": {
+        "@vitest/browser": {
+          "optional": true
+        }
+      }
+    },
     "node_modules/@vitest/expect": {
       "version": "2.1.9",
       "resolved": "https://registry.npmjs.org/@vitest/expect/-/expect-2.1.9.tgz",
@@ -1289,7 +1492,6 @@
       "integrity": "sha512-NZyJarBfL7nWwIq+FDL6Zp/yHEhePMNnnJ0y3qfieCrmNvYct8uvtiV41UvlSe6apAfk0fY1FbWx+NwfmpvtTg==",
       "dev": true,
       "license": "MIT",
-      "peer": true,
       "bin": {
         "acorn": "bin/acorn"
       },
@@ -1574,6 +1776,20 @@
         "node": ">=6.0.0"
       }
     },
+    "node_modules/eastasianwidth": {
+      "version": "0.2.0",
+      "resolved": "https://registry.npmjs.org/eastasianwidth/-/eastasianwidth-0.2.0.tgz",
+      "integrity": "sha512-I88TYZWc9XiYHRQ4/3c5rjjfgkjhLyW2luGIheGERbNQ6OY7yTybanSpDXZa8y7VUP9YmDcYa+eyq4ca7iLqWA==",
+      "dev": true,
+      "license": "MIT"
+    },
+    "node_modules/emoji-regex": {
+      "version": "9.2.2",
+      "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-9.2.2.tgz",
+      "integrity": "sha512-L18DaJsXSUk2+42pv8mLs5jJT2hqFkFE4j21wOmgbUqsZ2hL72NsUU785g9RXgo3s0ZNgVl42TiHp3ZtOv/Vyg==",
+      "dev": true,
+      "license": "MIT"
+    },
     "node_modules/es-module-lexer": {
       "version": "1.7.0",
       "resolved": "https://registry.npmjs.org/es-module-lexer/-/es-module-lexer-1.7.0.tgz",
@@ -1640,7 +1856,6 @@
       "deprecated": "This version is no longer supported. Please see https://eslint.org/version-support for other options.",
       "dev": true,
       "license": "MIT",
-      "peer": true,
       "dependencies": {
         "@eslint-community/eslint-utils": "^4.2.0",
         "@eslint-community/regexpp": "^4.6.1",
@@ -1955,6 +2170,23 @@
       "dev": true,
       "license": "ISC"
     },
+    "node_modules/foreground-child": {
+      "version": "3.3.1",
+      "resolved": "https://registry.npmjs.org/foreground-child/-/foreground-child-3.3.1.tgz",
+      "integrity": "sha512-gIXjKqtFuWEgzFRJA9WCQeSJLZDjgJUOMCMzxtvFq/37KojM1BFGufqsCy0r4qSQmYLsZYMeyRqzIWOMup03sw==",
+      "dev": true,
+      "license": "ISC",
+      "dependencies": {
+        "cross-spawn": "^7.0.6",
+        "signal-exit": "^4.0.1"
+      },
+      "engines": {
+        "node": ">=14"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/isaacs"
+      }
+    },
     "node_modules/fs.realpath": {
       "version": "1.0.0",
       "resolved": "https://registry.npmjs.org/fs.realpath/-/fs.realpath-1.0.0.tgz",
@@ -2090,6 +2322,13 @@
         "node": ">=8"
       }
     },
+    "node_modules/html-escaper": {
+      "version": "2.0.2",
+      "resolved": "https://registry.npmjs.org/html-escaper/-/html-escaper-2.0.2.tgz",
+      "integrity": "sha512-H2iMtd0I4Mt5eYiapRdIDjp+XzelXQ0tFE4JS7YFwFevXXMmOp9myNrUvCg0D6ws8iqkRPBfKHgbwig1SmlLfg==",
+      "dev": true,
+      "license": "MIT"
+    },
     "node_modules/ignore": {
       "version": "5.3.2",
       "resolved": "https://registry.npmjs.org/ignore/-/ignore-5.3.2.tgz",
@@ -2156,6 +2395,16 @@
         "node": ">=0.10.0"
       }
     },
+    "node_modules/is-fullwidth-code-point": {
+      "version": "3.0.0",
+      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/is-fullwidth-code-point-3.0.0.tgz",
+      "integrity": "sha512-zymm5+u+sCsSWyD9qNaejV3DFvhCKclKdizYaJUuHA83RLjb7nSuGnddCHGv0hk+KY7BMAlsWeK4Ueg6EV6XQg==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=8"
+      }
+    },
     "node_modules/is-glob": {
       "version": "4.0.3",
       "resolved": "https://registry.npmjs.org/is-glob/-/is-glob-4.0.3.tgz",
@@ -2196,6 +2445,76 @@
       "dev": true,
       "license": "ISC"
     },
+    "node_modules/istanbul-lib-coverage": {
+      "version": "3.2.2",
+      "resolved": "https://registry.npmjs.org/istanbul-lib-coverage/-/istanbul-lib-coverage-3.2.2.tgz",
+      "integrity": "sha512-O8dpsF+r0WV/8MNRKfnmrtCWhuKjxrq2w+jpzBL5UZKTi2LeVWnWOmWRxFlesJONmc+wLAGvKQZEOanko0LFTg==",
+      "dev": true,
+      "license": "BSD-3-Clause",
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/istanbul-lib-report": {
+      "version": "3.0.1",
+      "resolved": "https://registry.npmjs.org/istanbul-lib-report/-/istanbul-lib-report-3.0.1.tgz",
+      "integrity": "sha512-GCfE1mtsHGOELCU8e/Z7YWzpmybrx/+dSTfLrvY8qRmaY6zXTKWn6WQIjaAFw069icm6GVMNkgu0NzI4iPZUNw==",
+      "dev": true,
+      "license": "BSD-3-Clause",
+      "dependencies": {
+        "istanbul-lib-coverage": "^3.0.0",
+        "make-dir": "^4.0.0",
+        "supports-color": "^7.1.0"
+      },
+      "engines": {
+        "node": ">=10"
+      }
+    },
+    "node_modules/istanbul-lib-source-maps": {
+      "version": "5.0.6",
+      "resolved": "https://registry.npmjs.org/istanbul-lib-source-maps/-/istanbul-lib-source-maps-5.0.6.tgz",
+      "integrity": "sha512-yg2d+Em4KizZC5niWhQaIomgf5WlL4vOOjZ5xGCmF8SnPE/mDWWXgvRExdcpCgh9lLRRa1/fSYp2ymmbJ1pI+A==",
+      "dev": true,
+      "license": "BSD-3-Clause",
+      "dependencies": {
+        "@jridgewell/trace-mapping": "^0.3.23",
+        "debug": "^4.1.1",
+        "istanbul-lib-coverage": "^3.0.0"
+      },
+      "engines": {
+        "node": ">=10"
+      }
+    },
+    "node_modules/istanbul-reports": {
+      "version": "3.2.0",
+      "resolved": "https://registry.npmjs.org/istanbul-reports/-/istanbul-reports-3.2.0.tgz",
+      "integrity": "sha512-HGYWWS/ehqTV3xN10i23tkPkpH46MLCIMFNCaaKNavAXTF1RkqxawEPtnjnGZ6XKSInBKkiOA5BKS+aZiY3AvA==",
+      "dev": true,
+      "license": "BSD-3-Clause",
+      "dependencies": {
+        "html-escaper": "^2.0.0",
+        "istanbul-lib-report": "^3.0.0"
+      },
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/jackspeak": {
+      "version": "3.4.3",
+      "resolved": "https://registry.npmjs.org/jackspeak/-/jackspeak-3.4.3.tgz",
+      "integrity": "sha512-OGlZQpz2yfahA/Rd1Y8Cd9SIEsqvXkLVoSw/cgwhnhFMDbsQFeZYoJJ7bIZBS9BcamUW96asq/npPWugM+RQBw==",
+      "dev": true,
+      "license": "BlueOak-1.0.0",
+      "dependencies": {
+        "@isaacs/cliui": "^8.0.2"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/isaacs"
+      },
+      "optionalDependencies": {
+        "@pkgjs/parseargs": "^0.11.0"
+      }
+    },
     "node_modules/js-yaml": {
       "version": "4.1.1",
       "resolved": "https://registry.npmjs.org/js-yaml/-/js-yaml-4.1.1.tgz",
@@ -2284,6 +2603,13 @@
       "dev": true,
       "license": "MIT"
     },
+    "node_modules/lru-cache": {
+      "version": "10.4.3",
+      "resolved": "https://registry.npmjs.org/lru-cache/-/lru-cache-10.4.3.tgz",
+      "integrity": "sha512-JNAzZcXrCt42VGLuYz0zfAzDfAvJWW6AfYlDBQyDV5DClI2m5sAmK+OIO7s59XfsRsWHp02jAJrRadPRGTt6SQ==",
+      "dev": true,
+      "license": "ISC"
+    },
     "node_modules/magic-string": {
       "version": "0.30.21",
       "resolved": "https://registry.npmjs.org/magic-string/-/magic-string-0.30.21.tgz",
@@ -2294,6 +2620,34 @@
         "@jridgewell/sourcemap-codec": "^1.5.5"
       }
     },
+    "node_modules/magicast": {
+      "version": "0.3.5",
+      "resolved": "https://registry.npmjs.org/magicast/-/magicast-0.3.5.tgz",
+      "integrity": "sha512-L0WhttDl+2BOsybvEOLK7fW3UA0OQ0IQ2d6Zl2x/a6vVRs3bAY0ECOSHHeL5jD+SbOpOCUEi0y1DgHEn9Qn1AQ==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@babel/parser": "^7.25.4",
+        "@babel/types": "^7.25.4",
+        "source-map-js": "^1.2.0"
+      }
+    },
+    "node_modules/make-dir": {
+      "version": "4.0.0",
+      "resolved": "https://registry.npmjs.org/make-dir/-/make-dir-4.0.0.tgz",
+      "integrity": "sha512-hXdUTZYIVOt1Ex//jAQi+wTZZpUpwBj/0QsOzqegb3rGMMeJiSEu5xLHnYfBrRV4RH2+OCSOO95Is/7x1WJ4bw==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "semver": "^7.5.3"
+      },
+      "engines": {
+        "node": ">=10"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/sindresorhus"
+      }
+    },
     "node_modules/merge2": {
       "version": "1.4.1",
       "resolved": "https://registry.npmjs.org/merge2/-/merge2-1.4.1.tgz",
@@ -2334,6 +2688,16 @@
         "url": "https://github.com/sponsors/isaacs"
       }
     },
+    "node_modules/minipass": {
+      "version": "7.1.2",
+      "resolved": "https://registry.npmjs.org/minipass/-/minipass-7.1.2.tgz",
+      "integrity": "sha512-qOOzS1cBTWYF4BH8fVePDBOO9iptMnGUEZwNc/cMWnTV2nVLZ7VoNWEPHkYczZA0pdoA7dl6e7FL659nX9S2aw==",
+      "dev": true,
+      "license": "ISC",
+      "engines": {
+        "node": ">=16 || 14 >=14.17"
+      }
+    },
     "node_modules/ms": {
       "version": "2.1.3",
       "resolved": "https://registry.npmjs.org/ms/-/ms-2.1.3.tgz",
@@ -2427,6 +2791,13 @@
         "url": "https://github.com/sponsors/sindresorhus"
       }
     },
+    "node_modules/package-json-from-dist": {
+      "version": "1.0.1",
+      "resolved": "https://registry.npmjs.org/package-json-from-dist/-/package-json-from-dist-1.0.1.tgz",
+      "integrity": "sha512-UEZIS3/by4OC8vL3P2dTXRETpebLI2NiI5vIrjaD/5UtrkFX/tNbwjTSRAGC/+7CAo2pIcBaRgWmcBBHcsaCIw==",
+      "dev": true,
+      "license": "BlueOak-1.0.0"
+    },
     "node_modules/parent-module": {
       "version": "1.0.1",
       "resolved": "https://registry.npmjs.org/parent-module/-/parent-module-1.0.1.tgz",
@@ -2470,6 +2841,23 @@
         "node": ">=8"
       }
     },
+    "node_modules/path-scurry": {
+      "version": "1.11.1",
+      "resolved": "https://registry.npmjs.org/path-scurry/-/path-scurry-1.11.1.tgz",
+      "integrity": "sha512-Xa4Nw17FS9ApQFJ9umLiJS4orGjm7ZzwUrwamcGQuHSzDyth9boKDaycYdDcZDuqYATXw4HFXgaqWTctW/v1HA==",
+      "dev": true,
+      "license": "BlueOak-1.0.0",
+      "dependencies": {
+        "lru-cache": "^10.2.0",
+        "minipass": "^5.0.0 || ^6.0.2 || ^7.0.0"
+      },
+      "engines": {
+        "node": ">=16 || 14 >=14.18"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/isaacs"
+      }
+    },
     "node_modules/path-type": {
       "version": "4.0.0",
       "resolved": "https://registry.npmjs.org/path-type/-/path-type-4.0.0.tgz",
@@ -2737,6 +3125,19 @@
       "dev": true,
       "license": "ISC"
     },
+    "node_modules/signal-exit": {
+      "version": "4.1.0",
+      "resolved": "https://registry.npmjs.org/signal-exit/-/signal-exit-4.1.0.tgz",
+      "integrity": "sha512-bzyZ1e88w9O1iNJbKnOlvYTrWPDl46O1bG0D3XInv+9tkPrxrN8jUUTiFlDkkmKWgn1M6CfIA13SuGqOa9Korw==",
+      "dev": true,
+      "license": "ISC",
+      "engines": {
+        "node": ">=14"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/isaacs"
+      }
+    },
     "node_modules/slash": {
       "version": "3.0.0",
       "resolved": "https://registry.npmjs.org/slash/-/slash-3.0.0.tgz",
@@ -2771,6 +3172,76 @@
       "dev": true,
       "license": "MIT"
     },
+    "node_modules/string-width": {
+      "version": "5.1.2",
+      "resolved": "https://registry.npmjs.org/string-width/-/string-width-5.1.2.tgz",
+      "integrity": "sha512-HnLOCR3vjcY8beoNLtcjZ5/nxn2afmME6lhrDrebokqMap+XbeW8n9TXpPDOqdGK5qcI3oT0GKTW6wC7EMiVqA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "eastasianwidth": "^0.2.0",
+        "emoji-regex": "^9.2.2",
+        "strip-ansi": "^7.0.1"
+      },
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/sindresorhus"
+      }
+    },
+    "node_modules/string-width-cjs": {
+      "name": "string-width",
+      "version": "4.2.3",
+      "resolved": "https://registry.npmjs.org/string-width/-/string-width-4.2.3.tgz",
+      "integrity": "sha512-wKyQRQpjJ0sIp62ErSZdGsjMJWsap5oRNihHhu6G7JVO/9jIB6UyevL+tXuOqrng8j/cxKTWyWUwvSTriiZz/g==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "emoji-regex": "^8.0.0",
+        "is-fullwidth-code-point": "^3.0.0",
+        "strip-ansi": "^6.0.1"
+      },
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/string-width-cjs/node_modules/emoji-regex": {
+      "version": "8.0.0",
+      "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-8.0.0.tgz",
+      "integrity": "sha512-MSjYzcWNOA0ewAHpz0MxpYFvwg6yjy1NG3xteoqz644VCo/RPgnr1/GGt+ic3iJTzQ8Eu3TdM14SawnVUmGE6A==",
+      "dev": true,
+      "license": "MIT"
+    },
+    "node_modules/string-width/node_modules/ansi-regex": {
+      "version": "6.2.2",
+      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-6.2.2.tgz",
+      "integrity": "sha512-Bq3SmSpyFHaWjPk8If9yc6svM8c56dB5BAtW4Qbw5jHTwwXXcTLoRMkpDJp6VL0XzlWaCHTXrkFURMYmD0sLqg==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/ansi-regex?sponsor=1"
+      }
+    },
+    "node_modules/string-width/node_modules/strip-ansi": {
+      "version": "7.1.2",
+      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-7.1.2.tgz",
+      "integrity": "sha512-gmBGslpoQJtgnMAvOVqGZpEz9dyoKTCzy2nfz/n8aIFhN/jCE/rCmcxabB6jOOHV+0WNnylOxaxBQPSvcWklhA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "ansi-regex": "^6.0.1"
+      },
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/strip-ansi?sponsor=1"
+      }
+    },
     "node_modules/strip-ansi": {
       "version": "6.0.1",
       "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-6.0.1.tgz",
@@ -2784,6 +3255,20 @@
         "node": ">=8"
       }
     },
+    "node_modules/strip-ansi-cjs": {
+      "name": "strip-ansi",
+      "version": "6.0.1",
+      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-6.0.1.tgz",
+      "integrity": "sha512-Y38VPSHcqkFrCpFnQ9vuSXmquuv5oXOKpGeT6aGrr3o3Gc9AlVa6JBfUSOCnbxGGZF+/0ooI7KrPuUSztUdU5A==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "ansi-regex": "^5.0.1"
+      },
+      "engines": {
+        "node": ">=8"
+      }
+    },
     "node_modules/strip-json-comments": {
       "version": "3.1.1",
       "resolved": "https://registry.npmjs.org/strip-json-comments/-/strip-json-comments-3.1.1.tgz",
@@ -2810,6 +3295,43 @@
         "node": ">=8"
       }
     },
+    "node_modules/test-exclude": {
+      "version": "7.0.1",
+      "resolved": "https://registry.npmjs.org/test-exclude/-/test-exclude-7.0.1.tgz",
+      "integrity": "sha512-pFYqmTw68LXVjeWJMST4+borgQP2AyMNbg1BpZh9LbyhUeNkeaPF9gzfPGUAnSMV3qPYdWUwDIjjCLiSDOl7vg==",
+      "dev": true,
+      "license": "ISC",
+      "dependencies": {
+        "@istanbuljs/schema": "^0.1.2",
+        "glob": "^10.4.1",
+        "minimatch": "^9.0.4"
+      },
+      "engines": {
+        "node": ">=18"
+      }
+    },
+    "node_modules/test-exclude/node_modules/glob": {
+      "version": "10.5.0",
+      "resolved": "https://registry.npmjs.org/glob/-/glob-10.5.0.tgz",
+      "integrity": "sha512-DfXN8DfhJ7NH3Oe7cFmu3NCu1wKbkReJ8TorzSAFbSKrlNaQSKfIzqYqVY8zlbs2NLBbWpRiU52GX2PbaBVNkg==",
+      "deprecated": "Old versions of glob are not supported, and contain widely publicized security vulnerabilities, which have been fixed in the current version. Please update. Support for old versions may be purchased (at exorbitant rates) by contacting i@izs.me",
+      "dev": true,
+      "license": "ISC",
+      "dependencies": {
+        "foreground-child": "^3.1.0",
+        "jackspeak": "^3.1.2",
+        "minimatch": "^9.0.4",
+        "minipass": "^7.1.2",
+        "package-json-from-dist": "^1.0.0",
+        "path-scurry": "^1.11.1"
+      },
+      "bin": {
+        "glob": "dist/esm/bin.mjs"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/isaacs"
+      }
+    },
     "node_modules/text-table": {
       "version": "0.2.0",
       "resolved": "https://registry.npmjs.org/text-table/-/text-table-0.2.0.tgz",
@@ -2919,7 +3441,6 @@
       "integrity": "sha512-jl1vZzPDinLr9eUt3J/t7V6FgNEw9QjvBPdysz9KfQDD41fQrC2Y4vKQdiaUpFT4bXlb1RHhLpp8wtm6M5TgSw==",
       "dev": true,
       "license": "Apache-2.0",
-      "peer": true,
       "bin": {
         "tsc": "bin/tsc",
         "tsserver": "bin/tsserver"
@@ -2951,7 +3472,6 @@
       "integrity": "sha512-o5a9xKjbtuhY6Bi5S3+HvbRERmouabWbyUcpXXUA1u+GNUKoROi9byOJ8M0nHbHYHkYICiMlqxkg1KkYmm25Sw==",
       "dev": true,
       "license": "MIT",
-      "peer": true,
       "dependencies": {
         "esbuild": "^0.21.3",
         "postcss": "^8.4.43",
@@ -3138,6 +3658,107 @@
         "node": ">=0.10.0"
       }
     },
+    "node_modules/wrap-ansi": {
+      "version": "8.1.0",
+      "resolved": "https://registry.npmjs.org/wrap-ansi/-/wrap-ansi-8.1.0.tgz",
+      "integrity": "sha512-si7QWI6zUMq56bESFvagtmzMdGOtoxfR+Sez11Mobfc7tm+VkUckk9bW2UeffTGVUbOksxmSw0AA2gs8g71NCQ==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "ansi-styles": "^6.1.0",
+        "string-width": "^5.0.1",
+        "strip-ansi": "^7.0.1"
+      },
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/wrap-ansi?sponsor=1"
+      }
+    },
+    "node_modules/wrap-ansi-cjs": {
+      "name": "wrap-ansi",
+      "version": "7.0.0",
+      "resolved": "https://registry.npmjs.org/wrap-ansi/-/wrap-ansi-7.0.0.tgz",
+      "integrity": "sha512-YVGIj2kamLSTxw6NsZjoBxfSwsn0ycdesmc4p+Q21c5zPuZ1pl+NfxVdxPtdHvmNVOQ6XSYG4AUtyt/Fi7D16Q==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "ansi-styles": "^4.0.0",
+        "string-width": "^4.1.0",
+        "strip-ansi": "^6.0.0"
+      },
+      "engines": {
+        "node": ">=10"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/wrap-ansi?sponsor=1"
+      }
+    },
+    "node_modules/wrap-ansi-cjs/node_modules/emoji-regex": {
+      "version": "8.0.0",
+      "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-8.0.0.tgz",
+      "integrity": "sha512-MSjYzcWNOA0ewAHpz0MxpYFvwg6yjy1NG3xteoqz644VCo/RPgnr1/GGt+ic3iJTzQ8Eu3TdM14SawnVUmGE6A==",
+      "dev": true,
+      "license": "MIT"
+    },
+    "node_modules/wrap-ansi-cjs/node_modules/string-width": {
+      "version": "4.2.3",
+      "resolved": "https://registry.npmjs.org/string-width/-/string-width-4.2.3.tgz",
+      "integrity": "sha512-wKyQRQpjJ0sIp62ErSZdGsjMJWsap5oRNihHhu6G7JVO/9jIB6UyevL+tXuOqrng8j/cxKTWyWUwvSTriiZz/g==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "emoji-regex": "^8.0.0",
+        "is-fullwidth-code-point": "^3.0.0",
+        "strip-ansi": "^6.0.1"
+      },
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/wrap-ansi/node_modules/ansi-regex": {
+      "version": "6.2.2",
+      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-6.2.2.tgz",
+      "integrity": "sha512-Bq3SmSpyFHaWjPk8If9yc6svM8c56dB5BAtW4Qbw5jHTwwXXcTLoRMkpDJp6VL0XzlWaCHTXrkFURMYmD0sLqg==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/ansi-regex?sponsor=1"
+      }
+    },
+    "node_modules/wrap-ansi/node_modules/ansi-styles": {
+      "version": "6.2.3",
+      "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-6.2.3.tgz",
+      "integrity": "sha512-4Dj6M28JB+oAH8kFkTLUo+a2jwOFkuqb3yucU0CANcRRUbxS0cP0nZYCGjcc3BNXwRIsUVmDGgzawme7zvJHvg==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/ansi-styles?sponsor=1"
+      }
+    },
+    "node_modules/wrap-ansi/node_modules/strip-ansi": {
+      "version": "7.1.2",
+      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-7.1.2.tgz",
+      "integrity": "sha512-gmBGslpoQJtgnMAvOVqGZpEz9dyoKTCzy2nfz/n8aIFhN/jCE/rCmcxabB6jOOHV+0WNnylOxaxBQPSvcWklhA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "ansi-regex": "^6.0.1"
+      },
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/strip-ansi?sponsor=1"
+      }
+    },
     "node_modules/wrappy": {
       "version": "1.0.2",
       "resolved": "https://registry.npmjs.org/wrappy/-/wrappy-1.0.2.tgz",
diff --git a/src/index.ts b/src/index.ts
new file mode 100644
index 0000000..8b318f3
--- /dev/null
+++ b/src/index.ts
@@ -0,0 +1,9 @@
+export { Task, TaskStatus, TaskOptions, TaskProgress, ProgressListener, createTask, resetTaskIdCounter } from './task.js';
+export {
+  TaskQueue,
+  TaskHandler,
+  TaskContext,
+  MiddlewareFn,
+  RecurringSchedule,
+  ShutdownResult,
+} from './task-queue.js';
diff --git a/src/task-queue.test.ts b/src/task-queue.test.ts
new file mode 100644
index 0000000..a450758
--- /dev/null
+++ b/src/task-queue.test.ts
@@ -0,0 +1,609 @@
+import { describe, it, expect } from 'vitest';
+import { TaskQueue } from './task-queue.js';
+
+// ============================================================
+// Phase 1: Basic FIFO Queue
+// ============================================================
+describe('Phase 1: Basic FIFO Queue', () => {
+  it('should add a task and return a task object with id, status, and createdAt', () => {
+    const q = new TaskQueue();
+    const task = q.addTask({ action: 'test' });
+    expect(task.id).toBeDefined();
+    expect(task.status).toBe('pending');
+    expect(task.createdAt).toBeInstanceOf(Date);
+    expect(task.payload).toEqual({ action: 'test' });
+  });
+
+  it('should retrieve tasks in FIFO order', () => {
+    const q = new TaskQueue();
+    const t1 = q.addTask('first');
+    const t2 = q.addTask('second');
+    const got1 = q.getNextTask();
+    expect(got1?.id).toBe(t1.id);
+    expect(got1?.status).toBe('processing');
+    const got2 = q.getNextTask();
+    expect(got2?.id).toBe(t2.id);
+  });
+
+  it('should return null when no tasks available', () => {
+    const q = new TaskQueue();
+    expect(q.getNextTask()).toBeNull();
+  });
+
+  it('should report pending count', () => {
+    const q = new TaskQueue();
+    q.addTask('a');
+    q.addTask('b');
+    expect(q.getPendingCount()).toBe(2);
+    q.getNextTask();
+    expect(q.getPendingCount()).toBe(1);
+  });
+
+  it('should get a task by id', () => {
+    const q = new TaskQueue();
+    const task = q.addTask('data');
+    const found = q.getTask(task.id);
+    expect(found?.id).toBe(task.id);
+    expect(q.getTask('nonexistent')).toBeNull();
+  });
+});
+
+// ============================================================
+// Phase 2: Named Queues
+// ============================================================
+describe('Phase 2: Named Queues', () => {
+  it('should support named queues independently', () => {
+    const q = new TaskQueue();
+    q.addTask('a', { queue: 'q1' });
+    q.addTask('b', { queue: 'q2' });
+    expect(q.getPendingCount('q1')).toBe(1);
+    expect(q.getPendingCount('q2')).toBe(1);
+    expect(q.getNextTask('q1')?.payload).toBe('a');
+    expect(q.getNextTask('q2')?.payload).toBe('b');
+  });
+
+  it('should default to "default" queue', () => {
+    const q = new TaskQueue();
+    q.addTask('x');
+    expect(q.getQueueNames()).toContain('default');
+  });
+
+  it('should return null from empty or non-existent queue', () => {
+    const q = new TaskQueue();
+    expect(q.getNextTask('nonexistent')).toBeNull();
+  });
+
+  it('should list queue names', () => {
+    const q = new TaskQueue();
+    q.addTask('a', { queue: 'alpha' });
+    q.addTask('b', { queue: 'beta' });
+    const names = q.getQueueNames();
+    expect(names).toContain('alpha');
+    expect(names).toContain('beta');
+  });
+});
+
+// ============================================================
+// Phase 3: Priority
+// ============================================================
+describe('Phase 3: Priority', () => {
+  it('should return higher-priority tasks first', () => {
+    const q = new TaskQueue();
+    q.addTask('low', { priority: 10 });
+    q.addTask('high', { priority: 1 });
+    q.addTask('mid', { priority: 5 });
+    expect(q.getNextTask()?.payload).toBe('high');
+    expect(q.getNextTask()?.payload).toBe('mid');
+    expect(q.getNextTask()?.payload).toBe('low');
+  });
+
+  it('should FIFO within same priority', () => {
+    const q = new TaskQueue();
+    const t1 = q.addTask('first', { priority: 5 });
+    const t2 = q.addTask('second', { priority: 5 });
+    expect(q.getNextTask()?.id).toBe(t1.id);
+    expect(q.getNextTask()?.id).toBe(t2.id);
+  });
+
+  it('should reject invalid priority', () => {
+    const q = new TaskQueue();
+    expect(() => q.addTask('x', { priority: 0 })).toThrow();
+    expect(() => q.addTask('x', { priority: 11 })).toThrow();
+    expect(() => q.addTask('x', { priority: 1.5 })).toThrow();
+  });
+
+  it('should default priority to 5', () => {
+    const q = new TaskQueue();
+    const task = q.addTask('x');
+    expect(task.priority).toBe(5);
+  });
+});
+
+// ============================================================
+// Phase 4: Delayed Tasks
+// ============================================================
+describe('Phase 4: Delayed Tasks', () => {
+  it('should not return delayed tasks before their time', () => {
+    const q = new TaskQueue();
+    q.addTask('delayed', { delay: 60000 }); // 60 seconds in the future
+    expect(q.getNextTask()).toBeNull();
+  });
+
+  it('should return delayed tasks after their time', () => {
+    const q = new TaskQueue();
+    const task = q.addTask('past', { availableAt: new Date(Date.now() - 1000) });
+    const got = q.getNextTask();
+    expect(got?.id).toBe(task.id);
+  });
+
+  it('should prefer non-delayed tasks', () => {
+    const q = new TaskQueue();
+    q.addTask('delayed', { delay: 60000, priority: 1 });
+    const immediate = q.addTask('immediate', { priority: 5 });
+    expect(q.getNextTask()?.id).toBe(immediate.id);
+  });
+});
+
+// ============================================================
+// Phase 5: Retry with Backoff
+// ============================================================
+describe('Phase 5: Retry with Backoff', () => {
+  it('should complete a task', () => {
+    const q = new TaskQueue();
+    const task = q.addTask('x');
+    q.getNextTask();
+    q.completeTask(task.id);
+    expect(q.getTask(task.id)?.status).toBe('completed');
+  });
+
+  it('should retry a failed task with backoff', () => {
+    const q = new TaskQueue();
+    const task = q.addTask('x', { maxRetries: 2, backoffDelay: 100 });
+    q.getNextTask();
+    q.failTask(task.id, new Error('fail'));
+    const t = q.getTask(task.id)!;
+    expect(t.status).toBe('pending');
+    expect(t.attempts).toBe(1);
+    // Should not be available yet (backoff delay)
+    expect(t.availableAt.getTime()).toBeGreaterThan(Date.now() - 1);
+  });
+
+  it('should track attempt count', () => {
+    const q = new TaskQueue();
+    const task = q.addTask('x', { maxRetries: 3, backoffDelay: 1 });
+    q.getNextTask();
+    expect(q.getTask(task.id)?.attempts).toBe(1);
+  });
+});
+
+// ============================================================
+// Phase 6: Dead Letter Queue
+// ============================================================
+describe('Phase 6: Dead Letter Queue', () => {
+  it('should move failed task to DLQ after exhausting retries', () => {
+    const q = new TaskQueue();
+    const task = q.addTask('x', { maxRetries: 0, backoffDelay: 0 });
+
+    // First (and only) attempt - maxRetries=0 means no retries
+    q.getNextTask();
+    q.failTask(task.id, new Error('err1'));
+    expect(task.status).toBe('failed');
+    expect(q.getDeadLetterQueue()).toHaveLength(1);
+  });
+
+  it('should retry a dead-lettered task', () => {
+    const q = new TaskQueue();
+    const task = q.addTask('x', { maxRetries: 0, backoffDelay: 0 });
+    q.getNextTask();
+    q.failTask(task.id);
+    expect(q.getDeadLetterQueue()).toHaveLength(1);
+
+    const retried = q.retryDeadLetter(task.id);
+    expect(retried?.status).toBe('pending');
+    expect(q.getDeadLetterQueue()).toHaveLength(0);
+  });
+
+  it('should clear DLQ', () => {
+    const q = new TaskQueue();
+    const task = q.addTask('x', { maxRetries: 0 });
+    q.getNextTask();
+    q.failTask(task.id);
+    expect(q.getDeadLetterQueue()).toHaveLength(1);
+    q.clearDeadLetterQueue();
+    expect(q.getDeadLetterQueue()).toHaveLength(0);
+  });
+});
+
+// ============================================================
+// Phase 7: Task Dependencies
+// ============================================================
+describe('Phase 7: Task Dependencies', () => {
+  it('should block tasks with unresolved dependencies', () => {
+    const q = new TaskQueue();
+    const t1 = q.addTask('first');
+    const t2 = q.addTask('second', { dependencies: [t1.id] });
+    expect(t2.status).toBe('blocked');
+    expect(q.getNextTask()?.id).toBe(t1.id);
+    // t2 should not be available
+    expect(q.getNextTask()).toBeNull();
+  });
+
+  it('should unblock tasks when dependencies complete', () => {
+    const q = new TaskQueue();
+    const t1 = q.addTask('first');
+    const t2 = q.addTask('second', { dependencies: [t1.id] });
+    q.getNextTask();
+    q.completeTask(t1.id);
+    expect(t2.status).toBe('pending');
+    expect(q.getNextTask()?.id).toBe(t2.id);
+  });
+
+  it('should reject dependencies on non-existent tasks', () => {
+    const q = new TaskQueue();
+    expect(() => q.addTask('x', { dependencies: ['nonexistent'] })).toThrow();
+  });
+
+  it('should detect circular dependencies', () => {
+    const q = new TaskQueue();
+    const t1 = q.addTask('a');
+    const t2 = q.addTask('b', { dependencies: [t1.id] });
+    expect(() => q.addTask('c', { dependencies: [t2.id, t1.id] })).not.toThrow();
+    // But creating a cycle should throw - we can't easily test this with the current API
+    // since tasks reference IDs. Let's test with a helper.
+  });
+
+  it('should allow tasks with already-completed dependencies', () => {
+    const q = new TaskQueue();
+    const t1 = q.addTask('first');
+    q.getNextTask();
+    q.completeTask(t1.id);
+    const t2 = q.addTask('second', { dependencies: [t1.id] });
+    expect(t2.status).toBe('pending');
+  });
+});
+
+// ============================================================
+// Phase 8: Concurrency Control
+// ============================================================
+describe('Phase 8: Concurrency Control', () => {
+  it('should default to unlimited concurrency', () => {
+    const q = new TaskQueue();
+    q.addTask('a');
+    q.addTask('b');
+    q.addTask('c');
+    expect(q.getNextTask()).not.toBeNull();
+    expect(q.getNextTask()).not.toBeNull();
+    expect(q.getNextTask()).not.toBeNull();
+  });
+
+  it('should limit concurrent processing to concurrency setting', () => {
+    const q = new TaskQueue();
+    q.setConcurrency('default', 2);
+    q.addTask('a');
+    q.addTask('b');
+    q.addTask('c');
+
+    const t1 = q.getNextTask();
+    expect(t1).not.toBeNull();
+    const t2 = q.getNextTask();
+    expect(t2).not.toBeNull();
+    // Third should be blocked by concurrency limit
+    const t3 = q.getNextTask();
+    expect(t3).toBeNull();
+  });
+
+  it('should free concurrency slot when task completes', () => {
+    const q = new TaskQueue();
+    q.setConcurrency('default', 1);
+    const task1 = q.addTask('a');
+    q.addTask('b');
+
+    const got1 = q.getNextTask();
+    expect(got1?.id).toBe(task1.id);
+    // Can't get another while one is processing
+    expect(q.getNextTask()).toBeNull();
+
+    q.completeTask(task1.id);
+    // Now should be able to get the next
+    const got2 = q.getNextTask();
+    expect(got2).not.toBeNull();
+    expect(got2?.payload).toBe('b');
+  });
+
+  it('should free concurrency slot when task fails', () => {
+    const q = new TaskQueue();
+    q.setConcurrency('default', 1);
+    const task1 = q.addTask('a', { maxRetries: 0 });
+    q.addTask('b');
+
+    q.getNextTask();
+    // Can't get another while one is processing
+    expect(q.getNextTask()).toBeNull();
+
+    q.failTask(task1.id, new Error('err'));
+    // Now should be able to get the next
+    const got2 = q.getNextTask();
+    expect(got2).not.toBeNull();
+    expect(got2?.payload).toBe('b');
+  });
+
+  it('should respect concurrency per queue independently', () => {
+    const q = new TaskQueue();
+    q.setConcurrency('q1', 1);
+    q.setConcurrency('q2', 1);
+
+    q.addTask('q1-a', { queue: 'q1' });
+    q.addTask('q1-b', { queue: 'q1' });
+    q.addTask('q2-a', { queue: 'q2' });
+    q.addTask('q2-b', { queue: 'q2' });
+
+    expect(q.getNextTask('q1')).not.toBeNull();
+    expect(q.getNextTask('q1')).toBeNull(); // concurrency reached for q1
+
+    expect(q.getNextTask('q2')).not.toBeNull();
+    expect(q.getNextTask('q2')).toBeNull(); // concurrency reached for q2
+  });
+
+  it('should still respect priority ordering with concurrency limit', () => {
+    const q = new TaskQueue();
+    q.setConcurrency('default', 1);
+    q.addTask('low', { priority: 10 });
+    q.addTask('high', { priority: 1 });
+
+    const got = q.getNextTask();
+    expect(got?.payload).toBe('high');
+  });
+
+  it('should query concurrency limit', () => {
+    const q = new TaskQueue();
+    expect(q.getConcurrency('default')).toBeNull();
+    q.setConcurrency('default', 5);
+    expect(q.getConcurrency('default')).toBe(5);
+  });
+
+  it('should query active count', () => {
+    const q = new TaskQueue();
+    q.addTask('a');
+    q.addTask('b');
+    expect(q.getActiveCount()).toBe(0);
+    q.getNextTask();
+    expect(q.getActiveCount()).toBe(1);
+    q.getNextTask();
+    expect(q.getActiveCount()).toBe(2);
+  });
+
+  it('should allow removing concurrency limit', () => {
+    const q = new TaskQueue();
+    q.setConcurrency('default', 1);
+    q.addTask('a');
+    q.addTask('b');
+    q.addTask('c');
+
+    q.getNextTask();
+    expect(q.getNextTask()).toBeNull();
+
+    // Remove limit
+    q.setConcurrency('default', null);
+    expect(q.getNextTask()).not.toBeNull();
+    expect(q.getNextTask()).not.toBeNull();
+  });
+
+  it('should return null even if pending tasks exist when concurrency is full', () => {
+    const q = new TaskQueue();
+    q.setConcurrency('default', 2);
+    q.addTask('a');
+    q.addTask('b');
+    q.addTask('c');
+    q.addTask('d');
+
+    q.getNextTask();
+    q.getNextTask();
+    expect(q.getPendingCount()).toBe(2); // 2 still pending
+    expect(q.getNextTask()).toBeNull(); // but can't process more
+  });
+});
+
+// ============================================================
+// Phase 9: Progress Tracking and Cancellation
+// ============================================================
+describe('Phase 9: Progress Tracking', () => {
+  it('should report progress on a processing task', () => {
+    const q = new TaskQueue();
+    const task = q.addTask('work');
+    q.getNextTask();
+
+    q.reportProgress(task.id, 50, 'halfway');
+    const progress = q.getProgress(task.id);
+    expect(progress?.percentage).toBe(50);
+    expect(progress?.message).toBe('halfway');
+  });
+
+  it('should not allow progress on non-processing task', () => {
+    const q = new TaskQueue();
+    const task = q.addTask('work');
+    expect(() => q.reportProgress(task.id, 50)).toThrow();
+  });
+
+  it('should reject invalid progress percentage', () => {
+    const q = new TaskQueue();
+    const task = q.addTask('work');
+    q.getNextTask();
+    expect(() => q.reportProgress(task.id, -1)).toThrow();
+    expect(() => q.reportProgress(task.id, 101)).toThrow();
+  });
+
+  it('should start progress at 0', () => {
+    const q = new TaskQueue();
+    const task = q.addTask('work');
+    const progress = q.getProgress(task.id);
+    expect(progress?.percentage).toBe(0);
+  });
+
+  it('should subscribe to progress updates', () => {
+    const q = new TaskQueue();
+    const task = q.addTask('work');
+    q.getNextTask();
+
+    const updates: Array<{ percentage: number; message?: string }> = [];
+    q.onProgress(task.id, (progress) => {
+      updates.push({ ...progress });
+    });
+
+    q.reportProgress(task.id, 25, 'quarter');
+    q.reportProgress(task.id, 50, 'half');
+    q.reportProgress(task.id, 100, 'done');
+
+    expect(updates).toHaveLength(3);
+    expect(updates[0]).toEqual({ percentage: 25, message: 'quarter' });
+    expect(updates[1]).toEqual({ percentage: 50, message: 'half' });
+    expect(updates[2]).toEqual({ percentage: 100, message: 'done' });
+  });
+
+  it('should allow unsubscribing from progress updates', () => {
+    const q = new TaskQueue();
+    const task = q.addTask('work');
+    q.getNextTask();
+
+    const updates: number[] = [];
+    const unsubscribe = q.onProgress(task.id, (progress) => {
+      updates.push(progress.percentage);
+    });
+
+    q.reportProgress(task.id, 25);
+    unsubscribe();
+    q.reportProgress(task.id, 50);
+
+    expect(updates).toHaveLength(1);
+    expect(updates[0]).toBe(25);
+  });
+
+  it('should support multiple listeners', () => {
+    const q = new TaskQueue();
+    const task = q.addTask('work');
+    q.getNextTask();
+
+    const updates1: number[] = [];
+    const updates2: number[] = [];
+
+    q.onProgress(task.id, (p) => updates1.push(p.percentage));
+    q.onProgress(task.id, (p) => updates2.push(p.percentage));
+
+    q.reportProgress(task.id, 50);
+
+    expect(updates1).toEqual([50]);
+    expect(updates2).toEqual([50]);
+  });
+
+  it('should return null progress for non-existent task', () => {
+    const q = new TaskQueue();
+    expect(q.getProgress('nonexistent')).toBeNull();
+  });
+});
+
+describe('Phase 9: Cancellation', () => {
+  it('should cancel a pending task', () => {
+    const q = new TaskQueue();
+    const task = q.addTask('work');
+    const result = q.cancelTask(task.id);
+    expect(result).toBe(true);
+    expect(q.getTask(task.id)?.status).toBe('cancelled');
+    expect(q.getNextTask()).toBeNull(); // task was removed
+  });
+
+  it('should cancel a processing task', () => {
+    const q = new TaskQueue();
+    const task = q.addTask('work');
+    q.getNextTask();
+    expect(task.status).toBe('processing');
+
+    const result = q.cancelTask(task.id);
+    expect(result).toBe(true);
+    expect(q.getTask(task.id)?.status).toBe('cancelled');
+  });
+
+  it('should cancel a blocked task', () => {
+    const q = new TaskQueue();
+    const t1 = q.addTask('first');
+    const t2 = q.addTask('second', { dependencies: [t1.id] });
+    expect(t2.status).toBe('blocked');
+
+    const result = q.cancelTask(t2.id);
+    expect(result).toBe(true);
+    expect(q.getTask(t2.id)?.status).toBe('cancelled');
+  });
+
+  it('should return false for completed task', () => {
+    const q = new TaskQueue();
+    const task = q.addTask('work');
+    q.getNextTask();
+    q.completeTask(task.id);
+
+    const result = q.cancelTask(task.id);
+    expect(result).toBe(false);
+  });
+
+  it('should return false for failed task', () => {
+    const q = new TaskQueue();
+    const task = q.addTask('work', { maxRetries: 0 });
+    q.getNextTask();
+    q.failTask(task.id, new Error('err'));
+
+    const result = q.cancelTask(task.id);
+    expect(result).toBe(false);
+  });
+
+  it('should return false for non-existent task', () => {
+    const q = new TaskQueue();
+    expect(q.cancelTask('nonexistent')).toBe(false);
+  });
+
+  it('should not return cancelled pending tasks from queue', () => {
+    const q = new TaskQueue();
+    q.addTask('a');
+    const t2 = q.addTask('b');
+    q.addTask('c');
+
+    q.cancelTask(t2.id);
+
+    const got1 = q.getNextTask();
+    expect(got1?.payload).toBe('a');
+    const got2 = q.getNextTask();
+    expect(got2?.payload).toBe('c');
+  });
+
+  it('should never retry a cancelled task', () => {
+    const q = new TaskQueue();
+    const task = q.addTask('work', { maxRetries: 5 });
+    q.getNextTask();
+    q.cancelTask(task.id);
+    expect(task.status).toBe('cancelled');
+    // The task should not be retried
+    expect(q.getNextTask()).toBeNull();
+  });
+
+  it('should free concurrency slot when task is cancelled', () => {
+    const q = new TaskQueue();
+    q.setConcurrency('default', 1);
+    const task = q.addTask('a');
+    q.addTask('b');
+
+    q.getNextTask();
+    expect(q.getNextTask()).toBeNull();
+
+    q.cancelTask(task.id);
+    // Concurrency slot freed, should be able to get next
+    const got = q.getNextTask();
+    expect(got?.payload).toBe('b');
+  });
+
+  it('should handle cancelling task and progress interaction', () => {
+    const q = new TaskQueue();
+    const task = q.addTask('work');
+    q.getNextTask();
+    q.reportProgress(task.id, 50, 'halfway');
+    q.cancelTask(task.id);
+    expect(task.status).toBe('cancelled');
+    // Progress should still be queryable
+    expect(q.getProgress(task.id)?.percentage).toBe(50);
+  });
+});
diff --git a/src/task-queue.ts b/src/task-queue.ts
new file mode 100644
index 0000000..ee805ad
--- /dev/null
+++ b/src/task-queue.ts
@@ -0,0 +1,1057 @@
+import { Task, TaskOptions, TaskProgress, ProgressListener, TaskStatus, createTask } from './task.js';
+
+// ---------- Types ----------
+
+export type TaskHandler<T = unknown> = (task: Task<T>, ctx: TaskContext) => unknown | Promise<unknown>;
+
+export interface TaskContext {
+  setProgress: (progress: number) => void;
+  isCancelled: () => boolean;
+}
+
+export type MiddlewareFn = (task: Task, next: () => Promise<void>) => void | Promise<void>;
+
+export interface RecurringSchedule {
+  id: string;
+  cronExpression: string;
+  queueName: string;
+  taskName: string;
+  taskData: unknown;
+  taskOptions?: Omit<TaskOptions, 'queueName'>;
+  lastRunAt?: number;
+  intervalMs: number;
+}
+
+export interface ShutdownResult {
+  completed: number;
+  forceCancelled: number;
+  durationMs: number;
+}
+
+// ---------- Cron Parser ----------
+
+function parseCronToIntervalMs(expression: string): number {
+  const parts = expression.trim().split(/\s+/);
+  if (parts.length !== 5) {
+    throw new Error(`Invalid cron expression: ${expression}`);
+  }
+
+  const [minute, hour] = parts;
+
+  // */N * * * * => every N minutes
+  const everyNMinutes = minute.match(/^\*\/(\d+)$/);
+  if (everyNMinutes) {
+    return parseInt(everyNMinutes[1], 10) * 60 * 1000;
+  }
+
+  // 0 * * * * => every hour
+  if (minute === '0' && hour === '*') {
+    return 60 * 60 * 1000;
+  }
+
+  // 0 0 * * * => every day at midnight
+  if (minute === '0' && hour === '0') {
+    return 24 * 60 * 60 * 1000;
+  }
+
+  throw new Error(`Unsupported cron expression: ${expression}`);
+}
+
+function shouldRunCron(schedule: RecurringSchedule, now: number): boolean {
+  if (!schedule.lastRunAt) {
+    return true;
+  }
+  return (now - schedule.lastRunAt) >= schedule.intervalMs;
+}
+
+// ---------- Queue State ----------
+
+interface QueueState {
+  tasks: Map<string, Task>;
+  deadLetterQueue: Task[];
+  concurrencyLimit: number | null;
+  handler?: TaskHandler;
+  middleware: MiddlewareFn[];
+  concurrency: number;
+  activeCount: number;
+  processing: boolean;
+  activePromises: Set<Promise<void>>;
+}
+
+// ---------- TaskQueue ----------
+
+export class TaskQueue {
+  private queues: Map<string, QueueState> = new Map();
+  private allTasks: Map<string, Task> = new Map();
+  private recurringSchedules: Map<string, RecurringSchedule> = new Map();
+  private recurringIdCounter = 0;
+  private shutdownRequested = false;
+  private shutdownPromise: Promise<ShutdownResult> | null = null;
+  private shutdownCallbacks: Array<() => void | Promise<void>> = [];
+
+  // -- Queue Management --
+
+  private getOrCreateQueue(name: string): QueueState {
+    let queue = this.queues.get(name);
+    if (!queue) {
+      queue = {
+        tasks: new Map(),
+        deadLetterQueue: [],
+        concurrencyLimit: null,
+        middleware: [],
+        concurrency: 1,
+        activeCount: 0,
+        processing: false,
+        activePromises: new Set(),
+      };
+      this.queues.set(name, queue);
+    }
+    return queue;
+  }
+
+  // ================================================================
+  // Bead-2 API: add(), next(), complete(), fail(), pendingCount()
+  // Used by tests/phases-1-4.test.ts, tests/phase-05-retry.test.ts,
+  //          tests/phase-06-dlq.test.ts, tests/phase-07-dependencies.test.ts
+  // ================================================================
+
+  add<T = unknown>(payload: T, options: TaskOptions = {}): Task<T> {
+    const queueName = options.queue ?? 'default';
+    const task = new Task<T>(payload, { ...options, queue: queueName });
+    const queue = this.getOrCreateQueue(queueName);
+
+    // Validate dependencies
+    if (task.dependencies.length > 0) {
+      for (const depId of task.dependencies) {
+        const dep = this.allTasks.get(depId);
+        if (!dep) {
+          throw new Error(`Dependency task not found: ${depId}`);
+        }
+      }
+      this.detectCircularDependencies(task.id, task.dependencies);
+    }
+
+    queue.tasks.set(task.id, task as Task);
+    this.allTasks.set(task.id, task as Task);
+
+    // Check if dependencies are already resolved
+    if (task.dependencies.length > 0) {
+      for (const depId of task.dependencies) {
+        const depTask = this.allTasks.get(depId);
+        if (depTask && depTask.status === 'completed') {
+          task.resolveDependency(depId);
+        }
+      }
+    }
+
+    return task;
+  }
+
+  /**
+   * Retrieve the next available task from a queue.
+   * Priority: lower number = higher priority (bead-2/3 convention).
+   */
+  next(queueName: string = 'default'): Task | null {
+    const queue = this.queues.get(queueName);
+    if (!queue) return null;
+
+    // Concurrency check
+    if (queue.concurrencyLimit !== null) {
+      const activeCount = this._getActiveCount(queue);
+      if (activeCount >= queue.concurrencyLimit) {
+        return null;
+      }
+    }
+
+    const now = new Date();
+    let best: Task | null = null;
+
+    for (const task of queue.tasks.values()) {
+      if (task.status !== 'pending') continue;
+      if (task.availableAt > now) continue;
+
+      // Check dependencies
+      if (task.dependencies.length > 0) {
+        const blocked = task.dependencies.some(depId => {
+          const dep = this.allTasks.get(depId);
+          return !dep || dep.status !== 'completed';
+        });
+        if (blocked) continue;
+      }
+
+      if (!best) {
+        best = task;
+        continue;
+      }
+
+      // Lower priority number = higher priority
+      if (task.priority < best.priority) {
+        best = task;
+      } else if (task.priority === best.priority) {
+        if (task.createdAt < best.createdAt) {
+          best = task;
+        }
+      }
+    }
+
+    if (best) {
+      best.status = 'processing';
+      best.attempts += 1;
+    }
+
+    return best;
+  }
+
+  /**
+   * Mark a task as completed (bead-2 API).
+   */
+  complete(taskId: string): Task {
+    const task = this.allTasks.get(taskId);
+    if (!task) {
+      throw new Error(`Task not found: ${taskId}`);
+    }
+    if (task.status !== 'processing') {
+      throw new Error(`Cannot complete task in status: ${task.status}`);
+    }
+    task.status = 'completed';
+    task.completedAt = new Date();
+
+    // Resolve dependents
+    for (const t of this.allTasks.values()) {
+      if (t.dependencies.includes(taskId)) {
+        t.resolveDependency(taskId);
+      }
+    }
+
+    return task;
+  }
+
+  /**
+   * Mark a task as failed (bead-2 API). If retries remain, re-queue with backoff.
+   * If retries exhausted, move to dead letter queue.
+   */
+  fail(taskId: string, error?: string): Task {
+    const task = this.allTasks.get(taskId);
+    if (!task) {
+      throw new Error(`Task not found: ${taskId}`);
+    }
+    if (task.status !== 'processing') {
+      throw new Error(`Cannot fail task in status: ${task.status}`);
+    }
+
+    task.error = error;
+
+    if (task.attempts <= task.maxRetries) {
+      // Retry with exponential backoff
+      const delay = task.backoffDelay * Math.pow(2, task.attempts - 1);
+      task.status = 'pending';
+      task.availableAt = new Date(Date.now() + delay);
+      return task;
+    }
+
+    // All retries exhausted  move to dead letter queue
+    task.status = 'dead-lettered';
+    task.failedAt = new Date();
+    const queue = this.queues.get(task.queue);
+    if (queue) {
+      queue.deadLetterQueue.push(task);
+    }
+    return task;
+  }
+
+  pendingCount(queueName: string = 'default'): number {
+    const queue = this.queues.get(queueName);
+    if (!queue) return 0;
+    let count = 0;
+    for (const task of queue.tasks.values()) {
+      if (task.status !== 'pending') continue;
+      if (task.availableAt > new Date()) continue;
+
+      // Check dependencies
+      if (task.dependencies.length > 0) {
+        const blocked = task.dependencies.some(depId => {
+          const dep = this.allTasks.get(depId);
+          return !dep || dep.status !== 'completed';
+        });
+        if (blocked) continue;
+      }
+
+      count++;
+    }
+    return count;
+  }
+
+  getQueueNames(): string[] {
+    return Array.from(this.queues.keys());
+  }
+
+  // ---- Dead Letter Queue methods (bead-2 API) ----
+
+  getDeadLetterTasks(queueName: string = 'default'): Task[] {
+    const queue = this.queues.get(queueName);
+    if (!queue) return [];
+    return [...queue.deadLetterQueue];
+  }
+
+  replayDeadLetterTask(taskId: string): Task {
+    const task = this.allTasks.get(taskId);
+    if (!task) {
+      throw new Error(`Task not found: ${taskId}`);
+    }
+    if (task.status !== 'dead-lettered') {
+      throw new Error(`Task is not in the dead letter queue: ${taskId}`);
+    }
+
+    const queue = this.queues.get(task.queue);
+    if (!queue) {
+      throw new Error(`Queue not found: ${task.queue}`);
+    }
+
+    // Remove from DLQ
+    const idx = queue.deadLetterQueue.findIndex(t => t.id === taskId);
+    if (idx !== -1) {
+      queue.deadLetterQueue.splice(idx, 1);
+    }
+
+    // Reset task for fresh processing
+    task.status = 'pending';
+    task.attempts = 0;
+    task.error = undefined;
+    task.failedAt = undefined;
+    task.availableAt = new Date();
+
+    return task;
+  }
+
+  clearDeadLetterQueue(queueName: string = 'default'): void {
+    const queue = this.queues.get(queueName);
+    if (queue) {
+      for (const task of queue.deadLetterQueue) {
+        this.allTasks.delete(task.id);
+      }
+      queue.deadLetterQueue = [];
+    }
+  }
+
+  deadLetterCount(queueName: string = 'default'): number {
+    const queue = this.queues.get(queueName);
+    if (!queue) return 0;
+    return queue.deadLetterQueue.length;
+  }
+
+  // ---- Task Dependencies (bead-2 API) ----
+
+  getDependencyStatus(taskId: string): { total: number; completed: number; pending: number; failed: number; dependencies: Array<{ id: string; status: string }> } {
+    const task = this.allTasks.get(taskId);
+    if (!task) {
+      throw new Error(`Task not found: ${taskId}`);
+    }
+
+    const deps = task.dependencies.map(depId => {
+      const dep = this.allTasks.get(depId);
+      return {
+        id: depId,
+        status: dep ? dep.status : 'not-found',
+      };
+    });
+
+    return {
+      total: deps.length,
+      completed: deps.filter(d => d.status === 'completed').length,
+      pending: deps.filter(d => d.status !== 'completed' && d.status !== 'failed' && d.status !== 'dead-lettered').length,
+      failed: deps.filter(d => d.status === 'failed' || d.status === 'dead-lettered').length,
+      dependencies: deps,
+    };
+  }
+
+  private detectCircularDependencies(taskId: string, dependencies: string[]): void {
+    const visited = new Set<string>();
+
+    const visit = (currentId: string): void => {
+      if (currentId === taskId) {
+        throw new Error(`Circular dependency detected involving task: ${taskId}`);
+      }
+      if (visited.has(currentId)) return;
+      visited.add(currentId);
+
+      const currentTask = this.allTasks.get(currentId);
+      if (currentTask) {
+        for (const depId of currentTask.dependencies) {
+          visit(depId);
+        }
+      }
+    };
+
+    for (const depId of dependencies) {
+      visit(depId);
+    }
+  }
+
+  // ================================================================
+  // Bead-3 API: addTask(payload, options), getNextTask(), completeTask(), failTask()
+  // Used by src/task-queue.test.ts
+  // ================================================================
+
+  addTask<T = unknown>(payloadOrName: T, dataOrOptions?: TaskOptions | T, maybeOptions?: TaskOptions): Task<T> {
+    // Distinguish between:
+    // 1. addTask(payload) - single arg
+    // 2. addTask(payload, options) - payload + options object (bead-3)
+    // 3. addTask(name, data, options?) - name + data + optional options (bead-4)
+
+    if (maybeOptions !== undefined) {
+      // 3-arg form: addTask(name, data, options)
+      return this._addTaskBead4(payloadOrName as unknown as string, dataOrOptions as T, maybeOptions);
+    }
+
+    if (dataOrOptions === undefined) {
+      // 1-arg form: addTask(payload)
+      return this._addTaskBead3(payloadOrName);
+    }
+
+    // 2-arg form: need to distinguish (payload, options) vs (name, data)
+    // Check if second arg looks like TaskOptions
+    if (this._isTaskOptions(dataOrOptions)) {
+      return this._addTaskBead3(payloadOrName, dataOrOptions as TaskOptions);
+    }
+
+    // Otherwise it's (name, data) with no options
+    return this._addTaskBead4(payloadOrName as unknown as string, dataOrOptions as T, {});
+  }
+
+  private _isTaskOptions(obj: unknown): boolean {
+    if (obj === null || typeof obj !== 'object') return false;
+    const keys = Object.keys(obj as object);
+    if (keys.length === 0) return false;
+    const optionKeys = new Set(['queue', 'queueName', 'priority', 'delay', 'availableAt', 'maxRetries', 'backoffDelay', 'retryDelay', 'backoffMultiplier', 'dependencies']);
+    return keys.every(k => optionKeys.has(k));
+  }
+
+  private _addTaskBead3<T = unknown>(payload: T, options: TaskOptions = {}): Task<T> {
+    const queueName = options.queue ?? 'default';
+
+    // Validate dependencies
+    if (options.dependencies && options.dependencies.length > 0) {
+      for (const depId of options.dependencies) {
+        const depTask = this.allTasks.get(depId);
+        if (!depTask) {
+          throw new Error(`Dependency task "${depId}" does not exist`);
+        }
+      }
+      this.checkCircularDependencies(options.dependencies, new Set());
+    }
+
+    const task = new Task<T>(payload, { ...options, queue: queueName });
+    const queue = this.getOrCreateQueue(queueName);
+    queue.tasks.set(task.id, task as Task);
+    this.allTasks.set(task.id, task as Task);
+
+    // Check if dependencies are already resolved
+    if (task.dependencies.length > 0) {
+      for (const depId of task.dependencies) {
+        const depTask = this.allTasks.get(depId);
+        if (depTask && depTask.status === 'completed') {
+          task.resolveDependency(depId);
+        }
+      }
+    }
+
+    return task;
+  }
+
+  private _addTaskBead4<T = unknown>(name: string, data: T, options: TaskOptions = {}): Task<T> {
+    if (this.shutdownRequested) {
+      throw new Error('Queue is shutting down, cannot add new tasks');
+    }
+
+    const queueName = options.queueName ?? 'default';
+    const task = createTask(name, data, { ...options, queueName });
+    const queue = this.getOrCreateQueue(queueName);
+    queue.tasks.set(task.id, task as Task);
+    return task;
+  }
+
+  // Bead-3 circular dependency detection
+  private checkCircularDependencies(
+    dependencyIds: string[],
+    visited: Set<string>,
+  ): void {
+    for (const depId of dependencyIds) {
+      if (visited.has(depId)) {
+        throw new Error('Circular dependency detected');
+      }
+      visited.add(depId);
+      const depTask = this.allTasks.get(depId);
+      if (depTask && depTask.dependencies.length > 0) {
+        this.checkCircularDependencies(depTask.dependencies, new Set(visited));
+      }
+    }
+  }
+
+  /**
+   * Get next task (bead-3 API). Lower priority number = higher priority.
+   */
+  getNextTask(queueName = 'default'): Task | null {
+    const queue = this.queues.get(queueName);
+    if (!queue) return null;
+
+    // Concurrency check
+    if (queue.concurrencyLimit !== null) {
+      const activeCount = this._getActiveCount(queue);
+      if (activeCount >= queue.concurrencyLimit) {
+        return null;
+      }
+    }
+
+    const now = new Date();
+    const available: Task[] = [];
+
+    for (const task of queue.tasks.values()) {
+      if (task.isAvailable(now)) {
+        available.push(task);
+      }
+    }
+
+    if (available.length === 0) return null;
+
+    // Sort by: priority asc (lower = higher), then createdAt asc (FIFO)
+    available.sort((a, b) => {
+      if (a.priority !== b.priority) return a.priority - b.priority;
+      const aTime = a.availableAt.getTime();
+      const bTime = b.availableAt.getTime();
+      if (aTime !== bTime) return aTime - bTime;
+      return a.createdAt.getTime() - b.createdAt.getTime();
+    });
+
+    const task = available[0];
+    task.status = 'processing';
+    task.attempts++;
+    return task;
+  }
+
+  getPendingCount(queueName = 'default'): number {
+    const queue = this.queues.get(queueName);
+    if (!queue) return 0;
+    let count = 0;
+    const now = new Date();
+    for (const task of queue.tasks.values()) {
+      if (task.isAvailable(now)) {
+        count++;
+      }
+    }
+    return count;
+  }
+
+  getTask(taskId: string, queueName?: string): Task | null {
+    if (queueName) {
+      return this.queues.get(queueName)?.tasks.get(taskId) ?? null;
+    }
+    // Check allTasks first (for bead-2/3 API)
+    const fromAll = this.allTasks.get(taskId);
+    if (fromAll) return fromAll;
+    // Then check all queues (for bead-4 API)
+    for (const queue of this.queues.values()) {
+      const task = queue.tasks.get(taskId);
+      if (task) return task;
+    }
+    return null;
+  }
+
+  completeTask(taskId: string): void {
+    const task = this.allTasks.get(taskId);
+    if (!task) {
+      throw new Error(`Task "${taskId}" not found`);
+    }
+    if (task.status !== 'processing') {
+      throw new Error(`Cannot complete task with status "${task.status}"`);
+    }
+    task.status = 'completed';
+
+    // Resolve dependents
+    for (const t of this.allTasks.values()) {
+      if (t.dependencies.includes(taskId)) {
+        t.resolveDependency(taskId);
+      }
+    }
+  }
+
+  failTask(taskId: string, error?: Error): void {
+    const task = this.allTasks.get(taskId);
+    if (!task) {
+      throw new Error(`Task "${taskId}" not found`);
+    }
+    if (task.status !== 'processing') {
+      throw new Error(`Cannot fail task with status "${task.status}"`);
+    }
+
+    task.lastError = error;
+
+    if (task.attempts < task.maxRetries) {
+      // Retry with backoff
+      const delay = task.backoffDelay * Math.pow(2, task.attempts - 1);
+      task.availableAt = new Date(Date.now() + delay);
+      task.status = 'pending';
+      task.progress = 0;
+    } else {
+      // Move to dead letter queue
+      task.status = 'failed';
+      const queue = this.queues.get(task.queueName);
+      if (queue) {
+        queue.tasks.delete(task.id);
+        queue.deadLetterQueue.push(task);
+      }
+    }
+  }
+
+  getDeadLetterQueue(queueName = 'default'): Task[] {
+    const queue = this.queues.get(queueName);
+    if (!queue) return [];
+    return [...queue.deadLetterQueue];
+  }
+
+  retryDeadLetter(taskId: string): Task | null {
+    for (const queue of this.queues.values()) {
+      const idx = queue.deadLetterQueue.findIndex(t => t.id === taskId);
+      if (idx !== -1) {
+        const task = queue.deadLetterQueue[idx];
+        queue.deadLetterQueue.splice(idx, 1);
+        task.status = 'pending';
+        task.attempts = 0;
+        task.lastError = undefined;
+        task.availableAt = new Date();
+        task.progress = 0;
+        queue.tasks.set(task.id, task);
+        return task;
+      }
+    }
+    return null;
+  }
+
+  // Phase 8: Concurrency
+  setConcurrency(queueName: string, limit: number | null): void {
+    const queue = this.getOrCreateQueue(queueName);
+    queue.concurrencyLimit = limit;
+    queue.concurrency = limit ?? 1;
+  }
+
+  getConcurrency(queueName = 'default'): number | null {
+    const queue = this.queues.get(queueName);
+    if (!queue) return null;
+    return queue.concurrencyLimit;
+  }
+
+  getActiveCount(queueName = 'default'): number {
+    const queue = this.queues.get(queueName);
+    if (!queue) return 0;
+    return this._getActiveCount(queue);
+  }
+
+  private _getActiveCount(queue: QueueState): number {
+    let count = 0;
+    for (const task of queue.tasks.values()) {
+      if (task.status === 'processing') {
+        count++;
+      }
+    }
+    return count;
+  }
+
+  // Phase 9: Progress
+  reportProgress(taskId: string, percentage: number, message?: string): void {
+    const task = this.allTasks.get(taskId);
+    if (!task) {
+      throw new Error(`Task "${taskId}" not found`);
+    }
+    task.reportProgress(percentage, message);
+  }
+
+  getProgress(taskId: string): TaskProgress | null {
+    const task = this.allTasks.get(taskId);
+    if (!task) return null;
+    return task.getProgressObj();
+  }
+
+  onProgress(taskId: string, listener: ProgressListener): () => void {
+    const task = this.allTasks.get(taskId);
+    if (!task) {
+      throw new Error(`Task "${taskId}" not found`);
+    }
+    return task.onProgress(listener);
+  }
+
+  // Phase 9: Cancellation
+  cancelTask(taskId: string, queueName?: string): boolean {
+    const task = this.getTask(taskId, queueName);
+    if (!task) return false;
+
+    if (task.status === 'completed' || task.status === 'failed' || task.status === 'dead' || task.status === 'dead-lettered' || task.status === 'cancelled') {
+      return false;
+    }
+
+    if (task.status === 'processing') {
+      task.status = 'cancelled';
+      task.cancelRequested = true;
+      const q = this.queues.get(task.queueName);
+      if (q) {
+        q.tasks.delete(task.id);
+      }
+      return true;
+    }
+
+    if (task.status === 'pending' || task.status === 'blocked') {
+      task.status = 'cancelled';
+      const q = this.queues.get(task.queueName);
+      if (q) {
+        q.tasks.delete(task.id);
+      }
+      return true;
+    }
+
+    // running status (bead-4 API)
+    if (task.status === 'running') {
+      task.cancelRequested = true;
+      return true;
+    }
+
+    task.status = 'cancelled';
+    task.cancelledAt = Date.now();
+    return true;
+  }
+
+  // ================================================================
+  // Bead-4 API: process(), registerHandler(), middleware, recurring, shutdown
+  // Used by tests/basic.test.ts, tests/phase-10/11/12
+  // ================================================================
+
+  getAllTasks(queueName: string = 'default'): Task[] {
+    const queue = this.queues.get(queueName);
+    if (!queue) return [];
+    return Array.from(queue.tasks.values());
+  }
+
+  getTasksByStatus(status: TaskStatus, queueName: string = 'default'): Task[] {
+    return this.getAllTasks(queueName).filter(t => t.status === status);
+  }
+
+  // Handler registration
+  registerHandler(queueName: string, handler: TaskHandler): void {
+    const queue = this.getOrCreateQueue(queueName);
+    queue.handler = handler;
+  }
+
+  // Middleware
+  use(queueName: string, middleware: MiddlewareFn): void {
+    const queue = this.getOrCreateQueue(queueName);
+    queue.middleware.push(middleware);
+  }
+
+  getMiddleware(queueName: string): MiddlewareFn[] {
+    return this.queues.get(queueName)?.middleware ?? [];
+  }
+
+  // Processing (bead-4 style, higher priority number = higher priority)
+  async process(queueName: string = 'default', handler?: TaskHandler): Promise<void> {
+    const queue = this.getOrCreateQueue(queueName);
+
+    if (handler) {
+      queue.handler = handler;
+    }
+
+    const effectiveHandler = queue.handler;
+    if (!effectiveHandler) {
+      throw new Error(`No handler registered for queue "${queueName}"`);
+    }
+
+    // Promote delayed tasks
+    this.promoteDelayedTasks(queueName);
+    // Check dependency readiness
+    this.promoteDependentTasks(queueName);
+
+    // Get next available pending tasks up to concurrency limit
+    const pendingTasks = this.getNextPendingTasks(queue);
+
+    if (pendingTasks.length === 0) return;
+
+    const promises: Promise<void>[] = [];
+
+    for (const task of pendingTasks) {
+      const promise = this.processTask(task, effectiveHandler, queue);
+      queue.activePromises.add(promise);
+      promise.finally(() => queue.activePromises.delete(promise));
+      promises.push(promise);
+    }
+
+    await Promise.all(promises);
+
+    // After processing, check if more tasks are available (chain processing)
+    this.promoteDelayedTasks(queueName);
+    this.promoteDependentTasks(queueName);
+    const morePending = this.getNextPendingTasks(queue);
+    if (morePending.length > 0) {
+      await this.process(queueName);
+    }
+  }
+
+  private promoteDelayedTasks(queueName: string): void {
+    const queue = this.queues.get(queueName);
+    if (!queue) return;
+
+    const now = Date.now();
+    for (const task of queue.tasks.values()) {
+      if (task.status === 'delayed' && now >= task.availableAt.getTime()) {
+        task.status = 'pending';
+      }
+    }
+  }
+
+  private promoteDependentTasks(queueName: string): void {
+    const queue = this.queues.get(queueName);
+    if (!queue) return;
+
+    for (const task of queue.tasks.values()) {
+      if (task.status === 'waiting') {
+        const allDepsCompleted = task.dependencies.every(depId => {
+          const dep = this.getTask(depId);
+          return dep && dep.status === 'completed';
+        });
+        if (allDepsCompleted) {
+          if (task.availableAt.getTime() > Date.now()) {
+            task.status = 'delayed';
+          } else {
+            task.status = 'pending';
+          }
+        }
+      }
+    }
+  }
+
+  private getNextPendingTasks(queue: QueueState): Task[] {
+    const availableSlots = queue.concurrency - queue.activeCount;
+    if (availableSlots <= 0) return [];
+
+    const pending = Array.from(queue.tasks.values())
+      .filter(t => t.status === 'pending')
+      .sort((a, b) => {
+        // Higher priority number = higher priority (bead-4 convention)
+        if (b.priority !== a.priority) return b.priority - a.priority;
+        return a.createdAt.getTime() - b.createdAt.getTime();
+      });
+
+    return pending.slice(0, availableSlots);
+  }
+
+  private async processTask(task: Task, handler: TaskHandler, queue: QueueState): Promise<void> {
+    task.status = 'running';
+    task.startedAt = Date.now();
+    task.progress = 0;
+    queue.activeCount++;
+
+    const ctx: TaskContext = {
+      setProgress: (progress: number) => {
+        task.progress = Math.max(0, Math.min(100, progress));
+      },
+      isCancelled: () => task.cancelRequested,
+    };
+
+    try {
+      // Build middleware chain
+      const middlewareStack = [...queue.middleware];
+      let handlerCalled = false;
+
+      const executeChain = (index: number): (() => Promise<void>) => {
+        return async () => {
+          if (index < middlewareStack.length) {
+            await middlewareStack[index](task, executeChain(index + 1));
+          } else {
+            handlerCalled = true;
+            const result = await handler(task, ctx);
+            task.result = result;
+          }
+        };
+      };
+
+      await executeChain(0)();
+
+      if (task.cancelRequested) {
+        task.status = 'cancelled';
+        task.cancelledAt = Date.now();
+      } else if (!handlerCalled) {
+        task.status = 'completed';
+        task.completedAt = new Date();
+        task.progress = 100;
+      } else {
+        task.status = 'completed';
+        task.completedAt = new Date();
+        task.progress = 100;
+      }
+    } catch (error: unknown) {
+      const errorMessage = error instanceof Error ? error.message : String(error);
+      task.error = errorMessage;
+      task.failedAt = new Date();
+
+      if (task.retryCount < task.maxRetries) {
+        task.retryCount++;
+        const retryDelay = task.retryDelay * Math.pow(task.backoffMultiplier, task.retryCount - 1);
+        task.availableAt = new Date(Date.now() + retryDelay);
+        task.status = 'pending';
+        task.error = undefined;
+        task.failedAt = undefined;
+      } else if (task.maxRetries > 0) {
+        task.status = 'dead';
+        queue.deadLetterQueue.push(task);
+      } else {
+        task.status = 'failed';
+      }
+    } finally {
+      queue.activeCount--;
+    }
+  }
+
+  // -- Recurring Tasks (Phase 10) --
+
+  addRecurringTask(
+    cronExpression: string,
+    queueName: string,
+    taskName: string,
+    taskData: unknown,
+    taskOptions?: Omit<TaskOptions, 'queueName'>
+  ): RecurringSchedule {
+    if (this.shutdownRequested) {
+      throw new Error('Queue is shutting down, cannot add recurring tasks');
+    }
+
+    const intervalMs = parseCronToIntervalMs(cronExpression);
+    const id = `recurring-${++this.recurringIdCounter}`;
+
+    const schedule: RecurringSchedule = {
+      id,
+      cronExpression,
+      queueName,
+      taskName,
+      taskData,
+      taskOptions,
+      intervalMs,
+    };
+
+    this.recurringSchedules.set(id, schedule);
+    return schedule;
+  }
+
+  removeRecurringTask(id: string): boolean {
+    return this.recurringSchedules.delete(id);
+  }
+
+  getRecurringTasks(): RecurringSchedule[] {
+    return Array.from(this.recurringSchedules.values());
+  }
+
+  tick(now?: number): Task[] {
+    const currentTime = now ?? Date.now();
+    const created: Task[] = [];
+
+    for (const schedule of this.recurringSchedules.values()) {
+      if (shouldRunCron(schedule, currentTime)) {
+        const task = this._addTaskBead4(schedule.taskName, schedule.taskData, {
+          ...schedule.taskOptions,
+          queueName: schedule.queueName,
+        });
+        created.push(task as Task);
+        schedule.lastRunAt = currentTime;
+      }
+    }
+
+    return created;
+  }
+
+  // -- Graceful Shutdown (Phase 12) --
+
+  onShutdown(callback: () => void | Promise<void>): void {
+    this.shutdownCallbacks.push(callback);
+  }
+
+  async shutdown(timeoutMs: number = 5000): Promise<ShutdownResult> {
+    if (this.shutdownPromise) {
+      return this.shutdownPromise;
+    }
+
+    this.shutdownRequested = true;
+    this.shutdownPromise = this.performShutdown(timeoutMs);
+    return this.shutdownPromise;
+  }
+
+  get isShuttingDown(): boolean {
+    return this.shutdownRequested;
+  }
+
+  private async performShutdown(timeoutMs: number): Promise<ShutdownResult> {
+    const startTime = Date.now();
+
+    // Clear all recurring schedules
+    this.recurringSchedules.clear();
+
+    // Gather all active promises across all queues
+    const allActivePromises: Promise<void>[] = [];
+    const runningTasks: Task[] = [];
+
+    for (const queue of this.queues.values()) {
+      for (const promise of queue.activePromises) {
+        allActivePromises.push(promise);
+      }
+      for (const task of queue.tasks.values()) {
+        if (task.status === 'running') {
+          runningTasks.push(task);
+        }
+      }
+    }
+
+    let completed = 0;
+    let forceCancelled = 0;
+
+    if (allActivePromises.length > 0) {
+      const timeoutPromise = new Promise<'timeout'>((resolve) =>
+        setTimeout(() => resolve('timeout'), timeoutMs)
+      );
+
+      const result = await Promise.race([
+        Promise.all(allActivePromises).then(() => 'done' as const),
+        timeoutPromise,
+      ]);
+
+      if (result === 'timeout') {
+        for (const queue of this.queues.values()) {
+          for (const task of queue.tasks.values()) {
+            if (task.status === 'running') {
+              task.cancelRequested = true;
+              task.status = 'cancelled';
+              task.cancelledAt = Date.now();
+              forceCancelled++;
+            }
+          }
+        }
+      }
+    }
+
+    // Count completed tasks
+    for (const task of runningTasks) {
+      if (task.status === 'completed') {
+        completed++;
+      }
+    }
+
+    // Run shutdown callbacks
+    for (const callback of this.shutdownCallbacks) {
+      try {
+        await callback();
+      } catch {
+        // Ignore callback errors during shutdown
+      }
+    }
+
+    const durationMs = Date.now() - startTime;
+
+    return {
+      completed,
+      forceCancelled,
+      durationMs,
+    };
+  }
+}
diff --git a/src/task.ts b/src/task.ts
new file mode 100644
index 0000000..93bbf92
--- /dev/null
+++ b/src/task.ts
@@ -0,0 +1,219 @@
+import { randomUUID } from 'node:crypto';
+
+export type TaskStatus =
+  | 'pending'
+  | 'processing'
+  | 'completed'
+  | 'failed'
+  | 'dead-lettered'
+  | 'cancelled'
+  | 'blocked'
+  | 'waiting'
+  | 'delayed'
+  | 'running'
+  | 'dead';
+
+export interface TaskProgress {
+  percentage: number;
+  message?: string;
+}
+
+export type ProgressListener = (progress: TaskProgress) => void;
+
+export interface TaskOptions {
+  queue?: string;
+  queueName?: string;
+  priority?: number;
+  delay?: number;
+  availableAt?: Date;
+  maxRetries?: number;
+  backoffDelay?: number;
+  retryDelay?: number;
+  backoffMultiplier?: number;
+  dependencies?: string[];
+}
+
+export class Task<T = unknown> {
+  readonly id: string;
+  readonly createdAt: Date;
+
+  // Dual API: bead-2/3 use "payload"/"queue", bead-4 uses "name"/"data"/"queueName"
+  readonly payload: T;
+  readonly name: string;
+  readonly data: T;
+  readonly queueName: string;
+
+  // Alias for queueName (used by bead-2/3 tests)
+  get queue(): string {
+    return this.queueName;
+  }
+
+  status: TaskStatus;
+  priority: number;
+  availableAt: Date;
+
+  // Retry
+  maxRetries: number;
+  backoffDelay: number;
+  retryDelay: number;
+  backoffMultiplier: number;
+  attempts: number;
+  retryCount: number;
+  lastError?: Error;
+  error?: string;
+  result?: unknown;
+  completedAt?: Date;
+  failedAt?: Date;
+  startedAt?: number;
+
+  // Dependencies
+  dependencies: string[];
+  resolvedDependencies: Set<string>;
+
+  // Progress (Phase 9)
+  progress: number;
+  private _progressMessage?: string;
+  private progressListeners: Map<number, ProgressListener>;
+  private nextListenerId: number;
+
+  // Cancellation
+  cancelRequested: boolean;
+  cancelledAt?: number;
+
+  constructor(payload: T, options: TaskOptions = {}, name?: string) {
+    this.id = randomUUID();
+    this.createdAt = new Date();
+
+    // Dual API support
+    this.payload = payload;
+    if (name !== undefined) {
+      this.name = name;
+      this.data = payload;
+    } else {
+      this.name = '';
+      this.data = payload;
+    }
+
+    this.queueName = options.queueName ?? options.queue ?? 'default';
+
+    // Priority (Phase 3)
+    const priority = options.priority ?? 5;
+    if (priority < 1 || priority > 10 || !Number.isInteger(priority)) {
+      throw new Error(`Invalid priority: ${priority}. Must be an integer between 1 and 10.`);
+    }
+    this.priority = priority;
+
+    // Delay (Phase 4)
+    if (options.availableAt) {
+      this.availableAt = options.availableAt;
+    } else if (options.delay !== undefined && options.delay > 0) {
+      this.availableAt = new Date(Date.now() + options.delay);
+    } else {
+      this.availableAt = this.createdAt;
+    }
+
+    // Retry (Phase 5)
+    this.maxRetries = options.maxRetries ?? 3;
+    this.backoffDelay = options.backoffDelay ?? 1000;
+    this.retryDelay = options.retryDelay ?? this.backoffDelay;
+    this.backoffMultiplier = options.backoffMultiplier ?? 2;
+    this.attempts = 0;
+    this.retryCount = 0;
+
+    // Dependencies (Phase 7)
+    this.dependencies = options.dependencies ?? [];
+    this.resolvedDependencies = new Set();
+
+    // Status
+    if (this.dependencies.length > 0) {
+      this.status = 'blocked';
+    } else {
+      this.status = 'pending';
+    }
+
+    // Progress (Phase 9)
+    this.progress = 0;
+    this._progressMessage = undefined;
+    this.progressListeners = new Map();
+    this.nextListenerId = 0;
+
+    // Cancellation
+    this.cancelRequested = false;
+  }
+
+  isAvailable(now: Date = new Date()): boolean {
+    if (this.status !== 'pending') return false;
+    return now >= this.availableAt;
+  }
+
+  get isBlocked(): boolean {
+    return this.status === 'blocked';
+  }
+
+  get unresolvedDependencies(): string[] {
+    return this.dependencies.filter(d => !this.resolvedDependencies.has(d));
+  }
+
+  resolveDependency(taskId: string): void {
+    this.resolvedDependencies.add(taskId);
+    if (this.status === 'blocked' && this.unresolvedDependencies.length === 0) {
+      this.status = 'pending';
+    }
+  }
+
+  // Phase 9: Progress reporting
+  reportProgress(percentage: number, message?: string): void {
+    if (this.status !== 'processing') {
+      throw new Error(`Cannot report progress on task with status "${this.status}"`);
+    }
+    if (percentage < 0 || percentage > 100) {
+      throw new Error(`Progress percentage must be between 0 and 100, got ${percentage}`);
+    }
+    this.progress = percentage;
+    this._progressMessage = message;
+    const progressObj: TaskProgress = { percentage, message };
+    for (const listener of this.progressListeners.values()) {
+      listener(progressObj);
+    }
+  }
+
+  getProgressObj(): TaskProgress {
+    return { percentage: this.progress, message: this._progressMessage };
+  }
+
+  onProgress(listener: ProgressListener): () => void {
+    const id = this.nextListenerId++;
+    this.progressListeners.set(id, listener);
+    return () => {
+      this.progressListeners.delete(id);
+    };
+  }
+}
+
+let taskIdCounter = 0;
+
+export function createTask<T = unknown>(name: string, data: T, options: TaskOptions = {}): Task<T> {
+  // Bead-4 defaults: maxRetries=0, retryDelay=1000, backoffMultiplier=1
+  const bead4Options: TaskOptions = {
+    ...options,
+    maxRetries: options.maxRetries ?? 0,
+    retryDelay: options.retryDelay ?? 1000,
+    backoffMultiplier: options.backoffMultiplier ?? 1,
+  };
+  const task = new Task<T>(data, bead4Options, name);
+  // Override ID with sequential counter for bead-4 compatibility
+  (task as { id: string }).id = `task-${++taskIdCounter}`;
+
+  // Bead-4 uses 'delayed' and 'waiting' instead of 'pending' and 'blocked'
+  if (task.dependencies.length > 0) {
+    task.status = 'waiting';
+  } else if (bead4Options.delay !== undefined && bead4Options.delay > 0) {
+    task.status = 'delayed';
+  }
+
+  return task;
+}
+
+export function resetTaskIdCounter(): void {
+  taskIdCounter = 0;
+}
diff --git a/tests/basic.test.ts b/tests/basic.test.ts
new file mode 100644
index 0000000..4e4aad5
--- /dev/null
+++ b/tests/basic.test.ts
@@ -0,0 +1,183 @@
+import { describe, it, expect, beforeEach } from 'vitest';
+import { TaskQueue, resetTaskIdCounter } from '../src/index.js';
+
+describe('Basic Task Queue (Phases 1-9)', () => {
+  let queue: TaskQueue;
+
+  beforeEach(() => {
+    resetTaskIdCounter();
+    queue = new TaskQueue();
+  });
+
+  describe('Phase 1: Basic Queue', () => {
+    it('should add and retrieve tasks', () => {
+      const task = queue.addTask('test', { value: 1 });
+      expect(task.id).toBeDefined();
+      expect(task.name).toBe('test');
+      expect(task.data).toEqual({ value: 1 });
+      expect(task.status).toBe('pending');
+    });
+
+    it('should process tasks', async () => {
+      queue.addTask('test', { value: 1 });
+      let processed = false;
+      await queue.process('default', async () => {
+        processed = true;
+      });
+      expect(processed).toBe(true);
+    });
+
+    it('should get task by id', () => {
+      const task = queue.addTask('test', {});
+      const found = queue.getTask(task.id);
+      expect(found).toBe(task);
+    });
+  });
+
+  describe('Phase 2: Named Queues', () => {
+    it('should support multiple queues', () => {
+      queue.addTask('task1', {}, { queueName: 'queue1' });
+      queue.addTask('task2', {}, { queueName: 'queue2' });
+      expect(queue.getAllTasks('queue1')).toHaveLength(1);
+      expect(queue.getAllTasks('queue2')).toHaveLength(1);
+    });
+  });
+
+  describe('Phase 3: Priority', () => {
+    it('should process higher priority tasks first', async () => {
+      queue.addTask('low', {}, { priority: 1 });
+      queue.addTask('high', {}, { priority: 10 });
+      queue.addTask('mid', {}, { priority: 5 });
+
+      const order: string[] = [];
+      // Process one at a time
+      queue.setConcurrency('default', 1);
+      await queue.process('default', async (task) => {
+        order.push(task.name);
+      });
+
+      expect(order).toEqual(['high', 'mid', 'low']);
+    });
+  });
+
+  describe('Phase 4: Delayed Tasks', () => {
+    it('should delay task processing', () => {
+      const task = queue.addTask('delayed', {}, { delay: 10000 });
+      expect(task.status).toBe('delayed');
+    });
+  });
+
+  describe('Phase 5: Retry', () => {
+    it('should retry failed tasks', async () => {
+      let attempts = 0;
+      queue.addTask('retry-task', {}, { maxRetries: 2 });
+
+      // Process multiple times to handle retries
+      for (let i = 0; i < 3; i++) {
+        await queue.process('default', async () => {
+          attempts++;
+          if (attempts < 3) throw new Error('fail');
+          return 'success';
+        });
+      }
+
+      expect(attempts).toBe(3);
+    });
+  });
+
+  describe('Phase 6: Dead Letter Queue', () => {
+    it('should move permanently failed tasks to DLQ', async () => {
+      queue.addTask('fail-task', {}, { maxRetries: 1, retryDelay: 0 });
+
+      // Process all retries
+      for (let i = 0; i < 3; i++) {
+        await queue.process('default', async () => {
+          throw new Error('permanent failure');
+        });
+      }
+
+      const dlq = queue.getDeadLetterQueue('default');
+      expect(dlq.length).toBeGreaterThanOrEqual(1);
+    });
+  });
+
+  describe('Phase 7: Task Dependencies', () => {
+    it('should wait for dependencies before processing', async () => {
+      const task1 = queue.addTask('dep', { step: 1 });
+      const task2 = queue.addTask('dependent', { step: 2 }, { dependencies: [task1.id] });
+
+      expect(task2.status).toBe('waiting');
+
+      const order: number[] = [];
+      await queue.process('default', async (task) => {
+        order.push((task.data as { step: number }).step);
+      });
+
+      expect(order[0]).toBe(1);
+      // task2 should be promoted after task1 completes
+      await queue.process('default', async (task) => {
+        order.push((task.data as { step: number }).step);
+      });
+      expect(order).toEqual([1, 2]);
+    });
+  });
+
+  describe('Phase 8: Concurrency', () => {
+    it('should respect concurrency limits', async () => {
+      queue.setConcurrency('default', 2);
+      let maxConcurrent = 0;
+      let currentConcurrent = 0;
+
+      for (let i = 0; i < 4; i++) {
+        queue.addTask(`task-${i}`, {});
+      }
+
+      await queue.process('default', async () => {
+        currentConcurrent++;
+        maxConcurrent = Math.max(maxConcurrent, currentConcurrent);
+        await new Promise(resolve => setTimeout(resolve, 50));
+        currentConcurrent--;
+      });
+
+      expect(maxConcurrent).toBeLessThanOrEqual(2);
+    });
+  });
+
+  describe('Phase 9: Progress and Cancellation', () => {
+    it('should track progress', async () => {
+      const task = queue.addTask('progress-task', {});
+
+      await queue.process('default', async (_task, ctx) => {
+        ctx.setProgress(50);
+        expect(task.progress).toBe(50);
+        ctx.setProgress(100);
+      });
+
+      expect(task.progress).toBe(100);
+    });
+
+    it('should support cancellation', async () => {
+      const task = queue.addTask('cancel-task', {});
+      expect(queue.cancelTask(task.id)).toBe(true);
+      expect(task.status).toBe('cancelled');
+    });
+
+    it('should signal cancellation to running tasks', async () => {
+      const task = queue.addTask('cancel-running', {});
+      let wasCancelled = false;
+
+      const processPromise = queue.process('default', async (_task, ctx) => {
+        // Simulate work
+        await new Promise(resolve => setTimeout(resolve, 50));
+        wasCancelled = ctx.isCancelled();
+        return 'done';
+      });
+
+      await new Promise(resolve => setTimeout(resolve, 20));
+      queue.cancelTask(task.id);
+
+      await processPromise;
+      expect(wasCancelled).toBe(true);
+    });
+  });
+});
diff --git a/tests/phase-05-retry.test.ts b/tests/phase-05-retry.test.ts
new file mode 100644
index 0000000..0cf74e2
--- /dev/null
+++ b/tests/phase-05-retry.test.ts
@@ -0,0 +1,166 @@
+import { describe, it, expect } from 'vitest';
+import { TaskQueue } from '../src/task-queue.js';
+
+describe('Phase 5: Retry with Backoff', () => {
+  it('should track attempt count on tasks', () => {
+    const tq = new TaskQueue();
+    const task = tq.add('work');
+    expect(task.attempts).toBe(0);
+
+    const processing = tq.next()!;
+    expect(processing.attempts).toBe(1);
+  });
+
+  it('should complete a task successfully', () => {
+    const tq = new TaskQueue();
+    const task = tq.add('work');
+    tq.next();
+    const completed = tq.complete(task.id);
+    expect(completed.status).toBe('completed');
+    expect(completed.completedAt).toBeInstanceOf(Date);
+  });
+
+  it('should throw when completing a non-processing task', () => {
+    const tq = new TaskQueue();
+    const task = tq.add('work');
+    expect(() => tq.complete(task.id)).toThrow();
+  });
+
+  it('should re-queue a failed task with retries remaining', () => {
+    const tq = new TaskQueue();
+    const task = tq.add('work', { maxRetries: 3, backoffDelay: 100 });
+    tq.next(); // attempt 1
+
+    const failed = tq.fail(task.id, 'oops');
+    expect(failed.status).toBe('pending');
+    expect(failed.error).toBe('oops');
+    expect(failed.attempts).toBe(1);
+    // Should have a future availableAt due to backoff
+    expect(failed.availableAt.getTime()).toBeGreaterThan(Date.now() - 100);
+  });
+
+  it('should apply exponential backoff delays', () => {
+    const tq = new TaskQueue();
+    const task = tq.add('work', { maxRetries: 3, backoffDelay: 1000 });
+
+    // Attempt 1
+    tq.next();
+    const before1 = Date.now();
+    tq.fail(task.id, 'fail 1');
+    // Delay should be 1000 * 2^(1-1) = 1000ms
+    expect(task.availableAt.getTime()).toBeGreaterThanOrEqual(before1 + 1000 - 10);
+
+    // Manually make the task available again for testing
+    task.availableAt = new Date(Date.now() - 1);
+
+    // Attempt 2
+    tq.next();
+    const before2 = Date.now();
+    tq.fail(task.id, 'fail 2');
+    // Delay should be 1000 * 2^(2-1) = 2000ms
+    expect(task.availableAt.getTime()).toBeGreaterThanOrEqual(before2 + 2000 - 10);
+  });
+
+  it('should default maxRetries to 3', () => {
+    const tq = new TaskQueue();
+    const task = tq.add('work');
+    expect(task.maxRetries).toBe(3);
+  });
+
+  it('should default backoffDelay to 1000ms', () => {
+    const tq = new TaskQueue();
+    const task = tq.add('work');
+    expect(task.backoffDelay).toBe(1000);
+  });
+
+  it('should allow configuring maxRetries per task', () => {
+    const tq = new TaskQueue();
+    const task = tq.add('work', { maxRetries: 5 });
+    expect(task.maxRetries).toBe(5);
+  });
+
+  it('should allow configuring backoffDelay per task', () => {
+    const tq = new TaskQueue();
+    const task = tq.add('work', { backoffDelay: 500 });
+    expect(task.backoffDelay).toBe(500);
+  });
+
+  it('should keep original queue and priority on retry', () => {
+    const tq = new TaskQueue();
+    const task = tq.add('work', { queue: 'emails', priority: 2, maxRetries: 3, backoffDelay: 10 });
+    tq.next('emails');
+    tq.fail(task.id, 'fail');
+    expect(task.queue).toBe('emails');
+    expect(task.priority).toBe(2);
+  });
+
+  it('should exhaust retries: maxRetries=1 allows 1 retry then fails', () => {
+    const tq = new TaskQueue();
+    const task = tq.add('work', { maxRetries: 1, backoffDelay: 1 });
+
+    // Attempt 1
+    tq.next();
+    tq.fail(task.id, 'fail 1');
+    // attempts=1 <= maxRetries=1, so retry
+    expect(task.status).toBe('pending');
+
+    task.availableAt = new Date(Date.now() - 1);
+
+    // Attempt 2
+    tq.next();
+    tq.fail(task.id, 'fail 2');
+    // attempts=2 > maxRetries=1, permanently failed -> DLQ
+    expect(task.status).toBe('dead-lettered');
+  });
+
+  it('should exhaust retries: maxRetries=2 allows 2 retries then fails', () => {
+    const tq = new TaskQueue();
+    const task = tq.add('work', { maxRetries: 2, backoffDelay: 1 });
+
+    // Attempt 1
+    tq.next();
+    tq.fail(task.id, 'fail 1');
+    expect(task.status).toBe('pending'); // retry (1 <= 2)
+
+    task.availableAt = new Date(Date.now() - 1);
+
+    // Attempt 2 (first retry)
+    tq.next();
+    tq.fail(task.id, 'fail 2');
+    expect(task.status).toBe('pending'); // retry (2 <= 2)
+
+    task.availableAt = new Date(Date.now() - 1);
+
+    // Attempt 3 (second retry)
+    tq.next();
+    tq.fail(task.id, 'fail 3');
+    // attempts=3 > maxRetries=2, permanently failed -> DLQ
+    expect(task.status).toBe('dead-lettered');
+  });
+
+  it('should fail immediately with maxRetries=0 (no retries)', () => {
+    const tq = new TaskQueue();
+    const task = tq.add('work', { maxRetries: 0, backoffDelay: 1 });
+
+    tq.next();
+    tq.fail(task.id, 'fail');
+    // attempts=1 > maxRetries=0, permanently failed -> DLQ
+    expect(task.status).toBe('dead-lettered');
+  });
+
+  it('should throw when failing a non-processing task', () => {
+    const tq = new TaskQueue();
+    const task = tq.add('work');
+    expect(() => tq.fail(task.id, 'oops')).toThrow();
+  });
+
+  it('should throw when completing a non-existent task', () => {
+    const tq = new TaskQueue();
+    expect(() => tq.complete('nonexistent')).toThrow();
+  });
+
+  it('should throw when failing a non-existent task', () => {
+    const tq = new TaskQueue();
+    expect(() => tq.fail('nonexistent')).toThrow();
+  });
+});
diff --git a/tests/phase-06-dlq.test.ts b/tests/phase-06-dlq.test.ts
new file mode 100644
index 0000000..80b0d65
--- /dev/null
+++ b/tests/phase-06-dlq.test.ts
@@ -0,0 +1,137 @@
+import { describe, it, expect } from 'vitest';
+import { TaskQueue } from '../src/task-queue.js';
+
+describe('Phase 6: Dead Letter Queue', () => {
+  it('should move task to DLQ when retries are exhausted', () => {
+    const tq = new TaskQueue();
+    const task = tq.add('work', { maxRetries: 0, backoffDelay: 1 });
+
+    // Attempt 1 with maxRetries=0  no retries allowed
+    tq.next();
+    tq.fail(task.id, 'permanent failure');
+    expect(task.status).toBe('dead-lettered');
+
+    const dlqTasks = tq.getDeadLetterTasks();
+    expect(dlqTasks).toHaveLength(1);
+    expect(dlqTasks[0].id).toBe(task.id);
+  });
+
+  it('should move task to DLQ after exhausting retries', () => {
+    const tq = new TaskQueue();
+    const task = tq.add('work', { maxRetries: 1, backoffDelay: 1 });
+
+    // Attempt 1: retry allowed
+    tq.next();
+    tq.fail(task.id, 'fail 1');
+    expect(task.status).toBe('pending');
+
+    task.availableAt = new Date(Date.now() - 1);
+
+    // Attempt 2: no more retries
+    tq.next();
+    tq.fail(task.id, 'fail 2');
+    expect(task.status).toBe('dead-lettered');
+
+    const dlqTasks = tq.getDeadLetterTasks();
+    expect(dlqTasks).toHaveLength(1);
+    expect(dlqTasks[0].id).toBe(task.id);
+  });
+
+  it('should retain error information on dead-lettered tasks', () => {
+    const tq = new TaskQueue();
+    const task = tq.add('work', { maxRetries: 0, backoffDelay: 1 });
+    tq.next();
+    tq.fail(task.id, 'something went wrong');
+    const dlqTasks = tq.getDeadLetterTasks();
+    expect(dlqTasks[0].error).toBe('something went wrong');
+    expect(dlqTasks[0].attempts).toBe(1);
+  });
+
+  it('should allow viewing dead-lettered tasks for a specific queue', () => {
+    const tq = new TaskQueue();
+    const t1 = tq.add('email', { queue: 'emails', maxRetries: 0, backoffDelay: 1 });
+    const t2 = tq.add('sms', { queue: 'sms', maxRetries: 0, backoffDelay: 1 });
+
+    tq.next('emails');
+    tq.fail(t1.id, 'email fail');
+    tq.next('sms');
+    tq.fail(t2.id, 'sms fail');
+
+    expect(tq.getDeadLetterTasks('emails')).toHaveLength(1);
+    expect(tq.getDeadLetterTasks('sms')).toHaveLength(1);
+    expect(tq.getDeadLetterTasks('emails')[0].payload).toBe('email');
+    expect(tq.getDeadLetterTasks('sms')[0].payload).toBe('sms');
+  });
+
+  it('should replay a dead-lettered task back to its original queue', () => {
+    const tq = new TaskQueue();
+    const task = tq.add('work', { maxRetries: 0, backoffDelay: 1, priority: 2, queue: 'myqueue' });
+    tq.next('myqueue');
+    tq.fail(task.id, 'fail');
+
+    // Verify it's in DLQ
+    expect(tq.getDeadLetterTasks('myqueue')).toHaveLength(1);
+
+    // Replay it
+    const replayed = tq.replayDeadLetterTask(task.id);
+    expect(replayed.status).toBe('pending');
+    expect(replayed.attempts).toBe(0);
+    expect(replayed.error).toBeUndefined();
+    expect(replayed.queue).toBe('myqueue');
+    expect(replayed.priority).toBe(2);
+
+    // DLQ should be empty now
+    expect(tq.getDeadLetterTasks('myqueue')).toHaveLength(0);
+
+    // Task should be processable again
+    const next = tq.next('myqueue');
+    expect(next).not.toBeNull();
+    expect(next?.id).toBe(task.id);
+  });
+
+  it('should clear all dead-lettered tasks for a queue', () => {
+    const tq = new TaskQueue();
+    const t1 = tq.add('w1', { maxRetries: 0, backoffDelay: 1 });
+    const t2 = tq.add('w2', { maxRetries: 0, backoffDelay: 1 });
+
+    tq.next(); tq.fail(t1.id, 'f1');
+    tq.next(); tq.fail(t2.id, 'f2');
+
+    expect(tq.getDeadLetterTasks()).toHaveLength(2);
+
+    tq.clearDeadLetterQueue();
+    expect(tq.getDeadLetterTasks()).toHaveLength(0);
+  });
+
+  it('should have independent DLQs per named queue', () => {
+    const tq = new TaskQueue();
+    const t1 = tq.add('a', { queue: 'q1', maxRetries: 0, backoffDelay: 1 });
+    const t2 = tq.add('b', { queue: 'q2', maxRetries: 0, backoffDelay: 1 });
+
+    tq.next('q1'); tq.fail(t1.id, 'f');
+    tq.next('q2'); tq.fail(t2.id, 'f');
+
+    tq.clearDeadLetterQueue('q1');
+    expect(tq.getDeadLetterTasks('q1')).toHaveLength(0);
+    expect(tq.getDeadLetterTasks('q2')).toHaveLength(1);
+  });
+
+  it('should report dead letter count', () => {
+    const tq = new TaskQueue();
+    const task = tq.add('work', { maxRetries: 0, backoffDelay: 1 });
+    tq.next();
+    tq.fail(task.id, 'fail');
+    expect(tq.deadLetterCount()).toBe(1);
+  });
+
+  it('should throw when replaying a task not in DLQ', () => {
+    const tq = new TaskQueue();
+    const task = tq.add('work');
+    expect(() => tq.replayDeadLetterTask(task.id)).toThrow();
+  });
+
+  it('should return empty array for non-existent queue DLQ', () => {
+    const tq = new TaskQueue();
+    expect(tq.getDeadLetterTasks('nonexistent')).toEqual([]);
+  });
+});
diff --git a/tests/phase-07-dependencies.test.ts b/tests/phase-07-dependencies.test.ts
new file mode 100644
index 0000000..cf417a7
--- /dev/null
+++ b/tests/phase-07-dependencies.test.ts
@@ -0,0 +1,206 @@
+import { describe, it, expect } from 'vitest';
+import { TaskQueue } from '../src/task-queue.js';
+
+describe('Phase 7: Task Dependencies', () => {
+  it('should allow specifying dependencies when adding a task', () => {
+    const tq = new TaskQueue();
+    const t1 = tq.add('prerequisite');
+    const t2 = tq.add('dependent', { dependencies: [t1.id] });
+    expect(t2.dependencies).toEqual([t1.id]);
+  });
+
+  it('should block tasks with unresolved dependencies', () => {
+    const tq = new TaskQueue();
+    const t1 = tq.add('prerequisite');
+    tq.add('dependent', { dependencies: [t1.id] });
+
+    // Only t1 should be available
+    const next = tq.next();
+    expect(next?.payload).toBe('prerequisite');
+
+    // t2 should still be blocked
+    const next2 = tq.next();
+    expect(next2).toBeNull();
+  });
+
+  it('should unblock dependent task when dependency completes', () => {
+    const tq = new TaskQueue();
+    const t1 = tq.add('prerequisite');
+    const t2 = tq.add('dependent', { dependencies: [t1.id] });
+
+    // Process and complete t1
+    tq.next();
+    tq.complete(t1.id);
+
+    // Now t2 should be available
+    const next = tq.next();
+    expect(next?.id).toBe(t2.id);
+    expect(next?.payload).toBe('dependent');
+  });
+
+  it('should handle multiple dependencies', () => {
+    const tq = new TaskQueue();
+    const t1 = tq.add('step1');
+    const t2 = tq.add('step2');
+    const t3 = tq.add('final', { dependencies: [t1.id, t2.id] });
+
+    // Complete only t1
+    tq.next(); // t1
+    tq.complete(t1.id);
+
+    // t3 still blocked because t2 is not complete
+    tq.next(); // t2
+    expect(tq.next()).toBeNull(); // t3 blocked
+
+    tq.complete(t2.id);
+
+    // Now t3 should be available
+    const next = tq.next();
+    expect(next?.id).toBe(t3.id);
+  });
+
+  it('should detect direct circular dependencies', () => {
+    const tq = new TaskQueue();
+    const t1 = tq.add('step1');
+    tq.complete(tq.next()!.id); // Complete t1 first
+
+    // Can't create a task that depends on a task that would depend on it
+    // Direct circular: t2 depends on t1, then try to create t3 that depends on t2 while t2 depends on t3
+    // Actually, we can't create circular deps since you need to reference existing task IDs
+    // So the only circular case is: task A depends on task B which depends on task A
+    // But we can't create that since both would need to exist first.
+    // However, indirect circulars: A -> B -> C -> A
+    // The only possible scenario: task depends on itself
+
+    // Let's test: A depends on B, B depends on A won't work because
+    // when creating B, A exists but B doesn't exist yet to be referenced by A.
+    // Actually the concern is more about chains.
+
+    // Test: a task cannot depend on a non-existent task
+    expect(() => tq.add('cycle', { dependencies: ['nonexistent'] })).toThrow();
+  });
+
+  it('should throw when depending on non-existent task', () => {
+    const tq = new TaskQueue();
+    expect(() => tq.add('task', { dependencies: ['fake-id'] })).toThrow(/not found/i);
+  });
+
+  it('should detect indirect circular dependencies', () => {
+    const tq = new TaskQueue();
+    const t1 = tq.add('step1');
+    const t2 = tq.add('step2', { dependencies: [t1.id] });
+
+    // Try to create a task that would create a circular dependency
+    // t1 -> t2 exists. Now trying to make t3 depend on t2 is fine.
+    const t3 = tq.add('step3', { dependencies: [t2.id] });
+    expect(t3.dependencies).toEqual([t2.id]);
+  });
+
+  it('should keep dependent tasks blocked when dependency fails', () => {
+    const tq = new TaskQueue();
+    const t1 = tq.add('prerequisite', { maxRetries: 1, backoffDelay: 1 });
+    tq.add('dependent', { dependencies: [t1.id] });
+
+    // Process and fail t1
+    tq.next();
+    tq.fail(t1.id, 'broken');
+
+    // t2 should remain blocked (dependency failed, not completed)
+    const next = tq.next();
+    expect(next).toBeNull();
+  });
+
+  it('should inspect dependency status', () => {
+    const tq = new TaskQueue();
+    const t1 = tq.add('step1');
+    const t2 = tq.add('step2');
+    const t3 = tq.add('final', { dependencies: [t1.id, t2.id] });
+
+    const status = tq.getDependencyStatus(t3.id);
+    expect(status.total).toBe(2);
+    expect(status.completed).toBe(0);
+    expect(status.pending).toBe(2);
+    expect(status.failed).toBe(0);
+    expect(status.dependencies).toHaveLength(2);
+
+    // Complete t1
+    tq.next(); // t1
+    tq.complete(t1.id);
+
+    const status2 = tq.getDependencyStatus(t3.id);
+    expect(status2.completed).toBe(1);
+    expect(status2.pending).toBe(1);
+  });
+
+  it('should throw when getting dependency status of non-existent task', () => {
+    const tq = new TaskQueue();
+    expect(() => tq.getDependencyStatus('nonexistent')).toThrow();
+  });
+
+  it('should work with tasks having no dependencies', () => {
+    const tq = new TaskQueue();
+    const task = tq.add('simple');
+    expect(task.dependencies).toEqual([]);
+
+    const next = tq.next();
+    expect(next?.payload).toBe('simple');
+  });
+
+  it('should handle dependency chains (A -> B -> C)', () => {
+    const tq = new TaskQueue();
+    const tA = tq.add('A');
+    const tB = tq.add('B', { dependencies: [tA.id] });
+    const tC = tq.add('C', { dependencies: [tB.id] });
+
+    // Only A should be available
+    expect(tq.next()?.id).toBe(tA.id);
+    expect(tq.next()).toBeNull();
+
+    tq.complete(tA.id);
+
+    // Now B should be available
+    expect(tq.next()?.id).toBe(tB.id);
+    expect(tq.next()).toBeNull();
+
+    tq.complete(tB.id);
+
+    // Now C should be available
+    expect(tq.next()?.id).toBe(tC.id);
+  });
+
+  it('should handle diamond dependencies', () => {
+    const tq = new TaskQueue();
+    const tA = tq.add('A');
+    const tB = tq.add('B', { dependencies: [tA.id] });
+    const tC = tq.add('C', { dependencies: [tA.id] });
+    const tD = tq.add('D', { dependencies: [tB.id, tC.id] });
+
+    // Only A available
+    tq.next(); tq.complete(tA.id);
+
+    // B and C available
+    const next1 = tq.next();
+    const next2 = tq.next();
+    expect([next1?.payload, next2?.payload].sort()).toEqual(['B', 'C']);
+
+    // D still blocked
+    expect(tq.next()).toBeNull();
+
+    tq.complete(tB.id);
+    // D still blocked (C not complete)
+    expect(tq.next()).toBeNull();
+
+    tq.complete(tC.id);
+    // D now available
+    expect(tq.next()?.id).toBe(tD.id);
+  });
+
+  it('should not count blocked tasks in pendingCount', () => {
+    const tq = new TaskQueue();
+    const t1 = tq.add('prerequisite');
+    tq.add('dependent', { dependencies: [t1.id] });
+
+    // Only t1 should count as pending (t2 is blocked)
+    expect(tq.pendingCount()).toBe(1);
+  });
+});
diff --git a/tests/phase-10-recurring.test.ts b/tests/phase-10-recurring.test.ts
new file mode 100644
index 0000000..5ade97a
--- /dev/null
+++ b/tests/phase-10-recurring.test.ts
@@ -0,0 +1,151 @@
+import { describe, it, expect, beforeEach } from 'vitest';
+import { TaskQueue, resetTaskIdCounter } from '../src/index.js';
+
+describe('Phase 10: Recurring Tasks', () => {
+  let queue: TaskQueue;
+
+  beforeEach(() => {
+    resetTaskIdCounter();
+    queue = new TaskQueue();
+  });
+
+  describe('addRecurringTask', () => {
+    it('should create a recurring schedule with every-N-minutes cron', () => {
+      const schedule = queue.addRecurringTask('*/5 * * * *', 'default', 'cleanup', { type: 'cache' });
+      expect(schedule.id).toBeDefined();
+      expect(schedule.cronExpression).toBe('*/5 * * * *');
+      expect(schedule.queueName).toBe('default');
+      expect(schedule.taskName).toBe('cleanup');
+      expect(schedule.taskData).toEqual({ type: 'cache' });
+      expect(schedule.intervalMs).toBe(5 * 60 * 1000);
+    });
+
+    it('should create a recurring schedule with every-hour cron', () => {
+      const schedule = queue.addRecurringTask('0 * * * *', 'reports', 'generate-report', {});
+      expect(schedule.intervalMs).toBe(60 * 60 * 1000);
+    });
+
+    it('should create a recurring schedule with daily cron', () => {
+      const schedule = queue.addRecurringTask('0 0 * * *', 'default', 'daily-cleanup', null);
+      expect(schedule.intervalMs).toBe(24 * 60 * 60 * 1000);
+    });
+
+    it('should throw on unsupported cron expression', () => {
+      expect(() => queue.addRecurringTask('bad', 'default', 'test', {})).toThrow();
+    });
+
+    it('should throw on invalid cron expression format', () => {
+      expect(() => queue.addRecurringTask('1 2 3', 'default', 'test', {})).toThrow('Invalid cron expression');
+    });
+
+    it('should assign unique IDs', () => {
+      const s1 = queue.addRecurringTask('*/1 * * * *', 'default', 'task1', {});
+      const s2 = queue.addRecurringTask('*/2 * * * *', 'default', 'task2', {});
+      expect(s1.id).not.toBe(s2.id);
+    });
+  });
+
+  describe('removeRecurringTask', () => {
+    it('should remove an existing schedule', () => {
+      const schedule = queue.addRecurringTask('*/5 * * * *', 'default', 'cleanup', {});
+      expect(queue.removeRecurringTask(schedule.id)).toBe(true);
+      expect(queue.getRecurringTasks()).toHaveLength(0);
+    });
+
+    it('should return false for non-existent schedule', () => {
+      expect(queue.removeRecurringTask('nonexistent')).toBe(false);
+    });
+
+    it('should stop future occurrences after removal', () => {
+      const schedule = queue.addRecurringTask('*/5 * * * *', 'default', 'cleanup', {});
+      const now = Date.now();
+      queue.tick(now);
+      expect(queue.getAllTasks('default')).toHaveLength(1);
+
+      queue.removeRecurringTask(schedule.id);
+      queue.tick(now + 10 * 60 * 1000);
+      // No new tasks should be created
+      expect(queue.getAllTasks('default')).toHaveLength(1);
+    });
+  });
+
+  describe('getRecurringTasks', () => {
+    it('should return empty list initially', () => {
+      expect(queue.getRecurringTasks()).toEqual([]);
+    });
+
+    it('should return all active schedules', () => {
+      queue.addRecurringTask('*/5 * * * *', 'default', 'task1', {});
+      queue.addRecurringTask('*/10 * * * *', 'default', 'task2', {});
+      expect(queue.getRecurringTasks()).toHaveLength(2);
+    });
+  });
+
+  describe('tick', () => {
+    it('should create tasks when schedule is due', () => {
+      queue.addRecurringTask('*/5 * * * *', 'default', 'cleanup', { key: 'value' });
+      const now = Date.now();
+      const created = queue.tick(now);
+      expect(created).toHaveLength(1);
+      expect(created[0].name).toBe('cleanup');
+      expect(created[0].data).toEqual({ key: 'value' });
+      expect(created[0].queueName).toBe('default');
+    });
+
+    it('should not create tasks before interval elapses', () => {
+      queue.addRecurringTask('*/5 * * * *', 'default', 'cleanup', {});
+      const now = Date.now();
+      queue.tick(now);
+      // tick again 2 minutes later - should not create
+      const created = queue.tick(now + 2 * 60 * 1000);
+      expect(created).toHaveLength(0);
+    });
+
+    it('should create tasks after interval elapses', () => {
+      queue.addRecurringTask('*/5 * * * *', 'default', 'cleanup', {});
+      const now = Date.now();
+      queue.tick(now);
+      // tick again 5 minutes later - should create
+      const created = queue.tick(now + 5 * 60 * 1000);
+      expect(created).toHaveLength(1);
+    });
+
+    it('should handle multiple schedules independently', () => {
+      queue.addRecurringTask('*/5 * * * *', 'queue1', 'task1', {});
+      queue.addRecurringTask('*/10 * * * *', 'queue2', 'task2', {});
+      const now = Date.now();
+      queue.tick(now);
+
+      // After 5 minutes, only first should fire
+      const created5 = queue.tick(now + 5 * 60 * 1000);
+      expect(created5).toHaveLength(1);
+      expect(created5[0].name).toBe('task1');
+
+      // After 10 minutes from start, both should fire
+      const created10 = queue.tick(now + 10 * 60 * 1000);
+      expect(created10).toHaveLength(2);
+    });
+
+    it('should pass taskOptions to created tasks', () => {
+      queue.addRecurringTask('*/1 * * * *', 'default', 'prio-task', { x: 1 }, { priority: 10 });
+      const now = Date.now();
+      const created = queue.tick(now);
+      expect(created[0].priority).toBe(10);
+    });
+
+    it('created tasks are regular tasks subject to queue rules', async () => {
+      queue.addRecurringTask('*/1 * * * *', 'default', 'process-me', { value: 42 });
+      const now = Date.now();
+      queue.tick(now);
+
+      const results: unknown[] = [];
+      await queue.process('default', async (task) => {
+        results.push(task.data);
+        return 'done';
+      });
+
+      expect(results).toHaveLength(1);
+      expect(results[0]).toEqual({ value: 42 });
+    });
+  });
+});
diff --git a/tests/phase-11-middleware.test.ts b/tests/phase-11-middleware.test.ts
new file mode 100644
index 0000000..74b631e
--- /dev/null
+++ b/tests/phase-11-middleware.test.ts
@@ -0,0 +1,208 @@
+import { describe, it, expect, beforeEach } from 'vitest';
+import { TaskQueue, Task, resetTaskIdCounter } from '../src/index.js';
+
+describe('Phase 11: Middleware Pipeline', () => {
+  let queue: TaskQueue;
+
+  beforeEach(() => {
+    resetTaskIdCounter();
+    queue = new TaskQueue();
+  });
+
+  describe('middleware registration', () => {
+    it('should register middleware for a queue', () => {
+      const mw = async (_task: Task, next: () => Promise<void>) => { await next(); };
+      queue.use('default', mw);
+      expect(queue.getMiddleware('default')).toHaveLength(1);
+    });
+
+    it('should support multiple middleware in order', () => {
+      const mw1 = async (_task: Task, next: () => Promise<void>) => { await next(); };
+      const mw2 = async (_task: Task, next: () => Promise<void>) => { await next(); };
+      queue.use('default', mw1);
+      queue.use('default', mw2);
+      expect(queue.getMiddleware('default')).toHaveLength(2);
+      expect(queue.getMiddleware('default')[0]).toBe(mw1);
+      expect(queue.getMiddleware('default')[1]).toBe(mw2);
+    });
+
+    it('should have independent middleware stacks per queue', () => {
+      const mw1 = async (_task: Task, next: () => Promise<void>) => { await next(); };
+      const mw2 = async (_task: Task, next: () => Promise<void>) => { await next(); };
+      queue.use('queue1', mw1);
+      queue.use('queue2', mw2);
+      expect(queue.getMiddleware('queue1')).toHaveLength(1);
+      expect(queue.getMiddleware('queue2')).toHaveLength(1);
+      expect(queue.getMiddleware('queue1')[0]).toBe(mw1);
+      expect(queue.getMiddleware('queue2')[0]).toBe(mw2);
+    });
+  });
+
+  describe('middleware execution', () => {
+    it('should pass tasks through middleware before handler', async () => {
+      const order: string[] = [];
+
+      queue.use('default', async (_task, next) => {
+        order.push('middleware1-before');
+        await next();
+        order.push('middleware1-after');
+      });
+
+      queue.use('default', async (_task, next) => {
+        order.push('middleware2-before');
+        await next();
+        order.push('middleware2-after');
+      });
+
+      queue.addTask('test', {}, { queueName: 'default' });
+      await queue.process('default', async () => {
+        order.push('handler');
+      });
+
+      expect(order).toEqual([
+        'middleware1-before',
+        'middleware2-before',
+        'handler',
+        'middleware2-after',
+        'middleware1-after',
+      ]);
+    });
+
+    it('should allow middleware to modify task data', async () => {
+      queue.use('default', async (task, next) => {
+        (task.data as Record<string, unknown>).enriched = true;
+        await next();
+      });
+
+      queue.addTask('test', { original: true }, { queueName: 'default' });
+
+      let receivedData: unknown;
+      await queue.process('default', async (task) => {
+        receivedData = task.data;
+      });
+
+      expect(receivedData).toEqual({ original: true, enriched: true });
+    });
+
+    it('should short-circuit if middleware does not call next', async () => {
+      let handlerCalled = false;
+
+      queue.use('default', async (_task, _next) => {
+        // Intentionally not calling next
+      });
+
+      queue.addTask('test', {}, { queueName: 'default' });
+      await queue.process('default', async () => {
+        handlerCalled = true;
+      });
+
+      expect(handlerCalled).toBe(false);
+    });
+
+    it('should mark task as completed even if middleware short-circuits', async () => {
+      queue.use('default', async (_task, _next) => {
+        // Short-circuit
+      });
+
+      const task = queue.addTask('test', {}, { queueName: 'default' });
+      await queue.process('default', async () => {});
+
+      expect(task.status).toBe('completed');
+    });
+
+    it('should mark task as failed if middleware throws', async () => {
+      queue.use('default', async () => {
+        throw new Error('middleware error');
+      });
+
+      const task = queue.addTask('test', {}, { queueName: 'default' });
+      await queue.process('default', async () => {});
+
+      expect(task.status).toBe('failed');
+      expect(task.error).toBe('middleware error');
+    });
+
+    it('should support logging middleware pattern', async () => {
+      const logs: string[] = [];
+
+      queue.use('default', async (task, next) => {
+        logs.push(`start: ${task.name}`);
+        const startTime = Date.now();
+        await next();
+        logs.push(`end: ${task.name} (${Date.now() - startTime}ms)`);
+      });
+
+      queue.addTask('myTask', {}, { queueName: 'default' });
+      await queue.process('default', async () => {});
+
+      expect(logs[0]).toBe('start: myTask');
+      expect(logs[1]).toMatch(/^end: myTask/);
+    });
+
+    it('should work with registerHandler', async () => {
+      const order: string[] = [];
+
+      queue.use('default', async (_task, next) => {
+        order.push('middleware');
+        await next();
+      });
+
+      queue.registerHandler('default', async () => {
+        order.push('handler');
+      });
+
+      queue.addTask('test', {}, { queueName: 'default' });
+      await queue.process('default');
+
+      expect(order).toEqual(['middleware', 'handler']);
+    });
+  });
+
+  describe('middleware composability', () => {
+    it('should compose multiple middleware in a chain', async () => {
+      const trace: number[] = [];
+
+      for (let i = 0; i < 5; i++) {
+        const idx = i;
+        queue.use('default', async (_task, next) => {
+          trace.push(idx);
+          await next();
+        });
+      }
+
+      queue.addTask('test', {}, { queueName: 'default' });
+      await queue.process('default', async () => {
+        trace.push(99);
+      });
+
+      expect(trace).toEqual([0, 1, 2, 3, 4, 99]);
+    });
+
+    it('should allow a middleware in the middle to short-circuit', async () => {
+      const trace: number[] = [];
+
+      queue.use('default', async (_task, next) => {
+        trace.push(1);
+        await next();
+        trace.push(4);
+      });
+
+      queue.use('default', async (_task, _next) => {
+        trace.push(2);
+        // Don't call next - short circuit
+      });
+
+      queue.use('default', async (_task, next) => {
+        trace.push(3); // Should never be reached
+        await next();
+      });
+
+      queue.addTask('test', {}, { queueName: 'default' });
+      await queue.process('default', async () => {
+        trace.push(99);
+      });
+
+      expect(trace).toEqual([1, 2, 4]);
+    });
+  });
+});
diff --git a/tests/phase-12-shutdown.test.ts b/tests/phase-12-shutdown.test.ts
new file mode 100644
index 0000000..ab44e20
--- /dev/null
+++ b/tests/phase-12-shutdown.test.ts
@@ -0,0 +1,159 @@
+import { describe, it, expect, beforeEach } from 'vitest';
+import { TaskQueue, resetTaskIdCounter } from '../src/index.js';
+
+describe('Phase 12: Graceful Shutdown', () => {
+  let queue: TaskQueue;
+
+  beforeEach(() => {
+    resetTaskIdCounter();
+    queue = new TaskQueue();
+  });
+
+  describe('basic shutdown', () => {
+    it('should complete immediately when no tasks are processing', async () => {
+      const result = await queue.shutdown();
+      expect(result.completed).toBe(0);
+      expect(result.forceCancelled).toBe(0);
+      expect(result.durationMs).toBeGreaterThanOrEqual(0);
+    });
+
+    it('should return a shutdown summary', async () => {
+      const result = await queue.shutdown();
+      expect(result).toHaveProperty('completed');
+      expect(result).toHaveProperty('forceCancelled');
+      expect(result).toHaveProperty('durationMs');
+    });
+  });
+
+  describe('rejecting new tasks', () => {
+    it('should reject new tasks after shutdown is initiated', async () => {
+      await queue.shutdown();
+      expect(() => queue.addTask('test', {})).toThrow('shutting down');
+    });
+
+    it('should reject recurring tasks after shutdown', async () => {
+      await queue.shutdown();
+      expect(() => queue.addRecurringTask('*/5 * * * *', 'default', 'test', {})).toThrow('shutting down');
+    });
+
+    it('should indicate shutdown state', async () => {
+      expect(queue.isShuttingDown).toBe(false);
+      const shutdownPromise = queue.shutdown();
+      expect(queue.isShuttingDown).toBe(true);
+      await shutdownPromise;
+    });
+  });
+
+  describe('waiting for running tasks', () => {
+    it('should wait for running tasks to complete', async () => {
+      let taskResolved = false;
+
+      queue.addTask('slow', {}, { queueName: 'default' });
+
+      // Start processing in the background
+      const processPromise = queue.process('default', async () => {
+        await new Promise(resolve => setTimeout(resolve, 100));
+        taskResolved = true;
+        return 'done';
+      });
+
+      // Give it time to start
+      await new Promise(resolve => setTimeout(resolve, 20));
+
+      const result = await queue.shutdown(5000);
+      await processPromise;
+
+      expect(taskResolved).toBe(true);
+      expect(result.completed).toBe(1);
+      expect(result.forceCancelled).toBe(0);
+    });
+
+    it('should force-cancel tasks that exceed timeout', async () => {
+      queue.addTask('very-slow', {}, { queueName: 'default' });
+
+      // Start processing - this task takes very long
+      const processPromise = queue.process('default', async (_task, ctx) => {
+        // Check cancellation in a loop
+        for (let i = 0; i < 100; i++) {
+          if (ctx.isCancelled()) return;
+          await new Promise(resolve => setTimeout(resolve, 50));
+        }
+      });
+
+      // Give it time to start
+      await new Promise(resolve => setTimeout(resolve, 20));
+
+      const result = await queue.shutdown(100);
+
+      // Wait for process to finish after cancellation
+      await processPromise.catch(() => {});
+
+      expect(result.forceCancelled).toBe(1);
+    });
+  });
+
+  describe('idempotent shutdown', () => {
+    it('should return the same result when called multiple times', async () => {
+      const result1Promise = queue.shutdown();
+      const result2Promise = queue.shutdown();
+
+      const result1 = await result1Promise;
+      const result2 = await result2Promise;
+
+      expect(result1).toBe(result2);
+    });
+  });
+
+  describe('shutdown callbacks', () => {
+    it('should run registered shutdown callbacks', async () => {
+      let callbackRan = false;
+      queue.onShutdown(() => {
+        callbackRan = true;
+      });
+
+      await queue.shutdown();
+      expect(callbackRan).toBe(true);
+    });
+
+    it('should run multiple callbacks', async () => {
+      const order: number[] = [];
+      queue.onShutdown(() => { order.push(1); });
+      queue.onShutdown(() => { order.push(2); });
+      queue.onShutdown(() => { order.push(3); });
+
+      await queue.shutdown();
+      expect(order).toEqual([1, 2, 3]);
+    });
+
+    it('should run async callbacks', async () => {
+      let asyncDone = false;
+      queue.onShutdown(async () => {
+        await new Promise(resolve => setTimeout(resolve, 50));
+        asyncDone = true;
+      });
+
+      await queue.shutdown();
+      expect(asyncDone).toBe(true);
+    });
+
+    it('should not fail if a callback throws', async () => {
+      queue.onShutdown(() => {
+        throw new Error('callback error');
+      });
+
+      // Should not throw
+      const result = await queue.shutdown();
+      expect(result).toBeDefined();
+    });
+  });
+
+  describe('recurring task cleanup on shutdown', () => {
+    it('should clear recurring schedules on shutdown', async () => {
+      queue.addRecurringTask('*/5 * * * *', 'default', 'test', {});
+      expect(queue.getRecurringTasks()).toHaveLength(1);
+
+      await queue.shutdown();
+      expect(queue.getRecurringTasks()).toHaveLength(0);
+    });
+  });
+});
diff --git a/tests/phases-1-4.test.ts b/tests/phases-1-4.test.ts
new file mode 100644
index 0000000..b3f0ce2
--- /dev/null
+++ b/tests/phases-1-4.test.ts
@@ -0,0 +1,297 @@
+import { describe, it, expect, vi } from 'vitest';
+import { TaskQueue } from '../src/task-queue.js';
+
+describe('Phase 1: Basic FIFO Queue', () => {
+  it('should add a task and return a task object with required fields', () => {
+    const tq = new TaskQueue();
+    const task = tq.add({ message: 'hello' });
+
+    expect(task.id).toBeDefined();
+    expect(typeof task.id).toBe('string');
+    expect(task.payload).toEqual({ message: 'hello' });
+    expect(task.status).toBe('pending');
+    expect(task.createdAt).toBeInstanceOf(Date);
+    expect(task.priority).toBe(5);
+  });
+
+  it('should generate unique IDs for each task', () => {
+    const tq = new TaskQueue();
+    const t1 = tq.add('a');
+    const t2 = tq.add('b');
+    expect(t1.id).not.toBe(t2.id);
+  });
+
+  it('should retrieve tasks in FIFO order', () => {
+    const tq = new TaskQueue();
+    tq.add('first');
+    tq.add('second');
+    tq.add('third');
+
+    const t1 = tq.next();
+    expect(t1?.payload).toBe('first');
+    const t2 = tq.next();
+    expect(t2?.payload).toBe('second');
+    const t3 = tq.next();
+    expect(t3?.payload).toBe('third');
+  });
+
+  it('should transition task to processing when retrieved', () => {
+    const tq = new TaskQueue();
+    tq.add('work');
+    const task = tq.next();
+    expect(task?.status).toBe('processing');
+  });
+
+  it('should return null when no tasks are available', () => {
+    const tq = new TaskQueue();
+    expect(tq.next()).toBeNull();
+  });
+
+  it('should track pending count', () => {
+    const tq = new TaskQueue();
+    expect(tq.pendingCount()).toBe(0);
+    tq.add('a');
+    tq.add('b');
+    expect(tq.pendingCount()).toBe(2);
+    tq.next();
+    expect(tq.pendingCount()).toBe(1);
+  });
+
+  it('should process a task with a handler', async () => {
+    const tq = new TaskQueue();
+    tq.add('data');
+
+    const handler = vi.fn();
+    const result = await tq.process(undefined, handler);
+
+    expect(result).toBeUndefined();
+    expect(handler).toHaveBeenCalledTimes(1);
+  });
+
+  it('should get a task by ID', () => {
+    const tq = new TaskQueue();
+    const task = tq.add('data');
+    const found = tq.getTask(task.id);
+    expect(found).toBe(task);
+  });
+
+  it('should return null for non-existent task ID', () => {
+    const tq = new TaskQueue();
+    expect(tq.getTask('nonexistent')).toBeNull();
+  });
+});
+
+describe('Phase 2: Named Queues', () => {
+  it('should support adding tasks to named queues', () => {
+    const tq = new TaskQueue();
+    const t1 = tq.add('email', { queue: 'emails' });
+    const t2 = tq.add('sms', { queue: 'sms' });
+
+    expect(t1.queue).toBe('emails');
+    expect(t2.queue).toBe('sms');
+  });
+
+  it('should use default queue when no name is given', () => {
+    const tq = new TaskQueue();
+    const task = tq.add('data');
+    expect(task.queue).toBe('default');
+  });
+
+  it('should operate queues independently', () => {
+    const tq = new TaskQueue();
+    tq.add('email-1', { queue: 'emails' });
+    tq.add('sms-1', { queue: 'sms' });
+
+    const emailTask = tq.next('emails');
+    expect(emailTask?.payload).toBe('email-1');
+    expect(tq.pendingCount('emails')).toBe(0);
+    expect(tq.pendingCount('sms')).toBe(1);
+  });
+
+  it('should return null for non-existent queue', () => {
+    const tq = new TaskQueue();
+    expect(tq.next('nonexistent')).toBeNull();
+  });
+
+  it('should return null for empty queue', () => {
+    const tq = new TaskQueue();
+    tq.add('task', { queue: 'q1' });
+    tq.next('q1');
+    expect(tq.next('q1')).toBeNull();
+  });
+
+  it('should list all queue names', () => {
+    const tq = new TaskQueue();
+    tq.add('a', { queue: 'alpha' });
+    tq.add('b', { queue: 'beta' });
+    tq.add('c'); // default
+
+    const names = tq.getQueueNames();
+    expect(names).toContain('alpha');
+    expect(names).toContain('beta');
+    expect(names).toContain('default');
+  });
+
+  it('should create queues implicitly', () => {
+    const tq = new TaskQueue();
+    expect(tq.getQueueNames()).toHaveLength(0);
+    tq.add('data', { queue: 'new-queue' });
+    expect(tq.getQueueNames()).toContain('new-queue');
+  });
+
+  it('should be backward compatible with Phase 1 API', () => {
+    const tq = new TaskQueue();
+    tq.add('data');
+    const task = tq.next();
+    expect(task?.payload).toBe('data');
+  });
+});
+
+describe('Phase 3: Priority', () => {
+  it('should default priority to 5', () => {
+    const tq = new TaskQueue();
+    const task = tq.add('data');
+    expect(task.priority).toBe(5);
+  });
+
+  it('should accept priority 1-10', () => {
+    const tq = new TaskQueue();
+    const t1 = tq.add('high', { priority: 1 });
+    const t10 = tq.add('low', { priority: 10 });
+    expect(t1.priority).toBe(1);
+    expect(t10.priority).toBe(10);
+  });
+
+  it('should reject invalid priority values', () => {
+    const tq = new TaskQueue();
+    expect(() => tq.add('data', { priority: 0 })).toThrow();
+    expect(() => tq.add('data', { priority: 11 })).toThrow();
+    expect(() => tq.add('data', { priority: -1 })).toThrow();
+    expect(() => tq.add('data', { priority: 1.5 })).toThrow();
+  });
+
+  it('should dequeue higher priority tasks first (lower number = higher priority)', () => {
+    const tq = new TaskQueue();
+    tq.add('low', { priority: 10 });
+    tq.add('high', { priority: 1 });
+    tq.add('medium', { priority: 5 });
+
+    expect(tq.next()?.payload).toBe('high');
+    expect(tq.next()?.payload).toBe('medium');
+    expect(tq.next()?.payload).toBe('low');
+  });
+
+  it('should maintain FIFO for same priority', () => {
+    const tq = new TaskQueue();
+    tq.add('first', { priority: 3 });
+    tq.add('second', { priority: 3 });
+    tq.add('third', { priority: 3 });
+
+    expect(tq.next()?.payload).toBe('first');
+    expect(tq.next()?.payload).toBe('second');
+    expect(tq.next()?.payload).toBe('third');
+  });
+
+  it('should handle priority per queue independently', () => {
+    const tq = new TaskQueue();
+    tq.add('q1-low', { queue: 'q1', priority: 10 });
+    tq.add('q1-high', { queue: 'q1', priority: 1 });
+    tq.add('q2-low', { queue: 'q2', priority: 10 });
+
+    expect(tq.next('q1')?.payload).toBe('q1-high');
+    expect(tq.next('q2')?.payload).toBe('q2-low');
+  });
+});
+
+describe('Phase 4: Delayed Tasks', () => {
+  it('should not return delayed tasks before their availability time', () => {
+    const tq = new TaskQueue();
+    tq.add('delayed', { delay: 60000 }); // 1 minute delay
+
+    expect(tq.next()).toBeNull();
+    expect(tq.pendingCount()).toBe(0);
+  });
+
+  it('should return delayed tasks after their availability time', () => {
+    const tq = new TaskQueue();
+    tq.add('past', { availableAt: new Date(Date.now() - 1000) });
+    const task = tq.next();
+    expect(task?.payload).toBe('past');
+  });
+
+  it('should support delay in milliseconds', () => {
+    const tq = new TaskQueue();
+    const task = tq.add('delayed', { delay: 5000 });
+
+    expect(task.availableAt.getTime()).toBeGreaterThan(task.createdAt.getTime());
+    expect(task.availableAt.getTime() - task.createdAt.getTime()).toBeCloseTo(5000, -2);
+  });
+
+  it('should support specific availableAt date', () => {
+    const future = new Date(Date.now() + 10000);
+    const tq = new TaskQueue();
+    const task = tq.add('scheduled', { availableAt: future });
+    expect(task.availableAt).toBe(future);
+  });
+
+  it('should prefer non-delayed tasks over delayed ones', () => {
+    const tq = new TaskQueue();
+    tq.add('delayed', { delay: 60000 });
+    tq.add('immediate');
+
+    const task = tq.next();
+    expect(task?.payload).toBe('immediate');
+  });
+
+  it('should order available delayed tasks by FIFO within same priority', () => {
+    const tq = new TaskQueue();
+
+    const later = new Date(Date.now() - 1000);
+    const earlier = new Date(Date.now() - 2000);
+
+    tq.add('later-task', { availableAt: later });
+    tq.add('earlier-task', { availableAt: earlier });
+
+    // Both available, same priority (5), FIFO: later-task was added first
+    const t1 = tq.next();
+    const t2 = tq.next();
+    expect(t1?.payload).toBe('later-task');
+    expect(t2?.payload).toBe('earlier-task');
+  });
+
+  it('should work with named queues', () => {
+    const tq = new TaskQueue();
+    tq.add('delayed-email', { queue: 'emails', delay: 60000 });
+    tq.add('immediate-sms', { queue: 'sms' });
+
+    expect(tq.next('emails')).toBeNull();
+    expect(tq.next('sms')?.payload).toBe('immediate-sms');
+  });
+
+  it('should show availableAt on the task object', () => {
+    const tq = new TaskQueue();
+    const task = tq.add('data', { delay: 3000 });
+    expect(task.availableAt).toBeInstanceOf(Date);
+    expect(task.availableAt.getTime()).toBeGreaterThan(Date.now() - 100);
+  });
+
+  it('non-delayed tasks should have availableAt equal to createdAt', () => {
+    const tq = new TaskQueue();
+    const task = tq.add('data');
+    expect(task.availableAt.getTime()).toBe(task.createdAt.getTime());
+  });
+
+  it('should handle priority with delayed tasks correctly', () => {
+    const tq = new TaskQueue();
+
+    // High priority but delayed
+    tq.add('high-delayed', { priority: 1, delay: 60000 });
+    // Low priority but immediate
+    tq.add('low-immediate', { priority: 10 });
+
+    // Low priority immediate should come first since high is delayed
+    const task = tq.next();
+    expect(task?.payload).toBe('low-immediate');
+    expect(tq.next()).toBeNull(); // high priority still delayed
+  });
+});
