diff --git a/.thunderdome-metrics.json b/.thunderdome-metrics.json
new file mode 100644
index 0000000..93cc9de
--- /dev/null
+++ b/.thunderdome-metrics.json
@@ -0,0 +1,128 @@
+{
+  "input_tokens": 258,
+  "output_tokens": 60875,
+  "cache_read_tokens": 3195838,
+  "cache_creation_tokens": 171174,
+  "turns": 162,
+  "tools_used": [
+    "Read",
+    "TodoWrite",
+    "Bash",
+    "Glob",
+    "Write",
+    "Edit"
+  ],
+  "duration_ms": 513000,
+  "total_cost_usd": 4.273,
+  "gastown_meta": {
+    "strategy": "parallel",
+    "polecat_count": 4,
+    "roles": {
+      "mayor": {
+        "input_tokens": 3,
+        "output_tokens": 1204,
+        "cache_read_tokens": 7687,
+        "cache_creation_tokens": 1219,
+        "turns": 1,
+        "tools_used": [],
+        "duration_ms": 17958,
+        "total_cost_usd": 0.04157725
+      },
+      "polecat-0": {
+        "input_tokens": 67,
+        "output_tokens": 8928,
+        "cache_read_tokens": 475147,
+        "cache_creation_tokens": 16632,
+        "turns": 28,
+        "tools_used": [
+          "Read",
+          "TodoWrite",
+          "Bash",
+          "Glob",
+          "Write"
+        ],
+        "duration_ms": 145426,
+        "total_cost_usd": 0.5805004999999996
+      },
+      "polecat-1": {
+        "input_tokens": 70,
+        "output_tokens": 6379,
+        "cache_read_tokens": 548433,
+        "cache_creation_tokens": 15520,
+        "turns": 30,
+        "tools_used": [
+          "Read",
+          "TodoWrite",
+          "Bash",
+          "Write",
+          "Edit"
+        ],
+        "duration_ms": 146501,
+        "total_cost_usd": 0.5557625
+      },
+      "polecat-2": {
+        "input_tokens": 66,
+        "output_tokens": 10832,
+        "cache_read_tokens": 458276,
+        "cache_creation_tokens": 17799,
+        "turns": 25,
+        "tools_used": [
+          "Read",
+          "Glob",
+          "TodoWrite",
+          "Bash",
+          "Write"
+        ],
+        "duration_ms": 157820,
+        "total_cost_usd": 0.6249227499999999
+      },
+      "polecat-3": {
+        "input_tokens": 23,
+        "output_tokens": 19647,
+        "cache_read_tokens": 620186,
+        "cache_creation_tokens": 29699,
+        "turns": 37,
+        "tools_used": [
+          "Read",
+          "Glob",
+          "Bash",
+          "TodoWrite",
+          "Write",
+          "Edit"
+        ],
+        "duration_ms": 261114,
+        "total_cost_usd": 1.00579375
+      },
+      "refinery-fixup": {
+        "input_tokens": 22,
+        "output_tokens": 7666,
+        "cache_read_tokens": 890131,
+        "cache_creation_tokens": 44920,
+        "turns": 35,
+        "tools_used": [
+          "Read",
+          "Bash",
+          "Glob",
+          "Edit",
+          "Write"
+        ],
+        "duration_ms": 140300,
+        "total_cost_usd": 0.9263965000000003
+      },
+      "refinery-merge-3": {
+        "input_tokens": 7,
+        "output_tokens": 6219,
+        "cache_read_tokens": 195978,
+        "cache_creation_tokens": 45385,
+        "turns": 6,
+        "tools_used": [
+          "Read",
+          "TodoWrite",
+          "Write"
+        ],
+        "duration_ms": 75233,
+        "total_cost_usd": 0.53789225
+      }
+    }
+  }
+}
\ No newline at end of file
diff --git a/package-lock.json b/package-lock.json
index fb449ee..1a20967 100644
--- a/package-lock.json
+++ b/package-lock.json
@@ -16,11 +16,83 @@
         "@types/semver": "^7.5.0",
         "@typescript-eslint/eslint-plugin": "^7.0.0",
         "@typescript-eslint/parser": "^7.0.0",
+        "@vitest/coverage-v8": "^2.0.0",
         "eslint": "^8.56.0",
         "typescript": "^5.4.0",
         "vitest": "^2.0.0"
       }
     },
+    "node_modules/@ampproject/remapping": {
+      "version": "2.3.0",
+      "resolved": "https://registry.npmjs.org/@ampproject/remapping/-/remapping-2.3.0.tgz",
+      "integrity": "sha512-30iZtAPgz+LTIYoeivqYo853f02jBYSd5uGnGpkFV0M3xOt9aN73erkgYAmZU43x4VfqcnLxW9Kpg3R5LC4YYw==",
+      "dev": true,
+      "license": "Apache-2.0",
+      "dependencies": {
+        "@jridgewell/gen-mapping": "^0.3.5",
+        "@jridgewell/trace-mapping": "^0.3.24"
+      },
+      "engines": {
+        "node": ">=6.0.0"
+      }
+    },
+    "node_modules/@babel/helper-string-parser": {
+      "version": "7.27.1",
+      "resolved": "https://registry.npmjs.org/@babel/helper-string-parser/-/helper-string-parser-7.27.1.tgz",
+      "integrity": "sha512-qMlSxKbpRlAridDExk92nSobyDdpPijUq2DW6oDnUqd0iOGxmQjyqhMIihI9+zv4LPyZdRje2cavWPbCbWm3eA==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=6.9.0"
+      }
+    },
+    "node_modules/@babel/helper-validator-identifier": {
+      "version": "7.28.5",
+      "resolved": "https://registry.npmjs.org/@babel/helper-validator-identifier/-/helper-validator-identifier-7.28.5.tgz",
+      "integrity": "sha512-qSs4ifwzKJSV39ucNjsvc6WVHs6b7S03sOh2OcHF9UHfVPqWWALUsNUVzhSBiItjRZoLHx7nIarVjqKVusUZ1Q==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=6.9.0"
+      }
+    },
+    "node_modules/@babel/parser": {
+      "version": "7.29.0",
+      "resolved": "https://registry.npmjs.org/@babel/parser/-/parser-7.29.0.tgz",
+      "integrity": "sha512-IyDgFV5GeDUVX4YdF/3CPULtVGSXXMLh1xVIgdCgxApktqnQV0r7/8Nqthg+8YLGaAtdyIlo2qIdZrbCv4+7ww==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@babel/types": "^7.29.0"
+      },
+      "bin": {
+        "parser": "bin/babel-parser.js"
+      },
+      "engines": {
+        "node": ">=6.0.0"
+      }
+    },
+    "node_modules/@babel/types": {
+      "version": "7.29.0",
+      "resolved": "https://registry.npmjs.org/@babel/types/-/types-7.29.0.tgz",
+      "integrity": "sha512-LwdZHpScM4Qz8Xw2iKSzS+cfglZzJGvofQICy7W7v4caru4EaAmyUuO6BGrbyQ2mYV11W0U8j5mBhd14dd3B0A==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@babel/helper-string-parser": "^7.27.1",
+        "@babel/helper-validator-identifier": "^7.28.5"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      }
+    },
+    "node_modules/@bcoe/v8-coverage": {
+      "version": "0.2.3",
+      "resolved": "https://registry.npmjs.org/@bcoe/v8-coverage/-/v8-coverage-0.2.3.tgz",
+      "integrity": "sha512-0hYQ8SB4Db5zvZB4axdMHGwEaQjkZzFjQiN9LVYvIFB2nSUHW9tYpxWriPrWDASIxiaXax83REcLxuSdnGPZtw==",
+      "dev": true,
+      "license": "MIT"
+    },
     "node_modules/@esbuild/aix-ppc64": {
       "version": "0.21.5",
       "resolved": "https://registry.npmjs.org/@esbuild/aix-ppc64/-/aix-ppc64-0.21.5.tgz",
@@ -561,6 +633,84 @@
       "dev": true,
       "license": "BSD-3-Clause"
     },
+    "node_modules/@isaacs/cliui": {
+      "version": "8.0.2",
+      "resolved": "https://registry.npmjs.org/@isaacs/cliui/-/cliui-8.0.2.tgz",
+      "integrity": "sha512-O8jcjabXaleOG9DQ0+ARXWZBTfnP4WNAqzuiJK7ll44AmxGKv/J2M4TPjxjY3znBCfvBXFzucm1twdyFybFqEA==",
+      "dev": true,
+      "license": "ISC",
+      "dependencies": {
+        "string-width": "^5.1.2",
+        "string-width-cjs": "npm:string-width@^4.2.0",
+        "strip-ansi": "^7.0.1",
+        "strip-ansi-cjs": "npm:strip-ansi@^6.0.1",
+        "wrap-ansi": "^8.1.0",
+        "wrap-ansi-cjs": "npm:wrap-ansi@^7.0.0"
+      },
+      "engines": {
+        "node": ">=12"
+      }
+    },
+    "node_modules/@isaacs/cliui/node_modules/ansi-regex": {
+      "version": "6.2.2",
+      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-6.2.2.tgz",
+      "integrity": "sha512-Bq3SmSpyFHaWjPk8If9yc6svM8c56dB5BAtW4Qbw5jHTwwXXcTLoRMkpDJp6VL0XzlWaCHTXrkFURMYmD0sLqg==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/ansi-regex?sponsor=1"
+      }
+    },
+    "node_modules/@isaacs/cliui/node_modules/strip-ansi": {
+      "version": "7.1.2",
+      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-7.1.2.tgz",
+      "integrity": "sha512-gmBGslpoQJtgnMAvOVqGZpEz9dyoKTCzy2nfz/n8aIFhN/jCE/rCmcxabB6jOOHV+0WNnylOxaxBQPSvcWklhA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "ansi-regex": "^6.0.1"
+      },
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/strip-ansi?sponsor=1"
+      }
+    },
+    "node_modules/@istanbuljs/schema": {
+      "version": "0.1.3",
+      "resolved": "https://registry.npmjs.org/@istanbuljs/schema/-/schema-0.1.3.tgz",
+      "integrity": "sha512-ZXRY4jNvVgSVQ8DL3LTcakaAtXwTVUxE81hslsyD2AtoXW/wVob10HkOJ1X/pAlcI7D+2YoZKg5do8G/w6RYgA==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/@jridgewell/gen-mapping": {
+      "version": "0.3.13",
+      "resolved": "https://registry.npmjs.org/@jridgewell/gen-mapping/-/gen-mapping-0.3.13.tgz",
+      "integrity": "sha512-2kkt/7niJ6MgEPxF0bYdQ6etZaA+fQvDcLKckhy1yIQOzaoKjBBjSj63/aLVjYE3qhRt5dvM+uUyfCg6UKCBbA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@jridgewell/sourcemap-codec": "^1.5.0",
+        "@jridgewell/trace-mapping": "^0.3.24"
+      }
+    },
+    "node_modules/@jridgewell/resolve-uri": {
+      "version": "3.1.2",
+      "resolved": "https://registry.npmjs.org/@jridgewell/resolve-uri/-/resolve-uri-3.1.2.tgz",
+      "integrity": "sha512-bRISgCIjP20/tbWSPWMEi54QVPRZExkuD9lJL+UIxUKtwVJA8wW1Trb1jMs1RFXo1CBTNZ/5hpC9QvmKWdopKw==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=6.0.0"
+      }
+    },
     "node_modules/@jridgewell/sourcemap-codec": {
       "version": "1.5.5",
       "resolved": "https://registry.npmjs.org/@jridgewell/sourcemap-codec/-/sourcemap-codec-1.5.5.tgz",
@@ -568,6 +718,17 @@
       "dev": true,
       "license": "MIT"
     },
+    "node_modules/@jridgewell/trace-mapping": {
+      "version": "0.3.31",
+      "resolved": "https://registry.npmjs.org/@jridgewell/trace-mapping/-/trace-mapping-0.3.31.tgz",
+      "integrity": "sha512-zzNR+SdQSDJzc8joaeP8QQoCQr8NuYx2dIIytl1QeBEZHJ9uW6hebsrYgbz8hJwUQao3TWCMtmfV8Nu1twOLAw==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@jridgewell/resolve-uri": "^3.1.0",
+        "@jridgewell/sourcemap-codec": "^1.4.14"
+      }
+    },
     "node_modules/@nodelib/fs.scandir": {
       "version": "2.1.5",
       "resolved": "https://registry.npmjs.org/@nodelib/fs.scandir/-/fs.scandir-2.1.5.tgz",
@@ -606,6 +767,17 @@
         "node": ">= 8"
       }
     },
+    "node_modules/@pkgjs/parseargs": {
+      "version": "0.11.0",
+      "resolved": "https://registry.npmjs.org/@pkgjs/parseargs/-/parseargs-0.11.0.tgz",
+      "integrity": "sha512-+1VkjdD0QBLPodGrJUeqarH8VAIvQODIbwh9XpP5Syisf7YoQgsJKPNFoqqLQlu+VQ/tVSshMR6loPMn8U+dPg==",
+      "dev": true,
+      "license": "MIT",
+      "optional": true,
+      "engines": {
+        "node": ">=14"
+      }
+    },
     "node_modules/@rollup/rollup-android-arm-eabi": {
       "version": "4.57.1",
       "resolved": "https://registry.npmjs.org/@rollup/rollup-android-arm-eabi/-/rollup-android-arm-eabi-4.57.1.tgz",
@@ -979,7 +1151,6 @@
       "integrity": "sha512-m0jEgYlYz+mDJZ2+F4v8D1AyQb+QzsNqRuI7xg1VQX/KlKS0qT9r1Mo16yo5F/MtifXFgaofIFsdFMox2SxIbQ==",
       "dev": true,
       "license": "MIT",
-      "peer": true,
       "dependencies": {
         "undici-types": "~7.16.0"
       }
@@ -1031,7 +1202,6 @@
       "integrity": "sha512-4Z+L8I2OqhZV8qA132M4wNL30ypZGYOQVBfMgxDH/K5UX0PNqTu1c6za9ST5r9+tavvHiTWmBnKzpCJ/GlVFtg==",
       "dev": true,
       "license": "BSD-2-Clause",
-      "peer": true,
       "dependencies": {
         "@typescript-eslint/scope-manager": "7.18.0",
         "@typescript-eslint/types": "7.18.0",
@@ -1192,6 +1362,39 @@
       "dev": true,
       "license": "ISC"
     },
+    "node_modules/@vitest/coverage-v8": {
+      "version": "2.1.9",
+      "resolved": "https://registry.npmjs.org/@vitest/coverage-v8/-/coverage-v8-2.1.9.tgz",
+      "integrity": "sha512-Z2cOr0ksM00MpEfyVE8KXIYPEcBFxdbLSs56L8PO0QQMxt/6bDj45uQfxoc96v05KW3clk7vvgP0qfDit9DmfQ==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@ampproject/remapping": "^2.3.0",
+        "@bcoe/v8-coverage": "^0.2.3",
+        "debug": "^4.3.7",
+        "istanbul-lib-coverage": "^3.2.2",
+        "istanbul-lib-report": "^3.0.1",
+        "istanbul-lib-source-maps": "^5.0.6",
+        "istanbul-reports": "^3.1.7",
+        "magic-string": "^0.30.12",
+        "magicast": "^0.3.5",
+        "std-env": "^3.8.0",
+        "test-exclude": "^7.0.1",
+        "tinyrainbow": "^1.2.0"
+      },
+      "funding": {
+        "url": "https://opencollective.com/vitest"
+      },
+      "peerDependencies": {
+        "@vitest/browser": "2.1.9",
+        "vitest": "2.1.9"
+      },
+      "peerDependenciesMeta": {
+        "@vitest/browser": {
+          "optional": true
+        }
+      }
+    },
     "node_modules/@vitest/expect": {
       "version": "2.1.9",
       "resolved": "https://registry.npmjs.org/@vitest/expect/-/expect-2.1.9.tgz",
@@ -1311,7 +1514,6 @@
       "integrity": "sha512-NZyJarBfL7nWwIq+FDL6Zp/yHEhePMNnnJ0y3qfieCrmNvYct8uvtiV41UvlSe6apAfk0fY1FbWx+NwfmpvtTg==",
       "dev": true,
       "license": "MIT",
-      "peer": true,
       "bin": {
         "acorn": "bin/acorn"
       },
@@ -1710,6 +1912,20 @@
         "node": ">=6.0.0"
       }
     },
+    "node_modules/eastasianwidth": {
+      "version": "0.2.0",
+      "resolved": "https://registry.npmjs.org/eastasianwidth/-/eastasianwidth-0.2.0.tgz",
+      "integrity": "sha512-I88TYZWc9XiYHRQ4/3c5rjjfgkjhLyW2luGIheGERbNQ6OY7yTybanSpDXZa8y7VUP9YmDcYa+eyq4ca7iLqWA==",
+      "dev": true,
+      "license": "MIT"
+    },
+    "node_modules/emoji-regex": {
+      "version": "9.2.2",
+      "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-9.2.2.tgz",
+      "integrity": "sha512-L18DaJsXSUk2+42pv8mLs5jJT2hqFkFE4j21wOmgbUqsZ2hL72NsUU785g9RXgo3s0ZNgVl42TiHp3ZtOv/Vyg==",
+      "dev": true,
+      "license": "MIT"
+    },
     "node_modules/end-of-stream": {
       "version": "1.4.5",
       "resolved": "https://registry.npmjs.org/end-of-stream/-/end-of-stream-1.4.5.tgz",
@@ -1785,7 +2001,6 @@
       "deprecated": "This version is no longer supported. Please see https://eslint.org/version-support for other options.",
       "dev": true,
       "license": "MIT",
-      "peer": true,
       "dependencies": {
         "@eslint-community/eslint-utils": "^4.2.0",
         "@eslint-community/regexpp": "^4.6.1",
@@ -2115,6 +2330,23 @@
       "dev": true,
       "license": "ISC"
     },
+    "node_modules/foreground-child": {
+      "version": "3.3.1",
+      "resolved": "https://registry.npmjs.org/foreground-child/-/foreground-child-3.3.1.tgz",
+      "integrity": "sha512-gIXjKqtFuWEgzFRJA9WCQeSJLZDjgJUOMCMzxtvFq/37KojM1BFGufqsCy0r4qSQmYLsZYMeyRqzIWOMup03sw==",
+      "dev": true,
+      "license": "ISC",
+      "dependencies": {
+        "cross-spawn": "^7.0.6",
+        "signal-exit": "^4.0.1"
+      },
+      "engines": {
+        "node": ">=14"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/isaacs"
+      }
+    },
     "node_modules/fs-constants": {
       "version": "1.0.0",
       "resolved": "https://registry.npmjs.org/fs-constants/-/fs-constants-1.0.0.tgz",
@@ -2262,6 +2494,13 @@
         "node": ">=8"
       }
     },
+    "node_modules/html-escaper": {
+      "version": "2.0.2",
+      "resolved": "https://registry.npmjs.org/html-escaper/-/html-escaper-2.0.2.tgz",
+      "integrity": "sha512-H2iMtd0I4Mt5eYiapRdIDjp+XzelXQ0tFE4JS7YFwFevXXMmOp9myNrUvCg0D6ws8iqkRPBfKHgbwig1SmlLfg==",
+      "dev": true,
+      "license": "MIT"
+    },
     "node_modules/ieee754": {
       "version": "1.2.1",
       "resolved": "https://registry.npmjs.org/ieee754/-/ieee754-1.2.1.tgz",
@@ -2353,6 +2592,16 @@
         "node": ">=0.10.0"
       }
     },
+    "node_modules/is-fullwidth-code-point": {
+      "version": "3.0.0",
+      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/is-fullwidth-code-point-3.0.0.tgz",
+      "integrity": "sha512-zymm5+u+sCsSWyD9qNaejV3DFvhCKclKdizYaJUuHA83RLjb7nSuGnddCHGv0hk+KY7BMAlsWeK4Ueg6EV6XQg==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=8"
+      }
+    },
     "node_modules/is-glob": {
       "version": "4.0.3",
       "resolved": "https://registry.npmjs.org/is-glob/-/is-glob-4.0.3.tgz",
@@ -2393,6 +2642,76 @@
       "dev": true,
       "license": "ISC"
     },
+    "node_modules/istanbul-lib-coverage": {
+      "version": "3.2.2",
+      "resolved": "https://registry.npmjs.org/istanbul-lib-coverage/-/istanbul-lib-coverage-3.2.2.tgz",
+      "integrity": "sha512-O8dpsF+r0WV/8MNRKfnmrtCWhuKjxrq2w+jpzBL5UZKTi2LeVWnWOmWRxFlesJONmc+wLAGvKQZEOanko0LFTg==",
+      "dev": true,
+      "license": "BSD-3-Clause",
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/istanbul-lib-report": {
+      "version": "3.0.1",
+      "resolved": "https://registry.npmjs.org/istanbul-lib-report/-/istanbul-lib-report-3.0.1.tgz",
+      "integrity": "sha512-GCfE1mtsHGOELCU8e/Z7YWzpmybrx/+dSTfLrvY8qRmaY6zXTKWn6WQIjaAFw069icm6GVMNkgu0NzI4iPZUNw==",
+      "dev": true,
+      "license": "BSD-3-Clause",
+      "dependencies": {
+        "istanbul-lib-coverage": "^3.0.0",
+        "make-dir": "^4.0.0",
+        "supports-color": "^7.1.0"
+      },
+      "engines": {
+        "node": ">=10"
+      }
+    },
+    "node_modules/istanbul-lib-source-maps": {
+      "version": "5.0.6",
+      "resolved": "https://registry.npmjs.org/istanbul-lib-source-maps/-/istanbul-lib-source-maps-5.0.6.tgz",
+      "integrity": "sha512-yg2d+Em4KizZC5niWhQaIomgf5WlL4vOOjZ5xGCmF8SnPE/mDWWXgvRExdcpCgh9lLRRa1/fSYp2ymmbJ1pI+A==",
+      "dev": true,
+      "license": "BSD-3-Clause",
+      "dependencies": {
+        "@jridgewell/trace-mapping": "^0.3.23",
+        "debug": "^4.1.1",
+        "istanbul-lib-coverage": "^3.0.0"
+      },
+      "engines": {
+        "node": ">=10"
+      }
+    },
+    "node_modules/istanbul-reports": {
+      "version": "3.2.0",
+      "resolved": "https://registry.npmjs.org/istanbul-reports/-/istanbul-reports-3.2.0.tgz",
+      "integrity": "sha512-HGYWWS/ehqTV3xN10i23tkPkpH46MLCIMFNCaaKNavAXTF1RkqxawEPtnjnGZ6XKSInBKkiOA5BKS+aZiY3AvA==",
+      "dev": true,
+      "license": "BSD-3-Clause",
+      "dependencies": {
+        "html-escaper": "^2.0.0",
+        "istanbul-lib-report": "^3.0.0"
+      },
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/jackspeak": {
+      "version": "3.4.3",
+      "resolved": "https://registry.npmjs.org/jackspeak/-/jackspeak-3.4.3.tgz",
+      "integrity": "sha512-OGlZQpz2yfahA/Rd1Y8Cd9SIEsqvXkLVoSw/cgwhnhFMDbsQFeZYoJJ7bIZBS9BcamUW96asq/npPWugM+RQBw==",
+      "dev": true,
+      "license": "BlueOak-1.0.0",
+      "dependencies": {
+        "@isaacs/cliui": "^8.0.2"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/isaacs"
+      },
+      "optionalDependencies": {
+        "@pkgjs/parseargs": "^0.11.0"
+      }
+    },
     "node_modules/js-yaml": {
       "version": "4.1.1",
       "resolved": "https://registry.npmjs.org/js-yaml/-/js-yaml-4.1.1.tgz",
@@ -2481,6 +2800,13 @@
       "dev": true,
       "license": "MIT"
     },
+    "node_modules/lru-cache": {
+      "version": "10.4.3",
+      "resolved": "https://registry.npmjs.org/lru-cache/-/lru-cache-10.4.3.tgz",
+      "integrity": "sha512-JNAzZcXrCt42VGLuYz0zfAzDfAvJWW6AfYlDBQyDV5DClI2m5sAmK+OIO7s59XfsRsWHp02jAJrRadPRGTt6SQ==",
+      "dev": true,
+      "license": "ISC"
+    },
     "node_modules/magic-string": {
       "version": "0.30.21",
       "resolved": "https://registry.npmjs.org/magic-string/-/magic-string-0.30.21.tgz",
@@ -2491,6 +2817,34 @@
         "@jridgewell/sourcemap-codec": "^1.5.5"
       }
     },
+    "node_modules/magicast": {
+      "version": "0.3.5",
+      "resolved": "https://registry.npmjs.org/magicast/-/magicast-0.3.5.tgz",
+      "integrity": "sha512-L0WhttDl+2BOsybvEOLK7fW3UA0OQ0IQ2d6Zl2x/a6vVRs3bAY0ECOSHHeL5jD+SbOpOCUEi0y1DgHEn9Qn1AQ==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@babel/parser": "^7.25.4",
+        "@babel/types": "^7.25.4",
+        "source-map-js": "^1.2.0"
+      }
+    },
+    "node_modules/make-dir": {
+      "version": "4.0.0",
+      "resolved": "https://registry.npmjs.org/make-dir/-/make-dir-4.0.0.tgz",
+      "integrity": "sha512-hXdUTZYIVOt1Ex//jAQi+wTZZpUpwBj/0QsOzqegb3rGMMeJiSEu5xLHnYfBrRV4RH2+OCSOO95Is/7x1WJ4bw==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "semver": "^7.5.3"
+      },
+      "engines": {
+        "node": ">=10"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/sindresorhus"
+      }
+    },
     "node_modules/merge2": {
       "version": "1.4.1",
       "resolved": "https://registry.npmjs.org/merge2/-/merge2-1.4.1.tgz",
@@ -2552,6 +2906,16 @@
         "url": "https://github.com/sponsors/ljharb"
       }
     },
+    "node_modules/minipass": {
+      "version": "7.1.2",
+      "resolved": "https://registry.npmjs.org/minipass/-/minipass-7.1.2.tgz",
+      "integrity": "sha512-qOOzS1cBTWYF4BH8fVePDBOO9iptMnGUEZwNc/cMWnTV2nVLZ7VoNWEPHkYczZA0pdoA7dl6e7FL659nX9S2aw==",
+      "dev": true,
+      "license": "ISC",
+      "engines": {
+        "node": ">=16 || 14 >=14.17"
+      }
+    },
     "node_modules/mkdirp-classic": {
       "version": "0.5.3",
       "resolved": "https://registry.npmjs.org/mkdirp-classic/-/mkdirp-classic-0.5.3.tgz",
@@ -2668,6 +3032,13 @@
         "url": "https://github.com/sponsors/sindresorhus"
       }
     },
+    "node_modules/package-json-from-dist": {
+      "version": "1.0.1",
+      "resolved": "https://registry.npmjs.org/package-json-from-dist/-/package-json-from-dist-1.0.1.tgz",
+      "integrity": "sha512-UEZIS3/by4OC8vL3P2dTXRETpebLI2NiI5vIrjaD/5UtrkFX/tNbwjTSRAGC/+7CAo2pIcBaRgWmcBBHcsaCIw==",
+      "dev": true,
+      "license": "BlueOak-1.0.0"
+    },
     "node_modules/parent-module": {
       "version": "1.0.1",
       "resolved": "https://registry.npmjs.org/parent-module/-/parent-module-1.0.1.tgz",
@@ -2711,6 +3082,23 @@
         "node": ">=8"
       }
     },
+    "node_modules/path-scurry": {
+      "version": "1.11.1",
+      "resolved": "https://registry.npmjs.org/path-scurry/-/path-scurry-1.11.1.tgz",
+      "integrity": "sha512-Xa4Nw17FS9ApQFJ9umLiJS4orGjm7ZzwUrwamcGQuHSzDyth9boKDaycYdDcZDuqYATXw4HFXgaqWTctW/v1HA==",
+      "dev": true,
+      "license": "BlueOak-1.0.0",
+      "dependencies": {
+        "lru-cache": "^10.2.0",
+        "minipass": "^5.0.0 || ^6.0.2 || ^7.0.0"
+      },
+      "engines": {
+        "node": ">=16 || 14 >=14.18"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/isaacs"
+      }
+    },
     "node_modules/path-type": {
       "version": "4.0.0",
       "resolved": "https://registry.npmjs.org/path-type/-/path-type-4.0.0.tgz",
@@ -3071,6 +3459,19 @@
       "dev": true,
       "license": "ISC"
     },
+    "node_modules/signal-exit": {
+      "version": "4.1.0",
+      "resolved": "https://registry.npmjs.org/signal-exit/-/signal-exit-4.1.0.tgz",
+      "integrity": "sha512-bzyZ1e88w9O1iNJbKnOlvYTrWPDl46O1bG0D3XInv+9tkPrxrN8jUUTiFlDkkmKWgn1M6CfIA13SuGqOa9Korw==",
+      "dev": true,
+      "license": "ISC",
+      "engines": {
+        "node": ">=14"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/isaacs"
+      }
+    },
     "node_modules/simple-concat": {
       "version": "1.0.1",
       "resolved": "https://registry.npmjs.org/simple-concat/-/simple-concat-1.0.1.tgz",
@@ -3159,6 +3560,76 @@
         "safe-buffer": "~5.2.0"
       }
     },
+    "node_modules/string-width": {
+      "version": "5.1.2",
+      "resolved": "https://registry.npmjs.org/string-width/-/string-width-5.1.2.tgz",
+      "integrity": "sha512-HnLOCR3vjcY8beoNLtcjZ5/nxn2afmME6lhrDrebokqMap+XbeW8n9TXpPDOqdGK5qcI3oT0GKTW6wC7EMiVqA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "eastasianwidth": "^0.2.0",
+        "emoji-regex": "^9.2.2",
+        "strip-ansi": "^7.0.1"
+      },
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/sindresorhus"
+      }
+    },
+    "node_modules/string-width-cjs": {
+      "name": "string-width",
+      "version": "4.2.3",
+      "resolved": "https://registry.npmjs.org/string-width/-/string-width-4.2.3.tgz",
+      "integrity": "sha512-wKyQRQpjJ0sIp62ErSZdGsjMJWsap5oRNihHhu6G7JVO/9jIB6UyevL+tXuOqrng8j/cxKTWyWUwvSTriiZz/g==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "emoji-regex": "^8.0.0",
+        "is-fullwidth-code-point": "^3.0.0",
+        "strip-ansi": "^6.0.1"
+      },
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/string-width-cjs/node_modules/emoji-regex": {
+      "version": "8.0.0",
+      "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-8.0.0.tgz",
+      "integrity": "sha512-MSjYzcWNOA0ewAHpz0MxpYFvwg6yjy1NG3xteoqz644VCo/RPgnr1/GGt+ic3iJTzQ8Eu3TdM14SawnVUmGE6A==",
+      "dev": true,
+      "license": "MIT"
+    },
+    "node_modules/string-width/node_modules/ansi-regex": {
+      "version": "6.2.2",
+      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-6.2.2.tgz",
+      "integrity": "sha512-Bq3SmSpyFHaWjPk8If9yc6svM8c56dB5BAtW4Qbw5jHTwwXXcTLoRMkpDJp6VL0XzlWaCHTXrkFURMYmD0sLqg==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/ansi-regex?sponsor=1"
+      }
+    },
+    "node_modules/string-width/node_modules/strip-ansi": {
+      "version": "7.1.2",
+      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-7.1.2.tgz",
+      "integrity": "sha512-gmBGslpoQJtgnMAvOVqGZpEz9dyoKTCzy2nfz/n8aIFhN/jCE/rCmcxabB6jOOHV+0WNnylOxaxBQPSvcWklhA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "ansi-regex": "^6.0.1"
+      },
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/strip-ansi?sponsor=1"
+      }
+    },
     "node_modules/strip-ansi": {
       "version": "6.0.1",
       "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-6.0.1.tgz",
@@ -3172,6 +3643,20 @@
         "node": ">=8"
       }
     },
+    "node_modules/strip-ansi-cjs": {
+      "name": "strip-ansi",
+      "version": "6.0.1",
+      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-6.0.1.tgz",
+      "integrity": "sha512-Y38VPSHcqkFrCpFnQ9vuSXmquuv5oXOKpGeT6aGrr3o3Gc9AlVa6JBfUSOCnbxGGZF+/0ooI7KrPuUSztUdU5A==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "ansi-regex": "^5.0.1"
+      },
+      "engines": {
+        "node": ">=8"
+      }
+    },
     "node_modules/strip-json-comments": {
       "version": "3.1.1",
       "resolved": "https://registry.npmjs.org/strip-json-comments/-/strip-json-comments-3.1.1.tgz",
@@ -3226,6 +3711,43 @@
         "node": ">=6"
       }
     },
+    "node_modules/test-exclude": {
+      "version": "7.0.1",
+      "resolved": "https://registry.npmjs.org/test-exclude/-/test-exclude-7.0.1.tgz",
+      "integrity": "sha512-pFYqmTw68LXVjeWJMST4+borgQP2AyMNbg1BpZh9LbyhUeNkeaPF9gzfPGUAnSMV3qPYdWUwDIjjCLiSDOl7vg==",
+      "dev": true,
+      "license": "ISC",
+      "dependencies": {
+        "@istanbuljs/schema": "^0.1.2",
+        "glob": "^10.4.1",
+        "minimatch": "^9.0.4"
+      },
+      "engines": {
+        "node": ">=18"
+      }
+    },
+    "node_modules/test-exclude/node_modules/glob": {
+      "version": "10.5.0",
+      "resolved": "https://registry.npmjs.org/glob/-/glob-10.5.0.tgz",
+      "integrity": "sha512-DfXN8DfhJ7NH3Oe7cFmu3NCu1wKbkReJ8TorzSAFbSKrlNaQSKfIzqYqVY8zlbs2NLBbWpRiU52GX2PbaBVNkg==",
+      "deprecated": "Old versions of glob are not supported, and contain widely publicized security vulnerabilities, which have been fixed in the current version. Please update. Support for old versions may be purchased (at exorbitant rates) by contacting i@izs.me",
+      "dev": true,
+      "license": "ISC",
+      "dependencies": {
+        "foreground-child": "^3.1.0",
+        "jackspeak": "^3.1.2",
+        "minimatch": "^9.0.4",
+        "minipass": "^7.1.2",
+        "package-json-from-dist": "^1.0.0",
+        "path-scurry": "^1.11.1"
+      },
+      "bin": {
+        "glob": "dist/esm/bin.mjs"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/isaacs"
+      }
+    },
     "node_modules/text-table": {
       "version": "0.2.0",
       "resolved": "https://registry.npmjs.org/text-table/-/text-table-0.2.0.tgz",
@@ -3347,7 +3869,6 @@
       "integrity": "sha512-jl1vZzPDinLr9eUt3J/t7V6FgNEw9QjvBPdysz9KfQDD41fQrC2Y4vKQdiaUpFT4bXlb1RHhLpp8wtm6M5TgSw==",
       "dev": true,
       "license": "Apache-2.0",
-      "peer": true,
       "bin": {
         "tsc": "bin/tsc",
         "tsserver": "bin/tsserver"
@@ -3571,6 +4092,107 @@
         "node": ">=0.10.0"
       }
     },
+    "node_modules/wrap-ansi": {
+      "version": "8.1.0",
+      "resolved": "https://registry.npmjs.org/wrap-ansi/-/wrap-ansi-8.1.0.tgz",
+      "integrity": "sha512-si7QWI6zUMq56bESFvagtmzMdGOtoxfR+Sez11Mobfc7tm+VkUckk9bW2UeffTGVUbOksxmSw0AA2gs8g71NCQ==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "ansi-styles": "^6.1.0",
+        "string-width": "^5.0.1",
+        "strip-ansi": "^7.0.1"
+      },
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/wrap-ansi?sponsor=1"
+      }
+    },
+    "node_modules/wrap-ansi-cjs": {
+      "name": "wrap-ansi",
+      "version": "7.0.0",
+      "resolved": "https://registry.npmjs.org/wrap-ansi/-/wrap-ansi-7.0.0.tgz",
+      "integrity": "sha512-YVGIj2kamLSTxw6NsZjoBxfSwsn0ycdesmc4p+Q21c5zPuZ1pl+NfxVdxPtdHvmNVOQ6XSYG4AUtyt/Fi7D16Q==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "ansi-styles": "^4.0.0",
+        "string-width": "^4.1.0",
+        "strip-ansi": "^6.0.0"
+      },
+      "engines": {
+        "node": ">=10"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/wrap-ansi?sponsor=1"
+      }
+    },
+    "node_modules/wrap-ansi-cjs/node_modules/emoji-regex": {
+      "version": "8.0.0",
+      "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-8.0.0.tgz",
+      "integrity": "sha512-MSjYzcWNOA0ewAHpz0MxpYFvwg6yjy1NG3xteoqz644VCo/RPgnr1/GGt+ic3iJTzQ8Eu3TdM14SawnVUmGE6A==",
+      "dev": true,
+      "license": "MIT"
+    },
+    "node_modules/wrap-ansi-cjs/node_modules/string-width": {
+      "version": "4.2.3",
+      "resolved": "https://registry.npmjs.org/string-width/-/string-width-4.2.3.tgz",
+      "integrity": "sha512-wKyQRQpjJ0sIp62ErSZdGsjMJWsap5oRNihHhu6G7JVO/9jIB6UyevL+tXuOqrng8j/cxKTWyWUwvSTriiZz/g==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "emoji-regex": "^8.0.0",
+        "is-fullwidth-code-point": "^3.0.0",
+        "strip-ansi": "^6.0.1"
+      },
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/wrap-ansi/node_modules/ansi-regex": {
+      "version": "6.2.2",
+      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-6.2.2.tgz",
+      "integrity": "sha512-Bq3SmSpyFHaWjPk8If9yc6svM8c56dB5BAtW4Qbw5jHTwwXXcTLoRMkpDJp6VL0XzlWaCHTXrkFURMYmD0sLqg==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/ansi-regex?sponsor=1"
+      }
+    },
+    "node_modules/wrap-ansi/node_modules/ansi-styles": {
+      "version": "6.2.3",
+      "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-6.2.3.tgz",
+      "integrity": "sha512-4Dj6M28JB+oAH8kFkTLUo+a2jwOFkuqb3yucU0CANcRRUbxS0cP0nZYCGjcc3BNXwRIsUVmDGgzawme7zvJHvg==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/ansi-styles?sponsor=1"
+      }
+    },
+    "node_modules/wrap-ansi/node_modules/strip-ansi": {
+      "version": "7.1.2",
+      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-7.1.2.tgz",
+      "integrity": "sha512-gmBGslpoQJtgnMAvOVqGZpEz9dyoKTCzy2nfz/n8aIFhN/jCE/rCmcxabB6jOOHV+0WNnylOxaxBQPSvcWklhA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "ansi-regex": "^6.0.1"
+      },
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/strip-ansi?sponsor=1"
+      }
+    },
     "node_modules/wrappy": {
       "version": "1.0.2",
       "resolved": "https://registry.npmjs.org/wrappy/-/wrappy-1.0.2.tgz",
diff --git a/src/deps/deps.test.ts b/src/deps/deps.test.ts
new file mode 100644
index 0000000..0a5d81e
--- /dev/null
+++ b/src/deps/deps.test.ts
@@ -0,0 +1,263 @@
+import { describe, it, expect, beforeEach } from 'vitest';
+import { createDepsAnalyzer as createDepsService } from './index.js';
+import type { DepsService, PluginManifest, RegistryService } from '../types.js';
+
+function createMockRegistry(
+  plugins: Record<string, PluginManifest>
+): RegistryService {
+  return {
+    register: () => {},
+    get: (name: string) => plugins[name] ?? null,
+    getVersion: () => null,
+    list: () => Object.values(plugins),
+    search: () => [],
+    remove: () => false,
+    listVersions: () => [],
+    update: () => {},
+  };
+}
+
+function makeManifest(
+  name: string,
+  deps: Record<string, string> = {}
+): PluginManifest {
+  return {
+    name,
+    version: '1.0.0',
+    description: '',
+    author: 'test',
+    dependencies: deps,
+    entryPoint: '',
+    permissions: [],
+  };
+}
+
+describe('DepsService', () => {
+  let service: DepsService;
+
+  beforeEach(() => {
+    service = createDepsService();
+  });
+
+  describe('buildTree', () => {
+    it('should build a tree for a plugin with no dependencies', () => {
+      const registry = createMockRegistry({
+        'plugin-a': makeManifest('plugin-a'),
+      });
+
+      const tree = service.buildTree('plugin-a', registry);
+      expect(tree.name).toBe('plugin-a');
+      expect(tree.version).toBe('1.0.0');
+      expect(tree.dependencies).toEqual([]);
+    });
+
+    it('should build a tree with nested dependencies', () => {
+      const registry = createMockRegistry({
+        'plugin-a': makeManifest('plugin-a', { 'plugin-b': '^1.0.0' }),
+        'plugin-b': makeManifest('plugin-b', { 'plugin-c': '^1.0.0' }),
+        'plugin-c': makeManifest('plugin-c'),
+      });
+
+      const tree = service.buildTree('plugin-a', registry);
+      expect(tree.name).toBe('plugin-a');
+      expect(tree.dependencies).toHaveLength(1);
+      expect(tree.dependencies[0].name).toBe('plugin-b');
+      expect(tree.dependencies[0].dependencies).toHaveLength(1);
+      expect(tree.dependencies[0].dependencies[0].name).toBe('plugin-c');
+    });
+
+    it('should handle unknown plugins gracefully', () => {
+      const registry = createMockRegistry({});
+
+      const tree = service.buildTree('unknown', registry);
+      expect(tree.name).toBe('unknown');
+      expect(tree.version).toBe('unknown');
+      expect(tree.dependencies).toEqual([]);
+    });
+
+    it('should handle circular deps without infinite recursion', () => {
+      const registry = createMockRegistry({
+        a: makeManifest('a', { b: '^1.0.0' }),
+        b: makeManifest('b', { a: '^1.0.0' }),
+      });
+
+      const tree = service.buildTree('a', registry);
+      expect(tree.name).toBe('a');
+      expect(tree.dependencies).toHaveLength(1);
+      expect(tree.dependencies[0].name).toBe('b');
+      // circular: b -> a should stop recursing
+      expect(tree.dependencies[0].dependencies).toHaveLength(1);
+      expect(tree.dependencies[0].dependencies[0].name).toBe('a');
+      expect(tree.dependencies[0].dependencies[0].dependencies).toEqual([]);
+    });
+  });
+
+  describe('detectCycles', () => {
+    it('should return null when there are no cycles', () => {
+      const registry = createMockRegistry({
+        a: makeManifest('a', { b: '^1.0.0' }),
+        b: makeManifest('b', { c: '^1.0.0' }),
+        c: makeManifest('c'),
+      });
+
+      expect(service.detectCycles('a', registry)).toBeNull();
+    });
+
+    it('should detect a direct cycle', () => {
+      const registry = createMockRegistry({
+        a: makeManifest('a', { b: '^1.0.0' }),
+        b: makeManifest('b', { a: '^1.0.0' }),
+      });
+
+      const cycles = service.detectCycles('a', registry);
+      expect(cycles).not.toBeNull();
+      expect(cycles!.length).toBeGreaterThan(0);
+      // The cycle should contain both a and b
+      const cycle = cycles![0];
+      expect(cycle).toContain('a');
+      expect(cycle).toContain('b');
+    });
+
+    it('should detect a self-referencing cycle', () => {
+      const registry = createMockRegistry({
+        a: makeManifest('a', { a: '^1.0.0' }),
+      });
+
+      const cycles = service.detectCycles('a', registry);
+      expect(cycles).not.toBeNull();
+      expect(cycles!.length).toBeGreaterThan(0);
+    });
+
+    it('should detect indirect cycles', () => {
+      const registry = createMockRegistry({
+        a: makeManifest('a', { b: '^1.0.0' }),
+        b: makeManifest('b', { c: '^1.0.0' }),
+        c: makeManifest('c', { a: '^1.0.0' }),
+      });
+
+      const cycles = service.detectCycles('a', registry);
+      expect(cycles).not.toBeNull();
+    });
+  });
+
+  describe('topologicalSort', () => {
+    it('should return correct order for linear dependencies', () => {
+      const registry = createMockRegistry({
+        a: makeManifest('a', { b: '^1.0.0' }),
+        b: makeManifest('b', { c: '^1.0.0' }),
+        c: makeManifest('c'),
+      });
+
+      const sorted = service.topologicalSort('a', registry);
+      expect(sorted).toEqual(['c', 'b', 'a']);
+    });
+
+    it('should return single element for no dependencies', () => {
+      const registry = createMockRegistry({
+        a: makeManifest('a'),
+      });
+
+      const sorted = service.topologicalSort('a', registry);
+      expect(sorted).toEqual(['a']);
+    });
+
+    it('should throw on circular dependencies', () => {
+      const registry = createMockRegistry({
+        a: makeManifest('a', { b: '^1.0.0' }),
+        b: makeManifest('b', { a: '^1.0.0' }),
+      });
+
+      expect(() => service.topologicalSort('a', registry)).toThrow(
+        /[Cc]ircular/
+      );
+    });
+
+    it('should handle diamond dependencies', () => {
+      const registry = createMockRegistry({
+        a: makeManifest('a', { b: '^1.0.0', c: '^1.0.0' }),
+        b: makeManifest('b', { d: '^1.0.0' }),
+        c: makeManifest('c', { d: '^1.0.0' }),
+        d: makeManifest('d'),
+      });
+
+      const sorted = service.topologicalSort('a', registry);
+      expect(sorted).toContain('a');
+      expect(sorted).toContain('b');
+      expect(sorted).toContain('c');
+      expect(sorted).toContain('d');
+      // d must come before b and c, and a must be last
+      expect(sorted.indexOf('d')).toBeLessThan(sorted.indexOf('b'));
+      expect(sorted.indexOf('d')).toBeLessThan(sorted.indexOf('c'));
+      expect(sorted.indexOf('a')).toBe(sorted.length - 1);
+    });
+  });
+
+  describe('flattenDependencies', () => {
+    it('should return all transitive dependencies', () => {
+      const registry = createMockRegistry({
+        a: makeManifest('a', { b: '^1.0.0' }),
+        b: makeManifest('b', { c: '^1.0.0' }),
+        c: makeManifest('c'),
+      });
+
+      const deps = service.flattenDependencies('a', registry);
+      expect(deps).toContain('b');
+      expect(deps).toContain('c');
+      expect(deps).not.toContain('a');
+    });
+
+    it('should return empty array when no dependencies', () => {
+      const registry = createMockRegistry({
+        a: makeManifest('a'),
+      });
+
+      expect(service.flattenDependencies('a', registry)).toEqual([]);
+    });
+
+    it('should not include duplicates in diamond pattern', () => {
+      const registry = createMockRegistry({
+        a: makeManifest('a', { b: '^1.0.0', c: '^1.0.0' }),
+        b: makeManifest('b', { d: '^1.0.0' }),
+        c: makeManifest('c', { d: '^1.0.0' }),
+        d: makeManifest('d'),
+      });
+
+      const deps = service.flattenDependencies('a', registry);
+      expect(deps).toContain('b');
+      expect(deps).toContain('c');
+      expect(deps).toContain('d');
+      // No duplicates
+      expect(new Set(deps).size).toBe(deps.length);
+    });
+
+    it('should handle circular deps without infinite loop', () => {
+      const registry = createMockRegistry({
+        a: makeManifest('a', { b: '^1.0.0' }),
+        b: makeManifest('b', { a: '^1.0.0' }),
+      });
+
+      const deps = service.flattenDependencies('a', registry);
+      expect(deps).toContain('b');
+    });
+  });
+
+  describe('hasCircularDependency', () => {
+    it('should return false for acyclic graph', () => {
+      const registry = createMockRegistry({
+        a: makeManifest('a', { b: '^1.0.0' }),
+        b: makeManifest('b'),
+      });
+
+      expect(service.hasCircularDependency('a', registry)).toBe(false);
+    });
+
+    it('should return true for cyclic graph', () => {
+      const registry = createMockRegistry({
+        a: makeManifest('a', { b: '^1.0.0' }),
+        b: makeManifest('b', { a: '^1.0.0' }),
+      });
+
+      expect(service.hasCircularDependency('a', registry)).toBe(true);
+    });
+  });
+});
diff --git a/src/deps/index.ts b/src/deps/index.ts
new file mode 100644
index 0000000..b207309
--- /dev/null
+++ b/src/deps/index.ts
@@ -0,0 +1,112 @@
+import type { DependencyNode, RegistryService, DepsService } from '../types.js';
+
+export function createDepsAnalyzer(): DepsService {
+  function buildTree(name: string, registry: RegistryService, visited?: Set<string>): DependencyNode {
+    const manifest = registry.get(name);
+    if (!manifest) {
+      return { name, version: 'unknown', dependencies: [] };
+    }
+
+    const seen = visited ?? new Set<string>();
+    if (seen.has(name)) {
+      return { name, version: manifest.version, dependencies: [] };
+    }
+    seen.add(name);
+
+    const deps: DependencyNode[] = [];
+    for (const depName of Object.keys(manifest.dependencies)) {
+      deps.push(buildTree(depName, registry, seen));
+    }
+
+    return {
+      name,
+      version: manifest.version,
+      dependencies: deps,
+    };
+  }
+
+  function detectCycles(name: string, registry: RegistryService): string[][] | null {
+    const cycles: string[][] = [];
+
+    function dfs(current: string, path: string[], visited: Set<string>): void {
+      if (path.includes(current)) {
+        const cycleStart = path.indexOf(current);
+        cycles.push([...path.slice(cycleStart), current]);
+        return;
+      }
+      if (visited.has(current)) return;
+
+      const manifest = registry.get(current);
+      if (!manifest) return;
+
+      path.push(current);
+      for (const depName of Object.keys(manifest.dependencies)) {
+        dfs(depName, path, visited);
+      }
+      path.pop();
+      visited.add(current);
+    }
+
+    dfs(name, [], new Set<string>());
+    return cycles.length > 0 ? cycles : null;
+  }
+
+  function topologicalSort(name: string, registry: RegistryService): string[] {
+    const result: string[] = [];
+    const visited = new Set<string>();
+    const visiting = new Set<string>();
+
+    function visit(current: string): void {
+      if (visited.has(current)) return;
+      if (visiting.has(current)) {
+        throw new Error(`Circular dependency detected involving ${current}`);
+      }
+
+      visiting.add(current);
+      const manifest = registry.get(current);
+      if (manifest) {
+        for (const depName of Object.keys(manifest.dependencies)) {
+          visit(depName);
+        }
+      }
+      visiting.delete(current);
+      visited.add(current);
+      result.push(current);
+    }
+
+    visit(name);
+    return result;
+  }
+
+  function flattenDependencies(name: string, registry: RegistryService): string[] {
+    const deps = new Set<string>();
+
+    function collect(current: string, visited: Set<string>): void {
+      if (visited.has(current)) return;
+      visited.add(current);
+
+      const manifest = registry.get(current);
+      if (!manifest) return;
+
+      for (const depName of Object.keys(manifest.dependencies)) {
+        deps.add(depName);
+        collect(depName, visited);
+      }
+    }
+
+    collect(name, new Set<string>());
+    return Array.from(deps);
+  }
+
+  function hasCircularDependency(name: string, registry: RegistryService): boolean {
+    return detectCycles(name, registry) !== null;
+  }
+
+  return {
+    buildTree,
+    detectCycles,
+    topologicalSort,
+    flattenDependencies,
+    hasCircularDependency,
+  };
+}
diff --git a/src/index.ts b/src/index.ts
new file mode 100644
index 0000000..1b04a7d
--- /dev/null
+++ b/src/index.ts
@@ -0,0 +1,113 @@
+import type {
+  PluginManifest,
+  RegistryService,
+  ResolverService,
+  RunnerService,
+  ReviewService,
+  DepsService,
+  ResolvedVersion,
+  SandboxResult,
+  VersionConstraint,
+} from './types.js';
+
+import { createRegistry } from './registry/index.js';
+import { createResolver } from './resolver/index.js';
+import { createRunner } from './runner/index.js';
+import { createReviewSystem } from './reviews/index.js';
+import { createDepsAnalyzer } from './deps/index.js';
+
+export interface InstallResult {
+  resolvedDependencies: ResolvedVersion[];
+  executionResult: SandboxResult;
+}
+
+export interface Marketplace {
+  registry: RegistryService;
+  resolver: ResolverService;
+  runner: RunnerService;
+  reviews: ReviewService;
+  deps: DepsService;
+  installPlugin(manifest: PluginManifest): Promise<InstallResult>;
+}
+
+export function createMarketplace(): Marketplace {
+  const registry = createRegistry();
+  const resolver = createResolver();
+  const runner = createRunner();
+  const reviews = createReviewSystem();
+  const deps = createDepsAnalyzer();
+
+  async function installPlugin(manifest: PluginManifest): Promise<InstallResult> {
+    // 1. Validate required fields
+    if (!manifest.name || typeof manifest.name !== 'string') {
+      throw new Error('Plugin manifest must have a valid "name" field');
+    }
+    if (!manifest.version || typeof manifest.version !== 'string') {
+      throw new Error('Plugin manifest must have a valid "version" field');
+    }
+    if (!manifest.entryPoint || typeof manifest.entryPoint !== 'string') {
+      throw new Error('Plugin manifest must have a valid "entryPoint" field');
+    }
+
+    // 2. Register the plugin in the catalog
+    registry.register(manifest);
+
+    // 3. Resolve dependency versions against what's available
+    const constraints: VersionConstraint[] = Object.entries(
+      manifest.dependencies || {}
+    ).map(([name, range]) => ({ name, range }));
+
+    const available: Record<string, string[]> = {};
+    for (const constraint of constraints) {
+      available[constraint.name] = registry.listVersions(constraint.name);
+    }
+
+    const resolvedDependencies = resolver.resolve(constraints, available);
+
+    // 4. Check for circular dependencies
+    if (deps.hasCircularDependency(manifest.name, registry)) {
+      // Unregister the plugin since it introduces a cycle
+      registry.remove(manifest.name, manifest.version);
+      throw new Error(
+        `Circular dependency detected for plugin "${manifest.name}"`
+      );
+    }
+
+    // 5. Execute the plugin's entry point in the sandbox
+    const executionResult = await runner.execute(manifest.entryPoint);
+
+    // 6. Return results
+    return {
+      resolvedDependencies,
+      executionResult,
+    };
+  }
+
+  return {
+    registry,
+    resolver,
+    runner,
+    reviews,
+    deps,
+    installPlugin,
+  };
+}
+
+export { createRegistry } from './registry/index.js';
+export { createResolver } from './resolver/index.js';
+export { createRunner } from './runner/index.js';
+export { createReviewSystem } from './reviews/index.js';
+export { createDepsAnalyzer } from './deps/index.js';
+export type {
+  PluginManifest,
+  VersionConstraint,
+  ResolvedVersion,
+  Review,
+  DependencyNode,
+  SandboxResult,
+  RegistryService,
+  ResolverService,
+  RunnerService,
+  ReviewService,
+  DepsService,
+} from './types.js';
diff --git a/src/registry/index.ts b/src/registry/index.ts
new file mode 100644
index 0000000..32e3d72
--- /dev/null
+++ b/src/registry/index.ts
@@ -0,0 +1,84 @@
+import type { PluginManifest, RegistryService } from '../types.js';
+
+export function createRegistry(): RegistryService {
+  // Map<name, Map<version, PluginManifest>>
+  const plugins = new Map<string, Map<string, PluginManifest>>();
+
+  return {
+    register(manifest: PluginManifest): void {
+      if (!plugins.has(manifest.name)) {
+        plugins.set(manifest.name, new Map());
+      }
+      plugins.get(manifest.name)!.set(manifest.version, { ...manifest });
+    },
+
+    get(name: string): PluginManifest | null {
+      const versions = plugins.get(name);
+      if (!versions || versions.size === 0) return null;
+      // Return the latest registered version (last inserted)
+      let latest: PluginManifest | null = null;
+      for (const manifest of versions.values()) {
+        latest = manifest;
+      }
+      return latest ? { ...latest } : null;
+    },
+
+    getVersion(name: string, version: string): PluginManifest | null {
+      const versions = plugins.get(name);
+      if (!versions) return null;
+      const manifest = versions.get(version);
+      return manifest ? { ...manifest } : null;
+    },
+
+    list(): PluginManifest[] {
+      const result: PluginManifest[] = [];
+      for (const versions of plugins.values()) {
+        for (const manifest of versions.values()) {
+          result.push({ ...manifest });
+        }
+      }
+      return result;
+    },
+
+    search(query: string): PluginManifest[] {
+      const lower = query.toLowerCase();
+      const result: PluginManifest[] = [];
+      for (const versions of plugins.values()) {
+        for (const manifest of versions.values()) {
+          if (
+            manifest.name.toLowerCase().includes(lower) ||
+            manifest.description.toLowerCase().includes(lower) ||
+            manifest.author.toLowerCase().includes(lower)
+          ) {
+            result.push({ ...manifest });
+          }
+        }
+      }
+      return result;
+    },
+
+    remove(name: string, version: string): boolean {
+      const versions = plugins.get(name);
+      if (!versions) return false;
+      const deleted = versions.delete(version);
+      if (versions.size === 0) {
+        plugins.delete(name);
+      }
+      return deleted;
+    },
+
+    listVersions(name: string): string[] {
+      const versions = plugins.get(name);
+      if (!versions) return [];
+      return Array.from(versions.keys());
+    },
+
+    update(name: string, version: string, updates: Partial<PluginManifest>): void {
+      const versions = plugins.get(name);
+      if (!versions) throw new Error(`Plugin ${name} not found`);
+      const manifest = versions.get(version);
+      if (!manifest) throw new Error(`Plugin ${name}@${version} not found`);
+      Object.assign(manifest, updates);
+    },
+  };
+}
diff --git a/src/resolver/index.ts b/src/resolver/index.ts
new file mode 100644
index 0000000..9d17e05
--- /dev/null
+++ b/src/resolver/index.ts
@@ -0,0 +1,37 @@
+import semver from 'semver';
+import type { VersionConstraint, ResolvedVersion, ResolverService } from '../types.js';
+
+export function createResolver(): ResolverService {
+  return {
+    resolve(constraints: VersionConstraint[], available: Record<string, string[]>): ResolvedVersion[] {
+      const results: ResolvedVersion[] = [];
+      for (const constraint of constraints) {
+        const versions = available[constraint.name];
+        if (!versions || versions.length === 0) {
+          continue;
+        }
+        const best = semver.maxSatisfying(versions, constraint.range);
+        if (best) {
+          results.push({
+            name: constraint.name,
+            version: best,
+            satisfies: constraint.range,
+          });
+        }
+      }
+      return results;
+    },
+
+    satisfies(version: string, range: string): boolean {
+      return semver.satisfies(version, range);
+    },
+
+    maxSatisfying(versions: string[], range: string): string | null {
+      return semver.maxSatisfying(versions, range);
+    },
+
+    validRange(range: string): boolean {
+      return semver.validRange(range) !== null;
+    },
+  };
+}
diff --git a/src/reviews/index.ts b/src/reviews/index.ts
new file mode 100644
index 0000000..a87e926
--- /dev/null
+++ b/src/reviews/index.ts
@@ -0,0 +1,65 @@
+import type { Review, ReviewService } from '../types.js';
+
+export function createReviewSystem(): ReviewService {
+  const reviews: Review[] = [];
+  let nextId = 1;
+
+  return {
+    addReview(review: Omit<Review, 'id' | 'createdAt' | 'flagged'>): Review {
+      if (review.rating < 1 || review.rating > 5) {
+        throw new Error('Rating must be between 1 and 5');
+      }
+
+      const newReview: Review = {
+        ...review,
+        id: nextId++,
+        flagged: false,
+        createdAt: new Date().toISOString(),
+      };
+      reviews.push(newReview);
+      return { ...newReview };
+    },
+
+    getReviews(pluginName: string): Review[] {
+      return reviews
+        .filter((r) => r.pluginName === pluginName)
+        .map((r) => ({ ...r }));
+    },
+
+    getAverageRating(pluginName: string): number {
+      const pluginReviews = reviews.filter(
+        (r) => r.pluginName === pluginName && !r.flagged
+      );
+      if (pluginReviews.length === 0) return 0;
+      const sum = pluginReviews.reduce((acc, r) => acc + r.rating, 0);
+      return sum / pluginReviews.length;
+    },
+
+    flagReview(reviewId: number): void {
+      const review = reviews.find((r) => r.id === reviewId);
+      if (!review) {
+        throw new Error(`Review with id ${reviewId} not found`);
+      }
+      review.flagged = true;
+    },
+
+    getFlaggedReviews(): Review[] {
+      return reviews.filter((r) => r.flagged).map((r) => ({ ...r }));
+    },
+
+    removeReview(reviewId: number): boolean {
+      const index = reviews.findIndex((r) => r.id === reviewId);
+      if (index === -1) return false;
+      reviews.splice(index, 1);
+      return true;
+    },
+
+    getReviewsByUser(userId: string): Review[] {
+      return reviews.filter((r) => r.userId === userId).map((r) => ({ ...r }));
+    },
+
+    getReviewCount(pluginName: string): number {
+      return reviews.filter((r) => r.pluginName === pluginName).length;
+    },
+  };
+}
diff --git a/src/reviews/reviews.test.ts b/src/reviews/reviews.test.ts
new file mode 100644
index 0000000..a7a0667
--- /dev/null
+++ b/src/reviews/reviews.test.ts
@@ -0,0 +1,311 @@
+import { describe, it, expect, beforeEach } from 'vitest';
+import { createReviewSystem as createReviewService } from './index.js';
+import type { ReviewService } from '../types.js';
+
+describe('ReviewService', () => {
+  let service: ReviewService;
+
+  beforeEach(() => {
+    service = createReviewService();
+  });
+
+  describe('addReview', () => {
+    it('should add a review and return it with id, createdAt, and flagged=false', () => {
+      const review = service.addReview({
+        pluginName: 'test-plugin',
+        pluginVersion: '1.0.0',
+        userId: 'user1',
+        rating: 4,
+        comment: 'Great plugin!',
+      });
+
+      expect(review.id).toBe(1);
+      expect(review.pluginName).toBe('test-plugin');
+      expect(review.pluginVersion).toBe('1.0.0');
+      expect(review.userId).toBe('user1');
+      expect(review.rating).toBe(4);
+      expect(review.comment).toBe('Great plugin!');
+      expect(review.flagged).toBe(false);
+      expect(review.createdAt).toBeDefined();
+    });
+
+    it('should auto-increment ids', () => {
+      const r1 = service.addReview({
+        pluginName: 'p1',
+        pluginVersion: '1.0.0',
+        userId: 'u1',
+        rating: 3,
+        comment: 'ok',
+      });
+      const r2 = service.addReview({
+        pluginName: 'p2',
+        pluginVersion: '1.0.0',
+        userId: 'u2',
+        rating: 5,
+        comment: 'amazing',
+      });
+
+      expect(r1.id).toBe(1);
+      expect(r2.id).toBe(2);
+    });
+
+    it('should reject ratings outside 1-5', () => {
+      expect(() =>
+        service.addReview({
+          pluginName: 'p',
+          pluginVersion: '1.0.0',
+          userId: 'u',
+          rating: 0,
+          comment: '',
+        })
+      ).toThrow();
+
+      expect(() =>
+        service.addReview({
+          pluginName: 'p',
+          pluginVersion: '1.0.0',
+          userId: 'u',
+          rating: 6,
+          comment: '',
+        })
+      ).toThrow();
+    });
+  });
+
+  describe('getReviews', () => {
+    it('should return reviews for a specific plugin', () => {
+      service.addReview({
+        pluginName: 'plugin-a',
+        pluginVersion: '1.0.0',
+        userId: 'u1',
+        rating: 4,
+        comment: 'good',
+      });
+      service.addReview({
+        pluginName: 'plugin-b',
+        pluginVersion: '1.0.0',
+        userId: 'u2',
+        rating: 3,
+        comment: 'ok',
+      });
+      service.addReview({
+        pluginName: 'plugin-a',
+        pluginVersion: '2.0.0',
+        userId: 'u3',
+        rating: 5,
+        comment: 'great',
+      });
+
+      const reviews = service.getReviews('plugin-a');
+      expect(reviews).toHaveLength(2);
+      expect(reviews.every((r) => r.pluginName === 'plugin-a')).toBe(true);
+    });
+
+    it('should return empty array for unknown plugin', () => {
+      expect(service.getReviews('nonexistent')).toEqual([]);
+    });
+  });
+
+  describe('getAverageRating', () => {
+    it('should compute the average rating', () => {
+      service.addReview({
+        pluginName: 'p',
+        pluginVersion: '1.0.0',
+        userId: 'u1',
+        rating: 4,
+        comment: '',
+      });
+      service.addReview({
+        pluginName: 'p',
+        pluginVersion: '1.0.0',
+        userId: 'u2',
+        rating: 2,
+        comment: '',
+      });
+
+      expect(service.getAverageRating('p')).toBe(3);
+    });
+
+    it('should return 0 for plugin with no reviews', () => {
+      expect(service.getAverageRating('nonexistent')).toBe(0);
+    });
+
+    it('should exclude flagged reviews from average', () => {
+      const r1 = service.addReview({
+        pluginName: 'p',
+        pluginVersion: '1.0.0',
+        userId: 'u1',
+        rating: 5,
+        comment: '',
+      });
+      service.addReview({
+        pluginName: 'p',
+        pluginVersion: '1.0.0',
+        userId: 'u2',
+        rating: 3,
+        comment: '',
+      });
+
+      service.flagReview(r1.id);
+
+      expect(service.getAverageRating('p')).toBe(3);
+    });
+
+    it('should return 0 when all reviews are flagged', () => {
+      const r1 = service.addReview({
+        pluginName: 'p',
+        pluginVersion: '1.0.0',
+        userId: 'u1',
+        rating: 5,
+        comment: '',
+      });
+      service.flagReview(r1.id);
+
+      expect(service.getAverageRating('p')).toBe(0);
+    });
+  });
+
+  describe('flagReview', () => {
+    it('should flag an existing review', () => {
+      const review = service.addReview({
+        pluginName: 'p',
+        pluginVersion: '1.0.0',
+        userId: 'u1',
+        rating: 3,
+        comment: '',
+      });
+
+      service.flagReview(review.id);
+
+      const flagged = service.getFlaggedReviews();
+      expect(flagged).toHaveLength(1);
+      expect(flagged[0].id).toBe(review.id);
+      expect(flagged[0].flagged).toBe(true);
+    });
+
+    it('should throw for nonexistent review id', () => {
+      expect(() => service.flagReview(999)).toThrow();
+    });
+  });
+
+  describe('getFlaggedReviews', () => {
+    it('should return only flagged reviews', () => {
+      service.addReview({
+        pluginName: 'p',
+        pluginVersion: '1.0.0',
+        userId: 'u1',
+        rating: 5,
+        comment: '',
+      });
+      const r2 = service.addReview({
+        pluginName: 'p',
+        pluginVersion: '1.0.0',
+        userId: 'u2',
+        rating: 1,
+        comment: 'spam',
+      });
+
+      service.flagReview(r2.id);
+
+      const flagged = service.getFlaggedReviews();
+      expect(flagged).toHaveLength(1);
+      expect(flagged[0].comment).toBe('spam');
+    });
+
+    it('should return empty array when no reviews are flagged', () => {
+      service.addReview({
+        pluginName: 'p',
+        pluginVersion: '1.0.0',
+        userId: 'u1',
+        rating: 5,
+        comment: '',
+      });
+      expect(service.getFlaggedReviews()).toEqual([]);
+    });
+  });
+
+  describe('removeReview', () => {
+    it('should remove an existing review and return true', () => {
+      const review = service.addReview({
+        pluginName: 'p',
+        pluginVersion: '1.0.0',
+        userId: 'u1',
+        rating: 3,
+        comment: '',
+      });
+
+      expect(service.removeReview(review.id)).toBe(true);
+      expect(service.getReviews('p')).toHaveLength(0);
+    });
+
+    it('should return false for nonexistent review', () => {
+      expect(service.removeReview(999)).toBe(false);
+    });
+  });
+
+  describe('getReviewsByUser', () => {
+    it('should return all reviews by a specific user', () => {
+      service.addReview({
+        pluginName: 'p1',
+        pluginVersion: '1.0.0',
+        userId: 'user1',
+        rating: 4,
+        comment: '',
+      });
+      service.addReview({
+        pluginName: 'p2',
+        pluginVersion: '1.0.0',
+        userId: 'user2',
+        rating: 3,
+        comment: '',
+      });
+      service.addReview({
+        pluginName: 'p3',
+        pluginVersion: '1.0.0',
+        userId: 'user1',
+        rating: 5,
+        comment: '',
+      });
+
+      const userReviews = service.getReviewsByUser('user1');
+      expect(userReviews).toHaveLength(2);
+      expect(userReviews.every((r) => r.userId === 'user1')).toBe(true);
+    });
+
+    it('should return empty array for unknown user', () => {
+      expect(service.getReviewsByUser('unknown')).toEqual([]);
+    });
+  });
+
+  describe('getReviewCount', () => {
+    it('should return the count of reviews for a plugin', () => {
+      service.addReview({
+        pluginName: 'p',
+        pluginVersion: '1.0.0',
+        userId: 'u1',
+        rating: 4,
+        comment: '',
+      });
+      service.addReview({
+        pluginName: 'p',
+        pluginVersion: '1.0.0',
+        userId: 'u2',
+        rating: 3,
+        comment: '',
+      });
+      service.addReview({
+        pluginName: 'other',
+        pluginVersion: '1.0.0',
+        userId: 'u3',
+        rating: 5,
+        comment: '',
+      });
+
+      expect(service.getReviewCount('p')).toBe(2);
+    });
+
+    it('should return 0 for unknown plugin', () => {
+      expect(service.getReviewCount('nonexistent')).toBe(0);
+    });
+  });
+});
diff --git a/src/runner/index.ts b/src/runner/index.ts
new file mode 100644
index 0000000..2714b2f
--- /dev/null
+++ b/src/runner/index.ts
@@ -0,0 +1,67 @@
+import vm from 'node:vm';
+import type { SandboxResult, RunnerService } from '../types.js';
+
+export function createRunner(): RunnerService {
+  async function execute(
+    code: string,
+    context: Record<string, unknown> = {},
+    timeoutMs?: number
+  ): Promise<SandboxResult> {
+    const startTime = performance.now();
+    const startMem = process.memoryUsage().heapUsed;
+
+    try {
+      const sandbox: Record<string, unknown> = { ...context };
+      const vmContext = vm.createContext(sandbox);
+
+      const script = new vm.Script(code, { filename: 'plugin.js' });
+      const options: vm.RunningScriptOptions = {};
+      if (timeoutMs !== undefined) {
+        options.timeout = timeoutMs;
+      }
+
+      const result = script.runInContext(vmContext, options);
+
+      const duration = performance.now() - startTime;
+      const memoryUsed = Math.max(0, process.memoryUsage().heapUsed - startMem);
+
+      return {
+        success: true,
+        output: result,
+        duration,
+        memoryUsed,
+      };
+    } catch (err: unknown) {
+      const duration = performance.now() - startTime;
+      const memoryUsed = Math.max(0, process.memoryUsage().heapUsed - startMem);
+
+      // instanceof Error may fail across VM realm boundaries, so use duck typing
+      const errorMessage =
+        (err && typeof err === 'object' && 'message' in err)
+          ? String((err as { message: unknown }).message)
+          : String(err);
+
+      return {
+        success: false,
+        output: null,
+        duration,
+        memoryUsed,
+        error: errorMessage,
+      };
+    }
+  }
+
+  return {
+    execute(code: string, context?: Record<string, unknown>): Promise<SandboxResult> {
+      return execute(code, context);
+    },
+
+    executeWithTimeout(
+      code: string,
+      timeoutMs: number,
+      context?: Record<string, unknown>
+    ): Promise<SandboxResult> {
+      return execute(code, context, timeoutMs);
+    },
+  };
+}
diff --git a/src/runner/runner.test.ts b/src/runner/runner.test.ts
new file mode 100644
index 0000000..9e4dfd3
--- /dev/null
+++ b/src/runner/runner.test.ts
@@ -0,0 +1,174 @@
+import { describe, it, expect } from 'vitest';
+import { createRunner } from './index.js';
+
+describe('Sandboxed Runner', () => {
+  const runner = createRunner();
+
+  describe('execute', () => {
+    it('should execute simple code and return result', async () => {
+      const result = await runner.execute('1 + 2');
+      expect(result.success).toBe(true);
+      expect(result.output).toBe(3);
+      expect(result.duration).toBeGreaterThanOrEqual(0);
+      expect(result.memoryUsed).toBeGreaterThanOrEqual(0);
+      expect(result.error).toBeUndefined();
+    });
+
+    it('should return undefined output for statements without return value', async () => {
+      const result = await runner.execute('var x = 10;');
+      expect(result.success).toBe(true);
+      expect(result.output).toBeUndefined();
+    });
+
+    it('should execute multi-line code', async () => {
+      const code = `
+        var a = 5;
+        var b = 10;
+        a + b;
+      `;
+      const result = await runner.execute(code);
+      expect(result.success).toBe(true);
+      expect(result.output).toBe(15);
+    });
+
+    it('should handle syntax errors', async () => {
+      const result = await runner.execute('function {{{');
+      expect(result.success).toBe(false);
+      expect(result.error).toBeDefined();
+      expect(result.output).toBeNull();
+    });
+
+    it('should handle runtime errors', async () => {
+      const result = await runner.execute('undefinedVariable.property');
+      expect(result.success).toBe(false);
+      expect(result.error).toBeDefined();
+    });
+
+    it('should handle thrown errors', async () => {
+      const result = await runner.execute('throw new Error("test error")');
+      expect(result.success).toBe(false);
+      expect(result.error).toBe('test error');
+    });
+
+    it('should handle thrown strings', async () => {
+      const result = await runner.execute('throw "string error"');
+      expect(result.success).toBe(false);
+      expect(result.error).toBe('string error');
+    });
+  });
+
+  describe('context variables', () => {
+    it('should pass context variables into the sandbox', async () => {
+      const result = await runner.execute('x + y', { x: 10, y: 20 });
+      expect(result.success).toBe(true);
+      expect(result.output).toBe(30);
+    });
+
+    it('should support complex context objects', async () => {
+      const context = {
+        data: { values: [1, 2, 3] },
+        multiplier: 2,
+      };
+      const code = 'data.values.map(function(v) { return v * multiplier; })';
+      const result = await runner.execute(code, context);
+      expect(result.success).toBe(true);
+      expect(result.output).toEqual([2, 4, 6]);
+    });
+
+    it('should support function context', async () => {
+      const result = await runner.execute('greet("world")', {
+        greet: (name: string) => `hello ${name}`,
+      });
+      expect(result.success).toBe(true);
+      expect(result.output).toBe('hello world');
+    });
+
+    it('should work without context', async () => {
+      const result = await runner.execute('42');
+      expect(result.success).toBe(true);
+      expect(result.output).toBe(42);
+    });
+
+    it('should work with empty context', async () => {
+      const result = await runner.execute('42', {});
+      expect(result.success).toBe(true);
+      expect(result.output).toBe(42);
+    });
+  });
+
+  describe('isolation', () => {
+    it('should isolate executions from each other', async () => {
+      await runner.execute('var secret = "hidden"');
+      const result = await runner.execute(
+        'typeof secret === "undefined" ? "isolated" : secret',
+      );
+      expect(result.success).toBe(true);
+      expect(result.output).toBe('isolated');
+    });
+
+    it('should not expose Node.js globals like require', async () => {
+      const result = await runner.execute('typeof require');
+      expect(result.success).toBe(true);
+      expect(result.output).toBe('undefined');
+    });
+
+    it('should not expose process', async () => {
+      const result = await runner.execute('typeof process');
+      expect(result.success).toBe(true);
+      expect(result.output).toBe('undefined');
+    });
+  });
+
+  describe('executeWithTimeout', () => {
+    it('should execute code within timeout', async () => {
+      const result = await runner.executeWithTimeout('1 + 1', 1000);
+      expect(result.success).toBe(true);
+      expect(result.output).toBe(2);
+    });
+
+    it('should timeout on infinite loops', async () => {
+      const result = await runner.executeWithTimeout('while(true) {}', 100);
+      expect(result.success).toBe(false);
+      expect(result.error).toBeDefined();
+    });
+
+    it('should pass context with timeout', async () => {
+      const result = await runner.executeWithTimeout('x * 2', 1000, {
+        x: 21,
+      });
+      expect(result.success).toBe(true);
+      expect(result.output).toBe(42);
+    });
+  });
+
+  describe('result structure', () => {
+    it('should include duration in result', async () => {
+      const result = await runner.execute('1 + 1');
+      expect(typeof result.duration).toBe('number');
+      expect(result.duration).toBeGreaterThanOrEqual(0);
+    });
+
+    it('should include memoryUsed in result', async () => {
+      const result = await runner.execute('1 + 1');
+      expect(typeof result.memoryUsed).toBe('number');
+      expect(result.memoryUsed).toBeGreaterThanOrEqual(0);
+    });
+
+    it('should conform to SandboxResult interface', async () => {
+      const result = await runner.execute('42');
+      expect(result).toHaveProperty('success');
+      expect(result).toHaveProperty('output');
+      expect(result).toHaveProperty('duration');
+      expect(result).toHaveProperty('memoryUsed');
+    });
+
+    it('should include error field only on failure', async () => {
+      const successResult = await runner.execute('42');
+      expect(successResult.error).toBeUndefined();
+
+      const failResult = await runner.execute('throw new Error("fail")');
+      expect(failResult.error).toBeDefined();
+      expect(failResult.error).toBe('fail');
+    });
+  });
+});
diff --git a/tests/deps.test.ts b/tests/deps.test.ts
new file mode 100644
index 0000000..ce4017d
--- /dev/null
+++ b/tests/deps.test.ts
@@ -0,0 +1,152 @@
+import { describe, it, expect, beforeEach } from 'vitest';
+import { createDepsAnalyzer } from '../src/deps/index.js';
+import { createRegistry } from '../src/registry/index.js';
+import type { DepsService, RegistryService, PluginManifest } from '../src/types.js';
+
+function makeManifest(
+  name: string,
+  deps: Record<string, string> = {}
+): PluginManifest {
+  return {
+    name,
+    version: '1.0.0',
+    description: `Plugin ${name}`,
+    author: 'tester',
+    dependencies: deps,
+    entryPoint: `"${name}"`,
+    permissions: [],
+  };
+}
+
+describe('Deps', () => {
+  let deps: DepsService;
+  let registry: RegistryService;
+
+  beforeEach(() => {
+    deps = createDepsAnalyzer();
+    registry = createRegistry();
+  });
+
+  describe('buildTree', () => {
+    it('should build a tree for a plugin with no dependencies', () => {
+      registry.register(makeManifest('a'));
+      const tree = deps.buildTree('a', registry);
+      expect(tree.name).toBe('a');
+      expect(tree.version).toBe('1.0.0');
+      expect(tree.dependencies).toHaveLength(0);
+    });
+
+    it('should build a tree with nested dependencies', () => {
+      registry.register(makeManifest('a', { b: '^1.0.0' }));
+      registry.register(makeManifest('b', { c: '^1.0.0' }));
+      registry.register(makeManifest('c'));
+
+      const tree = deps.buildTree('a', registry);
+      expect(tree.name).toBe('a');
+      expect(tree.dependencies).toHaveLength(1);
+      expect(tree.dependencies[0].name).toBe('b');
+      expect(tree.dependencies[0].dependencies).toHaveLength(1);
+      expect(tree.dependencies[0].dependencies[0].name).toBe('c');
+    });
+
+    it('should handle non-existent plugin', () => {
+      const tree = deps.buildTree('nonexistent', registry);
+      expect(tree.name).toBe('nonexistent');
+      expect(tree.version).toBe('unknown');
+    });
+  });
+
+  describe('detectCycles', () => {
+    it('should return null when no cycles exist', () => {
+      registry.register(makeManifest('a', { b: '^1.0.0' }));
+      registry.register(makeManifest('b'));
+      expect(deps.detectCycles('a', registry)).toBeNull();
+    });
+
+    it('should detect direct circular dependency', () => {
+      registry.register(makeManifest('a', { b: '^1.0.0' }));
+      registry.register(makeManifest('b', { a: '^1.0.0' }));
+      const cycles = deps.detectCycles('a', registry);
+      expect(cycles).not.toBeNull();
+      expect(cycles!.length).toBeGreaterThan(0);
+    });
+
+    it('should detect indirect circular dependency', () => {
+      registry.register(makeManifest('a', { b: '^1.0.0' }));
+      registry.register(makeManifest('b', { c: '^1.0.0' }));
+      registry.register(makeManifest('c', { a: '^1.0.0' }));
+      const cycles = deps.detectCycles('a', registry);
+      expect(cycles).not.toBeNull();
+      expect(cycles!.length).toBeGreaterThan(0);
+    });
+  });
+
+  describe('hasCircularDependency', () => {
+    it('should return false for no circular dependency', () => {
+      registry.register(makeManifest('a', { b: '^1.0.0' }));
+      registry.register(makeManifest('b'));
+      expect(deps.hasCircularDependency('a', registry)).toBe(false);
+    });
+
+    it('should return true for circular dependency', () => {
+      registry.register(makeManifest('a', { b: '^1.0.0' }));
+      registry.register(makeManifest('b', { a: '^1.0.0' }));
+      expect(deps.hasCircularDependency('a', registry)).toBe(true);
+    });
+  });
+
+  describe('topologicalSort', () => {
+    it('should return topological order', () => {
+      registry.register(makeManifest('a', { b: '^1.0.0', c: '^1.0.0' }));
+      registry.register(makeManifest('b', { c: '^1.0.0' }));
+      registry.register(makeManifest('c'));
+
+      const order = deps.topologicalSort('a', registry);
+      expect(order).toEqual(['c', 'b', 'a']);
+    });
+
+    it('should handle single node', () => {
+      registry.register(makeManifest('a'));
+      expect(deps.topologicalSort('a', registry)).toEqual(['a']);
+    });
+
+    it('should throw on circular dependency', () => {
+      registry.register(makeManifest('a', { b: '^1.0.0' }));
+      registry.register(makeManifest('b', { a: '^1.0.0' }));
+      expect(() => deps.topologicalSort('a', registry)).toThrow(
+        /[Cc]ircular/
+      );
+    });
+  });
+
+  describe('flattenDependencies', () => {
+    it('should flatten all transitive dependencies', () => {
+      registry.register(makeManifest('a', { b: '^1.0.0' }));
+      registry.register(makeManifest('b', { c: '^1.0.0', d: '^1.0.0' }));
+      registry.register(makeManifest('c'));
+      registry.register(makeManifest('d'));
+
+      const flat = deps.flattenDependencies('a', registry);
+      expect(flat).toContain('b');
+      expect(flat).toContain('c');
+      expect(flat).toContain('d');
+      expect(flat).not.toContain('a');
+    });
+
+    it('should return empty array for plugin with no deps', () => {
+      registry.register(makeManifest('a'));
+      expect(deps.flattenDependencies('a', registry)).toEqual([]);
+    });
+
+    it('should handle shared dependencies without duplication', () => {
+      registry.register(makeManifest('a', { b: '^1.0.0', c: '^1.0.0' }));
+      registry.register(makeManifest('b', { d: '^1.0.0' }));
+      registry.register(makeManifest('c', { d: '^1.0.0' }));
+      registry.register(makeManifest('d'));
+
+      const flat = deps.flattenDependencies('a', registry);
+      const dCount = flat.filter((n) => n === 'd').length;
+      expect(dCount).toBe(1);
+    });
+  });
+});
diff --git a/tests/integration.test.ts b/tests/integration.test.ts
new file mode 100644
index 0000000..a5f7a41
--- /dev/null
+++ b/tests/integration.test.ts
@@ -0,0 +1,257 @@
+import { describe, it, expect, beforeEach } from 'vitest';
+import { createMarketplace } from '../src/index.js';
+import type { Marketplace } from '../src/index.js';
+import type { PluginManifest } from '../src/types.js';
+
+function makeManifest(overrides: Partial<PluginManifest> = {}): PluginManifest {
+  return {
+    name: 'test-plugin',
+    version: '1.0.0',
+    description: 'A test plugin',
+    author: 'tester',
+    dependencies: {},
+    entryPoint: '1 + 1',
+    permissions: [],
+    ...overrides,
+  };
+}
+
+describe('Integration: createMarketplace', () => {
+  let marketplace: Marketplace;
+
+  beforeEach(() => {
+    marketplace = createMarketplace();
+  });
+
+  it('should create a marketplace with all services', () => {
+    expect(marketplace.registry).toBeDefined();
+    expect(marketplace.resolver).toBeDefined();
+    expect(marketplace.runner).toBeDefined();
+    expect(marketplace.reviews).toBeDefined();
+    expect(marketplace.deps).toBeDefined();
+    expect(marketplace.installPlugin).toBeDefined();
+  });
+
+  describe('installPlugin', () => {
+    it('should install a simple plugin successfully', async () => {
+      const result = await marketplace.installPlugin(makeManifest());
+      expect(result.executionResult.success).toBe(true);
+      expect(result.executionResult.output).toBe(2);
+      expect(result.resolvedDependencies).toEqual([]);
+    });
+
+    it('should register the plugin in the catalog', async () => {
+      await marketplace.installPlugin(makeManifest());
+      const plugin = marketplace.registry.get('test-plugin');
+      expect(plugin).not.toBeNull();
+      expect(plugin!.name).toBe('test-plugin');
+    });
+
+    it('should execute the entry point code', async () => {
+      const result = await marketplace.installPlugin(
+        makeManifest({ entryPoint: '"hello world"' })
+      );
+      expect(result.executionResult.success).toBe(true);
+      expect(result.executionResult.output).toBe('hello world');
+    });
+
+    it('should resolve dependencies against registry', async () => {
+      // Register a dependency first
+      marketplace.registry.register(
+        makeManifest({ name: 'dep-lib', version: '1.0.0', entryPoint: '1' })
+      );
+      marketplace.registry.register(
+        makeManifest({ name: 'dep-lib', version: '1.2.0', entryPoint: '1' })
+      );
+
+      const result = await marketplace.installPlugin(
+        makeManifest({
+          name: 'my-plugin',
+          dependencies: { 'dep-lib': '^1.0.0' },
+        })
+      );
+
+      expect(result.resolvedDependencies).toHaveLength(1);
+      expect(result.resolvedDependencies[0].name).toBe('dep-lib');
+      expect(result.resolvedDependencies[0].version).toBe('1.2.0');
+    });
+
+    it('should reject plugin with missing name', async () => {
+      await expect(
+        marketplace.installPlugin(makeManifest({ name: '' }))
+      ).rejects.toThrow(/name/);
+    });
+
+    it('should reject plugin with missing version', async () => {
+      await expect(
+        marketplace.installPlugin(makeManifest({ version: '' }))
+      ).rejects.toThrow(/version/);
+    });
+
+    it('should reject plugin with missing entryPoint', async () => {
+      await expect(
+        marketplace.installPlugin(makeManifest({ entryPoint: '' }))
+      ).rejects.toThrow(/entryPoint/);
+    });
+
+    it('should reject plugin with circular dependencies', async () => {
+      // Create a circular dependency: A -> B -> A
+      marketplace.registry.register(
+        makeManifest({
+          name: 'plugin-b',
+          version: '1.0.0',
+          dependencies: { 'plugin-a': '^1.0.0' },
+        })
+      );
+
+      await expect(
+        marketplace.installPlugin(
+          makeManifest({
+            name: 'plugin-a',
+            version: '1.0.0',
+            dependencies: { 'plugin-b': '^1.0.0' },
+          })
+        )
+      ).rejects.toThrow(/[Cc]ircular/);
+    });
+
+    it('should unregister plugin when circular dep is detected', async () => {
+      marketplace.registry.register(
+        makeManifest({
+          name: 'plugin-b',
+          version: '1.0.0',
+          dependencies: { 'plugin-a': '^1.0.0' },
+        })
+      );
+
+      try {
+        await marketplace.installPlugin(
+          makeManifest({
+            name: 'plugin-a',
+            version: '1.0.0',
+            dependencies: { 'plugin-b': '^1.0.0' },
+          })
+        );
+      } catch {
+        // expected
+      }
+
+      expect(marketplace.registry.get('plugin-a')).toBeNull();
+    });
+
+    it('should handle entry point that throws', async () => {
+      const result = await marketplace.installPlugin(
+        makeManifest({ entryPoint: 'throw new Error("boom")' })
+      );
+      expect(result.executionResult.success).toBe(false);
+      expect(result.executionResult.error).toContain('boom');
+    });
+
+    it('should install multiple plugins', async () => {
+      await marketplace.installPlugin(
+        makeManifest({ name: 'plugin-a', version: '1.0.0' })
+      );
+      await marketplace.installPlugin(
+        makeManifest({ name: 'plugin-b', version: '1.0.0' })
+      );
+
+      const all = marketplace.registry.list();
+      expect(all).toHaveLength(2);
+    });
+
+    it('should handle dependencies that are not in registry', async () => {
+      const result = await marketplace.installPlugin(
+        makeManifest({
+          dependencies: { 'nonexistent-dep': '^1.0.0' },
+        })
+      );
+      // Should still install, just with no resolved deps
+      expect(result.resolvedDependencies).toHaveLength(0);
+      expect(result.executionResult.success).toBe(true);
+    });
+  });
+
+  describe('full workflow', () => {
+    it('should support register, install, review workflow', async () => {
+      // Register a dependency
+      marketplace.registry.register(
+        makeManifest({
+          name: 'utils',
+          version: '1.0.0',
+          entryPoint: '"utils v1"',
+        })
+      );
+
+      // Install a plugin that depends on utils
+      const installResult = await marketplace.installPlugin(
+        makeManifest({
+          name: 'my-app',
+          version: '1.0.0',
+          dependencies: { utils: '^1.0.0' },
+          entryPoint: '42',
+        })
+      );
+
+      expect(installResult.executionResult.success).toBe(true);
+      expect(installResult.resolvedDependencies[0].version).toBe('1.0.0');
+
+      // Add reviews
+      marketplace.reviews.addReview({
+        pluginName: 'my-app',
+        pluginVersion: '1.0.0',
+        userId: 'user1',
+        rating: 5,
+        comment: 'Excellent!',
+      });
+
+      marketplace.reviews.addReview({
+        pluginName: 'my-app',
+        pluginVersion: '1.0.0',
+        userId: 'user2',
+        rating: 4,
+        comment: 'Good plugin',
+      });
+
+      expect(marketplace.reviews.getAverageRating('my-app')).toBe(4.5);
+      expect(marketplace.reviews.getReviewCount('my-app')).toBe(2);
+
+      // Check dependencies
+      const tree = marketplace.deps.buildTree('my-app', marketplace.registry);
+      expect(tree.dependencies).toHaveLength(1);
+      expect(tree.dependencies[0].name).toBe('utils');
+    });
+
+    it('should support search and version resolution workflow', async () => {
+      marketplace.registry.register(
+        makeManifest({
+          name: 'logger',
+          version: '1.0.0',
+          description: 'A logging library',
+        })
+      );
+      marketplace.registry.register(
+        makeManifest({
+          name: 'logger',
+          version: '1.1.0',
+          description: 'A logging library',
+        })
+      );
+      marketplace.registry.register(
+        makeManifest({
+          name: 'logger',
+          version: '2.0.0',
+          description: 'A logging library v2',
+        })
+      );
+
+      // Search
+      const searchResults = marketplace.registry.search('logging');
+      expect(searchResults.length).toBeGreaterThan(0);
+
+      // Resolve versions
+      const versions = marketplace.registry.listVersions('logger');
+      const best = marketplace.resolver.maxSatisfying(versions, '^1.0.0');
+      expect(best).toBe('1.1.0');
+    });
+  });
+});
diff --git a/tests/registry.test.ts b/tests/registry.test.ts
new file mode 100644
index 0000000..c454bf9
--- /dev/null
+++ b/tests/registry.test.ts
@@ -0,0 +1,193 @@
+import { describe, it, expect, beforeEach } from 'vitest';
+import { createRegistry } from '../src/registry/index.js';
+import type { PluginManifest, RegistryService } from '../src/types.js';
+
+function makeManifest(overrides: Partial<PluginManifest> = {}): PluginManifest {
+  return {
+    name: 'test-plugin',
+    version: '1.0.0',
+    description: 'A test plugin',
+    author: 'tester',
+    dependencies: {},
+    entryPoint: 'console.log("hello")',
+    permissions: [],
+    ...overrides,
+  };
+}
+
+describe('Plugin Registry', () => {
+  let registry: RegistryService;
+
+  beforeEach(() => {
+    registry = createRegistry();
+  });
+
+  describe('register & get', () => {
+    it('should register and retrieve a plugin', () => {
+      const manifest = makeManifest();
+      registry.register(manifest);
+      const result = registry.get('test-plugin');
+      expect(result).toEqual(manifest);
+    });
+
+    it('should return null for non-existent plugin', () => {
+      expect(registry.get('nonexistent')).toBeNull();
+    });
+
+    it('should return the latest version when calling get()', () => {
+      registry.register(makeManifest({ version: '1.0.0' }));
+      registry.register(makeManifest({ version: '2.0.0' }));
+      const result = registry.get('test-plugin');
+      expect(result?.version).toBe('2.0.0');
+    });
+  });
+
+  describe('getVersion', () => {
+    it('should retrieve a specific version', () => {
+      registry.register(makeManifest({ version: '1.0.0' }));
+      registry.register(makeManifest({ version: '2.0.0' }));
+      const v1 = registry.getVersion('test-plugin', '1.0.0');
+      expect(v1?.version).toBe('1.0.0');
+      const v2 = registry.getVersion('test-plugin', '2.0.0');
+      expect(v2?.version).toBe('2.0.0');
+    });
+
+    it('should return null for non-existent version', () => {
+      registry.register(makeManifest({ version: '1.0.0' }));
+      expect(registry.getVersion('test-plugin', '3.0.0')).toBeNull();
+    });
+
+    it('should return null for non-existent plugin name', () => {
+      expect(registry.getVersion('nope', '1.0.0')).toBeNull();
+    });
+  });
+
+  describe('list', () => {
+    it('should return all registered manifests', () => {
+      registry.register(makeManifest({ name: 'a', version: '1.0.0' }));
+      registry.register(makeManifest({ name: 'b', version: '1.0.0' }));
+      registry.register(makeManifest({ name: 'a', version: '2.0.0' }));
+      const all = registry.list();
+      expect(all).toHaveLength(3);
+    });
+
+    it('should return empty array when no plugins registered', () => {
+      expect(registry.list()).toEqual([]);
+    });
+  });
+
+  describe('search', () => {
+    it('should find plugins by name', () => {
+      registry.register(makeManifest({ name: 'auth-plugin', description: 'handles auth' }));
+      registry.register(makeManifest({ name: 'logger', description: 'logs stuff' }));
+      const results = registry.search('auth');
+      expect(results).toHaveLength(1);
+      expect(results[0].name).toBe('auth-plugin');
+    });
+
+    it('should find plugins by description', () => {
+      registry.register(makeManifest({ name: 'foo', description: 'handles authentication' }));
+      const results = registry.search('authentication');
+      expect(results).toHaveLength(1);
+    });
+
+    it('should find plugins by author', () => {
+      registry.register(makeManifest({ name: 'foo', author: 'JaneDoe' }));
+      const results = registry.search('janedoe');
+      expect(results).toHaveLength(1);
+    });
+
+    it('should be case-insensitive', () => {
+      registry.register(makeManifest({ name: 'MyPlugin' }));
+      expect(registry.search('myplugin')).toHaveLength(1);
+      expect(registry.search('MYPLUGIN')).toHaveLength(1);
+    });
+
+    it('should return empty array when no matches', () => {
+      registry.register(makeManifest());
+      expect(registry.search('zzzzz')).toEqual([]);
+    });
+  });
+
+  describe('remove', () => {
+    it('should remove a specific version', () => {
+      registry.register(makeManifest({ version: '1.0.0' }));
+      registry.register(makeManifest({ version: '2.0.0' }));
+      const removed = registry.remove('test-plugin', '1.0.0');
+      expect(removed).toBe(true);
+      expect(registry.getVersion('test-plugin', '1.0.0')).toBeNull();
+      expect(registry.getVersion('test-plugin', '2.0.0')).not.toBeNull();
+    });
+
+    it('should return false when removing non-existent version', () => {
+      registry.register(makeManifest({ version: '1.0.0' }));
+      expect(registry.remove('test-plugin', '9.9.9')).toBe(false);
+    });
+
+    it('should return false when removing from non-existent plugin', () => {
+      expect(registry.remove('nope', '1.0.0')).toBe(false);
+    });
+
+    it('should clean up plugin entry when last version is removed', () => {
+      registry.register(makeManifest({ version: '1.0.0' }));
+      registry.remove('test-plugin', '1.0.0');
+      expect(registry.get('test-plugin')).toBeNull();
+      expect(registry.listVersions('test-plugin')).toEqual([]);
+    });
+  });
+
+  describe('listVersions', () => {
+    it('should list all versions of a plugin', () => {
+      registry.register(makeManifest({ version: '1.0.0' }));
+      registry.register(makeManifest({ version: '2.0.0' }));
+      registry.register(makeManifest({ version: '1.5.0' }));
+      const versions = registry.listVersions('test-plugin');
+      expect(versions).toHaveLength(3);
+      expect(versions).toContain('1.0.0');
+      expect(versions).toContain('2.0.0');
+      expect(versions).toContain('1.5.0');
+    });
+
+    it('should return empty array for non-existent plugin', () => {
+      expect(registry.listVersions('nope')).toEqual([]);
+    });
+  });
+
+  describe('update', () => {
+    it('should update manifest fields', () => {
+      registry.register(makeManifest({ version: '1.0.0', description: 'old' }));
+      registry.update('test-plugin', '1.0.0', { description: 'new' });
+      const updated = registry.getVersion('test-plugin', '1.0.0');
+      expect(updated?.description).toBe('new');
+    });
+
+    it('should throw for non-existent plugin', () => {
+      expect(() => registry.update('nope', '1.0.0', { description: 'x' })).toThrow();
+    });
+
+    it('should throw for non-existent version', () => {
+      registry.register(makeManifest({ version: '1.0.0' }));
+      expect(() => registry.update('test-plugin', '9.0.0', { description: 'x' })).toThrow();
+    });
+  });
+
+  describe('immutability', () => {
+    it('should not allow external mutation of stored manifests via register', () => {
+      const manifest = makeManifest();
+      registry.register(manifest);
+      manifest.description = 'mutated';
+      const retrieved = registry.get('test-plugin');
+      expect(retrieved?.description).toBe('A test plugin');
+    });
+
+    it('should not allow external mutation of retrieved manifests', () => {
+      registry.register(makeManifest());
+      const retrieved = registry.get('test-plugin');
+      if (retrieved) {
+        retrieved.description = 'mutated';
+      }
+      const fresh = registry.get('test-plugin');
+      expect(fresh?.description).toBe('A test plugin');
+    });
+  });
+});
diff --git a/tests/resolver.test.ts b/tests/resolver.test.ts
new file mode 100644
index 0000000..fe36b9a
--- /dev/null
+++ b/tests/resolver.test.ts
@@ -0,0 +1,142 @@
+import { describe, it, expect, beforeEach } from 'vitest';
+import { createResolver } from '../src/resolver/index.js';
+import type { ResolverService } from '../src/types.js';
+
+describe('Version Resolver', () => {
+  let resolver: ResolverService;
+
+  beforeEach(() => {
+    resolver = createResolver();
+  });
+
+  describe('resolve', () => {
+    it('should resolve constraints to best matching versions', () => {
+      const constraints = [
+        { name: 'foo', range: '^1.0.0' },
+        { name: 'bar', range: '~2.1.0' },
+      ];
+      const available = {
+        foo: ['1.0.0', '1.2.3', '1.5.0', '2.0.0'],
+        bar: ['2.0.0', '2.1.0', '2.1.5', '2.2.0'],
+      };
+      const result = resolver.resolve(constraints, available);
+      expect(result).toHaveLength(2);
+
+      const foo = result.find(r => r.name === 'foo');
+      expect(foo?.version).toBe('1.5.0'); // ^1.0.0 -> highest 1.x
+      expect(foo?.satisfies).toBe('^1.0.0');
+
+      const bar = result.find(r => r.name === 'bar');
+      expect(bar?.version).toBe('2.1.5'); // ~2.1.0 -> highest 2.1.x
+      expect(bar?.satisfies).toBe('~2.1.0');
+    });
+
+    it('should skip constraints with no matching versions', () => {
+      const constraints = [
+        { name: 'foo', range: '^3.0.0' },
+      ];
+      const available = {
+        foo: ['1.0.0', '2.0.0'],
+      };
+      const result = resolver.resolve(constraints, available);
+      expect(result).toHaveLength(0);
+    });
+
+    it('should skip constraints with no available versions', () => {
+      const constraints = [
+        { name: 'missing', range: '^1.0.0' },
+      ];
+      const result = resolver.resolve(constraints, {});
+      expect(result).toHaveLength(0);
+    });
+
+    it('should handle exact version constraints', () => {
+      const constraints = [
+        { name: 'foo', range: '1.0.0' },
+      ];
+      const available = {
+        foo: ['1.0.0', '2.0.0'],
+      };
+      const result = resolver.resolve(constraints, available);
+      expect(result).toHaveLength(1);
+      expect(result[0].version).toBe('1.0.0');
+    });
+
+    it('should handle wildcard constraints', () => {
+      const constraints = [
+        { name: 'foo', range: '*' },
+      ];
+      const available = {
+        foo: ['1.0.0', '2.0.0', '3.0.0'],
+      };
+      const result = resolver.resolve(constraints, available);
+      expect(result).toHaveLength(1);
+      expect(result[0].version).toBe('3.0.0');
+    });
+
+    it('should handle >= constraints', () => {
+      const constraints = [
+        { name: 'foo', range: '>=2.0.0' },
+      ];
+      const available = {
+        foo: ['1.0.0', '2.0.0', '3.0.0'],
+      };
+      const result = resolver.resolve(constraints, available);
+      expect(result).toHaveLength(1);
+      expect(result[0].version).toBe('3.0.0');
+    });
+
+    it('should handle empty constraints', () => {
+      const results = resolver.resolve([], { 'dep-a': ['1.0.0'] });
+      expect(results).toHaveLength(0);
+    });
+  });
+
+  describe('satisfies', () => {
+    it('should check if a version satisfies a range', () => {
+      expect(resolver.satisfies('1.2.3', '^1.0.0')).toBe(true);
+      expect(resolver.satisfies('2.0.0', '^1.0.0')).toBe(false);
+      expect(resolver.satisfies('1.0.0', '~1.0.0')).toBe(true);
+      expect(resolver.satisfies('1.1.0', '~1.0.0')).toBe(false);
+    });
+
+    it('should handle exact versions', () => {
+      expect(resolver.satisfies('1.0.0', '1.0.0')).toBe(true);
+      expect(resolver.satisfies('1.0.1', '1.0.0')).toBe(false);
+    });
+
+    it('should handle tilde ranges', () => {
+      expect(resolver.satisfies('1.2.5', '~1.2.0')).toBe(true);
+      expect(resolver.satisfies('1.3.0', '~1.2.0')).toBe(false);
+    });
+  });
+
+  describe('maxSatisfying', () => {
+    it('should return the highest version satisfying the range', () => {
+      expect(resolver.maxSatisfying(['1.0.0', '1.5.0', '2.0.0'], '^1.0.0')).toBe('1.5.0');
+    });
+
+    it('should return null if no version satisfies', () => {
+      expect(resolver.maxSatisfying(['1.0.0'], '^2.0.0')).toBeNull();
+    });
+
+    it('should return null for empty versions array', () => {
+      expect(resolver.maxSatisfying([], '^1.0.0')).toBeNull();
+    });
+  });
+
+  describe('validRange', () => {
+    it('should validate correct semver ranges', () => {
+      expect(resolver.validRange('^1.0.0')).toBe(true);
+      expect(resolver.validRange('~2.0.0')).toBe(true);
+      expect(resolver.validRange('>=1.0.0 <3.0.0')).toBe(true);
+      expect(resolver.validRange('*')).toBe(true);
+      expect(resolver.validRange('1.0.0')).toBe(true);
+    });
+
+    it('should reject invalid ranges', () => {
+      expect(resolver.validRange('not-a-version')).toBe(false);
+      expect(resolver.validRange('abc.def.ghi')).toBe(false);
+    });
+  });
+});
diff --git a/tests/reviews.test.ts b/tests/reviews.test.ts
new file mode 100644
index 0000000..78d5f81
--- /dev/null
+++ b/tests/reviews.test.ts
@@ -0,0 +1,212 @@
+import { describe, it, expect, beforeEach } from 'vitest';
+import { createReviewSystem } from '../src/reviews/index.js';
+import type { ReviewService } from '../src/types.js';
+
+describe('Reviews', () => {
+  let reviews: ReviewService;
+
+  beforeEach(() => {
+    reviews = createReviewSystem();
+  });
+
+  it('should add a review and return it with id and timestamp', () => {
+    const review = reviews.addReview({
+      pluginName: 'test-plugin',
+      pluginVersion: '1.0.0',
+      userId: 'user1',
+      rating: 5,
+      comment: 'Great plugin!',
+    });
+    expect(review.id).toBe(1);
+    expect(review.flagged).toBe(false);
+    expect(review.createdAt).toBeDefined();
+    expect(review.pluginName).toBe('test-plugin');
+    expect(review.rating).toBe(5);
+  });
+
+  it('should auto-increment review ids', () => {
+    const r1 = reviews.addReview({
+      pluginName: 'p1',
+      pluginVersion: '1.0.0',
+      userId: 'u1',
+      rating: 3,
+      comment: 'ok',
+    });
+    const r2 = reviews.addReview({
+      pluginName: 'p2',
+      pluginVersion: '1.0.0',
+      userId: 'u2',
+      rating: 4,
+      comment: 'good',
+    });
+    expect(r2.id).toBe(r1.id + 1);
+  });
+
+  it('should get reviews by plugin name', () => {
+    reviews.addReview({
+      pluginName: 'plugin-a',
+      pluginVersion: '1.0.0',
+      userId: 'u1',
+      rating: 5,
+      comment: 'great',
+    });
+    reviews.addReview({
+      pluginName: 'plugin-b',
+      pluginVersion: '1.0.0',
+      userId: 'u2',
+      rating: 3,
+      comment: 'ok',
+    });
+    reviews.addReview({
+      pluginName: 'plugin-a',
+      pluginVersion: '2.0.0',
+      userId: 'u3',
+      rating: 4,
+      comment: 'good',
+    });
+    const pluginAReviews = reviews.getReviews('plugin-a');
+    expect(pluginAReviews).toHaveLength(2);
+  });
+
+  it('should compute average rating excluding flagged reviews', () => {
+    reviews.addReview({
+      pluginName: 'p',
+      pluginVersion: '1.0.0',
+      userId: 'u1',
+      rating: 5,
+      comment: 'great',
+    });
+    reviews.addReview({
+      pluginName: 'p',
+      pluginVersion: '1.0.0',
+      userId: 'u2',
+      rating: 3,
+      comment: 'ok',
+    });
+    const r3 = reviews.addReview({
+      pluginName: 'p',
+      pluginVersion: '1.0.0',
+      userId: 'u3',
+      rating: 1,
+      comment: 'bad',
+    });
+
+    // Average of 5, 3, 1 = 3
+    expect(reviews.getAverageRating('p')).toBe(3);
+
+    // Flag the 1-star review, average should be (5+3)/2 = 4
+    reviews.flagReview(r3.id);
+    expect(reviews.getAverageRating('p')).toBe(4);
+  });
+
+  it('should return 0 average for plugin with no reviews', () => {
+    expect(reviews.getAverageRating('nonexistent')).toBe(0);
+  });
+
+  it('should return 0 average when all reviews are flagged', () => {
+    const r = reviews.addReview({
+      pluginName: 'p',
+      pluginVersion: '1.0.0',
+      userId: 'u1',
+      rating: 5,
+      comment: 'great',
+    });
+    reviews.flagReview(r.id);
+    expect(reviews.getAverageRating('p')).toBe(0);
+  });
+
+  it('should flag a review', () => {
+    const r = reviews.addReview({
+      pluginName: 'p',
+      pluginVersion: '1.0.0',
+      userId: 'u1',
+      rating: 5,
+      comment: 'great',
+    });
+    reviews.flagReview(r.id);
+    const flagged = reviews.getFlaggedReviews();
+    expect(flagged).toHaveLength(1);
+    expect(flagged[0].id).toBe(r.id);
+    expect(flagged[0].flagged).toBe(true);
+  });
+
+  it('should get flagged reviews', () => {
+    reviews.addReview({
+      pluginName: 'p',
+      pluginVersion: '1.0.0',
+      userId: 'u1',
+      rating: 5,
+      comment: 'great',
+    });
+    const r2 = reviews.addReview({
+      pluginName: 'p',
+      pluginVersion: '1.0.0',
+      userId: 'u2',
+      rating: 1,
+      comment: 'spam',
+    });
+    reviews.flagReview(r2.id);
+    expect(reviews.getFlaggedReviews()).toHaveLength(1);
+  });
+
+  it('should remove a review', () => {
+    const r = reviews.addReview({
+      pluginName: 'p',
+      pluginVersion: '1.0.0',
+      userId: 'u1',
+      rating: 5,
+      comment: 'great',
+    });
+    expect(reviews.removeReview(r.id)).toBe(true);
+    expect(reviews.getReviews('p')).toHaveLength(0);
+  });
+
+  it('should return false when removing non-existent review', () => {
+    expect(reviews.removeReview(999)).toBe(false);
+  });
+
+  it('should get reviews by user', () => {
+    reviews.addReview({
+      pluginName: 'p1',
+      pluginVersion: '1.0.0',
+      userId: 'alice',
+      rating: 5,
+      comment: 'great',
+    });
+    reviews.addReview({
+      pluginName: 'p2',
+      pluginVersion: '1.0.0',
+      userId: 'bob',
+      rating: 3,
+      comment: 'ok',
+    });
+    reviews.addReview({
+      pluginName: 'p3',
+      pluginVersion: '1.0.0',
+      userId: 'alice',
+      rating: 4,
+      comment: 'good',
+    });
+    const aliceReviews = reviews.getReviewsByUser('alice');
+    expect(aliceReviews).toHaveLength(2);
+  });
+
+  it('should get review count for a plugin', () => {
+    reviews.addReview({
+      pluginName: 'p',
+      pluginVersion: '1.0.0',
+      userId: 'u1',
+      rating: 5,
+      comment: 'great',
+    });
+    reviews.addReview({
+      pluginName: 'p',
+      pluginVersion: '1.0.0',
+      userId: 'u2',
+      rating: 3,
+      comment: 'ok',
+    });
+    expect(reviews.getReviewCount('p')).toBe(2);
+    expect(reviews.getReviewCount('other')).toBe(0);
+  });
+});
diff --git a/tests/runner.test.ts b/tests/runner.test.ts
new file mode 100644
index 0000000..08ca44e
--- /dev/null
+++ b/tests/runner.test.ts
@@ -0,0 +1,89 @@
+import { describe, it, expect, beforeEach } from 'vitest';
+import { createRunner } from '../src/runner/index.js';
+import type { RunnerService } from '../src/types.js';
+
+describe('Runner', () => {
+  let runner: RunnerService;
+
+  beforeEach(() => {
+    runner = createRunner();
+  });
+
+  describe('execute', () => {
+    it('should execute simple code and return result', async () => {
+      const result = await runner.execute('1 + 2');
+      expect(result.success).toBe(true);
+      expect(result.output).toBe(3);
+      expect(result.duration).toBeGreaterThanOrEqual(0);
+      expect(result.memoryUsed).toBeGreaterThanOrEqual(0);
+    });
+
+    it('should execute code with string output', async () => {
+      const result = await runner.execute('"hello" + " " + "world"');
+      expect(result.success).toBe(true);
+      expect(result.output).toBe('hello world');
+    });
+
+    it('should pass context variables into sandbox', async () => {
+      const result = await runner.execute('x + y', { x: 10, y: 20 });
+      expect(result.success).toBe(true);
+      expect(result.output).toBe(30);
+    });
+
+    it('should handle code errors gracefully', async () => {
+      const result = await runner.execute('throw new Error("oops")');
+      expect(result.success).toBe(false);
+      expect(result.error).toContain('oops');
+      expect(result.output).toBeNull();
+    });
+
+    it('should handle syntax errors', async () => {
+      const result = await runner.execute('function {{{');
+      expect(result.success).toBe(false);
+      expect(result.error).toBeDefined();
+    });
+
+    it('should handle undefined variable errors', async () => {
+      const result = await runner.execute('nonExistentVar.foo');
+      expect(result.success).toBe(false);
+      expect(result.error).toBeDefined();
+    });
+
+    it('should isolate sandbox from host environment', async () => {
+      const result = await runner.execute('typeof require');
+      expect(result.success).toBe(true);
+      expect(result.output).toBe('undefined');
+    });
+
+    it('should handle object output', async () => {
+      const result = await runner.execute('({ a: 1, b: 2 })');
+      expect(result.success).toBe(true);
+      expect(result.output).toEqual({ a: 1, b: 2 });
+    });
+  });
+
+  describe('executeWithTimeout', () => {
+    it('should execute code within timeout', async () => {
+      const result = await runner.executeWithTimeout('1 + 1', 5000);
+      expect(result.success).toBe(true);
+      expect(result.output).toBe(2);
+    });
+
+    it('should fail on timeout for infinite loops', async () => {
+      const result = await runner.executeWithTimeout(
+        'while(true) {}',
+        100
+      );
+      expect(result.success).toBe(false);
+      expect(result.error).toBeDefined();
+    });
+
+    it('should pass context with timeout', async () => {
+      const result = await runner.executeWithTimeout('x * 2', 5000, {
+        x: 21,
+      });
+      expect(result.success).toBe(true);
+      expect(result.output).toBe(42);
+    });
+  });
+});
