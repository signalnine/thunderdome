diff --git a/.amplifier/settings.local.yaml b/.amplifier/settings.local.yaml
new file mode 100644
index 0000000..64831cc
--- /dev/null
+++ b/.amplifier/settings.local.yaml
@@ -0,0 +1,11 @@
+config:
+  providers:
+  - config:
+      api_key: ${ANTHROPIC_API_KEY}
+      base_url: https://api.anthropic.com
+      default_model: claude-opus-4-6
+      enable_1m_context: 'true'
+      enable_prompt_caching: 'true'
+      priority: 1
+    module: provider-anthropic
+    source: /opt/amplifier-provider-anthropic
diff --git a/.thunderdome-stderr.log b/.thunderdome-stderr.log
new file mode 100644
index 0000000..fd371b2
--- /dev/null
+++ b/.thunderdome-stderr.log
@@ -0,0 +1,6 @@
+
+[36mðŸ§  Thinking...[0m
+
+[36mðŸ§  Thinking...[0m
+
+[36mðŸ§  Thinking...[0m
diff --git a/package-lock.json b/package-lock.json
index fb449ee..1a20967 100644
--- a/package-lock.json
+++ b/package-lock.json
@@ -16,11 +16,83 @@
         "@types/semver": "^7.5.0",
         "@typescript-eslint/eslint-plugin": "^7.0.0",
         "@typescript-eslint/parser": "^7.0.0",
+        "@vitest/coverage-v8": "^2.0.0",
         "eslint": "^8.56.0",
         "typescript": "^5.4.0",
         "vitest": "^2.0.0"
       }
     },
+    "node_modules/@ampproject/remapping": {
+      "version": "2.3.0",
+      "resolved": "https://registry.npmjs.org/@ampproject/remapping/-/remapping-2.3.0.tgz",
+      "integrity": "sha512-30iZtAPgz+LTIYoeivqYo853f02jBYSd5uGnGpkFV0M3xOt9aN73erkgYAmZU43x4VfqcnLxW9Kpg3R5LC4YYw==",
+      "dev": true,
+      "license": "Apache-2.0",
+      "dependencies": {
+        "@jridgewell/gen-mapping": "^0.3.5",
+        "@jridgewell/trace-mapping": "^0.3.24"
+      },
+      "engines": {
+        "node": ">=6.0.0"
+      }
+    },
+    "node_modules/@babel/helper-string-parser": {
+      "version": "7.27.1",
+      "resolved": "https://registry.npmjs.org/@babel/helper-string-parser/-/helper-string-parser-7.27.1.tgz",
+      "integrity": "sha512-qMlSxKbpRlAridDExk92nSobyDdpPijUq2DW6oDnUqd0iOGxmQjyqhMIihI9+zv4LPyZdRje2cavWPbCbWm3eA==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=6.9.0"
+      }
+    },
+    "node_modules/@babel/helper-validator-identifier": {
+      "version": "7.28.5",
+      "resolved": "https://registry.npmjs.org/@babel/helper-validator-identifier/-/helper-validator-identifier-7.28.5.tgz",
+      "integrity": "sha512-qSs4ifwzKJSV39ucNjsvc6WVHs6b7S03sOh2OcHF9UHfVPqWWALUsNUVzhSBiItjRZoLHx7nIarVjqKVusUZ1Q==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=6.9.0"
+      }
+    },
+    "node_modules/@babel/parser": {
+      "version": "7.29.0",
+      "resolved": "https://registry.npmjs.org/@babel/parser/-/parser-7.29.0.tgz",
+      "integrity": "sha512-IyDgFV5GeDUVX4YdF/3CPULtVGSXXMLh1xVIgdCgxApktqnQV0r7/8Nqthg+8YLGaAtdyIlo2qIdZrbCv4+7ww==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@babel/types": "^7.29.0"
+      },
+      "bin": {
+        "parser": "bin/babel-parser.js"
+      },
+      "engines": {
+        "node": ">=6.0.0"
+      }
+    },
+    "node_modules/@babel/types": {
+      "version": "7.29.0",
+      "resolved": "https://registry.npmjs.org/@babel/types/-/types-7.29.0.tgz",
+      "integrity": "sha512-LwdZHpScM4Qz8Xw2iKSzS+cfglZzJGvofQICy7W7v4caru4EaAmyUuO6BGrbyQ2mYV11W0U8j5mBhd14dd3B0A==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@babel/helper-string-parser": "^7.27.1",
+        "@babel/helper-validator-identifier": "^7.28.5"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      }
+    },
+    "node_modules/@bcoe/v8-coverage": {
+      "version": "0.2.3",
+      "resolved": "https://registry.npmjs.org/@bcoe/v8-coverage/-/v8-coverage-0.2.3.tgz",
+      "integrity": "sha512-0hYQ8SB4Db5zvZB4axdMHGwEaQjkZzFjQiN9LVYvIFB2nSUHW9tYpxWriPrWDASIxiaXax83REcLxuSdnGPZtw==",
+      "dev": true,
+      "license": "MIT"
+    },
     "node_modules/@esbuild/aix-ppc64": {
       "version": "0.21.5",
       "resolved": "https://registry.npmjs.org/@esbuild/aix-ppc64/-/aix-ppc64-0.21.5.tgz",
@@ -561,6 +633,84 @@
       "dev": true,
       "license": "BSD-3-Clause"
     },
+    "node_modules/@isaacs/cliui": {
+      "version": "8.0.2",
+      "resolved": "https://registry.npmjs.org/@isaacs/cliui/-/cliui-8.0.2.tgz",
+      "integrity": "sha512-O8jcjabXaleOG9DQ0+ARXWZBTfnP4WNAqzuiJK7ll44AmxGKv/J2M4TPjxjY3znBCfvBXFzucm1twdyFybFqEA==",
+      "dev": true,
+      "license": "ISC",
+      "dependencies": {
+        "string-width": "^5.1.2",
+        "string-width-cjs": "npm:string-width@^4.2.0",
+        "strip-ansi": "^7.0.1",
+        "strip-ansi-cjs": "npm:strip-ansi@^6.0.1",
+        "wrap-ansi": "^8.1.0",
+        "wrap-ansi-cjs": "npm:wrap-ansi@^7.0.0"
+      },
+      "engines": {
+        "node": ">=12"
+      }
+    },
+    "node_modules/@isaacs/cliui/node_modules/ansi-regex": {
+      "version": "6.2.2",
+      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-6.2.2.tgz",
+      "integrity": "sha512-Bq3SmSpyFHaWjPk8If9yc6svM8c56dB5BAtW4Qbw5jHTwwXXcTLoRMkpDJp6VL0XzlWaCHTXrkFURMYmD0sLqg==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/ansi-regex?sponsor=1"
+      }
+    },
+    "node_modules/@isaacs/cliui/node_modules/strip-ansi": {
+      "version": "7.1.2",
+      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-7.1.2.tgz",
+      "integrity": "sha512-gmBGslpoQJtgnMAvOVqGZpEz9dyoKTCzy2nfz/n8aIFhN/jCE/rCmcxabB6jOOHV+0WNnylOxaxBQPSvcWklhA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "ansi-regex": "^6.0.1"
+      },
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/strip-ansi?sponsor=1"
+      }
+    },
+    "node_modules/@istanbuljs/schema": {
+      "version": "0.1.3",
+      "resolved": "https://registry.npmjs.org/@istanbuljs/schema/-/schema-0.1.3.tgz",
+      "integrity": "sha512-ZXRY4jNvVgSVQ8DL3LTcakaAtXwTVUxE81hslsyD2AtoXW/wVob10HkOJ1X/pAlcI7D+2YoZKg5do8G/w6RYgA==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/@jridgewell/gen-mapping": {
+      "version": "0.3.13",
+      "resolved": "https://registry.npmjs.org/@jridgewell/gen-mapping/-/gen-mapping-0.3.13.tgz",
+      "integrity": "sha512-2kkt/7niJ6MgEPxF0bYdQ6etZaA+fQvDcLKckhy1yIQOzaoKjBBjSj63/aLVjYE3qhRt5dvM+uUyfCg6UKCBbA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@jridgewell/sourcemap-codec": "^1.5.0",
+        "@jridgewell/trace-mapping": "^0.3.24"
+      }
+    },
+    "node_modules/@jridgewell/resolve-uri": {
+      "version": "3.1.2",
+      "resolved": "https://registry.npmjs.org/@jridgewell/resolve-uri/-/resolve-uri-3.1.2.tgz",
+      "integrity": "sha512-bRISgCIjP20/tbWSPWMEi54QVPRZExkuD9lJL+UIxUKtwVJA8wW1Trb1jMs1RFXo1CBTNZ/5hpC9QvmKWdopKw==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=6.0.0"
+      }
+    },
     "node_modules/@jridgewell/sourcemap-codec": {
       "version": "1.5.5",
       "resolved": "https://registry.npmjs.org/@jridgewell/sourcemap-codec/-/sourcemap-codec-1.5.5.tgz",
@@ -568,6 +718,17 @@
       "dev": true,
       "license": "MIT"
     },
+    "node_modules/@jridgewell/trace-mapping": {
+      "version": "0.3.31",
+      "resolved": "https://registry.npmjs.org/@jridgewell/trace-mapping/-/trace-mapping-0.3.31.tgz",
+      "integrity": "sha512-zzNR+SdQSDJzc8joaeP8QQoCQr8NuYx2dIIytl1QeBEZHJ9uW6hebsrYgbz8hJwUQao3TWCMtmfV8Nu1twOLAw==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@jridgewell/resolve-uri": "^3.1.0",
+        "@jridgewell/sourcemap-codec": "^1.4.14"
+      }
+    },
     "node_modules/@nodelib/fs.scandir": {
       "version": "2.1.5",
       "resolved": "https://registry.npmjs.org/@nodelib/fs.scandir/-/fs.scandir-2.1.5.tgz",
@@ -606,6 +767,17 @@
         "node": ">= 8"
       }
     },
+    "node_modules/@pkgjs/parseargs": {
+      "version": "0.11.0",
+      "resolved": "https://registry.npmjs.org/@pkgjs/parseargs/-/parseargs-0.11.0.tgz",
+      "integrity": "sha512-+1VkjdD0QBLPodGrJUeqarH8VAIvQODIbwh9XpP5Syisf7YoQgsJKPNFoqqLQlu+VQ/tVSshMR6loPMn8U+dPg==",
+      "dev": true,
+      "license": "MIT",
+      "optional": true,
+      "engines": {
+        "node": ">=14"
+      }
+    },
     "node_modules/@rollup/rollup-android-arm-eabi": {
       "version": "4.57.1",
       "resolved": "https://registry.npmjs.org/@rollup/rollup-android-arm-eabi/-/rollup-android-arm-eabi-4.57.1.tgz",
@@ -979,7 +1151,6 @@
       "integrity": "sha512-m0jEgYlYz+mDJZ2+F4v8D1AyQb+QzsNqRuI7xg1VQX/KlKS0qT9r1Mo16yo5F/MtifXFgaofIFsdFMox2SxIbQ==",
       "dev": true,
       "license": "MIT",
-      "peer": true,
       "dependencies": {
         "undici-types": "~7.16.0"
       }
@@ -1031,7 +1202,6 @@
       "integrity": "sha512-4Z+L8I2OqhZV8qA132M4wNL30ypZGYOQVBfMgxDH/K5UX0PNqTu1c6za9ST5r9+tavvHiTWmBnKzpCJ/GlVFtg==",
       "dev": true,
       "license": "BSD-2-Clause",
-      "peer": true,
       "dependencies": {
         "@typescript-eslint/scope-manager": "7.18.0",
         "@typescript-eslint/types": "7.18.0",
@@ -1192,6 +1362,39 @@
       "dev": true,
       "license": "ISC"
     },
+    "node_modules/@vitest/coverage-v8": {
+      "version": "2.1.9",
+      "resolved": "https://registry.npmjs.org/@vitest/coverage-v8/-/coverage-v8-2.1.9.tgz",
+      "integrity": "sha512-Z2cOr0ksM00MpEfyVE8KXIYPEcBFxdbLSs56L8PO0QQMxt/6bDj45uQfxoc96v05KW3clk7vvgP0qfDit9DmfQ==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@ampproject/remapping": "^2.3.0",
+        "@bcoe/v8-coverage": "^0.2.3",
+        "debug": "^4.3.7",
+        "istanbul-lib-coverage": "^3.2.2",
+        "istanbul-lib-report": "^3.0.1",
+        "istanbul-lib-source-maps": "^5.0.6",
+        "istanbul-reports": "^3.1.7",
+        "magic-string": "^0.30.12",
+        "magicast": "^0.3.5",
+        "std-env": "^3.8.0",
+        "test-exclude": "^7.0.1",
+        "tinyrainbow": "^1.2.0"
+      },
+      "funding": {
+        "url": "https://opencollective.com/vitest"
+      },
+      "peerDependencies": {
+        "@vitest/browser": "2.1.9",
+        "vitest": "2.1.9"
+      },
+      "peerDependenciesMeta": {
+        "@vitest/browser": {
+          "optional": true
+        }
+      }
+    },
     "node_modules/@vitest/expect": {
       "version": "2.1.9",
       "resolved": "https://registry.npmjs.org/@vitest/expect/-/expect-2.1.9.tgz",
@@ -1311,7 +1514,6 @@
       "integrity": "sha512-NZyJarBfL7nWwIq+FDL6Zp/yHEhePMNnnJ0y3qfieCrmNvYct8uvtiV41UvlSe6apAfk0fY1FbWx+NwfmpvtTg==",
       "dev": true,
       "license": "MIT",
-      "peer": true,
       "bin": {
         "acorn": "bin/acorn"
       },
@@ -1710,6 +1912,20 @@
         "node": ">=6.0.0"
       }
     },
+    "node_modules/eastasianwidth": {
+      "version": "0.2.0",
+      "resolved": "https://registry.npmjs.org/eastasianwidth/-/eastasianwidth-0.2.0.tgz",
+      "integrity": "sha512-I88TYZWc9XiYHRQ4/3c5rjjfgkjhLyW2luGIheGERbNQ6OY7yTybanSpDXZa8y7VUP9YmDcYa+eyq4ca7iLqWA==",
+      "dev": true,
+      "license": "MIT"
+    },
+    "node_modules/emoji-regex": {
+      "version": "9.2.2",
+      "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-9.2.2.tgz",
+      "integrity": "sha512-L18DaJsXSUk2+42pv8mLs5jJT2hqFkFE4j21wOmgbUqsZ2hL72NsUU785g9RXgo3s0ZNgVl42TiHp3ZtOv/Vyg==",
+      "dev": true,
+      "license": "MIT"
+    },
     "node_modules/end-of-stream": {
       "version": "1.4.5",
       "resolved": "https://registry.npmjs.org/end-of-stream/-/end-of-stream-1.4.5.tgz",
@@ -1785,7 +2001,6 @@
       "deprecated": "This version is no longer supported. Please see https://eslint.org/version-support for other options.",
       "dev": true,
       "license": "MIT",
-      "peer": true,
       "dependencies": {
         "@eslint-community/eslint-utils": "^4.2.0",
         "@eslint-community/regexpp": "^4.6.1",
@@ -2115,6 +2330,23 @@
       "dev": true,
       "license": "ISC"
     },
+    "node_modules/foreground-child": {
+      "version": "3.3.1",
+      "resolved": "https://registry.npmjs.org/foreground-child/-/foreground-child-3.3.1.tgz",
+      "integrity": "sha512-gIXjKqtFuWEgzFRJA9WCQeSJLZDjgJUOMCMzxtvFq/37KojM1BFGufqsCy0r4qSQmYLsZYMeyRqzIWOMup03sw==",
+      "dev": true,
+      "license": "ISC",
+      "dependencies": {
+        "cross-spawn": "^7.0.6",
+        "signal-exit": "^4.0.1"
+      },
+      "engines": {
+        "node": ">=14"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/isaacs"
+      }
+    },
     "node_modules/fs-constants": {
       "version": "1.0.0",
       "resolved": "https://registry.npmjs.org/fs-constants/-/fs-constants-1.0.0.tgz",
@@ -2262,6 +2494,13 @@
         "node": ">=8"
       }
     },
+    "node_modules/html-escaper": {
+      "version": "2.0.2",
+      "resolved": "https://registry.npmjs.org/html-escaper/-/html-escaper-2.0.2.tgz",
+      "integrity": "sha512-H2iMtd0I4Mt5eYiapRdIDjp+XzelXQ0tFE4JS7YFwFevXXMmOp9myNrUvCg0D6ws8iqkRPBfKHgbwig1SmlLfg==",
+      "dev": true,
+      "license": "MIT"
+    },
     "node_modules/ieee754": {
       "version": "1.2.1",
       "resolved": "https://registry.npmjs.org/ieee754/-/ieee754-1.2.1.tgz",
@@ -2353,6 +2592,16 @@
         "node": ">=0.10.0"
       }
     },
+    "node_modules/is-fullwidth-code-point": {
+      "version": "3.0.0",
+      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/is-fullwidth-code-point-3.0.0.tgz",
+      "integrity": "sha512-zymm5+u+sCsSWyD9qNaejV3DFvhCKclKdizYaJUuHA83RLjb7nSuGnddCHGv0hk+KY7BMAlsWeK4Ueg6EV6XQg==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=8"
+      }
+    },
     "node_modules/is-glob": {
       "version": "4.0.3",
       "resolved": "https://registry.npmjs.org/is-glob/-/is-glob-4.0.3.tgz",
@@ -2393,6 +2642,76 @@
       "dev": true,
       "license": "ISC"
     },
+    "node_modules/istanbul-lib-coverage": {
+      "version": "3.2.2",
+      "resolved": "https://registry.npmjs.org/istanbul-lib-coverage/-/istanbul-lib-coverage-3.2.2.tgz",
+      "integrity": "sha512-O8dpsF+r0WV/8MNRKfnmrtCWhuKjxrq2w+jpzBL5UZKTi2LeVWnWOmWRxFlesJONmc+wLAGvKQZEOanko0LFTg==",
+      "dev": true,
+      "license": "BSD-3-Clause",
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/istanbul-lib-report": {
+      "version": "3.0.1",
+      "resolved": "https://registry.npmjs.org/istanbul-lib-report/-/istanbul-lib-report-3.0.1.tgz",
+      "integrity": "sha512-GCfE1mtsHGOELCU8e/Z7YWzpmybrx/+dSTfLrvY8qRmaY6zXTKWn6WQIjaAFw069icm6GVMNkgu0NzI4iPZUNw==",
+      "dev": true,
+      "license": "BSD-3-Clause",
+      "dependencies": {
+        "istanbul-lib-coverage": "^3.0.0",
+        "make-dir": "^4.0.0",
+        "supports-color": "^7.1.0"
+      },
+      "engines": {
+        "node": ">=10"
+      }
+    },
+    "node_modules/istanbul-lib-source-maps": {
+      "version": "5.0.6",
+      "resolved": "https://registry.npmjs.org/istanbul-lib-source-maps/-/istanbul-lib-source-maps-5.0.6.tgz",
+      "integrity": "sha512-yg2d+Em4KizZC5niWhQaIomgf5WlL4vOOjZ5xGCmF8SnPE/mDWWXgvRExdcpCgh9lLRRa1/fSYp2ymmbJ1pI+A==",
+      "dev": true,
+      "license": "BSD-3-Clause",
+      "dependencies": {
+        "@jridgewell/trace-mapping": "^0.3.23",
+        "debug": "^4.1.1",
+        "istanbul-lib-coverage": "^3.0.0"
+      },
+      "engines": {
+        "node": ">=10"
+      }
+    },
+    "node_modules/istanbul-reports": {
+      "version": "3.2.0",
+      "resolved": "https://registry.npmjs.org/istanbul-reports/-/istanbul-reports-3.2.0.tgz",
+      "integrity": "sha512-HGYWWS/ehqTV3xN10i23tkPkpH46MLCIMFNCaaKNavAXTF1RkqxawEPtnjnGZ6XKSInBKkiOA5BKS+aZiY3AvA==",
+      "dev": true,
+      "license": "BSD-3-Clause",
+      "dependencies": {
+        "html-escaper": "^2.0.0",
+        "istanbul-lib-report": "^3.0.0"
+      },
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/jackspeak": {
+      "version": "3.4.3",
+      "resolved": "https://registry.npmjs.org/jackspeak/-/jackspeak-3.4.3.tgz",
+      "integrity": "sha512-OGlZQpz2yfahA/Rd1Y8Cd9SIEsqvXkLVoSw/cgwhnhFMDbsQFeZYoJJ7bIZBS9BcamUW96asq/npPWugM+RQBw==",
+      "dev": true,
+      "license": "BlueOak-1.0.0",
+      "dependencies": {
+        "@isaacs/cliui": "^8.0.2"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/isaacs"
+      },
+      "optionalDependencies": {
+        "@pkgjs/parseargs": "^0.11.0"
+      }
+    },
     "node_modules/js-yaml": {
       "version": "4.1.1",
       "resolved": "https://registry.npmjs.org/js-yaml/-/js-yaml-4.1.1.tgz",
@@ -2481,6 +2800,13 @@
       "dev": true,
       "license": "MIT"
     },
+    "node_modules/lru-cache": {
+      "version": "10.4.3",
+      "resolved": "https://registry.npmjs.org/lru-cache/-/lru-cache-10.4.3.tgz",
+      "integrity": "sha512-JNAzZcXrCt42VGLuYz0zfAzDfAvJWW6AfYlDBQyDV5DClI2m5sAmK+OIO7s59XfsRsWHp02jAJrRadPRGTt6SQ==",
+      "dev": true,
+      "license": "ISC"
+    },
     "node_modules/magic-string": {
       "version": "0.30.21",
       "resolved": "https://registry.npmjs.org/magic-string/-/magic-string-0.30.21.tgz",
@@ -2491,6 +2817,34 @@
         "@jridgewell/sourcemap-codec": "^1.5.5"
       }
     },
+    "node_modules/magicast": {
+      "version": "0.3.5",
+      "resolved": "https://registry.npmjs.org/magicast/-/magicast-0.3.5.tgz",
+      "integrity": "sha512-L0WhttDl+2BOsybvEOLK7fW3UA0OQ0IQ2d6Zl2x/a6vVRs3bAY0ECOSHHeL5jD+SbOpOCUEi0y1DgHEn9Qn1AQ==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@babel/parser": "^7.25.4",
+        "@babel/types": "^7.25.4",
+        "source-map-js": "^1.2.0"
+      }
+    },
+    "node_modules/make-dir": {
+      "version": "4.0.0",
+      "resolved": "https://registry.npmjs.org/make-dir/-/make-dir-4.0.0.tgz",
+      "integrity": "sha512-hXdUTZYIVOt1Ex//jAQi+wTZZpUpwBj/0QsOzqegb3rGMMeJiSEu5xLHnYfBrRV4RH2+OCSOO95Is/7x1WJ4bw==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "semver": "^7.5.3"
+      },
+      "engines": {
+        "node": ">=10"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/sindresorhus"
+      }
+    },
     "node_modules/merge2": {
       "version": "1.4.1",
       "resolved": "https://registry.npmjs.org/merge2/-/merge2-1.4.1.tgz",
@@ -2552,6 +2906,16 @@
         "url": "https://github.com/sponsors/ljharb"
       }
     },
+    "node_modules/minipass": {
+      "version": "7.1.2",
+      "resolved": "https://registry.npmjs.org/minipass/-/minipass-7.1.2.tgz",
+      "integrity": "sha512-qOOzS1cBTWYF4BH8fVePDBOO9iptMnGUEZwNc/cMWnTV2nVLZ7VoNWEPHkYczZA0pdoA7dl6e7FL659nX9S2aw==",
+      "dev": true,
+      "license": "ISC",
+      "engines": {
+        "node": ">=16 || 14 >=14.17"
+      }
+    },
     "node_modules/mkdirp-classic": {
       "version": "0.5.3",
       "resolved": "https://registry.npmjs.org/mkdirp-classic/-/mkdirp-classic-0.5.3.tgz",
@@ -2668,6 +3032,13 @@
         "url": "https://github.com/sponsors/sindresorhus"
       }
     },
+    "node_modules/package-json-from-dist": {
+      "version": "1.0.1",
+      "resolved": "https://registry.npmjs.org/package-json-from-dist/-/package-json-from-dist-1.0.1.tgz",
+      "integrity": "sha512-UEZIS3/by4OC8vL3P2dTXRETpebLI2NiI5vIrjaD/5UtrkFX/tNbwjTSRAGC/+7CAo2pIcBaRgWmcBBHcsaCIw==",
+      "dev": true,
+      "license": "BlueOak-1.0.0"
+    },
     "node_modules/parent-module": {
       "version": "1.0.1",
       "resolved": "https://registry.npmjs.org/parent-module/-/parent-module-1.0.1.tgz",
@@ -2711,6 +3082,23 @@
         "node": ">=8"
       }
     },
+    "node_modules/path-scurry": {
+      "version": "1.11.1",
+      "resolved": "https://registry.npmjs.org/path-scurry/-/path-scurry-1.11.1.tgz",
+      "integrity": "sha512-Xa4Nw17FS9ApQFJ9umLiJS4orGjm7ZzwUrwamcGQuHSzDyth9boKDaycYdDcZDuqYATXw4HFXgaqWTctW/v1HA==",
+      "dev": true,
+      "license": "BlueOak-1.0.0",
+      "dependencies": {
+        "lru-cache": "^10.2.0",
+        "minipass": "^5.0.0 || ^6.0.2 || ^7.0.0"
+      },
+      "engines": {
+        "node": ">=16 || 14 >=14.18"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/isaacs"
+      }
+    },
     "node_modules/path-type": {
       "version": "4.0.0",
       "resolved": "https://registry.npmjs.org/path-type/-/path-type-4.0.0.tgz",
@@ -3071,6 +3459,19 @@
       "dev": true,
       "license": "ISC"
     },
+    "node_modules/signal-exit": {
+      "version": "4.1.0",
+      "resolved": "https://registry.npmjs.org/signal-exit/-/signal-exit-4.1.0.tgz",
+      "integrity": "sha512-bzyZ1e88w9O1iNJbKnOlvYTrWPDl46O1bG0D3XInv+9tkPrxrN8jUUTiFlDkkmKWgn1M6CfIA13SuGqOa9Korw==",
+      "dev": true,
+      "license": "ISC",
+      "engines": {
+        "node": ">=14"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/isaacs"
+      }
+    },
     "node_modules/simple-concat": {
       "version": "1.0.1",
       "resolved": "https://registry.npmjs.org/simple-concat/-/simple-concat-1.0.1.tgz",
@@ -3159,6 +3560,76 @@
         "safe-buffer": "~5.2.0"
       }
     },
+    "node_modules/string-width": {
+      "version": "5.1.2",
+      "resolved": "https://registry.npmjs.org/string-width/-/string-width-5.1.2.tgz",
+      "integrity": "sha512-HnLOCR3vjcY8beoNLtcjZ5/nxn2afmME6lhrDrebokqMap+XbeW8n9TXpPDOqdGK5qcI3oT0GKTW6wC7EMiVqA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "eastasianwidth": "^0.2.0",
+        "emoji-regex": "^9.2.2",
+        "strip-ansi": "^7.0.1"
+      },
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/sindresorhus"
+      }
+    },
+    "node_modules/string-width-cjs": {
+      "name": "string-width",
+      "version": "4.2.3",
+      "resolved": "https://registry.npmjs.org/string-width/-/string-width-4.2.3.tgz",
+      "integrity": "sha512-wKyQRQpjJ0sIp62ErSZdGsjMJWsap5oRNihHhu6G7JVO/9jIB6UyevL+tXuOqrng8j/cxKTWyWUwvSTriiZz/g==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "emoji-regex": "^8.0.0",
+        "is-fullwidth-code-point": "^3.0.0",
+        "strip-ansi": "^6.0.1"
+      },
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/string-width-cjs/node_modules/emoji-regex": {
+      "version": "8.0.0",
+      "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-8.0.0.tgz",
+      "integrity": "sha512-MSjYzcWNOA0ewAHpz0MxpYFvwg6yjy1NG3xteoqz644VCo/RPgnr1/GGt+ic3iJTzQ8Eu3TdM14SawnVUmGE6A==",
+      "dev": true,
+      "license": "MIT"
+    },
+    "node_modules/string-width/node_modules/ansi-regex": {
+      "version": "6.2.2",
+      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-6.2.2.tgz",
+      "integrity": "sha512-Bq3SmSpyFHaWjPk8If9yc6svM8c56dB5BAtW4Qbw5jHTwwXXcTLoRMkpDJp6VL0XzlWaCHTXrkFURMYmD0sLqg==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/ansi-regex?sponsor=1"
+      }
+    },
+    "node_modules/string-width/node_modules/strip-ansi": {
+      "version": "7.1.2",
+      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-7.1.2.tgz",
+      "integrity": "sha512-gmBGslpoQJtgnMAvOVqGZpEz9dyoKTCzy2nfz/n8aIFhN/jCE/rCmcxabB6jOOHV+0WNnylOxaxBQPSvcWklhA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "ansi-regex": "^6.0.1"
+      },
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/strip-ansi?sponsor=1"
+      }
+    },
     "node_modules/strip-ansi": {
       "version": "6.0.1",
       "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-6.0.1.tgz",
@@ -3172,6 +3643,20 @@
         "node": ">=8"
       }
     },
+    "node_modules/strip-ansi-cjs": {
+      "name": "strip-ansi",
+      "version": "6.0.1",
+      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-6.0.1.tgz",
+      "integrity": "sha512-Y38VPSHcqkFrCpFnQ9vuSXmquuv5oXOKpGeT6aGrr3o3Gc9AlVa6JBfUSOCnbxGGZF+/0ooI7KrPuUSztUdU5A==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "ansi-regex": "^5.0.1"
+      },
+      "engines": {
+        "node": ">=8"
+      }
+    },
     "node_modules/strip-json-comments": {
       "version": "3.1.1",
       "resolved": "https://registry.npmjs.org/strip-json-comments/-/strip-json-comments-3.1.1.tgz",
@@ -3226,6 +3711,43 @@
         "node": ">=6"
       }
     },
+    "node_modules/test-exclude": {
+      "version": "7.0.1",
+      "resolved": "https://registry.npmjs.org/test-exclude/-/test-exclude-7.0.1.tgz",
+      "integrity": "sha512-pFYqmTw68LXVjeWJMST4+borgQP2AyMNbg1BpZh9LbyhUeNkeaPF9gzfPGUAnSMV3qPYdWUwDIjjCLiSDOl7vg==",
+      "dev": true,
+      "license": "ISC",
+      "dependencies": {
+        "@istanbuljs/schema": "^0.1.2",
+        "glob": "^10.4.1",
+        "minimatch": "^9.0.4"
+      },
+      "engines": {
+        "node": ">=18"
+      }
+    },
+    "node_modules/test-exclude/node_modules/glob": {
+      "version": "10.5.0",
+      "resolved": "https://registry.npmjs.org/glob/-/glob-10.5.0.tgz",
+      "integrity": "sha512-DfXN8DfhJ7NH3Oe7cFmu3NCu1wKbkReJ8TorzSAFbSKrlNaQSKfIzqYqVY8zlbs2NLBbWpRiU52GX2PbaBVNkg==",
+      "deprecated": "Old versions of glob are not supported, and contain widely publicized security vulnerabilities, which have been fixed in the current version. Please update. Support for old versions may be purchased (at exorbitant rates) by contacting i@izs.me",
+      "dev": true,
+      "license": "ISC",
+      "dependencies": {
+        "foreground-child": "^3.1.0",
+        "jackspeak": "^3.1.2",
+        "minimatch": "^9.0.4",
+        "minipass": "^7.1.2",
+        "package-json-from-dist": "^1.0.0",
+        "path-scurry": "^1.11.1"
+      },
+      "bin": {
+        "glob": "dist/esm/bin.mjs"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/isaacs"
+      }
+    },
     "node_modules/text-table": {
       "version": "0.2.0",
       "resolved": "https://registry.npmjs.org/text-table/-/text-table-0.2.0.tgz",
@@ -3347,7 +3869,6 @@
       "integrity": "sha512-jl1vZzPDinLr9eUt3J/t7V6FgNEw9QjvBPdysz9KfQDD41fQrC2Y4vKQdiaUpFT4bXlb1RHhLpp8wtm6M5TgSw==",
       "dev": true,
       "license": "Apache-2.0",
-      "peer": true,
       "bin": {
         "tsc": "bin/tsc",
         "tsserver": "bin/tsserver"
@@ -3571,6 +4092,107 @@
         "node": ">=0.10.0"
       }
     },
+    "node_modules/wrap-ansi": {
+      "version": "8.1.0",
+      "resolved": "https://registry.npmjs.org/wrap-ansi/-/wrap-ansi-8.1.0.tgz",
+      "integrity": "sha512-si7QWI6zUMq56bESFvagtmzMdGOtoxfR+Sez11Mobfc7tm+VkUckk9bW2UeffTGVUbOksxmSw0AA2gs8g71NCQ==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "ansi-styles": "^6.1.0",
+        "string-width": "^5.0.1",
+        "strip-ansi": "^7.0.1"
+      },
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/wrap-ansi?sponsor=1"
+      }
+    },
+    "node_modules/wrap-ansi-cjs": {
+      "name": "wrap-ansi",
+      "version": "7.0.0",
+      "resolved": "https://registry.npmjs.org/wrap-ansi/-/wrap-ansi-7.0.0.tgz",
+      "integrity": "sha512-YVGIj2kamLSTxw6NsZjoBxfSwsn0ycdesmc4p+Q21c5zPuZ1pl+NfxVdxPtdHvmNVOQ6XSYG4AUtyt/Fi7D16Q==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "ansi-styles": "^4.0.0",
+        "string-width": "^4.1.0",
+        "strip-ansi": "^6.0.0"
+      },
+      "engines": {
+        "node": ">=10"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/wrap-ansi?sponsor=1"
+      }
+    },
+    "node_modules/wrap-ansi-cjs/node_modules/emoji-regex": {
+      "version": "8.0.0",
+      "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-8.0.0.tgz",
+      "integrity": "sha512-MSjYzcWNOA0ewAHpz0MxpYFvwg6yjy1NG3xteoqz644VCo/RPgnr1/GGt+ic3iJTzQ8Eu3TdM14SawnVUmGE6A==",
+      "dev": true,
+      "license": "MIT"
+    },
+    "node_modules/wrap-ansi-cjs/node_modules/string-width": {
+      "version": "4.2.3",
+      "resolved": "https://registry.npmjs.org/string-width/-/string-width-4.2.3.tgz",
+      "integrity": "sha512-wKyQRQpjJ0sIp62ErSZdGsjMJWsap5oRNihHhu6G7JVO/9jIB6UyevL+tXuOqrng8j/cxKTWyWUwvSTriiZz/g==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "emoji-regex": "^8.0.0",
+        "is-fullwidth-code-point": "^3.0.0",
+        "strip-ansi": "^6.0.1"
+      },
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/wrap-ansi/node_modules/ansi-regex": {
+      "version": "6.2.2",
+      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-6.2.2.tgz",
+      "integrity": "sha512-Bq3SmSpyFHaWjPk8If9yc6svM8c56dB5BAtW4Qbw5jHTwwXXcTLoRMkpDJp6VL0XzlWaCHTXrkFURMYmD0sLqg==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/ansi-regex?sponsor=1"
+      }
+    },
+    "node_modules/wrap-ansi/node_modules/ansi-styles": {
+      "version": "6.2.3",
+      "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-6.2.3.tgz",
+      "integrity": "sha512-4Dj6M28JB+oAH8kFkTLUo+a2jwOFkuqb3yucU0CANcRRUbxS0cP0nZYCGjcc3BNXwRIsUVmDGgzawme7zvJHvg==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/ansi-styles?sponsor=1"
+      }
+    },
+    "node_modules/wrap-ansi/node_modules/strip-ansi": {
+      "version": "7.1.2",
+      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-7.1.2.tgz",
+      "integrity": "sha512-gmBGslpoQJtgnMAvOVqGZpEz9dyoKTCzy2nfz/n8aIFhN/jCE/rCmcxabB6jOOHV+0WNnylOxaxBQPSvcWklhA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "ansi-regex": "^6.0.1"
+      },
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/strip-ansi?sponsor=1"
+      }
+    },
     "node_modules/wrappy": {
       "version": "1.0.2",
       "resolved": "https://registry.npmjs.org/wrappy/-/wrappy-1.0.2.tgz",
diff --git a/src/deps/index.ts b/src/deps/index.ts
new file mode 100644
index 0000000..2efd46a
--- /dev/null
+++ b/src/deps/index.ts
@@ -0,0 +1,146 @@
+import type { DependencyNode, DepsService, RegistryService } from '../types.js';
+
+export function createDepsService(): DepsService {
+  function buildTreeImpl(
+    name: string,
+    registry: RegistryService,
+    visited: Set<string>,
+  ): DependencyNode {
+    const manifest = registry.get(name);
+    if (!manifest) {
+      return { name, version: 'unknown', dependencies: [] };
+    }
+
+    const key = `${name}@${manifest.version}`;
+    if (visited.has(key)) {
+      // Circular reference - return a leaf to avoid infinite recursion
+      return { name, version: manifest.version, dependencies: [] };
+    }
+
+    visited.add(key);
+    const deps: DependencyNode[] = [];
+    for (const depName of Object.keys(manifest.dependencies)) {
+      deps.push(buildTreeImpl(depName, registry, new Set(visited)));
+    }
+
+    return {
+      name,
+      version: manifest.version,
+      dependencies: deps,
+    };
+  }
+
+  function detectCyclesImpl(
+    name: string,
+    registry: RegistryService,
+  ): string[][] | null {
+    const cycles: string[][] = [];
+
+    function dfs(current: string, path: string[], visited: Set<string>): void {
+      if (path.includes(current)) {
+        // Found a cycle - extract it
+        const cycleStart = path.indexOf(current);
+        cycles.push([...path.slice(cycleStart), current]);
+        return;
+      }
+
+      if (visited.has(current)) return;
+
+      const manifest = registry.get(current);
+      if (!manifest) return;
+
+      path.push(current);
+      for (const depName of Object.keys(manifest.dependencies)) {
+        dfs(depName, [...path], visited);
+      }
+      visited.add(current);
+    }
+
+    dfs(name, [], new Set());
+    return cycles.length > 0 ? cycles : null;
+  }
+
+  function topoSortImpl(
+    name: string,
+    registry: RegistryService,
+  ): string[] {
+    const result: string[] = [];
+    const visited = new Set<string>();
+    const inStack = new Set<string>();
+
+    function visit(current: string): void {
+      if (inStack.has(current)) {
+        throw new Error(`Circular dependency detected involving "${current}"`);
+      }
+      if (visited.has(current)) return;
+
+      inStack.add(current);
+      const manifest = registry.get(current);
+      if (manifest) {
+        for (const depName of Object.keys(manifest.dependencies)) {
+          visit(depName);
+        }
+      }
+      inStack.delete(current);
+      visited.add(current);
+      result.push(current);
+    }
+
+    visit(name);
+    return result;
+  }
+
+  function flattenImpl(
+    name: string,
+    registry: RegistryService,
+  ): string[] {
+    const deps = new Set<string>();
+
+    function collect(current: string, visited: Set<string>): void {
+      if (visited.has(current)) return;
+      visited.add(current);
+
+      const manifest = registry.get(current);
+      if (!manifest) return;
+
+      for (const depName of Object.keys(manifest.dependencies)) {
+        deps.add(depName);
+        collect(depName, visited);
+      }
+    }
+
+    collect(name, new Set());
+    return Array.from(deps);
+  }
+
+  return {
+    buildTree(name: string, registry: RegistryService): DependencyNode {
+      return buildTreeImpl(name, registry, new Set());
+    },
+
+    detectCycles(
+      name: string,
+      registry: RegistryService,
+    ): string[][] | null {
+      return detectCyclesImpl(name, registry);
+    },
+
+    topologicalSort(name: string, registry: RegistryService): string[] {
+      return topoSortImpl(name, registry);
+    },
+
+    flattenDependencies(
+      name: string,
+      registry: RegistryService,
+    ): string[] {
+      return flattenImpl(name, registry);
+    },
+
+    hasCircularDependency(
+      name: string,
+      registry: RegistryService,
+    ): boolean {
+      return detectCyclesImpl(name, registry) !== null;
+    },
+  };
+}
diff --git a/src/index.ts b/src/index.ts
new file mode 100644
index 0000000..071cd3b
--- /dev/null
+++ b/src/index.ts
@@ -0,0 +1,109 @@
+import type {
+  DepsService,
+  PluginManifest,
+  RegistryService,
+  ResolvedVersion,
+  ResolverService,
+  ReviewService,
+  RunnerService,
+  SandboxResult,
+} from './types.js';
+import { createRegistry } from './registry/index.js';
+import { createResolver } from './resolver/index.js';
+import { createRunner } from './runner/index.js';
+import { createReviewService } from './reviews/index.js';
+import { createDepsService } from './deps/index.js';
+
+export interface InstallResult {
+  resolvedDependencies: ResolvedVersion[];
+  executionResult: SandboxResult;
+}
+
+export interface Marketplace {
+  registry: RegistryService;
+  resolver: ResolverService;
+  runner: RunnerService;
+  reviews: ReviewService;
+  deps: DepsService;
+  installPlugin(manifest: PluginManifest): Promise<InstallResult>;
+}
+
+export function createMarketplace(reviewDbPath?: string): Marketplace {
+  const registry = createRegistry();
+  const resolver = createResolver();
+  const runner = createRunner();
+  const reviews = createReviewService(reviewDbPath);
+  const deps = createDepsService();
+
+  async function installPlugin(
+    manifest: PluginManifest,
+  ): Promise<InstallResult> {
+    // 1. Validate required fields
+    if (!manifest.name) {
+      throw new Error('Plugin manifest must have a name');
+    }
+    if (!manifest.version) {
+      throw new Error('Plugin manifest must have a version');
+    }
+    if (!manifest.entryPoint) {
+      throw new Error('Plugin manifest must have an entryPoint');
+    }
+
+    // 2. Register the plugin
+    registry.register(manifest);
+
+    // 3. Resolve dependency versions
+    let resolvedDependencies: ResolvedVersion[] = [];
+    const depEntries = Object.entries(manifest.dependencies ?? {});
+    if (depEntries.length > 0) {
+      const constraints = depEntries.map(([name, range]) => ({
+        name,
+        range,
+      }));
+
+      // Build available versions map from registry
+      const available: Record<string, string[]> = {};
+      for (const [depName] of depEntries) {
+        const versions = registry.listVersions(depName);
+        if (versions.length > 0) {
+          available[depName] = versions;
+        }
+      }
+
+      resolvedDependencies = resolver.resolve(constraints, available);
+    }
+
+    // 4. Check for circular dependencies
+    if (deps.hasCircularDependency(manifest.name, registry)) {
+      // Unregister on failure to keep registry clean
+      registry.remove(manifest.name, manifest.version);
+      throw new Error(
+        `Circular dependency detected for plugin "${manifest.name}"`,
+      );
+    }
+
+    // 5. Execute entry point in sandbox
+    const executionResult = await runner.execute(manifest.entryPoint);
+
+    return {
+      resolvedDependencies,
+      executionResult,
+    };
+  }
+
+  return {
+    registry,
+    resolver,
+    runner,
+    reviews,
+    deps,
+    installPlugin,
+  };
+}
+
+// Re-export module factories
+export { createRegistry } from './registry/index.js';
+export { createResolver } from './resolver/index.js';
+export { createRunner } from './runner/index.js';
+export { createReviewService } from './reviews/index.js';
+export { createDepsService } from './deps/index.js';
diff --git a/src/registry/index.ts b/src/registry/index.ts
new file mode 100644
index 0000000..6886064
--- /dev/null
+++ b/src/registry/index.ts
@@ -0,0 +1,98 @@
+import type { PluginManifest, RegistryService } from '../types.js';
+
+export function createRegistry(): RegistryService {
+  // Map of name -> Map of version -> manifest
+  const plugins = new Map<string, Map<string, PluginManifest>>();
+
+  return {
+    register(manifest: PluginManifest): void {
+      if (!manifest.name || !manifest.version) {
+        throw new Error('Plugin manifest must have name and version');
+      }
+      let versions = plugins.get(manifest.name);
+      if (!versions) {
+        versions = new Map();
+        plugins.set(manifest.name, versions);
+      }
+      if (versions.has(manifest.version)) {
+        throw new Error(`Plugin ${manifest.name}@${manifest.version} already registered`);
+      }
+      versions.set(manifest.version, { ...manifest });
+    },
+
+    get(name: string): PluginManifest | null {
+      const versions = plugins.get(name);
+      if (!versions || versions.size === 0) return null;
+      // Return the latest registered version (last inserted)
+      let latest: PluginManifest | null = null;
+      for (const manifest of versions.values()) {
+        latest = manifest;
+      }
+      return latest;
+    },
+
+    getVersion(name: string, version: string): PluginManifest | null {
+      const versions = plugins.get(name);
+      if (!versions) return null;
+      return versions.get(version) ?? null;
+    },
+
+    list(): PluginManifest[] {
+      const result: PluginManifest[] = [];
+      for (const versions of plugins.values()) {
+        for (const manifest of versions.values()) {
+          result.push(manifest);
+        }
+      }
+      return result;
+    },
+
+    search(query: string): PluginManifest[] {
+      const lower = query.toLowerCase();
+      const result: PluginManifest[] = [];
+      for (const versions of plugins.values()) {
+        for (const manifest of versions.values()) {
+          if (
+            manifest.name.toLowerCase().includes(lower) ||
+            manifest.description.toLowerCase().includes(lower) ||
+            manifest.author.toLowerCase().includes(lower)
+          ) {
+            result.push(manifest);
+          }
+        }
+      }
+      return result;
+    },
+
+    remove(name: string, version: string): boolean {
+      const versions = plugins.get(name);
+      if (!versions) return false;
+      const deleted = versions.delete(version);
+      if (versions.size === 0) {
+        plugins.delete(name);
+      }
+      return deleted;
+    },
+
+    listVersions(name: string): string[] {
+      const versions = plugins.get(name);
+      if (!versions) return [];
+      return Array.from(versions.keys());
+    },
+
+    update(name: string, version: string, updates: Partial<PluginManifest>): void {
+      const versions = plugins.get(name);
+      if (!versions) {
+        throw new Error(`Plugin ${name} not found`);
+      }
+      const manifest = versions.get(version);
+      if (!manifest) {
+        throw new Error(`Plugin ${name}@${version} not found`);
+      }
+      // Apply updates but don't allow changing name/version
+      const { name: _, version: __, ...safeUpdates } = updates;
+      void _; void __;
+      Object.assign(manifest, safeUpdates);
+    },
+  };
+}
diff --git a/src/resolver/index.ts b/src/resolver/index.ts
new file mode 100644
index 0000000..2eb7742
--- /dev/null
+++ b/src/resolver/index.ts
@@ -0,0 +1,49 @@
+import semver from 'semver';
+import type { ResolverService, ResolvedVersion, VersionConstraint } from '../types.js';
+
+export function createResolver(): ResolverService {
+  return {
+    resolve(
+      constraints: VersionConstraint[],
+      available: Record<string, string[]>,
+    ): ResolvedVersion[] {
+      const resolved: ResolvedVersion[] = [];
+
+      for (const constraint of constraints) {
+        const versions = available[constraint.name];
+        if (!versions || versions.length === 0) {
+          throw new Error(
+            `No versions available for "${constraint.name}"`,
+          );
+        }
+
+        const match = semver.maxSatisfying(versions, constraint.range);
+        if (!match) {
+          throw new Error(
+            `No version of "${constraint.name}" satisfies range "${constraint.range}"`,
+          );
+        }
+
+        resolved.push({
+          name: constraint.name,
+          version: match,
+          satisfies: constraint.range,
+        });
+      }
+
+      return resolved;
+    },
+
+    satisfies(version: string, range: string): boolean {
+      return semver.satisfies(version, range);
+    },
+
+    maxSatisfying(versions: string[], range: string): string | null {
+      return semver.maxSatisfying(versions, range);
+    },
+
+    validRange(range: string): boolean {
+      return semver.validRange(range) !== null;
+    },
+  };
+}
diff --git a/src/reviews/index.ts b/src/reviews/index.ts
new file mode 100644
index 0000000..7e35e5e
--- /dev/null
+++ b/src/reviews/index.ts
@@ -0,0 +1,127 @@
+import Database from 'better-sqlite3';
+import type { Review, ReviewService } from '../types.js';
+
+export function createReviewService(dbPath?: string): ReviewService {
+  const db = new Database(dbPath ?? ':memory:');
+
+  db.pragma('journal_mode = WAL');
+  db.exec(`
+    CREATE TABLE IF NOT EXISTS reviews (
+      id INTEGER PRIMARY KEY AUTOINCREMENT,
+      pluginName TEXT NOT NULL,
+      pluginVersion TEXT NOT NULL,
+      userId TEXT NOT NULL,
+      rating INTEGER NOT NULL CHECK(rating >= 1 AND rating <= 5),
+      comment TEXT NOT NULL,
+      flagged INTEGER NOT NULL DEFAULT 0,
+      createdAt TEXT NOT NULL
+    )
+  `);
+
+  const insertStmt = db.prepare(`
+    INSERT INTO reviews (pluginName, pluginVersion, userId, rating, comment, flagged, createdAt)
+    VALUES (@pluginName, @pluginVersion, @userId, @rating, @comment, 0, @createdAt)
+  `);
+
+  const getByPluginStmt = db.prepare(
+    `SELECT * FROM reviews WHERE pluginName = ?`,
+  );
+
+  const avgRatingStmt = db.prepare(
+    `SELECT AVG(rating) as avg FROM reviews WHERE pluginName = ? AND flagged = 0`,
+  );
+
+  const flagStmt = db.prepare(
+    `UPDATE reviews SET flagged = 1 WHERE id = ?`,
+  );
+
+  const getFlaggedStmt = db.prepare(
+    `SELECT * FROM reviews WHERE flagged = 1`,
+  );
+
+  const removeStmt = db.prepare(`DELETE FROM reviews WHERE id = ?`);
+
+  const getByUserStmt = db.prepare(
+    `SELECT * FROM reviews WHERE userId = ?`,
+  );
+
+  const countStmt = db.prepare(
+    `SELECT COUNT(*) as cnt FROM reviews WHERE pluginName = ?`,
+  );
+
+  function rowToReview(row: Record<string, unknown>): Review {
+    return {
+      id: row.id as number,
+      pluginName: row.pluginName as string,
+      pluginVersion: row.pluginVersion as string,
+      userId: row.userId as string,
+      rating: row.rating as number,
+      comment: row.comment as string,
+      flagged: (row.flagged as number) === 1,
+      createdAt: row.createdAt as string,
+    };
+  }
+
+  return {
+    addReview(
+      review: Omit<Review, 'id' | 'createdAt' | 'flagged'>,
+    ): Review {
+      if (review.rating < 1 || review.rating > 5) {
+        throw new Error('Rating must be between 1 and 5');
+      }
+      const createdAt = new Date().toISOString();
+      const result = insertStmt.run({
+        pluginName: review.pluginName,
+        pluginVersion: review.pluginVersion,
+        userId: review.userId,
+        rating: review.rating,
+        comment: review.comment,
+        createdAt,
+      });
+      return {
+        id: result.lastInsertRowid as number,
+        pluginName: review.pluginName,
+        pluginVersion: review.pluginVersion,
+        userId: review.userId,
+        rating: review.rating,
+        comment: review.comment,
+        flagged: false,
+        createdAt,
+      };
+    },
+
+    getReviews(pluginName: string): Review[] {
+      const rows = getByPluginStmt.all(pluginName) as Record<string, unknown>[];
+      return rows.map(rowToReview);
+    },
+
+    getAverageRating(pluginName: string): number {
+      const row = avgRatingStmt.get(pluginName) as { avg: number | null };
+      return row.avg ?? 0;
+    },
+
+    flagReview(reviewId: number): void {
+      flagStmt.run(reviewId);
+    },
+
+    getFlaggedReviews(): Review[] {
+      const rows = getFlaggedStmt.all() as Record<string, unknown>[];
+      return rows.map(rowToReview);
+    },
+
+    removeReview(reviewId: number): boolean {
+      const result = removeStmt.run(reviewId);
+      return result.changes > 0;
+    },
+
+    getReviewsByUser(userId: string): Review[] {
+      const rows = getByUserStmt.all(userId) as Record<string, unknown>[];
+      return rows.map(rowToReview);
+    },
+
+    getReviewCount(pluginName: string): number {
+      const row = countStmt.get(pluginName) as { cnt: number };
+      return row.cnt;
+    },
+  };
+}
diff --git a/src/runner/index.ts b/src/runner/index.ts
new file mode 100644
index 0000000..1f39946
--- /dev/null
+++ b/src/runner/index.ts
@@ -0,0 +1,74 @@
+import vm from 'node:vm';
+import type { RunnerService, SandboxResult } from '../types.js';
+
+const DEFAULT_TIMEOUT = 5000;
+
+export function createRunner(): RunnerService {
+  function run(
+    code: string,
+    timeoutMs: number,
+    context: Record<string, unknown> = {},
+  ): Promise<SandboxResult> {
+    return new Promise((resolve) => {
+      const startTime = performance.now();
+      const memBefore = process.memoryUsage().heapUsed;
+
+      try {
+        const sandbox: Record<string, unknown> = {
+          ...context,
+          __output: undefined,
+        };
+
+        vm.createContext(sandbox);
+
+        // Wrap code to capture the last expression value
+        const wrappedCode = `__output = (function() { ${code} })();`;
+
+        vm.runInContext(wrappedCode, sandbox, {
+          timeout: timeoutMs,
+          filename: 'plugin.js',
+        });
+
+        const duration = performance.now() - startTime;
+        const memAfter = process.memoryUsage().heapUsed;
+
+        resolve({
+          success: true,
+          output: sandbox.__output,
+          duration,
+          memoryUsed: Math.max(0, memAfter - memBefore),
+        });
+      } catch (err: unknown) {
+        const duration = performance.now() - startTime;
+        const memAfter = process.memoryUsage().heapUsed;
+        const errorMessage =
+          err instanceof Error ? err.message : String(err);
+
+        resolve({
+          success: false,
+          output: null,
+          duration,
+          memoryUsed: Math.max(0, memAfter - memBefore),
+          error: errorMessage,
+        });
+      }
+    });
+  }
+
+  return {
+    execute(
+      code: string,
+      context?: Record<string, unknown>,
+    ): Promise<SandboxResult> {
+      return run(code, DEFAULT_TIMEOUT, context);
+    },
+
+    executeWithTimeout(
+      code: string,
+      timeoutMs: number,
+      context?: Record<string, unknown>,
+    ): Promise<SandboxResult> {
+      return run(code, timeoutMs, context);
+    },
+  };
+}
diff --git a/tests/deps.test.ts b/tests/deps.test.ts
new file mode 100644
index 0000000..adda5ef
--- /dev/null
+++ b/tests/deps.test.ts
@@ -0,0 +1,160 @@
+import { describe, it, expect, beforeEach } from 'vitest';
+import { createDepsService } from '../src/deps/index.js';
+import { createRegistry } from '../src/registry/index.js';
+import type { DepsService, RegistryService, PluginManifest } from '../src/types.js';
+
+function makeManifest(
+  name: string,
+  version: string,
+  dependencies: Record<string, string> = {},
+): PluginManifest {
+  return {
+    name,
+    version,
+    description: `${name} plugin`,
+    author: 'tester',
+    dependencies,
+    entryPoint: 'return 1;',
+    permissions: [],
+  };
+}
+
+describe('Dependency Graph', () => {
+  let deps: DepsService;
+  let registry: RegistryService;
+
+  beforeEach(() => {
+    deps = createDepsService();
+    registry = createRegistry();
+  });
+
+  describe('buildTree', () => {
+    it('should build a tree for plugin with no dependencies', () => {
+      registry.register(makeManifest('root', '1.0.0'));
+      const tree = deps.buildTree('root', registry);
+      expect(tree.name).toBe('root');
+      expect(tree.version).toBe('1.0.0');
+      expect(tree.dependencies).toEqual([]);
+    });
+
+    it('should build a tree with nested dependencies', () => {
+      registry.register(makeManifest('root', '1.0.0', { child: '^1.0.0' }));
+      registry.register(makeManifest('child', '1.2.0', { grandchild: '^1.0.0' }));
+      registry.register(makeManifest('grandchild', '1.0.0'));
+
+      const tree = deps.buildTree('root', registry);
+      expect(tree.name).toBe('root');
+      expect(tree.dependencies).toHaveLength(1);
+      expect(tree.dependencies[0].name).toBe('child');
+      expect(tree.dependencies[0].dependencies).toHaveLength(1);
+      expect(tree.dependencies[0].dependencies[0].name).toBe('grandchild');
+    });
+
+    it('should handle missing plugins in tree', () => {
+      registry.register(makeManifest('root', '1.0.0', { missing: '^1.0.0' }));
+      const tree = deps.buildTree('root', registry);
+      expect(tree.dependencies[0].name).toBe('missing');
+      expect(tree.dependencies[0].version).toBe('unknown');
+    });
+
+    it('should handle circular dependencies without infinite recursion', () => {
+      registry.register(makeManifest('a', '1.0.0', { b: '^1.0.0' }));
+      registry.register(makeManifest('b', '1.0.0', { a: '^1.0.0' }));
+      // Should not throw or loop infinitely
+      const tree = deps.buildTree('a', registry);
+      expect(tree.name).toBe('a');
+      expect(tree.dependencies[0].name).toBe('b');
+    });
+  });
+
+  describe('detectCycles', () => {
+    it('should return null when no cycles exist', () => {
+      registry.register(makeManifest('a', '1.0.0', { b: '^1.0.0' }));
+      registry.register(makeManifest('b', '1.0.0'));
+      expect(deps.detectCycles('a', registry)).toBeNull();
+    });
+
+    it('should detect direct circular dependency', () => {
+      registry.register(makeManifest('a', '1.0.0', { b: '^1.0.0' }));
+      registry.register(makeManifest('b', '1.0.0', { a: '^1.0.0' }));
+      const cycles = deps.detectCycles('a', registry);
+      expect(cycles).not.toBeNull();
+      expect(cycles!.length).toBeGreaterThan(0);
+    });
+
+    it('should detect indirect circular dependency', () => {
+      registry.register(makeManifest('a', '1.0.0', { b: '^1.0.0' }));
+      registry.register(makeManifest('b', '1.0.0', { c: '^1.0.0' }));
+      registry.register(makeManifest('c', '1.0.0', { a: '^1.0.0' }));
+      const cycles = deps.detectCycles('a', registry);
+      expect(cycles).not.toBeNull();
+    });
+  });
+
+  describe('hasCircularDependency', () => {
+    it('should return false for acyclic graph', () => {
+      registry.register(makeManifest('a', '1.0.0', { b: '^1.0.0' }));
+      registry.register(makeManifest('b', '1.0.0'));
+      expect(deps.hasCircularDependency('a', registry)).toBe(false);
+    });
+
+    it('should return true for cyclic graph', () => {
+      registry.register(makeManifest('a', '1.0.0', { b: '^1.0.0' }));
+      registry.register(makeManifest('b', '1.0.0', { a: '^1.0.0' }));
+      expect(deps.hasCircularDependency('a', registry)).toBe(true);
+    });
+  });
+
+  describe('topologicalSort', () => {
+    it('should return correct topological order', () => {
+      registry.register(makeManifest('a', '1.0.0', { b: '^1.0.0', c: '^1.0.0' }));
+      registry.register(makeManifest('b', '1.0.0', { c: '^1.0.0' }));
+      registry.register(makeManifest('c', '1.0.0'));
+
+      const order = deps.topologicalSort('a', registry);
+      // c should come before b, b before a
+      expect(order.indexOf('c')).toBeLessThan(order.indexOf('b'));
+      expect(order.indexOf('b')).toBeLessThan(order.indexOf('a'));
+    });
+
+    it('should handle single plugin with no deps', () => {
+      registry.register(makeManifest('solo', '1.0.0'));
+      expect(deps.topologicalSort('solo', registry)).toEqual(['solo']);
+    });
+
+    it('should throw on circular dependencies', () => {
+      registry.register(makeManifest('a', '1.0.0', { b: '^1.0.0' }));
+      registry.register(makeManifest('b', '1.0.0', { a: '^1.0.0' }));
+      expect(() => deps.topologicalSort('a', registry)).toThrow('Circular');
+    });
+  });
+
+  describe('flattenDependencies', () => {
+    it('should return all transitive dependencies', () => {
+      registry.register(makeManifest('a', '1.0.0', { b: '^1.0.0' }));
+      registry.register(makeManifest('b', '1.0.0', { c: '^1.0.0' }));
+      registry.register(makeManifest('c', '1.0.0'));
+
+      const flat = deps.flattenDependencies('a', registry);
+      expect(flat).toContain('b');
+      expect(flat).toContain('c');
+      expect(flat).not.toContain('a');
+    });
+
+    it('should return empty array for plugin with no deps', () => {
+      registry.register(makeManifest('solo', '1.0.0'));
+      expect(deps.flattenDependencies('solo', registry)).toEqual([]);
+    });
+
+    it('should deduplicate shared dependencies', () => {
+      registry.register(makeManifest('a', '1.0.0', { b: '^1.0.0', c: '^1.0.0' }));
+      registry.register(makeManifest('b', '1.0.0', { d: '^1.0.0' }));
+      registry.register(makeManifest('c', '1.0.0', { d: '^1.0.0' }));
+      registry.register(makeManifest('d', '1.0.0'));
+
+      const flat = deps.flattenDependencies('a', registry);
+      const dCount = flat.filter((n) => n === 'd').length;
+      expect(dCount).toBe(1);
+    });
+  });
+});
diff --git a/tests/marketplace.test.ts b/tests/marketplace.test.ts
new file mode 100644
index 0000000..003c08d
--- /dev/null
+++ b/tests/marketplace.test.ts
@@ -0,0 +1,157 @@
+import { describe, it, expect, beforeEach } from 'vitest';
+import { createMarketplace } from '../src/index.js';
+import type { Marketplace } from '../src/index.js';
+import type { PluginManifest } from '../src/types.js';
+
+function makeManifest(overrides: Partial<PluginManifest> = {}): PluginManifest {
+  return {
+    name: 'my-plugin',
+    version: '1.0.0',
+    description: 'A plugin',
+    author: 'tester',
+    dependencies: {},
+    entryPoint: 'return "installed";',
+    permissions: [],
+    ...overrides,
+  };
+}
+
+describe('Marketplace Integration', () => {
+  let marketplace: Marketplace;
+
+  beforeEach(() => {
+    marketplace = createMarketplace();
+  });
+
+  describe('createMarketplace', () => {
+    it('should expose all services', () => {
+      expect(marketplace.registry).toBeDefined();
+      expect(marketplace.resolver).toBeDefined();
+      expect(marketplace.runner).toBeDefined();
+      expect(marketplace.reviews).toBeDefined();
+      expect(marketplace.deps).toBeDefined();
+      expect(marketplace.installPlugin).toBeDefined();
+    });
+  });
+
+  describe('installPlugin', () => {
+    it('should install a plugin with no dependencies', async () => {
+      const result = await marketplace.installPlugin(makeManifest());
+      expect(result.resolvedDependencies).toEqual([]);
+      expect(result.executionResult.success).toBe(true);
+      expect(result.executionResult.output).toBe('installed');
+    });
+
+    it('should register the plugin in the registry', async () => {
+      await marketplace.installPlugin(makeManifest());
+      const found = marketplace.registry.get('my-plugin');
+      expect(found).not.toBeNull();
+      expect(found?.name).toBe('my-plugin');
+    });
+
+    it('should resolve dependencies during install', async () => {
+      // Pre-register a dependency
+      marketplace.registry.register(makeManifest({
+        name: 'dep-a',
+        version: '1.0.0',
+        entryPoint: 'return true;',
+      }));
+      marketplace.registry.register(makeManifest({
+        name: 'dep-a',
+        version: '1.5.0',
+        entryPoint: 'return true;',
+      }));
+
+      const result = await marketplace.installPlugin(
+        makeManifest({
+          name: 'my-plugin',
+          dependencies: { 'dep-a': '^1.0.0' },
+        }),
+      );
+
+      expect(result.resolvedDependencies).toHaveLength(1);
+      expect(result.resolvedDependencies[0].name).toBe('dep-a');
+      expect(result.resolvedDependencies[0].version).toBe('1.5.0');
+    });
+
+    it('should reject plugin without name', async () => {
+      await expect(
+        marketplace.installPlugin(makeManifest({ name: '' })),
+      ).rejects.toThrow('name');
+    });
+
+    it('should reject plugin without version', async () => {
+      await expect(
+        marketplace.installPlugin(makeManifest({ version: '' })),
+      ).rejects.toThrow('version');
+    });
+
+    it('should reject plugin without entryPoint', async () => {
+      await expect(
+        marketplace.installPlugin(makeManifest({ entryPoint: '' })),
+      ).rejects.toThrow('entryPoint');
+    });
+
+    it('should reject circular dependencies', async () => {
+      // Register plugin B that depends on A
+      marketplace.registry.register(
+        makeManifest({
+          name: 'plugin-b',
+          version: '1.0.0',
+          dependencies: { 'plugin-a': '^1.0.0' },
+        }),
+      );
+
+      // Try to install plugin A that depends on B
+      await expect(
+        marketplace.installPlugin(
+          makeManifest({
+            name: 'plugin-a',
+            version: '1.0.0',
+            dependencies: { 'plugin-b': '^1.0.0' },
+          }),
+        ),
+      ).rejects.toThrow('Circular');
+    });
+
+    it('should remove plugin from registry when circular dep detected', async () => {
+      marketplace.registry.register(
+        makeManifest({
+          name: 'plugin-b',
+          version: '1.0.0',
+          dependencies: { 'plugin-a': '^1.0.0' },
+        }),
+      );
+
+      try {
+        await marketplace.installPlugin(
+          makeManifest({
+            name: 'plugin-a',
+            version: '1.0.0',
+            dependencies: { 'plugin-b': '^1.0.0' },
+          }),
+        );
+      } catch {
+        // Expected
+      }
+
+      expect(marketplace.registry.get('plugin-a')).toBeNull();
+    });
+
+    it('should execute the entry point code in sandbox', async () => {
+      const result = await marketplace.installPlugin(
+        makeManifest({ entryPoint: 'return 2 + 2;' }),
+      );
+      expect(result.executionResult.success).toBe(true);
+      expect(result.executionResult.output).toBe(4);
+    });
+
+    it('should handle entry point execution failure', async () => {
+      const result = await marketplace.installPlugin(
+        makeManifest({ entryPoint: 'throw new Error("init failed");' }),
+      );
+      expect(result.executionResult.success).toBe(false);
+      expect(result.executionResult.error).toContain('init failed');
+    });
+  });
+});
diff --git a/tests/registry.test.ts b/tests/registry.test.ts
new file mode 100644
index 0000000..f98c79e
--- /dev/null
+++ b/tests/registry.test.ts
@@ -0,0 +1,170 @@
+import { describe, it, expect, beforeEach } from 'vitest';
+import { createRegistry } from '../src/registry/index.js';
+import type { PluginManifest, RegistryService } from '../src/types.js';
+
+function makeManifest(overrides: Partial<PluginManifest> = {}): PluginManifest {
+  return {
+    name: 'test-plugin',
+    version: '1.0.0',
+    description: 'A test plugin',
+    author: 'tester',
+    dependencies: {},
+    entryPoint: 'return 1;',
+    permissions: [],
+    ...overrides,
+  };
+}
+
+describe('Plugin Registry', () => {
+  let registry: RegistryService;
+
+  beforeEach(() => {
+    registry = createRegistry();
+  });
+
+  describe('register', () => {
+    it('should register a plugin manifest', () => {
+      const manifest = makeManifest();
+      registry.register(manifest);
+      expect(registry.get('test-plugin')).toEqual(manifest);
+    });
+
+    it('should reject duplicate name+version', () => {
+      registry.register(makeManifest());
+      expect(() => registry.register(makeManifest())).toThrow('already registered');
+    });
+
+    it('should allow multiple versions of the same plugin', () => {
+      registry.register(makeManifest({ version: '1.0.0' }));
+      registry.register(makeManifest({ version: '2.0.0' }));
+      expect(registry.listVersions('test-plugin')).toEqual(['1.0.0', '2.0.0']);
+    });
+
+    it('should reject manifests without name', () => {
+      expect(() => registry.register(makeManifest({ name: '' }))).toThrow();
+    });
+
+    it('should reject manifests without version', () => {
+      expect(() => registry.register(makeManifest({ version: '' }))).toThrow();
+    });
+  });
+
+  describe('get', () => {
+    it('should return null for non-existent plugin', () => {
+      expect(registry.get('nonexistent')).toBeNull();
+    });
+
+    it('should return the latest registered version', () => {
+      registry.register(makeManifest({ version: '1.0.0' }));
+      registry.register(makeManifest({ version: '2.0.0' }));
+      const result = registry.get('test-plugin');
+      expect(result?.version).toBe('2.0.0');
+    });
+  });
+
+  describe('getVersion', () => {
+    it('should return specific version', () => {
+      registry.register(makeManifest({ version: '1.0.0' }));
+      registry.register(makeManifest({ version: '2.0.0' }));
+      const result = registry.getVersion('test-plugin', '1.0.0');
+      expect(result?.version).toBe('1.0.0');
+    });
+
+    it('should return null for non-existent version', () => {
+      registry.register(makeManifest());
+      expect(registry.getVersion('test-plugin', '9.9.9')).toBeNull();
+    });
+
+    it('should return null for non-existent plugin', () => {
+      expect(registry.getVersion('nonexistent', '1.0.0')).toBeNull();
+    });
+  });
+
+  describe('list', () => {
+    it('should return all registered manifests', () => {
+      registry.register(makeManifest({ name: 'a', version: '1.0.0' }));
+      registry.register(makeManifest({ name: 'b', version: '1.0.0' }));
+      registry.register(makeManifest({ name: 'a', version: '2.0.0' }));
+      expect(registry.list()).toHaveLength(3);
+    });
+
+    it('should return empty array when nothing registered', () => {
+      expect(registry.list()).toEqual([]);
+    });
+  });
+
+  describe('search', () => {
+    it('should search by name', () => {
+      registry.register(makeManifest({ name: 'auth-plugin' }));
+      registry.register(makeManifest({ name: 'cache-plugin', version: '1.0.0' }));
+      const results = registry.search('auth');
+      expect(results).toHaveLength(1);
+      expect(results[0].name).toBe('auth-plugin');
+    });
+
+    it('should search by description', () => {
+      registry.register(makeManifest({ name: 'my-plugin', description: 'Handles authentication' }));
+      const results = registry.search('authentication');
+      expect(results).toHaveLength(1);
+    });
+
+    it('should search by author', () => {
+      registry.register(makeManifest({ name: 'my-plugin', author: 'alice' }));
+      const results = registry.search('alice');
+      expect(results).toHaveLength(1);
+    });
+
+    it('should be case-insensitive', () => {
+      registry.register(makeManifest({ name: 'Auth-Plugin' }));
+      expect(registry.search('auth')).toHaveLength(1);
+      expect(registry.search('AUTH')).toHaveLength(1);
+    });
+  });
+
+  describe('remove', () => {
+    it('should remove a specific version', () => {
+      registry.register(makeManifest({ version: '1.0.0' }));
+      registry.register(makeManifest({ version: '2.0.0' }));
+      expect(registry.remove('test-plugin', '1.0.0')).toBe(true);
+      expect(registry.listVersions('test-plugin')).toEqual(['2.0.0']);
+    });
+
+    it('should return false for non-existent plugin', () => {
+      expect(registry.remove('nonexistent', '1.0.0')).toBe(false);
+    });
+
+    it('should return false for non-existent version', () => {
+      registry.register(makeManifest());
+      expect(registry.remove('test-plugin', '9.9.9')).toBe(false);
+    });
+
+    it('should clean up plugin entry when last version removed', () => {
+      registry.register(makeManifest());
+      registry.remove('test-plugin', '1.0.0');
+      expect(registry.get('test-plugin')).toBeNull();
+    });
+  });
+
+  describe('listVersions', () => {
+    it('should return empty array for non-existent plugin', () => {
+      expect(registry.listVersions('nonexistent')).toEqual([]);
+    });
+  });
+
+  describe('update', () => {
+    it('should update plugin fields', () => {
+      registry.register(makeManifest());
+      registry.update('test-plugin', '1.0.0', { description: 'Updated' });
+      expect(registry.getVersion('test-plugin', '1.0.0')?.description).toBe('Updated');
+    });
+
+    it('should throw for non-existent plugin', () => {
+      expect(() => registry.update('nonexistent', '1.0.0', {})).toThrow('not found');
+    });
+
+    it('should throw for non-existent version', () => {
+      registry.register(makeManifest());
+      expect(() => registry.update('test-plugin', '9.9.9', {})).toThrow('not found');
+    });
+  });
+});
diff --git a/tests/resolver.test.ts b/tests/resolver.test.ts
new file mode 100644
index 0000000..be6fff2
--- /dev/null
+++ b/tests/resolver.test.ts
@@ -0,0 +1,90 @@
+import { describe, it, expect, beforeEach } from 'vitest';
+import { createResolver } from '../src/resolver/index.js';
+import type { ResolverService } from '../src/types.js';
+
+describe('Version Resolver', () => {
+  let resolver: ResolverService;
+
+  beforeEach(() => {
+    resolver = createResolver();
+  });
+
+  describe('resolve', () => {
+    it('should resolve constraints to best matching versions', () => {
+      const result = resolver.resolve(
+        [{ name: 'foo', range: '^1.0.0' }],
+        { foo: ['1.0.0', '1.2.3', '1.5.0', '2.0.0'] },
+      );
+      expect(result).toHaveLength(1);
+      expect(result[0]).toEqual({ name: 'foo', version: '1.5.0', satisfies: '^1.0.0' });
+    });
+
+    it('should resolve multiple constraints', () => {
+      const result = resolver.resolve(
+        [
+          { name: 'foo', range: '^1.0.0' },
+          { name: 'bar', range: '~2.1.0' },
+        ],
+        {
+          foo: ['1.0.0', '1.3.0', '2.0.0'],
+          bar: ['2.0.0', '2.1.0', '2.1.5', '2.2.0'],
+        },
+      );
+      expect(result).toHaveLength(2);
+      expect(result[0].version).toBe('1.3.0');
+      expect(result[1].version).toBe('2.1.5');
+    });
+
+    it('should throw when no versions available for a dependency', () => {
+      expect(() =>
+        resolver.resolve([{ name: 'missing', range: '^1.0.0' }], {}),
+      ).toThrow('No versions available');
+    });
+
+    it('should throw when no version satisfies the range', () => {
+      expect(() =>
+        resolver.resolve(
+          [{ name: 'foo', range: '^3.0.0' }],
+          { foo: ['1.0.0', '2.0.0'] },
+        ),
+      ).toThrow('No version of "foo" satisfies range');
+    });
+  });
+
+  describe('satisfies', () => {
+    it('should return true for matching version', () => {
+      expect(resolver.satisfies('1.2.3', '^1.0.0')).toBe(true);
+    });
+
+    it('should return false for non-matching version', () => {
+      expect(resolver.satisfies('2.0.0', '^1.0.0')).toBe(false);
+    });
+
+    it('should handle tilde ranges', () => {
+      expect(resolver.satisfies('1.2.5', '~1.2.0')).toBe(true);
+      expect(resolver.satisfies('1.3.0', '~1.2.0')).toBe(false);
+    });
+  });
+
+  describe('maxSatisfying', () => {
+    it('should return the highest matching version', () => {
+      expect(resolver.maxSatisfying(['1.0.0', '1.5.0', '2.0.0'], '^1.0.0')).toBe('1.5.0');
+    });
+
+    it('should return null when nothing matches', () => {
+      expect(resolver.maxSatisfying(['1.0.0'], '^2.0.0')).toBeNull();
+    });
+  });
+
+  describe('validRange', () => {
+    it('should validate correct ranges', () => {
+      expect(resolver.validRange('^1.0.0')).toBe(true);
+      expect(resolver.validRange('~2.3.0')).toBe(true);
+      expect(resolver.validRange('>=1.0.0 <2.0.0')).toBe(true);
+    });
+
+    it('should reject invalid ranges', () => {
+      expect(resolver.validRange('not-a-range')).toBe(false);
+    });
+  });
+});
diff --git a/tests/reviews.test.ts b/tests/reviews.test.ts
new file mode 100644
index 0000000..7759849
--- /dev/null
+++ b/tests/reviews.test.ts
@@ -0,0 +1,170 @@
+import { describe, it, expect, beforeEach } from 'vitest';
+import { createReviewService } from '../src/reviews/index.js';
+import type { ReviewService } from '../src/types.js';
+
+describe('Review System', () => {
+  let reviews: ReviewService;
+
+  beforeEach(() => {
+    reviews = createReviewService(); // in-memory DB
+  });
+
+  describe('addReview', () => {
+    it('should add a review and return it with id and timestamp', () => {
+      const review = reviews.addReview({
+        pluginName: 'test-plugin',
+        pluginVersion: '1.0.0',
+        userId: 'user1',
+        rating: 5,
+        comment: 'Great plugin!',
+      });
+      expect(review.id).toBeDefined();
+      expect(review.id).toBeGreaterThan(0);
+      expect(review.flagged).toBe(false);
+      expect(review.createdAt).toBeDefined();
+      expect(review.rating).toBe(5);
+    });
+
+    it('should reject ratings outside 1-5', () => {
+      expect(() =>
+        reviews.addReview({
+          pluginName: 'test',
+          pluginVersion: '1.0.0',
+          userId: 'user1',
+          rating: 0,
+          comment: 'bad',
+        }),
+      ).toThrow();
+
+      expect(() =>
+        reviews.addReview({
+          pluginName: 'test',
+          pluginVersion: '1.0.0',
+          userId: 'user1',
+          rating: 6,
+          comment: 'bad',
+        }),
+      ).toThrow();
+    });
+
+    it('should assign incrementing IDs', () => {
+      const r1 = reviews.addReview({
+        pluginName: 'test',
+        pluginVersion: '1.0.0',
+        userId: 'user1',
+        rating: 3,
+        comment: 'ok',
+      });
+      const r2 = reviews.addReview({
+        pluginName: 'test',
+        pluginVersion: '1.0.0',
+        userId: 'user2',
+        rating: 4,
+        comment: 'good',
+      });
+      expect(r2.id).toBeGreaterThan(r1.id);
+    });
+  });
+
+  describe('getReviews', () => {
+    it('should return reviews for a specific plugin', () => {
+      reviews.addReview({ pluginName: 'a', pluginVersion: '1.0.0', userId: 'u1', rating: 5, comment: 'great' });
+      reviews.addReview({ pluginName: 'b', pluginVersion: '1.0.0', userId: 'u1', rating: 3, comment: 'ok' });
+      reviews.addReview({ pluginName: 'a', pluginVersion: '2.0.0', userId: 'u2', rating: 4, comment: 'good' });
+
+      const aReviews = reviews.getReviews('a');
+      expect(aReviews).toHaveLength(2);
+      expect(aReviews.every((r) => r.pluginName === 'a')).toBe(true);
+    });
+
+    it('should return empty array for plugin with no reviews', () => {
+      expect(reviews.getReviews('nonexistent')).toEqual([]);
+    });
+  });
+
+  describe('getAverageRating', () => {
+    it('should compute average excluding flagged reviews', () => {
+      const r1 = reviews.addReview({ pluginName: 'test', pluginVersion: '1.0.0', userId: 'u1', rating: 5, comment: 'a' });
+      reviews.addReview({ pluginName: 'test', pluginVersion: '1.0.0', userId: 'u2', rating: 3, comment: 'b' });
+      reviews.addReview({ pluginName: 'test', pluginVersion: '1.0.0', userId: 'u3', rating: 1, comment: 'c' });
+
+      // Average of 5, 3, 1 = 3
+      expect(reviews.getAverageRating('test')).toBe(3);
+
+      // Flag the 1-star review (r1 is the 5-star, third is 1-star with id = r1.id + 2)
+      reviews.flagReview(r1.id + 2);
+
+      // Average of 5, 3 = 4
+      expect(reviews.getAverageRating('test')).toBe(4);
+    });
+
+    it('should return 0 for plugin with no reviews', () => {
+      expect(reviews.getAverageRating('nonexistent')).toBe(0);
+    });
+
+    it('should return 0 when all reviews are flagged', () => {
+      const r = reviews.addReview({ pluginName: 'test', pluginVersion: '1.0.0', userId: 'u1', rating: 5, comment: 'a' });
+      reviews.flagReview(r.id);
+      expect(reviews.getAverageRating('test')).toBe(0);
+    });
+  });
+
+  describe('flagReview', () => {
+    it('should flag a review', () => {
+      const r = reviews.addReview({ pluginName: 'test', pluginVersion: '1.0.0', userId: 'u1', rating: 4, comment: 'nice' });
+      reviews.flagReview(r.id);
+      const flagged = reviews.getFlaggedReviews();
+      expect(flagged).toHaveLength(1);
+      expect(flagged[0].id).toBe(r.id);
+      expect(flagged[0].flagged).toBe(true);
+    });
+  });
+
+  describe('getFlaggedReviews', () => {
+    it('should return only flagged reviews', () => {
+      reviews.addReview({ pluginName: 'test', pluginVersion: '1.0.0', userId: 'u1', rating: 4, comment: 'ok' });
+      const r2 = reviews.addReview({ pluginName: 'test', pluginVersion: '1.0.0', userId: 'u2', rating: 1, comment: 'spam' });
+      reviews.flagReview(r2.id);
+
+      const flagged = reviews.getFlaggedReviews();
+      expect(flagged).toHaveLength(1);
+      expect(flagged[0].userId).toBe('u2');
+    });
+  });
+
+  describe('removeReview', () => {
+    it('should remove an existing review', () => {
+      const r = reviews.addReview({ pluginName: 'test', pluginVersion: '1.0.0', userId: 'u1', rating: 3, comment: 'ok' });
+      expect(reviews.removeReview(r.id)).toBe(true);
+      expect(reviews.getReviews('test')).toHaveLength(0);
+    });
+
+    it('should return false for non-existent review', () => {
+      expect(reviews.removeReview(99999)).toBe(false);
+    });
+  });
+
+  describe('getReviewsByUser', () => {
+    it('should return all reviews by a user', () => {
+      reviews.addReview({ pluginName: 'a', pluginVersion: '1.0.0', userId: 'alice', rating: 5, comment: 'great' });
+      reviews.addReview({ pluginName: 'b', pluginVersion: '1.0.0', userId: 'bob', rating: 3, comment: 'ok' });
+      reviews.addReview({ pluginName: 'c', pluginVersion: '1.0.0', userId: 'alice', rating: 4, comment: 'good' });
+
+      const aliceReviews = reviews.getReviewsByUser('alice');
+      expect(aliceReviews).toHaveLength(2);
+      expect(aliceReviews.every((r) => r.userId === 'alice')).toBe(true);
+    });
+  });
+
+  describe('getReviewCount', () => {
+    it('should return correct count', () => {
+      reviews.addReview({ pluginName: 'test', pluginVersion: '1.0.0', userId: 'u1', rating: 5, comment: 'a' });
+      reviews.addReview({ pluginName: 'test', pluginVersion: '1.0.0', userId: 'u2', rating: 3, comment: 'b' });
+      expect(reviews.getReviewCount('test')).toBe(2);
+    });
+
+    it('should return 0 for plugin with no reviews', () => {
+      expect(reviews.getReviewCount('nonexistent')).toBe(0);
+    });
+  });
+});
diff --git a/tests/runner.test.ts b/tests/runner.test.ts
new file mode 100644
index 0000000..cec3fc6
--- /dev/null
+++ b/tests/runner.test.ts
@@ -0,0 +1,77 @@
+import { describe, it, expect, beforeEach } from 'vitest';
+import { createRunner } from '../src/runner/index.js';
+import type { RunnerService } from '../src/types.js';
+
+describe('Sandboxed Runner', () => {
+  let runner: RunnerService;
+
+  beforeEach(() => {
+    runner = createRunner();
+  });
+
+  describe('execute', () => {
+    it('should execute simple code and return output', async () => {
+      const result = await runner.execute('return 42;');
+      expect(result.success).toBe(true);
+      expect(result.output).toBe(42);
+      expect(result.duration).toBeGreaterThanOrEqual(0);
+      expect(result.memoryUsed).toBeGreaterThanOrEqual(0);
+    });
+
+    it('should execute string-returning code', async () => {
+      const result = await runner.execute('return "hello world";');
+      expect(result.success).toBe(true);
+      expect(result.output).toBe('hello world');
+    });
+
+    it('should handle code errors gracefully', async () => {
+      const result = await runner.execute('throw new Error("boom");');
+      expect(result.success).toBe(false);
+      expect(result.error).toContain('boom');
+      expect(result.output).toBeNull();
+    });
+
+    it('should handle syntax errors', async () => {
+      const result = await runner.execute('if (');
+      expect(result.success).toBe(false);
+      expect(result.error).toBeDefined();
+    });
+
+    it('should pass context variables into sandbox', async () => {
+      const result = await runner.execute('return x + y;', { x: 10, y: 20 });
+      expect(result.success).toBe(true);
+      expect(result.output).toBe(30);
+    });
+
+    it('should isolate sandbox from host environment', async () => {
+      const result = await runner.execute('return typeof require;');
+      expect(result.success).toBe(true);
+      expect(result.output).toBe('undefined');
+    });
+
+    it('should handle object return values', async () => {
+      const result = await runner.execute('return { a: 1, b: "two" };');
+      expect(result.success).toBe(true);
+      expect(result.output).toEqual({ a: 1, b: 'two' });
+    });
+  });
+
+  describe('executeWithTimeout', () => {
+    it('should enforce timeout on infinite loops', async () => {
+      const result = await runner.executeWithTimeout('while(true) {}', 100);
+      expect(result.success).toBe(false);
+      expect(result.error).toBeDefined();
+    });
+
+    it('should succeed for fast code with generous timeout', async () => {
+      const result = await runner.executeWithTimeout('return 1 + 1;', 5000);
+      expect(result.success).toBe(true);
+      expect(result.output).toBe(2);
+    });
+
+    it('should report duration', async () => {
+      const result = await runner.executeWithTimeout('return true;', 1000);
+      expect(result.duration).toBeGreaterThanOrEqual(0);
+    });
+  });
+});
