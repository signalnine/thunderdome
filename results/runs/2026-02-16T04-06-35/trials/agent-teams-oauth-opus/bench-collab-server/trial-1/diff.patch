diff --git a/.thunderdome-metrics.json b/.thunderdome-metrics.json
new file mode 100644
index 0000000..f0761b3
--- /dev/null
+++ b/.thunderdome-metrics.json
@@ -0,0 +1,11 @@
+{
+  "input_tokens": 0,
+  "output_tokens": 0,
+  "cache_read_tokens": 0,
+  "cache_creation_tokens": 0,
+  "turns": 0,
+  "tools_used": [],
+  "duration_ms": 0,
+  "total_cost_usd": 0,
+  "note": "interactive-mode-metrics-approximate"
+}
\ No newline at end of file
diff --git a/package-lock.json b/package-lock.json
index b36b372..6f03430 100644
--- a/package-lock.json
+++ b/package-lock.json
@@ -19,12 +19,84 @@
         "@types/ws": "^8.5.0",
         "@typescript-eslint/eslint-plugin": "^7.0.0",
         "@typescript-eslint/parser": "^7.0.0",
+        "@vitest/coverage-v8": "^2.0.0",
         "eslint": "^8.56.0",
         "supertest": "^7.0.0",
         "typescript": "^5.4.0",
         "vitest": "^2.0.0"
       }
     },
+    "node_modules/@ampproject/remapping": {
+      "version": "2.3.0",
+      "resolved": "https://registry.npmjs.org/@ampproject/remapping/-/remapping-2.3.0.tgz",
+      "integrity": "sha512-30iZtAPgz+LTIYoeivqYo853f02jBYSd5uGnGpkFV0M3xOt9aN73erkgYAmZU43x4VfqcnLxW9Kpg3R5LC4YYw==",
+      "dev": true,
+      "license": "Apache-2.0",
+      "dependencies": {
+        "@jridgewell/gen-mapping": "^0.3.5",
+        "@jridgewell/trace-mapping": "^0.3.24"
+      },
+      "engines": {
+        "node": ">=6.0.0"
+      }
+    },
+    "node_modules/@babel/helper-string-parser": {
+      "version": "7.27.1",
+      "resolved": "https://registry.npmjs.org/@babel/helper-string-parser/-/helper-string-parser-7.27.1.tgz",
+      "integrity": "sha512-qMlSxKbpRlAridDExk92nSobyDdpPijUq2DW6oDnUqd0iOGxmQjyqhMIihI9+zv4LPyZdRje2cavWPbCbWm3eA==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=6.9.0"
+      }
+    },
+    "node_modules/@babel/helper-validator-identifier": {
+      "version": "7.28.5",
+      "resolved": "https://registry.npmjs.org/@babel/helper-validator-identifier/-/helper-validator-identifier-7.28.5.tgz",
+      "integrity": "sha512-qSs4ifwzKJSV39ucNjsvc6WVHs6b7S03sOh2OcHF9UHfVPqWWALUsNUVzhSBiItjRZoLHx7nIarVjqKVusUZ1Q==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=6.9.0"
+      }
+    },
+    "node_modules/@babel/parser": {
+      "version": "7.29.0",
+      "resolved": "https://registry.npmjs.org/@babel/parser/-/parser-7.29.0.tgz",
+      "integrity": "sha512-IyDgFV5GeDUVX4YdF/3CPULtVGSXXMLh1xVIgdCgxApktqnQV0r7/8Nqthg+8YLGaAtdyIlo2qIdZrbCv4+7ww==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@babel/types": "^7.29.0"
+      },
+      "bin": {
+        "parser": "bin/babel-parser.js"
+      },
+      "engines": {
+        "node": ">=6.0.0"
+      }
+    },
+    "node_modules/@babel/types": {
+      "version": "7.29.0",
+      "resolved": "https://registry.npmjs.org/@babel/types/-/types-7.29.0.tgz",
+      "integrity": "sha512-LwdZHpScM4Qz8Xw2iKSzS+cfglZzJGvofQICy7W7v4caru4EaAmyUuO6BGrbyQ2mYV11W0U8j5mBhd14dd3B0A==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@babel/helper-string-parser": "^7.27.1",
+        "@babel/helper-validator-identifier": "^7.28.5"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      }
+    },
+    "node_modules/@bcoe/v8-coverage": {
+      "version": "0.2.3",
+      "resolved": "https://registry.npmjs.org/@bcoe/v8-coverage/-/v8-coverage-0.2.3.tgz",
+      "integrity": "sha512-0hYQ8SB4Db5zvZB4axdMHGwEaQjkZzFjQiN9LVYvIFB2nSUHW9tYpxWriPrWDASIxiaXax83REcLxuSdnGPZtw==",
+      "dev": true,
+      "license": "MIT"
+    },
     "node_modules/@esbuild/aix-ppc64": {
       "version": "0.21.5",
       "resolved": "https://registry.npmjs.org/@esbuild/aix-ppc64/-/aix-ppc64-0.21.5.tgz",
@@ -565,6 +637,84 @@
       "dev": true,
       "license": "BSD-3-Clause"
     },
+    "node_modules/@isaacs/cliui": {
+      "version": "8.0.2",
+      "resolved": "https://registry.npmjs.org/@isaacs/cliui/-/cliui-8.0.2.tgz",
+      "integrity": "sha512-O8jcjabXaleOG9DQ0+ARXWZBTfnP4WNAqzuiJK7ll44AmxGKv/J2M4TPjxjY3znBCfvBXFzucm1twdyFybFqEA==",
+      "dev": true,
+      "license": "ISC",
+      "dependencies": {
+        "string-width": "^5.1.2",
+        "string-width-cjs": "npm:string-width@^4.2.0",
+        "strip-ansi": "^7.0.1",
+        "strip-ansi-cjs": "npm:strip-ansi@^6.0.1",
+        "wrap-ansi": "^8.1.0",
+        "wrap-ansi-cjs": "npm:wrap-ansi@^7.0.0"
+      },
+      "engines": {
+        "node": ">=12"
+      }
+    },
+    "node_modules/@isaacs/cliui/node_modules/ansi-regex": {
+      "version": "6.2.2",
+      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-6.2.2.tgz",
+      "integrity": "sha512-Bq3SmSpyFHaWjPk8If9yc6svM8c56dB5BAtW4Qbw5jHTwwXXcTLoRMkpDJp6VL0XzlWaCHTXrkFURMYmD0sLqg==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/ansi-regex?sponsor=1"
+      }
+    },
+    "node_modules/@isaacs/cliui/node_modules/strip-ansi": {
+      "version": "7.1.2",
+      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-7.1.2.tgz",
+      "integrity": "sha512-gmBGslpoQJtgnMAvOVqGZpEz9dyoKTCzy2nfz/n8aIFhN/jCE/rCmcxabB6jOOHV+0WNnylOxaxBQPSvcWklhA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "ansi-regex": "^6.0.1"
+      },
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/strip-ansi?sponsor=1"
+      }
+    },
+    "node_modules/@istanbuljs/schema": {
+      "version": "0.1.3",
+      "resolved": "https://registry.npmjs.org/@istanbuljs/schema/-/schema-0.1.3.tgz",
+      "integrity": "sha512-ZXRY4jNvVgSVQ8DL3LTcakaAtXwTVUxE81hslsyD2AtoXW/wVob10HkOJ1X/pAlcI7D+2YoZKg5do8G/w6RYgA==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/@jridgewell/gen-mapping": {
+      "version": "0.3.13",
+      "resolved": "https://registry.npmjs.org/@jridgewell/gen-mapping/-/gen-mapping-0.3.13.tgz",
+      "integrity": "sha512-2kkt/7niJ6MgEPxF0bYdQ6etZaA+fQvDcLKckhy1yIQOzaoKjBBjSj63/aLVjYE3qhRt5dvM+uUyfCg6UKCBbA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@jridgewell/sourcemap-codec": "^1.5.0",
+        "@jridgewell/trace-mapping": "^0.3.24"
+      }
+    },
+    "node_modules/@jridgewell/resolve-uri": {
+      "version": "3.1.2",
+      "resolved": "https://registry.npmjs.org/@jridgewell/resolve-uri/-/resolve-uri-3.1.2.tgz",
+      "integrity": "sha512-bRISgCIjP20/tbWSPWMEi54QVPRZExkuD9lJL+UIxUKtwVJA8wW1Trb1jMs1RFXo1CBTNZ/5hpC9QvmKWdopKw==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=6.0.0"
+      }
+    },
     "node_modules/@jridgewell/sourcemap-codec": {
       "version": "1.5.5",
       "resolved": "https://registry.npmjs.org/@jridgewell/sourcemap-codec/-/sourcemap-codec-1.5.5.tgz",
@@ -572,6 +722,17 @@
       "dev": true,
       "license": "MIT"
     },
+    "node_modules/@jridgewell/trace-mapping": {
+      "version": "0.3.31",
+      "resolved": "https://registry.npmjs.org/@jridgewell/trace-mapping/-/trace-mapping-0.3.31.tgz",
+      "integrity": "sha512-zzNR+SdQSDJzc8joaeP8QQoCQr8NuYx2dIIytl1QeBEZHJ9uW6hebsrYgbz8hJwUQao3TWCMtmfV8Nu1twOLAw==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@jridgewell/resolve-uri": "^3.1.0",
+        "@jridgewell/sourcemap-codec": "^1.4.14"
+      }
+    },
     "node_modules/@noble/hashes": {
       "version": "1.8.0",
       "resolved": "https://registry.npmjs.org/@noble/hashes/-/hashes-1.8.0.tgz",
@@ -633,6 +794,17 @@
         "@noble/hashes": "^1.1.5"
       }
     },
+    "node_modules/@pkgjs/parseargs": {
+      "version": "0.11.0",
+      "resolved": "https://registry.npmjs.org/@pkgjs/parseargs/-/parseargs-0.11.0.tgz",
+      "integrity": "sha512-+1VkjdD0QBLPodGrJUeqarH8VAIvQODIbwh9XpP5Syisf7YoQgsJKPNFoqqLQlu+VQ/tVSshMR6loPMn8U+dPg==",
+      "dev": true,
+      "license": "MIT",
+      "optional": true,
+      "engines": {
+        "node": ">=14"
+      }
+    },
     "node_modules/@rollup/rollup-android-arm-eabi": {
       "version": "4.57.1",
       "resolved": "https://registry.npmjs.org/@rollup/rollup-android-arm-eabi/-/rollup-android-arm-eabi-4.57.1.tgz",
@@ -1081,7 +1253,6 @@
       "integrity": "sha512-m0jEgYlYz+mDJZ2+F4v8D1AyQb+QzsNqRuI7xg1VQX/KlKS0qT9r1Mo16yo5F/MtifXFgaofIFsdFMox2SxIbQ==",
       "dev": true,
       "license": "MIT",
-      "peer": true,
       "dependencies": {
         "undici-types": "~7.16.0"
       }
@@ -1207,7 +1378,6 @@
       "integrity": "sha512-4Z+L8I2OqhZV8qA132M4wNL30ypZGYOQVBfMgxDH/K5UX0PNqTu1c6za9ST5r9+tavvHiTWmBnKzpCJ/GlVFtg==",
       "dev": true,
       "license": "BSD-2-Clause",
-      "peer": true,
       "dependencies": {
         "@typescript-eslint/scope-manager": "7.18.0",
         "@typescript-eslint/types": "7.18.0",
@@ -1368,6 +1538,39 @@
       "dev": true,
       "license": "ISC"
     },
+    "node_modules/@vitest/coverage-v8": {
+      "version": "2.1.9",
+      "resolved": "https://registry.npmjs.org/@vitest/coverage-v8/-/coverage-v8-2.1.9.tgz",
+      "integrity": "sha512-Z2cOr0ksM00MpEfyVE8KXIYPEcBFxdbLSs56L8PO0QQMxt/6bDj45uQfxoc96v05KW3clk7vvgP0qfDit9DmfQ==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@ampproject/remapping": "^2.3.0",
+        "@bcoe/v8-coverage": "^0.2.3",
+        "debug": "^4.3.7",
+        "istanbul-lib-coverage": "^3.2.2",
+        "istanbul-lib-report": "^3.0.1",
+        "istanbul-lib-source-maps": "^5.0.6",
+        "istanbul-reports": "^3.1.7",
+        "magic-string": "^0.30.12",
+        "magicast": "^0.3.5",
+        "std-env": "^3.8.0",
+        "test-exclude": "^7.0.1",
+        "tinyrainbow": "^1.2.0"
+      },
+      "funding": {
+        "url": "https://opencollective.com/vitest"
+      },
+      "peerDependencies": {
+        "@vitest/browser": "2.1.9",
+        "vitest": "2.1.9"
+      },
+      "peerDependenciesMeta": {
+        "@vitest/browser": {
+          "optional": true
+        }
+      }
+    },
     "node_modules/@vitest/expect": {
       "version": "2.1.9",
       "resolved": "https://registry.npmjs.org/@vitest/expect/-/expect-2.1.9.tgz",
@@ -1500,7 +1703,6 @@
       "integrity": "sha512-NZyJarBfL7nWwIq+FDL6Zp/yHEhePMNnnJ0y3qfieCrmNvYct8uvtiV41UvlSe6apAfk0fY1FbWx+NwfmpvtTg==",
       "dev": true,
       "license": "MIT",
-      "peer": true,
       "bin": {
         "acorn": "bin/acorn"
       },
@@ -2116,12 +2318,26 @@
         "node": ">= 0.4"
       }
     },
+    "node_modules/eastasianwidth": {
+      "version": "0.2.0",
+      "resolved": "https://registry.npmjs.org/eastasianwidth/-/eastasianwidth-0.2.0.tgz",
+      "integrity": "sha512-I88TYZWc9XiYHRQ4/3c5rjjfgkjhLyW2luGIheGERbNQ6OY7yTybanSpDXZa8y7VUP9YmDcYa+eyq4ca7iLqWA==",
+      "dev": true,
+      "license": "MIT"
+    },
     "node_modules/ee-first": {
       "version": "1.1.1",
       "resolved": "https://registry.npmjs.org/ee-first/-/ee-first-1.1.1.tgz",
       "integrity": "sha512-WMwm9LhRUo+WUaRN+vRuETqG89IgZphVSNkdFgeb6sS/E4OrDIN7t48CAewSHXc6C8lefD8KKfr5vY61brQlow==",
       "license": "MIT"
     },
+    "node_modules/emoji-regex": {
+      "version": "9.2.2",
+      "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-9.2.2.tgz",
+      "integrity": "sha512-L18DaJsXSUk2+42pv8mLs5jJT2hqFkFE4j21wOmgbUqsZ2hL72NsUU785g9RXgo3s0ZNgVl42TiHp3ZtOv/Vyg==",
+      "dev": true,
+      "license": "MIT"
+    },
     "node_modules/encodeurl": {
       "version": "2.0.0",
       "resolved": "https://registry.npmjs.org/encodeurl/-/encodeurl-2.0.0.tgz",
@@ -2258,7 +2474,6 @@
       "deprecated": "This version is no longer supported. Please see https://eslint.org/version-support for other options.",
       "dev": true,
       "license": "MIT",
-      "peer": true,
       "dependencies": {
         "@eslint-community/eslint-utils": "^4.2.0",
         "@eslint-community/regexpp": "^4.6.1",
@@ -2698,6 +2913,23 @@
       "dev": true,
       "license": "ISC"
     },
+    "node_modules/foreground-child": {
+      "version": "3.3.1",
+      "resolved": "https://registry.npmjs.org/foreground-child/-/foreground-child-3.3.1.tgz",
+      "integrity": "sha512-gIXjKqtFuWEgzFRJA9WCQeSJLZDjgJUOMCMzxtvFq/37KojM1BFGufqsCy0r4qSQmYLsZYMeyRqzIWOMup03sw==",
+      "dev": true,
+      "license": "ISC",
+      "dependencies": {
+        "cross-spawn": "^7.0.6",
+        "signal-exit": "^4.0.1"
+      },
+      "engines": {
+        "node": ">=14"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/isaacs"
+      }
+    },
     "node_modules/form-data": {
       "version": "4.0.5",
       "resolved": "https://registry.npmjs.org/form-data/-/form-data-4.0.5.tgz",
@@ -2996,6 +3228,13 @@
         "node": ">= 0.4"
       }
     },
+    "node_modules/html-escaper": {
+      "version": "2.0.2",
+      "resolved": "https://registry.npmjs.org/html-escaper/-/html-escaper-2.0.2.tgz",
+      "integrity": "sha512-H2iMtd0I4Mt5eYiapRdIDjp+XzelXQ0tFE4JS7YFwFevXXMmOp9myNrUvCg0D6ws8iqkRPBfKHgbwig1SmlLfg==",
+      "dev": true,
+      "license": "MIT"
+    },
     "node_modules/http-errors": {
       "version": "2.0.1",
       "resolved": "https://registry.npmjs.org/http-errors/-/http-errors-2.0.1.tgz",
@@ -3128,6 +3367,16 @@
         "node": ">=0.10.0"
       }
     },
+    "node_modules/is-fullwidth-code-point": {
+      "version": "3.0.0",
+      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/is-fullwidth-code-point-3.0.0.tgz",
+      "integrity": "sha512-zymm5+u+sCsSWyD9qNaejV3DFvhCKclKdizYaJUuHA83RLjb7nSuGnddCHGv0hk+KY7BMAlsWeK4Ueg6EV6XQg==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=8"
+      }
+    },
     "node_modules/is-glob": {
       "version": "4.0.3",
       "resolved": "https://registry.npmjs.org/is-glob/-/is-glob-4.0.3.tgz",
@@ -3168,6 +3417,76 @@
       "dev": true,
       "license": "ISC"
     },
+    "node_modules/istanbul-lib-coverage": {
+      "version": "3.2.2",
+      "resolved": "https://registry.npmjs.org/istanbul-lib-coverage/-/istanbul-lib-coverage-3.2.2.tgz",
+      "integrity": "sha512-O8dpsF+r0WV/8MNRKfnmrtCWhuKjxrq2w+jpzBL5UZKTi2LeVWnWOmWRxFlesJONmc+wLAGvKQZEOanko0LFTg==",
+      "dev": true,
+      "license": "BSD-3-Clause",
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/istanbul-lib-report": {
+      "version": "3.0.1",
+      "resolved": "https://registry.npmjs.org/istanbul-lib-report/-/istanbul-lib-report-3.0.1.tgz",
+      "integrity": "sha512-GCfE1mtsHGOELCU8e/Z7YWzpmybrx/+dSTfLrvY8qRmaY6zXTKWn6WQIjaAFw069icm6GVMNkgu0NzI4iPZUNw==",
+      "dev": true,
+      "license": "BSD-3-Clause",
+      "dependencies": {
+        "istanbul-lib-coverage": "^3.0.0",
+        "make-dir": "^4.0.0",
+        "supports-color": "^7.1.0"
+      },
+      "engines": {
+        "node": ">=10"
+      }
+    },
+    "node_modules/istanbul-lib-source-maps": {
+      "version": "5.0.6",
+      "resolved": "https://registry.npmjs.org/istanbul-lib-source-maps/-/istanbul-lib-source-maps-5.0.6.tgz",
+      "integrity": "sha512-yg2d+Em4KizZC5niWhQaIomgf5WlL4vOOjZ5xGCmF8SnPE/mDWWXgvRExdcpCgh9lLRRa1/fSYp2ymmbJ1pI+A==",
+      "dev": true,
+      "license": "BSD-3-Clause",
+      "dependencies": {
+        "@jridgewell/trace-mapping": "^0.3.23",
+        "debug": "^4.1.1",
+        "istanbul-lib-coverage": "^3.0.0"
+      },
+      "engines": {
+        "node": ">=10"
+      }
+    },
+    "node_modules/istanbul-reports": {
+      "version": "3.2.0",
+      "resolved": "https://registry.npmjs.org/istanbul-reports/-/istanbul-reports-3.2.0.tgz",
+      "integrity": "sha512-HGYWWS/ehqTV3xN10i23tkPkpH46MLCIMFNCaaKNavAXTF1RkqxawEPtnjnGZ6XKSInBKkiOA5BKS+aZiY3AvA==",
+      "dev": true,
+      "license": "BSD-3-Clause",
+      "dependencies": {
+        "html-escaper": "^2.0.0",
+        "istanbul-lib-report": "^3.0.0"
+      },
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/jackspeak": {
+      "version": "3.4.3",
+      "resolved": "https://registry.npmjs.org/jackspeak/-/jackspeak-3.4.3.tgz",
+      "integrity": "sha512-OGlZQpz2yfahA/Rd1Y8Cd9SIEsqvXkLVoSw/cgwhnhFMDbsQFeZYoJJ7bIZBS9BcamUW96asq/npPWugM+RQBw==",
+      "dev": true,
+      "license": "BlueOak-1.0.0",
+      "dependencies": {
+        "@isaacs/cliui": "^8.0.2"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/isaacs"
+      },
+      "optionalDependencies": {
+        "@pkgjs/parseargs": "^0.11.0"
+      }
+    },
     "node_modules/js-yaml": {
       "version": "4.1.1",
       "resolved": "https://registry.npmjs.org/js-yaml/-/js-yaml-4.1.1.tgz",
@@ -3256,6 +3575,13 @@
       "dev": true,
       "license": "MIT"
     },
+    "node_modules/lru-cache": {
+      "version": "10.4.3",
+      "resolved": "https://registry.npmjs.org/lru-cache/-/lru-cache-10.4.3.tgz",
+      "integrity": "sha512-JNAzZcXrCt42VGLuYz0zfAzDfAvJWW6AfYlDBQyDV5DClI2m5sAmK+OIO7s59XfsRsWHp02jAJrRadPRGTt6SQ==",
+      "dev": true,
+      "license": "ISC"
+    },
     "node_modules/magic-string": {
       "version": "0.30.21",
       "resolved": "https://registry.npmjs.org/magic-string/-/magic-string-0.30.21.tgz",
@@ -3266,6 +3592,34 @@
         "@jridgewell/sourcemap-codec": "^1.5.5"
       }
     },
+    "node_modules/magicast": {
+      "version": "0.3.5",
+      "resolved": "https://registry.npmjs.org/magicast/-/magicast-0.3.5.tgz",
+      "integrity": "sha512-L0WhttDl+2BOsybvEOLK7fW3UA0OQ0IQ2d6Zl2x/a6vVRs3bAY0ECOSHHeL5jD+SbOpOCUEi0y1DgHEn9Qn1AQ==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@babel/parser": "^7.25.4",
+        "@babel/types": "^7.25.4",
+        "source-map-js": "^1.2.0"
+      }
+    },
+    "node_modules/make-dir": {
+      "version": "4.0.0",
+      "resolved": "https://registry.npmjs.org/make-dir/-/make-dir-4.0.0.tgz",
+      "integrity": "sha512-hXdUTZYIVOt1Ex//jAQi+wTZZpUpwBj/0QsOzqegb3rGMMeJiSEu5xLHnYfBrRV4RH2+OCSOO95Is/7x1WJ4bw==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "semver": "^7.5.3"
+      },
+      "engines": {
+        "node": ">=10"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/sindresorhus"
+      }
+    },
     "node_modules/math-intrinsics": {
       "version": "1.1.0",
       "resolved": "https://registry.npmjs.org/math-intrinsics/-/math-intrinsics-1.1.0.tgz",
@@ -3396,6 +3750,16 @@
         "url": "https://github.com/sponsors/ljharb"
       }
     },
+    "node_modules/minipass": {
+      "version": "7.1.2",
+      "resolved": "https://registry.npmjs.org/minipass/-/minipass-7.1.2.tgz",
+      "integrity": "sha512-qOOzS1cBTWYF4BH8fVePDBOO9iptMnGUEZwNc/cMWnTV2nVLZ7VoNWEPHkYczZA0pdoA7dl6e7FL659nX9S2aw==",
+      "dev": true,
+      "license": "ISC",
+      "engines": {
+        "node": ">=16 || 14 >=14.17"
+      }
+    },
     "node_modules/mkdirp-classic": {
       "version": "0.5.3",
       "resolved": "https://registry.npmjs.org/mkdirp-classic/-/mkdirp-classic-0.5.3.tgz",
@@ -3544,6 +3908,13 @@
         "url": "https://github.com/sponsors/sindresorhus"
       }
     },
+    "node_modules/package-json-from-dist": {
+      "version": "1.0.1",
+      "resolved": "https://registry.npmjs.org/package-json-from-dist/-/package-json-from-dist-1.0.1.tgz",
+      "integrity": "sha512-UEZIS3/by4OC8vL3P2dTXRETpebLI2NiI5vIrjaD/5UtrkFX/tNbwjTSRAGC/+7CAo2pIcBaRgWmcBBHcsaCIw==",
+      "dev": true,
+      "license": "BlueOak-1.0.0"
+    },
     "node_modules/parent-module": {
       "version": "1.0.1",
       "resolved": "https://registry.npmjs.org/parent-module/-/parent-module-1.0.1.tgz",
@@ -3596,6 +3967,23 @@
         "node": ">=8"
       }
     },
+    "node_modules/path-scurry": {
+      "version": "1.11.1",
+      "resolved": "https://registry.npmjs.org/path-scurry/-/path-scurry-1.11.1.tgz",
+      "integrity": "sha512-Xa4Nw17FS9ApQFJ9umLiJS4orGjm7ZzwUrwamcGQuHSzDyth9boKDaycYdDcZDuqYATXw4HFXgaqWTctW/v1HA==",
+      "dev": true,
+      "license": "BlueOak-1.0.0",
+      "dependencies": {
+        "lru-cache": "^10.2.0",
+        "minipass": "^5.0.0 || ^6.0.2 || ^7.0.0"
+      },
+      "engines": {
+        "node": ">=16 || 14 >=14.18"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/isaacs"
+      }
+    },
     "node_modules/path-to-regexp": {
       "version": "0.1.12",
       "resolved": "https://registry.npmjs.org/path-to-regexp/-/path-to-regexp-0.1.12.tgz",
@@ -4152,6 +4540,19 @@
       "dev": true,
       "license": "ISC"
     },
+    "node_modules/signal-exit": {
+      "version": "4.1.0",
+      "resolved": "https://registry.npmjs.org/signal-exit/-/signal-exit-4.1.0.tgz",
+      "integrity": "sha512-bzyZ1e88w9O1iNJbKnOlvYTrWPDl46O1bG0D3XInv+9tkPrxrN8jUUTiFlDkkmKWgn1M6CfIA13SuGqOa9Korw==",
+      "dev": true,
+      "license": "ISC",
+      "engines": {
+        "node": ">=14"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/isaacs"
+      }
+    },
     "node_modules/simple-concat": {
       "version": "1.0.1",
       "resolved": "https://registry.npmjs.org/simple-concat/-/simple-concat-1.0.1.tgz",
@@ -4249,6 +4650,76 @@
         "safe-buffer": "~5.2.0"
       }
     },
+    "node_modules/string-width": {
+      "version": "5.1.2",
+      "resolved": "https://registry.npmjs.org/string-width/-/string-width-5.1.2.tgz",
+      "integrity": "sha512-HnLOCR3vjcY8beoNLtcjZ5/nxn2afmME6lhrDrebokqMap+XbeW8n9TXpPDOqdGK5qcI3oT0GKTW6wC7EMiVqA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "eastasianwidth": "^0.2.0",
+        "emoji-regex": "^9.2.2",
+        "strip-ansi": "^7.0.1"
+      },
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/sindresorhus"
+      }
+    },
+    "node_modules/string-width-cjs": {
+      "name": "string-width",
+      "version": "4.2.3",
+      "resolved": "https://registry.npmjs.org/string-width/-/string-width-4.2.3.tgz",
+      "integrity": "sha512-wKyQRQpjJ0sIp62ErSZdGsjMJWsap5oRNihHhu6G7JVO/9jIB6UyevL+tXuOqrng8j/cxKTWyWUwvSTriiZz/g==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "emoji-regex": "^8.0.0",
+        "is-fullwidth-code-point": "^3.0.0",
+        "strip-ansi": "^6.0.1"
+      },
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/string-width-cjs/node_modules/emoji-regex": {
+      "version": "8.0.0",
+      "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-8.0.0.tgz",
+      "integrity": "sha512-MSjYzcWNOA0ewAHpz0MxpYFvwg6yjy1NG3xteoqz644VCo/RPgnr1/GGt+ic3iJTzQ8Eu3TdM14SawnVUmGE6A==",
+      "dev": true,
+      "license": "MIT"
+    },
+    "node_modules/string-width/node_modules/ansi-regex": {
+      "version": "6.2.2",
+      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-6.2.2.tgz",
+      "integrity": "sha512-Bq3SmSpyFHaWjPk8If9yc6svM8c56dB5BAtW4Qbw5jHTwwXXcTLoRMkpDJp6VL0XzlWaCHTXrkFURMYmD0sLqg==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/ansi-regex?sponsor=1"
+      }
+    },
+    "node_modules/string-width/node_modules/strip-ansi": {
+      "version": "7.1.2",
+      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-7.1.2.tgz",
+      "integrity": "sha512-gmBGslpoQJtgnMAvOVqGZpEz9dyoKTCzy2nfz/n8aIFhN/jCE/rCmcxabB6jOOHV+0WNnylOxaxBQPSvcWklhA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "ansi-regex": "^6.0.1"
+      },
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/strip-ansi?sponsor=1"
+      }
+    },
     "node_modules/strip-ansi": {
       "version": "6.0.1",
       "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-6.0.1.tgz",
@@ -4262,6 +4733,20 @@
         "node": ">=8"
       }
     },
+    "node_modules/strip-ansi-cjs": {
+      "name": "strip-ansi",
+      "version": "6.0.1",
+      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-6.0.1.tgz",
+      "integrity": "sha512-Y38VPSHcqkFrCpFnQ9vuSXmquuv5oXOKpGeT6aGrr3o3Gc9AlVa6JBfUSOCnbxGGZF+/0ooI7KrPuUSztUdU5A==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "ansi-regex": "^5.0.1"
+      },
+      "engines": {
+        "node": ">=8"
+      }
+    },
     "node_modules/strip-json-comments": {
       "version": "3.1.1",
       "resolved": "https://registry.npmjs.org/strip-json-comments/-/strip-json-comments-3.1.1.tgz",
@@ -4375,6 +4860,43 @@
         "node": ">=6"
       }
     },
+    "node_modules/test-exclude": {
+      "version": "7.0.1",
+      "resolved": "https://registry.npmjs.org/test-exclude/-/test-exclude-7.0.1.tgz",
+      "integrity": "sha512-pFYqmTw68LXVjeWJMST4+borgQP2AyMNbg1BpZh9LbyhUeNkeaPF9gzfPGUAnSMV3qPYdWUwDIjjCLiSDOl7vg==",
+      "dev": true,
+      "license": "ISC",
+      "dependencies": {
+        "@istanbuljs/schema": "^0.1.2",
+        "glob": "^10.4.1",
+        "minimatch": "^9.0.4"
+      },
+      "engines": {
+        "node": ">=18"
+      }
+    },
+    "node_modules/test-exclude/node_modules/glob": {
+      "version": "10.5.0",
+      "resolved": "https://registry.npmjs.org/glob/-/glob-10.5.0.tgz",
+      "integrity": "sha512-DfXN8DfhJ7NH3Oe7cFmu3NCu1wKbkReJ8TorzSAFbSKrlNaQSKfIzqYqVY8zlbs2NLBbWpRiU52GX2PbaBVNkg==",
+      "deprecated": "Old versions of glob are not supported, and contain widely publicized security vulnerabilities, which have been fixed in the current version. Please update. Support for old versions may be purchased (at exorbitant rates) by contacting i@izs.me",
+      "dev": true,
+      "license": "ISC",
+      "dependencies": {
+        "foreground-child": "^3.1.0",
+        "jackspeak": "^3.1.2",
+        "minimatch": "^9.0.4",
+        "minipass": "^7.1.2",
+        "package-json-from-dist": "^1.0.0",
+        "path-scurry": "^1.11.1"
+      },
+      "bin": {
+        "glob": "dist/esm/bin.mjs"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/isaacs"
+      }
+    },
     "node_modules/text-table": {
       "version": "0.2.0",
       "resolved": "https://registry.npmjs.org/text-table/-/text-table-0.2.0.tgz",
@@ -4518,7 +5040,6 @@
       "integrity": "sha512-jl1vZzPDinLr9eUt3J/t7V6FgNEw9QjvBPdysz9KfQDD41fQrC2Y4vKQdiaUpFT4bXlb1RHhLpp8wtm6M5TgSw==",
       "dev": true,
       "license": "Apache-2.0",
-      "peer": true,
       "bin": {
         "tsc": "bin/tsc",
         "tsserver": "bin/tsserver"
@@ -4769,6 +5290,107 @@
         "node": ">=0.10.0"
       }
     },
+    "node_modules/wrap-ansi": {
+      "version": "8.1.0",
+      "resolved": "https://registry.npmjs.org/wrap-ansi/-/wrap-ansi-8.1.0.tgz",
+      "integrity": "sha512-si7QWI6zUMq56bESFvagtmzMdGOtoxfR+Sez11Mobfc7tm+VkUckk9bW2UeffTGVUbOksxmSw0AA2gs8g71NCQ==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "ansi-styles": "^6.1.0",
+        "string-width": "^5.0.1",
+        "strip-ansi": "^7.0.1"
+      },
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/wrap-ansi?sponsor=1"
+      }
+    },
+    "node_modules/wrap-ansi-cjs": {
+      "name": "wrap-ansi",
+      "version": "7.0.0",
+      "resolved": "https://registry.npmjs.org/wrap-ansi/-/wrap-ansi-7.0.0.tgz",
+      "integrity": "sha512-YVGIj2kamLSTxw6NsZjoBxfSwsn0ycdesmc4p+Q21c5zPuZ1pl+NfxVdxPtdHvmNVOQ6XSYG4AUtyt/Fi7D16Q==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "ansi-styles": "^4.0.0",
+        "string-width": "^4.1.0",
+        "strip-ansi": "^6.0.0"
+      },
+      "engines": {
+        "node": ">=10"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/wrap-ansi?sponsor=1"
+      }
+    },
+    "node_modules/wrap-ansi-cjs/node_modules/emoji-regex": {
+      "version": "8.0.0",
+      "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-8.0.0.tgz",
+      "integrity": "sha512-MSjYzcWNOA0ewAHpz0MxpYFvwg6yjy1NG3xteoqz644VCo/RPgnr1/GGt+ic3iJTzQ8Eu3TdM14SawnVUmGE6A==",
+      "dev": true,
+      "license": "MIT"
+    },
+    "node_modules/wrap-ansi-cjs/node_modules/string-width": {
+      "version": "4.2.3",
+      "resolved": "https://registry.npmjs.org/string-width/-/string-width-4.2.3.tgz",
+      "integrity": "sha512-wKyQRQpjJ0sIp62ErSZdGsjMJWsap5oRNihHhu6G7JVO/9jIB6UyevL+tXuOqrng8j/cxKTWyWUwvSTriiZz/g==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "emoji-regex": "^8.0.0",
+        "is-fullwidth-code-point": "^3.0.0",
+        "strip-ansi": "^6.0.1"
+      },
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/wrap-ansi/node_modules/ansi-regex": {
+      "version": "6.2.2",
+      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-6.2.2.tgz",
+      "integrity": "sha512-Bq3SmSpyFHaWjPk8If9yc6svM8c56dB5BAtW4Qbw5jHTwwXXcTLoRMkpDJp6VL0XzlWaCHTXrkFURMYmD0sLqg==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/ansi-regex?sponsor=1"
+      }
+    },
+    "node_modules/wrap-ansi/node_modules/ansi-styles": {
+      "version": "6.2.3",
+      "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-6.2.3.tgz",
+      "integrity": "sha512-4Dj6M28JB+oAH8kFkTLUo+a2jwOFkuqb3yucU0CANcRRUbxS0cP0nZYCGjcc3BNXwRIsUVmDGgzawme7zvJHvg==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/ansi-styles?sponsor=1"
+      }
+    },
+    "node_modules/wrap-ansi/node_modules/strip-ansi": {
+      "version": "7.1.2",
+      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-7.1.2.tgz",
+      "integrity": "sha512-gmBGslpoQJtgnMAvOVqGZpEz9dyoKTCzy2nfz/n8aIFhN/jCE/rCmcxabB6jOOHV+0WNnylOxaxBQPSvcWklhA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "ansi-regex": "^6.0.1"
+      },
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/strip-ansi?sponsor=1"
+      }
+    },
     "node_modules/wrappy": {
       "version": "1.0.2",
       "resolved": "https://registry.npmjs.org/wrappy/-/wrappy-1.0.2.tgz",
diff --git a/src/db.ts b/src/db.ts
new file mode 100644
index 0000000..ae87624
--- /dev/null
+++ b/src/db.ts
@@ -0,0 +1,136 @@
+import Database from 'better-sqlite3';
+import { randomUUID } from 'node:crypto';
+
+const SCHEMA = `
+CREATE TABLE IF NOT EXISTS documents (
+  id TEXT PRIMARY KEY,
+  title TEXT NOT NULL,
+  content TEXT NOT NULL DEFAULT '',
+  created_at TEXT NOT NULL DEFAULT (datetime('now')),
+  updated_at TEXT NOT NULL DEFAULT (datetime('now'))
+);
+
+CREATE TABLE IF NOT EXISTS versions (
+  id INTEGER PRIMARY KEY AUTOINCREMENT,
+  document_id TEXT NOT NULL REFERENCES documents(id) ON DELETE CASCADE,
+  version INTEGER NOT NULL,
+  content TEXT NOT NULL,
+  operation TEXT,
+  created_at TEXT NOT NULL DEFAULT (datetime('now')),
+  UNIQUE(document_id, version)
+);
+
+CREATE TABLE IF NOT EXISTS active_connections (
+  id TEXT PRIMARY KEY,
+  document_id TEXT NOT NULL REFERENCES documents(id) ON DELETE CASCADE,
+  connected_at TEXT NOT NULL DEFAULT (datetime('now'))
+);
+`;
+
+export interface DocumentRecord {
+  id: string;
+  title: string;
+  content: string;
+  created_at: string;
+  updated_at: string;
+}
+
+export interface VersionRecord {
+  id: number;
+  document_id: string;
+  version: number;
+  content: string;
+  operation: string | null;
+  created_at: string;
+}
+
+export class DocumentDB {
+  private db: InstanceType<typeof Database>;
+
+  constructor(filepath: string = ':memory:') {
+    this.db = new Database(filepath);
+    this.db.pragma('journal_mode = WAL');
+    this.db.pragma('foreign_keys = ON');
+    this.db.exec(SCHEMA);
+  }
+
+  createDocument(title: string, content: string = ''): DocumentRecord {
+    const id = randomUUID();
+    this.db.prepare(
+      'INSERT INTO documents (id, title, content) VALUES (?, ?, ?)'
+    ).run(id, title, content);
+
+    // Create initial version (version 0)
+    this.db.prepare(
+      'INSERT INTO versions (document_id, version, content) VALUES (?, 0, ?)'
+    ).run(id, content);
+
+    return this.getDocument(id)!;
+  }
+
+  getDocument(id: string): DocumentRecord | null {
+    return this.db.prepare(
+      'SELECT * FROM documents WHERE id = ?'
+    ).get(id) as DocumentRecord | null;
+  }
+
+  listDocuments(): DocumentRecord[] {
+    return this.db.prepare(
+      'SELECT * FROM documents ORDER BY updated_at DESC'
+    ).all() as DocumentRecord[];
+  }
+
+  updateDocument(id: string, updates: { title?: string; content?: string }): DocumentRecord | null {
+    const doc = this.getDocument(id);
+    if (!doc) return null;
+
+    const title = updates.title ?? doc.title;
+    const content = updates.content ?? doc.content;
+
+    this.db.prepare(
+      "UPDATE documents SET title = ?, content = ?, updated_at = datetime('now') WHERE id = ?"
+    ).run(title, content, id);
+
+    return this.getDocument(id)!;
+  }
+
+  deleteDocument(id: string): boolean {
+    const result = this.db.prepare('DELETE FROM documents WHERE id = ?').run(id);
+    return result.changes > 0;
+  }
+
+  getVersions(documentId: string): VersionRecord[] {
+    return this.db.prepare(
+      'SELECT * FROM versions WHERE document_id = ? ORDER BY version ASC'
+    ).all(documentId) as VersionRecord[];
+  }
+
+  getLatestVersion(documentId: string): number {
+    const row = this.db.prepare(
+      'SELECT MAX(version) as max_version FROM versions WHERE document_id = ?'
+    ).get(documentId) as { max_version: number | null };
+    return row?.max_version ?? 0;
+  }
+
+  getVersionsSince(documentId: string, sinceVersion: number): VersionRecord[] {
+    return this.db.prepare(
+      'SELECT * FROM versions WHERE document_id = ? AND version > ? ORDER BY version ASC'
+    ).all(documentId, sinceVersion) as VersionRecord[];
+  }
+
+  addVersion(documentId: string, version: number, content: string, operation: string): void {
+    this.db.prepare(
+      'INSERT INTO versions (document_id, version, content, operation) VALUES (?, ?, ?, ?)'
+    ).run(documentId, version, content, operation);
+  }
+
+  updateDocumentContent(id: string, content: string): void {
+    this.db.prepare(
+      "UPDATE documents SET content = ?, updated_at = datetime('now') WHERE id = ?"
+    ).run(content, id);
+  }
+
+  close(): void {
+    this.db.close();
+  }
+}
diff --git a/src/index.ts b/src/index.ts
new file mode 100644
index 0000000..5bfb883
--- /dev/null
+++ b/src/index.ts
@@ -0,0 +1,2 @@
+export { createApp } from './server.js';
+export type { AppInstance } from './server.js';
diff --git a/src/ot.ts b/src/ot.ts
new file mode 100644
index 0000000..107356e
--- /dev/null
+++ b/src/ot.ts
@@ -0,0 +1,173 @@
+export interface InsertOp {
+  type: 'insert';
+  position: number;
+  text: string;
+}
+
+export interface DeleteOp {
+  type: 'delete';
+  position: number;
+  count: number;
+}
+
+export type Operation = InsertOp | DeleteOp;
+
+export function validateOperation(op: unknown): Operation | null {
+  if (!op || typeof op !== 'object') return null;
+  const o = op as Record<string, unknown>;
+
+  if (o.type === 'insert') {
+    if (typeof o.position !== 'number' || o.position < 0) return null;
+    if (typeof o.text !== 'string' || o.text.length === 0) return null;
+    return { type: 'insert', position: o.position, text: o.text };
+  }
+
+  if (o.type === 'delete') {
+    if (typeof o.position !== 'number' || o.position < 0) return null;
+    if (typeof o.count !== 'number' || o.count <= 0) return null;
+    return { type: 'delete', position: o.position, count: o.count };
+  }
+
+  return null;
+}
+
+export function applyOp(doc: string, op: Operation): string {
+  if (op.type === 'insert') {
+    const pos = Math.max(0, Math.min(op.position, doc.length));
+    return doc.slice(0, pos) + op.text + doc.slice(pos);
+  } else {
+    const pos = Math.max(0, Math.min(op.position, doc.length));
+    const count = Math.max(0, Math.min(op.count, doc.length - pos));
+    if (count === 0) return doc;
+    return doc.slice(0, pos) + doc.slice(pos + count);
+  }
+}
+
+export function applyOps(doc: string, ops: Operation[]): string {
+  // Sort by position descending so non-overlapping operations
+  // don't affect each other's positions
+  const sorted = [...ops].sort((a, b) => b.position - a.position);
+  for (const op of sorted) {
+    doc = applyOp(doc, op);
+  }
+  return doc;
+}
+
+/**
+ * Transform `op` against an already-applied operation `against`.
+ * Returns the transformed operation(s).
+ *
+ * `opHasPriority`: when true, `op` wins tie-breaks at equal insert positions
+ * (i.e., `op` stays in place). When false (default), `against` wins and `op` shifts.
+ * For server-side OT, use false (the already-applied server op has priority).
+ * For TP1 convergence, call with (op1, op2, true) and (op2, op1, false).
+ */
+export function transformOp(op: Operation, against: Operation, opHasPriority = false): Operation[] {
+  if (op.type === 'insert' && against.type === 'insert') {
+    return transformInsertInsert(op, against, opHasPriority);
+  }
+  if (op.type === 'insert' && against.type === 'delete') {
+    return transformInsertDelete(op, against);
+  }
+  if (op.type === 'delete' && against.type === 'insert') {
+    return transformDeleteInsert(op, against);
+  }
+  return transformDeleteDelete(op as DeleteOp, against as DeleteOp);
+}
+
+function transformInsertInsert(op: InsertOp, against: InsertOp, opHasPriority: boolean): InsertOp[] {
+  if (op.position < against.position || (op.position === against.position && opHasPriority)) {
+    return [{ type: 'insert', position: op.position, text: op.text }];
+  }
+  return [{ type: 'insert', position: op.position + against.text.length, text: op.text }];
+}
+
+function transformInsertDelete(op: InsertOp, against: DeleteOp): InsertOp[] {
+  if (op.position <= against.position) {
+    return [{ type: 'insert', position: op.position, text: op.text }];
+  }
+  if (op.position >= against.position + against.count) {
+    return [{ type: 'insert', position: op.position - against.count, text: op.text }];
+  }
+  // Insert was inside the deleted range; place at the delete start
+  return [{ type: 'insert', position: against.position, text: op.text }];
+}
+
+function transformDeleteInsert(op: DeleteOp, against: InsertOp): DeleteOp[] {
+  const L = against.text.length;
+
+  // Delete entirely before the insert
+  if (op.position + op.count <= against.position) {
+    return [{ type: 'delete', position: op.position, count: op.count }];
+  }
+
+  // Delete entirely at/after the insert
+  if (op.position >= against.position) {
+    return [{ type: 'delete', position: op.position + L, count: op.count }];
+  }
+
+  // Delete spans the insert point: split into two non-contiguous deletes
+  // (preserving the inserted text between them)
+  const beforeCount = against.position - op.position;
+  const afterCount = op.count - beforeCount;
+  const result: DeleteOp[] = [];
+
+  // Higher-position delete first (for correct sequential application)
+  if (afterCount > 0) {
+    result.push({ type: 'delete', position: against.position + L, count: afterCount });
+  }
+  if (beforeCount > 0) {
+    result.push({ type: 'delete', position: op.position, count: beforeCount });
+  }
+  return result;
+}
+
+function transformDeleteDelete(op: DeleteOp, against: DeleteOp): DeleteOp[] {
+  const opEnd = op.position + op.count;
+  const againstEnd = against.position + against.count;
+
+  // No overlap: op entirely before against
+  if (opEnd <= against.position) {
+    return [{ type: 'delete', position: op.position, count: op.count }];
+  }
+
+  // No overlap: op entirely after against
+  if (op.position >= againstEnd) {
+    return [{ type: 'delete', position: op.position - against.count, count: op.count }];
+  }
+
+  // Op entirely inside against (already deleted)
+  if (op.position >= against.position && opEnd <= againstEnd) {
+    return [];
+  }
+
+  // Against entirely inside op
+  if (op.position <= against.position && opEnd >= againstEnd) {
+    return [{ type: 'delete', position: op.position, count: op.count - against.count }];
+  }
+
+  // Partial overlap: op starts before against
+  if (op.position < against.position) {
+    return [{ type: 'delete', position: op.position, count: against.position - op.position }];
+  }
+
+  // Partial overlap: op starts inside against, extends beyond
+  return [{ type: 'delete', position: against.position, count: opEnd - againstEnd }];
+}
+
+/**
+ * Transform a list of operations against a sequence of already-applied operations.
+ * Each op in `ops` is transformed independently against each op in `againstOps`.
+ * `opHasPriority` controls tie-breaking at equal insert positions (default: false).
+ */
+export function transformOpsAgainstOps(ops: Operation[], againstOps: Operation[], opHasPriority = false): Operation[] {
+  let current = ops;
+  for (const against of againstOps) {
+    const next: Operation[] = [];
+    for (const op of current) {
+      next.push(...transformOp(op, against, opHasPriority));
+    }
+    current = next;
+  }
+  return current;
+}
diff --git a/src/routes.ts b/src/routes.ts
new file mode 100644
index 0000000..bb138ed
--- /dev/null
+++ b/src/routes.ts
@@ -0,0 +1,91 @@
+import { Router } from 'express';
+import type { Request, Response } from 'express';
+import { DocumentDB } from './db.js';
+
+export function createRouter(db: DocumentDB): Router {
+  const router = Router();
+
+  // Create document
+  router.post('/documents', (req: Request, res: Response) => {
+    const { title, content } = req.body;
+    if (!title || typeof title !== 'string') {
+      res.status(400).json({ error: 'Title is required and must be a string' });
+      return;
+    }
+    const doc = db.createDocument(title.trim(), typeof content === 'string' ? content : '');
+    res.status(201).json(doc);
+  });
+
+  // List documents
+  router.get('/documents', (_req: Request, res: Response) => {
+    const docs = db.listDocuments();
+    res.json(docs);
+  });
+
+  // Get document
+  router.get('/documents/:id', (req: Request, res: Response) => {
+    const doc = db.getDocument(req.params.id);
+    if (!doc) {
+      res.status(404).json({ error: 'Document not found' });
+      return;
+    }
+    res.json(doc);
+  });
+
+  // Update document
+  router.put('/documents/:id', (req: Request, res: Response) => {
+    const { title, content } = req.body;
+    if (title !== undefined && typeof title !== 'string') {
+      res.status(400).json({ error: 'Title must be a string' });
+      return;
+    }
+    const updates: { title?: string; content?: string } = {};
+    if (typeof title === 'string') updates.title = title.trim();
+    if (typeof content === 'string') updates.content = content;
+
+    const doc = db.updateDocument(req.params.id, updates);
+    if (!doc) {
+      res.status(404).json({ error: 'Document not found' });
+      return;
+    }
+    res.json(doc);
+  });
+
+  // Partial update document
+  router.patch('/documents/:id', (req: Request, res: Response) => {
+    const { title, content } = req.body;
+    const updates: { title?: string; content?: string } = {};
+    if (typeof title === 'string') updates.title = title.trim();
+    if (typeof content === 'string') updates.content = content;
+
+    const doc = db.updateDocument(req.params.id, updates);
+    if (!doc) {
+      res.status(404).json({ error: 'Document not found' });
+      return;
+    }
+    res.json(doc);
+  });
+
+  // Delete document
+  router.delete('/documents/:id', (req: Request, res: Response) => {
+    const deleted = db.deleteDocument(req.params.id);
+    if (!deleted) {
+      res.status(404).json({ error: 'Document not found' });
+      return;
+    }
+    res.status(204).send();
+  });
+
+  // Get version history
+  router.get('/documents/:id/versions', (req: Request, res: Response) => {
+    const doc = db.getDocument(req.params.id);
+    if (!doc) {
+      res.status(404).json({ error: 'Document not found' });
+      return;
+    }
+    const versions = db.getVersions(req.params.id);
+    res.json(versions);
+  });
+
+  return router;
+}
diff --git a/src/server.ts b/src/server.ts
new file mode 100644
index 0000000..0c81f75
--- /dev/null
+++ b/src/server.ts
@@ -0,0 +1,61 @@
+import express from 'express';
+import { createServer } from 'node:http';
+import type { Server } from 'node:http';
+import { DocumentDB } from './db.js';
+import { createRouter } from './routes.js';
+import { CollaborationServer } from './ws.js';
+
+export interface AppInstance {
+  app: express.Express;
+  start(port?: number): Promise<number>;
+  stop(): Promise<void>;
+}
+
+export function createApp(dbPath?: string): AppInstance {
+  const db = new DocumentDB(dbPath || ':memory:');
+  const app = express();
+
+  app.use(express.json());
+
+  const router = createRouter(db);
+  // Mount routes at both /api and root to support different conventions
+  app.use('/api', router);
+  app.use('/', router);
+
+  let httpServer: Server | null = null;
+  let collabServer: CollaborationServer | null = null;
+
+  return {
+    app,
+
+    async start(port?: number): Promise<number> {
+      httpServer = createServer(app);
+      collabServer = new CollaborationServer(httpServer, db);
+
+      return new Promise((resolve) => {
+        httpServer!.listen(port ?? 0, () => {
+          const addr = httpServer!.address();
+          const actualPort = typeof addr === 'object' && addr ? addr.port : 0;
+          resolve(actualPort);
+        });
+      });
+    },
+
+    async stop(): Promise<void> {
+      if (collabServer) {
+        collabServer.closeAll();
+        collabServer = null;
+      }
+      if (httpServer) {
+        await new Promise<void>((resolve, reject) => {
+          httpServer!.close((err) => {
+            if (err) reject(err);
+            else resolve();
+          });
+        });
+        httpServer = null;
+      }
+      db.close();
+    },
+  };
+}
diff --git a/src/ws.ts b/src/ws.ts
new file mode 100644
index 0000000..be7266d
--- /dev/null
+++ b/src/ws.ts
@@ -0,0 +1,218 @@
+import { WebSocketServer, WebSocket } from 'ws';
+import type { Server } from 'node:http';
+import type { Duplex } from 'node:stream';
+import { randomUUID } from 'node:crypto';
+import { DocumentDB } from './db.js';
+import { Operation, validateOperation, applyOps, transformOpsAgainstOps } from './ot.js';
+
+interface ClientConnection {
+  ws: WebSocket;
+  clientId: string;
+  documentId: string;
+}
+
+interface DocumentRoom {
+  clients: Map<string, ClientConnection>;
+}
+
+export class CollaborationServer {
+  private wss: WebSocketServer;
+  private rooms: Map<string, DocumentRoom> = new Map();
+  private db: DocumentDB;
+
+  constructor(server: Server, db: DocumentDB) {
+    this.db = db;
+    this.wss = new WebSocketServer({ noServer: true });
+
+    server.on('upgrade', (request, socket: Duplex, head: Buffer) => {
+      const url = new URL(request.url || '/', `http://${request.headers.host || 'localhost'}`);
+      const pathname = url.pathname;
+
+      // Support multiple WebSocket path patterns:
+      // /ws/:documentId, /ws/documents/:documentId, /documents/:documentId/ws
+      let documentId: string | null = null;
+      const patterns = [
+        /^\/ws\/documents\/([^/]+)$/,
+        /^\/ws\/([^/]+)$/,
+        /^\/documents\/([^/]+)\/ws$/,
+        /^\/api\/documents\/([^/]+)\/ws$/,
+      ];
+      for (const pattern of patterns) {
+        const match = pathname.match(pattern);
+        if (match) {
+          documentId = match[1];
+          break;
+        }
+      }
+
+      if (documentId) {
+        this.wss.handleUpgrade(request, socket, head, (ws) => {
+          this.handleConnection(ws, documentId!);
+        });
+      } else {
+        socket.destroy();
+      }
+    });
+  }
+
+  private handleConnection(ws: WebSocket, documentId: string): void {
+    const doc = this.db.getDocument(documentId);
+    if (!doc) {
+      ws.close(4004, 'Document not found');
+      return;
+    }
+
+    const clientId = randomUUID();
+    const conn: ClientConnection = { ws, clientId, documentId };
+
+    // Add to room
+    if (!this.rooms.has(documentId)) {
+      this.rooms.set(documentId, { clients: new Map() });
+    }
+    const room = this.rooms.get(documentId)!;
+    room.clients.set(clientId, conn);
+
+    // Send sync message with current document state
+    const version = this.db.getLatestVersion(documentId);
+    ws.send(JSON.stringify({
+      type: 'sync',
+      document: { id: doc.id, title: doc.title, content: doc.content },
+      content: doc.content,
+      version,
+      clientId,
+    }));
+
+    ws.on('message', (data) => {
+      try {
+        const msg = JSON.parse(data.toString());
+        this.handleMessage(conn, msg);
+      } catch (_e) {
+        ws.send(JSON.stringify({ type: 'error', message: 'Invalid message format' }));
+      }
+    });
+
+    ws.on('close', () => {
+      room.clients.delete(clientId);
+      if (room.clients.size === 0) {
+        this.rooms.delete(documentId);
+      }
+    });
+
+    ws.on('error', () => {
+      room.clients.delete(clientId);
+      if (room.clients.size === 0) {
+        this.rooms.delete(documentId);
+      }
+    });
+  }
+
+  private handleMessage(conn: ClientConnection, msg: Record<string, unknown>): void {
+    if (msg.type !== 'op' && msg.type !== 'operation') {
+      conn.ws.send(JSON.stringify({ type: 'error', message: `Unknown message type: ${String(msg.type)}` }));
+      return;
+    }
+
+    const rawOp = msg.op ?? msg.operation;
+    const clientVersion = msg.version;
+
+    if (typeof clientVersion !== 'number' || clientVersion < 0) {
+      conn.ws.send(JSON.stringify({ type: 'error', message: 'Version must be a non-negative number' }));
+      return;
+    }
+
+    const validated = validateOperation(rawOp);
+    if (!validated) {
+      conn.ws.send(JSON.stringify({ type: 'error', message: 'Invalid operation' }));
+      return;
+    }
+
+    // Reload document content from DB for consistency
+    const doc = this.db.getDocument(conn.documentId);
+    if (!doc) {
+      conn.ws.send(JSON.stringify({ type: 'error', message: 'Document no longer exists' }));
+      return;
+    }
+
+    // Get all operations applied since the client's version
+    const versionsSince = this.db.getVersionsSince(conn.documentId, clientVersion);
+
+    // Collect server operations to transform against
+    const serverOps: Operation[] = [];
+    for (const v of versionsSince) {
+      if (v.operation) {
+        try {
+          const ops = JSON.parse(v.operation) as Operation[];
+          serverOps.push(...ops);
+        } catch (_e) {
+          // Skip malformed stored operations
+        }
+      }
+    }
+
+    // Transform the client operation against all server ops
+    let transformedOps: Operation[];
+    try {
+      transformedOps = transformOpsAgainstOps([validated], serverOps);
+    } catch (_e) {
+      conn.ws.send(JSON.stringify({ type: 'error', message: 'Transform failed' }));
+      return;
+    }
+
+    // If transform resulted in no-ops, acknowledge without creating a new version
+    if (transformedOps.length === 0) {
+      const currentVersion = this.db.getLatestVersion(conn.documentId);
+      conn.ws.send(JSON.stringify({ type: 'ack', version: currentVersion }));
+      return;
+    }
+
+    // Apply transformed ops to the current document content
+    let content = doc.content;
+    try {
+      content = applyOps(content, transformedOps);
+    } catch (_e) {
+      conn.ws.send(JSON.stringify({ type: 'error', message: 'Failed to apply operation' }));
+      return;
+    }
+
+    // Persist new version
+    const currentVersion = this.db.getLatestVersion(conn.documentId);
+    const newVersion = currentVersion + 1;
+    this.db.addVersion(conn.documentId, newVersion, content, JSON.stringify(transformedOps));
+    this.db.updateDocumentContent(conn.documentId, content);
+
+    // Acknowledge to sender
+    conn.ws.send(JSON.stringify({ type: 'ack', version: newVersion }));
+
+    // Broadcast to other clients in the room
+    const room = this.rooms.get(conn.documentId);
+    if (room) {
+      const broadcastData: Record<string, unknown> = {
+        type: 'op',
+        ops: transformedOps,
+        version: newVersion,
+        clientId: conn.clientId,
+      };
+      // Also include singular operation field for clients expecting a single op
+      if (transformedOps.length === 1) {
+        broadcastData.op = transformedOps[0];
+        broadcastData.operation = transformedOps[0];
+      }
+      const broadcast = JSON.stringify(broadcastData);
+      for (const [id, client] of room.clients) {
+        if (id !== conn.clientId && client.ws.readyState === WebSocket.OPEN) {
+          client.ws.send(broadcast);
+        }
+      }
+    }
+  }
+
+  closeAll(): void {
+    for (const [, room] of this.rooms) {
+      for (const [, client] of room.clients) {
+        client.ws.close(1001, 'Server shutting down');
+      }
+    }
+    this.rooms.clear();
+    this.wss.close();
+  }
+}
diff --git a/tests/ot.test.ts b/tests/ot.test.ts
new file mode 100644
index 0000000..8e7409d
--- /dev/null
+++ b/tests/ot.test.ts
@@ -0,0 +1,242 @@
+import { describe, it, expect } from 'vitest';
+import {
+  validateOperation,
+  applyOp,
+  applyOps,
+  transformOp,
+  transformOpsAgainstOps,
+  Operation,
+} from '../src/ot.js';
+
+describe('validateOperation', () => {
+  it('validates insert operations', () => {
+    expect(validateOperation({ type: 'insert', position: 0, text: 'hi' })).toEqual({
+      type: 'insert', position: 0, text: 'hi',
+    });
+  });
+
+  it('validates delete operations', () => {
+    expect(validateOperation({ type: 'delete', position: 2, count: 3 })).toEqual({
+      type: 'delete', position: 2, count: 3,
+    });
+  });
+
+  it('rejects invalid operations', () => {
+    expect(validateOperation(null)).toBeNull();
+    expect(validateOperation({})).toBeNull();
+    expect(validateOperation({ type: 'insert', position: -1, text: 'hi' })).toBeNull();
+    expect(validateOperation({ type: 'insert', position: 0, text: '' })).toBeNull();
+    expect(validateOperation({ type: 'delete', position: 0, count: 0 })).toBeNull();
+    expect(validateOperation({ type: 'delete', position: -1, count: 1 })).toBeNull();
+    expect(validateOperation({ type: 'unknown' })).toBeNull();
+  });
+});
+
+describe('applyOp', () => {
+  it('inserts text at a position', () => {
+    expect(applyOp('hello', { type: 'insert', position: 5, text: ' world' })).toBe('hello world');
+    expect(applyOp('hello', { type: 'insert', position: 0, text: 'say ' })).toBe('say hello');
+    expect(applyOp('helo', { type: 'insert', position: 3, text: 'l' })).toBe('hello');
+  });
+
+  it('deletes text at a position', () => {
+    expect(applyOp('hello world', { type: 'delete', position: 5, count: 6 })).toBe('hello');
+    expect(applyOp('hello', { type: 'delete', position: 0, count: 2 })).toBe('llo');
+  });
+
+  it('clamps positions to valid range', () => {
+    expect(applyOp('abc', { type: 'insert', position: 100, text: 'd' })).toBe('abcd');
+    expect(applyOp('abc', { type: 'delete', position: 2, count: 100 })).toBe('ab');
+  });
+});
+
+describe('transformOp', () => {
+  describe('insert vs insert', () => {
+    it('preserves both inserts when at different positions', () => {
+      const doc = 'hello';
+      const op1: Operation = { type: 'insert', position: 1, text: 'A' };
+      const op2: Operation = { type: 'insert', position: 4, text: 'B' };
+
+      // Apply op2, then transform op1 against op2
+      const docAfterOp2 = applyOp(doc, op2);
+      const op1Transformed = transformOp(op1, op2);
+      const result1 = applyOps(docAfterOp2, op1Transformed);
+
+      // Apply op1, then transform op2 against op1
+      const docAfterOp1 = applyOp(doc, op1);
+      const op2Transformed = transformOp(op2, op1);
+      const result2 = applyOps(docAfterOp1, op2Transformed);
+
+      expect(result1).toBe(result2);
+      expect(result1).toContain('A');
+      expect(result1).toContain('B');
+    });
+
+    it('handles inserts at the same position (TP1 convergence)', () => {
+      const doc = 'hello';
+      const op1: Operation = { type: 'insert', position: 2, text: 'A' };
+      const op2: Operation = { type: 'insert', position: 2, text: 'B' };
+
+      // TP1: apply(apply(doc, op1), transform(op2, op1, false))
+      //     == apply(apply(doc, op2), transform(op1, op2, true))
+      const docAfterOp1 = applyOp(doc, op1);
+      const op2t = transformOp(op2, op1, false); // op1 has priority (applied first)
+      const result1 = applyOps(docAfterOp1, op2t);
+
+      const docAfterOp2 = applyOp(doc, op2);
+      const op1t = transformOp(op1, op2, true); // op1 has priority
+      const result2 = applyOps(docAfterOp2, op1t);
+
+      expect(result1).toBe(result2);
+      expect(result1).toContain('A');
+      expect(result1).toContain('B');
+    });
+
+    it('handles inserts at the same position (server-side)', () => {
+      const doc = 'hello';
+      // Server applies op1 first, then transforms op2 against it
+      const serverOp: Operation = { type: 'insert', position: 2, text: 'A' };
+      const clientOp: Operation = { type: 'insert', position: 2, text: 'B' };
+
+      const docAfterServer = applyOp(doc, serverOp); // "heAllo"
+      const clientTransformed = transformOp(clientOp, serverOp); // default: serverOp has priority
+      const result = applyOps(docAfterServer, clientTransformed);
+
+      expect(result).toContain('A');
+      expect(result).toContain('B');
+      expect(result).toBe('heABllo');
+    });
+  });
+
+  describe('insert vs delete', () => {
+    it('adjusts insert position when delete is before', () => {
+      const doc = 'abcdef';
+      const ins: Operation = { type: 'insert', position: 4, text: 'X' };
+      const del: Operation = { type: 'delete', position: 1, count: 2 };
+
+      const transformed = transformOp(ins, del);
+      expect(transformed).toHaveLength(1);
+      expect(transformed[0]).toEqual({ type: 'insert', position: 2, text: 'X' });
+
+      // Verify convergence
+      const docAfterDel = applyOp(doc, del);
+      const result1 = applyOps(docAfterDel, transformed);
+
+      const docAfterIns = applyOp(doc, ins);
+      const delT = transformOp(del, ins);
+      const result2 = applyOps(docAfterIns, delT);
+
+      expect(result1).toBe(result2);
+    });
+
+    it('preserves insert when inside deleted range', () => {
+      const doc = 'abcdef';
+      const ins: Operation = { type: 'insert', position: 3, text: 'X' };
+      const del: Operation = { type: 'delete', position: 1, count: 4 };
+
+      const transformed = transformOp(ins, del);
+      expect(transformed).toHaveLength(1);
+      // Insert should be placed at the delete position
+      expect(transformed[0]).toEqual({ type: 'insert', position: 1, text: 'X' });
+    });
+  });
+
+  describe('delete vs insert', () => {
+    it('adjusts delete when insert is before', () => {
+      const doc = 'abcdef';
+      const del: Operation = { type: 'delete', position: 3, count: 2 };
+      const ins: Operation = { type: 'insert', position: 1, text: 'XY' };
+
+      const transformed = transformOp(del, ins);
+      expect(transformed).toHaveLength(1);
+      expect(transformed[0]).toEqual({ type: 'delete', position: 5, count: 2 });
+    });
+
+    it('splits delete when insert is inside delete range', () => {
+      const doc = 'ABCDEFGH';
+      const del: Operation = { type: 'delete', position: 1, count: 5 };
+      const ins: Operation = { type: 'insert', position: 3, text: 'XY' };
+
+      const transformed = transformOp(del, ins);
+      // Should produce two deletes preserving the inserted text
+      expect(transformed.length).toBe(2);
+
+      // Apply: insert first, then transformed deletes
+      const docAfterIns = applyOp(doc, ins); // "ABCXYDEFGH"
+      const result = applyOps(docAfterIns, transformed);
+      // Should remove B,C,D,E,F but keep XY
+      expect(result).toBe('AXYGH');
+    });
+  });
+
+  describe('delete vs delete', () => {
+    it('handles non-overlapping deletes', () => {
+      const doc = 'abcdefgh';
+      const del1: Operation = { type: 'delete', position: 1, count: 2 };
+      const del2: Operation = { type: 'delete', position: 5, count: 2 };
+
+      const del1t = transformOp(del1, del2);
+      const del2t = transformOp(del2, del1);
+
+      const docAfterDel2 = applyOp(doc, del2);
+      const result1 = applyOps(docAfterDel2, del1t);
+
+      const docAfterDel1 = applyOp(doc, del1);
+      const result2 = applyOps(docAfterDel1, del2t);
+
+      expect(result1).toBe(result2);
+    });
+
+    it('handles fully overlapping deletes', () => {
+      const doc = 'abcdef';
+      const del1: Operation = { type: 'delete', position: 1, count: 3 };
+      const del2: Operation = { type: 'delete', position: 1, count: 3 };
+
+      const transformed = transformOp(del1, del2);
+      expect(transformed).toHaveLength(0); // Already deleted
+    });
+
+    it('handles partially overlapping deletes', () => {
+      const doc = 'abcdefgh';
+      const del1: Operation = { type: 'delete', position: 1, count: 4 };
+      const del2: Operation = { type: 'delete', position: 3, count: 4 };
+
+      const del1t = transformOp(del1, del2);
+      const del2t = transformOp(del2, del1);
+
+      const docAfterDel2 = applyOp(doc, del2);
+      const result1 = applyOps(docAfterDel2, del1t);
+
+      const docAfterDel1 = applyOp(doc, del1);
+      const result2 = applyOps(docAfterDel1, del2t);
+
+      expect(result1).toBe(result2);
+    });
+  });
+});
+
+describe('transformOpsAgainstOps', () => {
+  it('transforms through a chain of operations', () => {
+    const doc = 'hello world';
+    const clientOp: Operation = { type: 'insert', position: 5, text: '!' };
+
+    const serverOps: Operation[] = [
+      { type: 'insert', position: 0, text: 'Say: ' },
+      { type: 'insert', position: 16, text: '.' },
+    ];
+
+    const transformed = transformOpsAgainstOps([clientOp], serverOps);
+
+    // Apply server ops to doc
+    let serverDoc = doc;
+    for (const op of serverOps) {
+      serverDoc = applyOp(serverDoc, op);
+    }
+
+    // Apply transformed client ops
+    const result = applyOps(serverDoc, transformed);
+
+    // The ! should be after "hello" in the final doc
+    expect(result).toContain('hello!');
+  });
+});
diff --git a/tests/server.test.ts b/tests/server.test.ts
new file mode 100644
index 0000000..3a80651
--- /dev/null
+++ b/tests/server.test.ts
@@ -0,0 +1,478 @@
+import { describe, it, expect, beforeEach, afterEach } from 'vitest';
+import { createApp, AppInstance } from '../src/server.js';
+import WebSocket from 'ws';
+
+let server: AppInstance;
+let port: number;
+let baseUrl: string;
+
+beforeEach(async () => {
+  server = createApp();
+  port = await server.start(0);
+  baseUrl = `http://127.0.0.1:${port}`;
+});
+
+afterEach(async () => {
+  await server.stop();
+});
+
+function wsUrl(docId: string): string {
+  return `ws://127.0.0.1:${port}/ws/${docId}`;
+}
+
+function connectWs(docId: string): Promise<{ ws: WebSocket; messages: unknown[]; sync: { content: string; version: number; clientId: string } }> {
+  return new Promise((resolve, reject) => {
+    const ws = new WebSocket(wsUrl(docId));
+    const messages: unknown[] = [];
+    ws.on('message', (data) => {
+      const msg = JSON.parse(data.toString());
+      messages.push(msg);
+      if (msg.type === 'sync') {
+        resolve({ ws, messages, sync: msg });
+      }
+    });
+    ws.on('error', reject);
+    setTimeout(() => reject(new Error('WebSocket connect timeout')), 5000);
+  });
+}
+
+function waitForMessage(ws: WebSocket, predicate: (msg: Record<string, unknown>) => boolean, timeoutMs = 3000): Promise<Record<string, unknown>> {
+  return new Promise((resolve, reject) => {
+    const timeout = setTimeout(() => reject(new Error('Timeout waiting for message')), timeoutMs);
+    const handler = (data: WebSocket.RawData) => {
+      const msg = JSON.parse(data.toString());
+      if (predicate(msg)) {
+        clearTimeout(timeout);
+        ws.off('message', handler);
+        resolve(msg);
+      }
+    };
+    ws.on('message', handler);
+  });
+}
+
+describe('REST API', () => {
+  it('creates a document', async () => {
+    const res = await fetch(`${baseUrl}/api/documents`, {
+      method: 'POST',
+      headers: { 'Content-Type': 'application/json' },
+      body: JSON.stringify({ title: 'Test Doc', content: 'Hello' }),
+    });
+    expect(res.status).toBe(201);
+    const doc = await res.json();
+    expect(doc.title).toBe('Test Doc');
+    expect(doc.content).toBe('Hello');
+    expect(doc.id).toBeDefined();
+  });
+
+  it('rejects document creation without title', async () => {
+    const res = await fetch(`${baseUrl}/api/documents`, {
+      method: 'POST',
+      headers: { 'Content-Type': 'application/json' },
+      body: JSON.stringify({ content: 'Hello' }),
+    });
+    expect(res.status).toBe(400);
+  });
+
+  it('lists documents', async () => {
+    await fetch(`${baseUrl}/api/documents`, {
+      method: 'POST',
+      headers: { 'Content-Type': 'application/json' },
+      body: JSON.stringify({ title: 'Doc 1' }),
+    });
+    await fetch(`${baseUrl}/api/documents`, {
+      method: 'POST',
+      headers: { 'Content-Type': 'application/json' },
+      body: JSON.stringify({ title: 'Doc 2' }),
+    });
+
+    const res = await fetch(`${baseUrl}/api/documents`);
+    expect(res.status).toBe(200);
+    const docs = await res.json();
+    expect(docs.length).toBe(2);
+  });
+
+  it('gets a document by id', async () => {
+    const createRes = await fetch(`${baseUrl}/api/documents`, {
+      method: 'POST',
+      headers: { 'Content-Type': 'application/json' },
+      body: JSON.stringify({ title: 'My Doc', content: 'Content here' }),
+    });
+    const created = await createRes.json();
+
+    const res = await fetch(`${baseUrl}/api/documents/${created.id}`);
+    expect(res.status).toBe(200);
+    const doc = await res.json();
+    expect(doc.id).toBe(created.id);
+    expect(doc.title).toBe('My Doc');
+    expect(doc.content).toBe('Content here');
+  });
+
+  it('returns 404 for non-existent document', async () => {
+    const res = await fetch(`${baseUrl}/api/documents/nonexistent`);
+    expect(res.status).toBe(404);
+  });
+
+  it('updates a document', async () => {
+    const createRes = await fetch(`${baseUrl}/api/documents`, {
+      method: 'POST',
+      headers: { 'Content-Type': 'application/json' },
+      body: JSON.stringify({ title: 'Original', content: 'Original content' }),
+    });
+    const created = await createRes.json();
+
+    const res = await fetch(`${baseUrl}/api/documents/${created.id}`, {
+      method: 'PUT',
+      headers: { 'Content-Type': 'application/json' },
+      body: JSON.stringify({ title: 'Updated', content: 'New content' }),
+    });
+    expect(res.status).toBe(200);
+    const doc = await res.json();
+    expect(doc.title).toBe('Updated');
+    expect(doc.content).toBe('New content');
+  });
+
+  it('deletes a document', async () => {
+    const createRes = await fetch(`${baseUrl}/api/documents`, {
+      method: 'POST',
+      headers: { 'Content-Type': 'application/json' },
+      body: JSON.stringify({ title: 'To Delete' }),
+    });
+    const created = await createRes.json();
+
+    const delRes = await fetch(`${baseUrl}/api/documents/${created.id}`, { method: 'DELETE' });
+    expect(delRes.status).toBe(204);
+
+    const getRes = await fetch(`${baseUrl}/api/documents/${created.id}`);
+    expect(getRes.status).toBe(404);
+  });
+
+  it('gets version history', async () => {
+    const createRes = await fetch(`${baseUrl}/api/documents`, {
+      method: 'POST',
+      headers: { 'Content-Type': 'application/json' },
+      body: JSON.stringify({ title: 'Versioned', content: 'initial' }),
+    });
+    const created = await createRes.json();
+
+    const res = await fetch(`${baseUrl}/api/documents/${created.id}/versions`);
+    expect(res.status).toBe(200);
+    const versions = await res.json();
+    expect(versions.length).toBeGreaterThanOrEqual(1);
+    expect(versions[0].version).toBe(0);
+    expect(versions[0].content).toBe('initial');
+  });
+});
+
+describe('WebSocket collaboration', () => {
+  it('sends sync message on connect', async () => {
+    const createRes = await fetch(`${baseUrl}/api/documents`, {
+      method: 'POST',
+      headers: { 'Content-Type': 'application/json' },
+      body: JSON.stringify({ title: 'WS Doc', content: 'hello' }),
+    });
+    const doc = await createRes.json();
+
+    const { ws, sync } = await connectWs(doc.id);
+    expect(sync.type).toBe('sync');
+    expect(sync.content).toBe('hello');
+    expect(sync.version).toBe(0);
+    expect(sync.clientId).toBeDefined();
+    ws.close();
+  });
+
+  it('applies an insert operation and acknowledges', async () => {
+    const createRes = await fetch(`${baseUrl}/api/documents`, {
+      method: 'POST',
+      headers: { 'Content-Type': 'application/json' },
+      body: JSON.stringify({ title: 'Edit Doc', content: 'hello' }),
+    });
+    const doc = await createRes.json();
+
+    const { ws, sync } = await connectWs(doc.id);
+
+    const ackPromise = waitForMessage(ws, (m) => m.type === 'ack');
+
+    ws.send(JSON.stringify({
+      type: 'op',
+      op: { type: 'insert', position: 5, text: ' world' },
+      version: sync.version,
+    }));
+
+    const ack = await ackPromise;
+    expect(ack.version).toBe(1);
+
+    // Verify via REST
+    const getRes = await fetch(`${baseUrl}/api/documents/${doc.id}`);
+    const updated = await getRes.json();
+    expect(updated.content).toBe('hello world');
+
+    ws.close();
+  });
+
+  it('applies a delete operation', async () => {
+    const createRes = await fetch(`${baseUrl}/api/documents`, {
+      method: 'POST',
+      headers: { 'Content-Type': 'application/json' },
+      body: JSON.stringify({ title: 'Del Doc', content: 'hello world' }),
+    });
+    const doc = await createRes.json();
+
+    const { ws, sync } = await connectWs(doc.id);
+
+    const ackPromise = waitForMessage(ws, (m) => m.type === 'ack');
+
+    ws.send(JSON.stringify({
+      type: 'op',
+      op: { type: 'delete', position: 5, count: 6 },
+      version: sync.version,
+    }));
+
+    const ack = await ackPromise;
+    expect(ack.version).toBe(1);
+
+    const getRes = await fetch(`${baseUrl}/api/documents/${doc.id}`);
+    const updated = await getRes.json();
+    expect(updated.content).toBe('hello');
+
+    ws.close();
+  });
+
+  it('broadcasts operations to other clients', async () => {
+    const createRes = await fetch(`${baseUrl}/api/documents`, {
+      method: 'POST',
+      headers: { 'Content-Type': 'application/json' },
+      body: JSON.stringify({ title: 'Broadcast', content: 'hello' }),
+    });
+    const doc = await createRes.json();
+
+    const client1 = await connectWs(doc.id);
+    const client2 = await connectWs(doc.id);
+
+    // Client2 should receive the operation from client1
+    const broadcastPromise = waitForMessage(client2.ws, (m) => m.type === 'op');
+
+    client1.ws.send(JSON.stringify({
+      type: 'op',
+      op: { type: 'insert', position: 5, text: '!' },
+      version: client1.sync.version,
+    }));
+
+    const broadcast = await broadcastPromise;
+    expect(broadcast.type).toBe('op');
+    expect(broadcast.version).toBe(1);
+    expect(Array.isArray(broadcast.ops)).toBe(true);
+
+    client1.ws.close();
+    client2.ws.close();
+  });
+
+  it('handles concurrent inserts from two clients (convergence)', async () => {
+    const createRes = await fetch(`${baseUrl}/api/documents`, {
+      method: 'POST',
+      headers: { 'Content-Type': 'application/json' },
+      body: JSON.stringify({ title: 'Concurrent', content: 'hello' }),
+    });
+    const doc = await createRes.json();
+
+    const client1 = await connectWs(doc.id);
+    const client2 = await connectWs(doc.id);
+
+    const version = client1.sync.version;
+
+    // Both clients send concurrent inserts based on the same version
+    const ack1Promise = waitForMessage(client1.ws, (m) => m.type === 'ack');
+    client1.ws.send(JSON.stringify({
+      type: 'op',
+      op: { type: 'insert', position: 0, text: 'A' },
+      version,
+    }));
+    await ack1Promise;
+
+    const ack2Promise = waitForMessage(client2.ws, (m) => m.type === 'ack');
+    client2.ws.send(JSON.stringify({
+      type: 'op',
+      op: { type: 'insert', position: 5, text: 'B' },
+      version,
+    }));
+    await ack2Promise;
+
+    // Check document via REST - both inserts should be present
+    const getRes = await fetch(`${baseUrl}/api/documents/${doc.id}`);
+    const updated = await getRes.json();
+    expect(updated.content).toContain('A');
+    expect(updated.content).toContain('B');
+    expect(updated.content).toContain('hello');
+
+    client1.ws.close();
+    client2.ws.close();
+  });
+
+  it('rejects invalid operations gracefully', async () => {
+    const createRes = await fetch(`${baseUrl}/api/documents`, {
+      method: 'POST',
+      headers: { 'Content-Type': 'application/json' },
+      body: JSON.stringify({ title: 'Error Test', content: 'hello' }),
+    });
+    const doc = await createRes.json();
+
+    const { ws } = await connectWs(doc.id);
+
+    // Send invalid operation
+    const errorPromise = waitForMessage(ws, (m) => m.type === 'error');
+    ws.send(JSON.stringify({
+      type: 'op',
+      op: { type: 'invalid' },
+      version: 0,
+    }));
+
+    const error = await errorPromise;
+    expect(error.type).toBe('error');
+    expect(error.message).toBeDefined();
+
+    ws.close();
+  });
+
+  it('rejects malformed messages', async () => {
+    const createRes = await fetch(`${baseUrl}/api/documents`, {
+      method: 'POST',
+      headers: { 'Content-Type': 'application/json' },
+      body: JSON.stringify({ title: 'Malformed', content: '' }),
+    });
+    const doc = await createRes.json();
+
+    const { ws } = await connectWs(doc.id);
+
+    const errorPromise = waitForMessage(ws, (m) => m.type === 'error');
+    ws.send('not json at all');
+
+    const error = await errorPromise;
+    expect(error.type).toBe('error');
+
+    ws.close();
+  });
+
+  it('creates version history from WebSocket operations', async () => {
+    const createRes = await fetch(`${baseUrl}/api/documents`, {
+      method: 'POST',
+      headers: { 'Content-Type': 'application/json' },
+      body: JSON.stringify({ title: 'History', content: 'start' }),
+    });
+    const doc = await createRes.json();
+
+    const { ws, sync } = await connectWs(doc.id);
+
+    // Send two operations sequentially
+    let ack = await (async () => {
+      const p = waitForMessage(ws, (m) => m.type === 'ack');
+      ws.send(JSON.stringify({
+        type: 'op',
+        op: { type: 'insert', position: 5, text: ' middle' },
+        version: sync.version,
+      }));
+      return p;
+    })();
+
+    ack = await (async () => {
+      const p = waitForMessage(ws, (m) => m.type === 'ack');
+      ws.send(JSON.stringify({
+        type: 'op',
+        op: { type: 'insert', position: 12, text: ' end' },
+        version: ack.version as number,
+      }));
+      return p;
+    })();
+
+    // Check version history
+    const versionsRes = await fetch(`${baseUrl}/api/documents/${doc.id}/versions`);
+    const versions = await versionsRes.json();
+    expect(versions.length).toBe(3); // initial + 2 ops
+    expect(versions[0].content).toBe('start');
+    expect(versions[1].content).toBe('start middle');
+    expect(versions[2].content).toBe('start middle end');
+
+    ws.close();
+  });
+});
+
+describe('Concurrent editing with 10 clients', () => {
+  it('handles 10 concurrent clients without corruption', async () => {
+    const createRes = await fetch(`${baseUrl}/api/documents`, {
+      method: 'POST',
+      headers: { 'Content-Type': 'application/json' },
+      body: JSON.stringify({ title: 'Stress Test', content: '' }),
+    });
+    const doc = await createRes.json();
+
+    // Connect 10 clients
+    const clients = await Promise.all(
+      Array.from({ length: 10 }, () => connectWs(doc.id))
+    );
+
+    // Each client inserts a unique character
+    for (let i = 0; i < clients.length; i++) {
+      const { ws, sync } = clients[i];
+      const ackPromise = waitForMessage(ws, (m) => m.type === 'ack');
+      ws.send(JSON.stringify({
+        type: 'op',
+        op: { type: 'insert', position: 0, text: String(i) },
+        version: sync.version,
+      }));
+      await ackPromise;
+    }
+
+    // Verify all characters are present
+    const getRes = await fetch(`${baseUrl}/api/documents/${doc.id}`);
+    const updated = await getRes.json();
+
+    for (let i = 0; i < 10; i++) {
+      expect(updated.content).toContain(String(i));
+    }
+    expect(updated.content.length).toBe(10);
+
+    // Close all clients
+    clients.forEach(({ ws }) => ws.close());
+  });
+});
+
+describe('Persistence', () => {
+  it('persists documents across server restarts', async () => {
+    const dbPath = '/tmp/test-persist-' + Date.now() + '.db';
+
+    // Start first server
+    const server1 = createApp(dbPath);
+    const port1 = await server1.start(0);
+    const baseUrl1 = `http://127.0.0.1:${port1}`;
+
+    // Create a document
+    const createRes = await fetch(`${baseUrl1}/api/documents`, {
+      method: 'POST',
+      headers: { 'Content-Type': 'application/json' },
+      body: JSON.stringify({ title: 'Persist Test', content: 'persisted content' }),
+    });
+    const doc = await createRes.json();
+
+    // Stop server
+    await server1.stop();
+
+    // Start second server with the same DB
+    const server2 = createApp(dbPath);
+    const port2 = await server2.start(0);
+    const baseUrl2 = `http://127.0.0.1:${port2}`;
+
+    // Read the document
+    const getRes = await fetch(`${baseUrl2}/api/documents/${doc.id}`);
+    expect(getRes.status).toBe(200);
+    const retrieved = await getRes.json();
+    expect(retrieved.title).toBe('Persist Test');
+    expect(retrieved.content).toBe('persisted content');
+
+    await server2.stop();
+
+    // Clean up
+    const { unlinkSync } = await import('node:fs');
+    try { unlinkSync(dbPath); } catch (_e) { /* ignore */ }
+    try { unlinkSync(dbPath + '-wal'); } catch (_e) { /* ignore */ }
+    try { unlinkSync(dbPath + '-shm'); } catch (_e) { /* ignore */ }
+  });
+});
