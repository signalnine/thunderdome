diff --git a/package-lock.json b/package-lock.json
index 1d53f39..7bfdff3 100644
--- a/package-lock.json
+++ b/package-lock.json
@@ -11,11 +11,83 @@
         "@types/node": "^25.2.3",
         "@typescript-eslint/eslint-plugin": "^7.0.0",
         "@typescript-eslint/parser": "^7.0.0",
+        "@vitest/coverage-v8": "^2.0.0",
         "eslint": "^8.56.0",
         "typescript": "^5.4.0",
         "vitest": "^2.0.0"
       }
     },
+    "node_modules/@ampproject/remapping": {
+      "version": "2.3.0",
+      "resolved": "https://registry.npmjs.org/@ampproject/remapping/-/remapping-2.3.0.tgz",
+      "integrity": "sha512-30iZtAPgz+LTIYoeivqYo853f02jBYSd5uGnGpkFV0M3xOt9aN73erkgYAmZU43x4VfqcnLxW9Kpg3R5LC4YYw==",
+      "dev": true,
+      "license": "Apache-2.0",
+      "dependencies": {
+        "@jridgewell/gen-mapping": "^0.3.5",
+        "@jridgewell/trace-mapping": "^0.3.24"
+      },
+      "engines": {
+        "node": ">=6.0.0"
+      }
+    },
+    "node_modules/@babel/helper-string-parser": {
+      "version": "7.27.1",
+      "resolved": "https://registry.npmjs.org/@babel/helper-string-parser/-/helper-string-parser-7.27.1.tgz",
+      "integrity": "sha512-qMlSxKbpRlAridDExk92nSobyDdpPijUq2DW6oDnUqd0iOGxmQjyqhMIihI9+zv4LPyZdRje2cavWPbCbWm3eA==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=6.9.0"
+      }
+    },
+    "node_modules/@babel/helper-validator-identifier": {
+      "version": "7.28.5",
+      "resolved": "https://registry.npmjs.org/@babel/helper-validator-identifier/-/helper-validator-identifier-7.28.5.tgz",
+      "integrity": "sha512-qSs4ifwzKJSV39ucNjsvc6WVHs6b7S03sOh2OcHF9UHfVPqWWALUsNUVzhSBiItjRZoLHx7nIarVjqKVusUZ1Q==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=6.9.0"
+      }
+    },
+    "node_modules/@babel/parser": {
+      "version": "7.29.0",
+      "resolved": "https://registry.npmjs.org/@babel/parser/-/parser-7.29.0.tgz",
+      "integrity": "sha512-IyDgFV5GeDUVX4YdF/3CPULtVGSXXMLh1xVIgdCgxApktqnQV0r7/8Nqthg+8YLGaAtdyIlo2qIdZrbCv4+7ww==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@babel/types": "^7.29.0"
+      },
+      "bin": {
+        "parser": "bin/babel-parser.js"
+      },
+      "engines": {
+        "node": ">=6.0.0"
+      }
+    },
+    "node_modules/@babel/types": {
+      "version": "7.29.0",
+      "resolved": "https://registry.npmjs.org/@babel/types/-/types-7.29.0.tgz",
+      "integrity": "sha512-LwdZHpScM4Qz8Xw2iKSzS+cfglZzJGvofQICy7W7v4caru4EaAmyUuO6BGrbyQ2mYV11W0U8j5mBhd14dd3B0A==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@babel/helper-string-parser": "^7.27.1",
+        "@babel/helper-validator-identifier": "^7.28.5"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      }
+    },
+    "node_modules/@bcoe/v8-coverage": {
+      "version": "0.2.3",
+      "resolved": "https://registry.npmjs.org/@bcoe/v8-coverage/-/v8-coverage-0.2.3.tgz",
+      "integrity": "sha512-0hYQ8SB4Db5zvZB4axdMHGwEaQjkZzFjQiN9LVYvIFB2nSUHW9tYpxWriPrWDASIxiaXax83REcLxuSdnGPZtw==",
+      "dev": true,
+      "license": "MIT"
+    },
     "node_modules/@esbuild/aix-ppc64": {
       "version": "0.21.5",
       "resolved": "https://registry.npmjs.org/@esbuild/aix-ppc64/-/aix-ppc64-0.21.5.tgz",
@@ -556,6 +628,84 @@
       "dev": true,
       "license": "BSD-3-Clause"
     },
+    "node_modules/@isaacs/cliui": {
+      "version": "8.0.2",
+      "resolved": "https://registry.npmjs.org/@isaacs/cliui/-/cliui-8.0.2.tgz",
+      "integrity": "sha512-O8jcjabXaleOG9DQ0+ARXWZBTfnP4WNAqzuiJK7ll44AmxGKv/J2M4TPjxjY3znBCfvBXFzucm1twdyFybFqEA==",
+      "dev": true,
+      "license": "ISC",
+      "dependencies": {
+        "string-width": "^5.1.2",
+        "string-width-cjs": "npm:string-width@^4.2.0",
+        "strip-ansi": "^7.0.1",
+        "strip-ansi-cjs": "npm:strip-ansi@^6.0.1",
+        "wrap-ansi": "^8.1.0",
+        "wrap-ansi-cjs": "npm:wrap-ansi@^7.0.0"
+      },
+      "engines": {
+        "node": ">=12"
+      }
+    },
+    "node_modules/@isaacs/cliui/node_modules/ansi-regex": {
+      "version": "6.2.2",
+      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-6.2.2.tgz",
+      "integrity": "sha512-Bq3SmSpyFHaWjPk8If9yc6svM8c56dB5BAtW4Qbw5jHTwwXXcTLoRMkpDJp6VL0XzlWaCHTXrkFURMYmD0sLqg==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/ansi-regex?sponsor=1"
+      }
+    },
+    "node_modules/@isaacs/cliui/node_modules/strip-ansi": {
+      "version": "7.1.2",
+      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-7.1.2.tgz",
+      "integrity": "sha512-gmBGslpoQJtgnMAvOVqGZpEz9dyoKTCzy2nfz/n8aIFhN/jCE/rCmcxabB6jOOHV+0WNnylOxaxBQPSvcWklhA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "ansi-regex": "^6.0.1"
+      },
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/strip-ansi?sponsor=1"
+      }
+    },
+    "node_modules/@istanbuljs/schema": {
+      "version": "0.1.3",
+      "resolved": "https://registry.npmjs.org/@istanbuljs/schema/-/schema-0.1.3.tgz",
+      "integrity": "sha512-ZXRY4jNvVgSVQ8DL3LTcakaAtXwTVUxE81hslsyD2AtoXW/wVob10HkOJ1X/pAlcI7D+2YoZKg5do8G/w6RYgA==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/@jridgewell/gen-mapping": {
+      "version": "0.3.13",
+      "resolved": "https://registry.npmjs.org/@jridgewell/gen-mapping/-/gen-mapping-0.3.13.tgz",
+      "integrity": "sha512-2kkt/7niJ6MgEPxF0bYdQ6etZaA+fQvDcLKckhy1yIQOzaoKjBBjSj63/aLVjYE3qhRt5dvM+uUyfCg6UKCBbA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@jridgewell/sourcemap-codec": "^1.5.0",
+        "@jridgewell/trace-mapping": "^0.3.24"
+      }
+    },
+    "node_modules/@jridgewell/resolve-uri": {
+      "version": "3.1.2",
+      "resolved": "https://registry.npmjs.org/@jridgewell/resolve-uri/-/resolve-uri-3.1.2.tgz",
+      "integrity": "sha512-bRISgCIjP20/tbWSPWMEi54QVPRZExkuD9lJL+UIxUKtwVJA8wW1Trb1jMs1RFXo1CBTNZ/5hpC9QvmKWdopKw==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=6.0.0"
+      }
+    },
     "node_modules/@jridgewell/sourcemap-codec": {
       "version": "1.5.5",
       "resolved": "https://registry.npmjs.org/@jridgewell/sourcemap-codec/-/sourcemap-codec-1.5.5.tgz",
@@ -563,6 +713,17 @@
       "dev": true,
       "license": "MIT"
     },
+    "node_modules/@jridgewell/trace-mapping": {
+      "version": "0.3.31",
+      "resolved": "https://registry.npmjs.org/@jridgewell/trace-mapping/-/trace-mapping-0.3.31.tgz",
+      "integrity": "sha512-zzNR+SdQSDJzc8joaeP8QQoCQr8NuYx2dIIytl1QeBEZHJ9uW6hebsrYgbz8hJwUQao3TWCMtmfV8Nu1twOLAw==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@jridgewell/resolve-uri": "^3.1.0",
+        "@jridgewell/sourcemap-codec": "^1.4.14"
+      }
+    },
     "node_modules/@nodelib/fs.scandir": {
       "version": "2.1.5",
       "resolved": "https://registry.npmjs.org/@nodelib/fs.scandir/-/fs.scandir-2.1.5.tgz",
@@ -601,6 +762,17 @@
         "node": ">= 8"
       }
     },
+    "node_modules/@pkgjs/parseargs": {
+      "version": "0.11.0",
+      "resolved": "https://registry.npmjs.org/@pkgjs/parseargs/-/parseargs-0.11.0.tgz",
+      "integrity": "sha512-+1VkjdD0QBLPodGrJUeqarH8VAIvQODIbwh9XpP5Syisf7YoQgsJKPNFoqqLQlu+VQ/tVSshMR6loPMn8U+dPg==",
+      "dev": true,
+      "license": "MIT",
+      "optional": true,
+      "engines": {
+        "node": ">=14"
+      }
+    },
     "node_modules/@rollup/rollup-android-arm-eabi": {
       "version": "4.57.1",
       "resolved": "https://registry.npmjs.org/@rollup/rollup-android-arm-eabi/-/rollup-android-arm-eabi-4.57.1.tgz",
@@ -964,7 +1136,6 @@
       "integrity": "sha512-m0jEgYlYz+mDJZ2+F4v8D1AyQb+QzsNqRuI7xg1VQX/KlKS0qT9r1Mo16yo5F/MtifXFgaofIFsdFMox2SxIbQ==",
       "dev": true,
       "license": "MIT",
-      "peer": true,
       "dependencies": {
         "undici-types": "~7.16.0"
       }
@@ -1009,7 +1180,6 @@
       "integrity": "sha512-4Z+L8I2OqhZV8qA132M4wNL30ypZGYOQVBfMgxDH/K5UX0PNqTu1c6za9ST5r9+tavvHiTWmBnKzpCJ/GlVFtg==",
       "dev": true,
       "license": "BSD-2-Clause",
-      "peer": true,
       "dependencies": {
         "@typescript-eslint/scope-manager": "7.18.0",
         "@typescript-eslint/types": "7.18.0",
@@ -1170,6 +1340,39 @@
       "dev": true,
       "license": "ISC"
     },
+    "node_modules/@vitest/coverage-v8": {
+      "version": "2.1.9",
+      "resolved": "https://registry.npmjs.org/@vitest/coverage-v8/-/coverage-v8-2.1.9.tgz",
+      "integrity": "sha512-Z2cOr0ksM00MpEfyVE8KXIYPEcBFxdbLSs56L8PO0QQMxt/6bDj45uQfxoc96v05KW3clk7vvgP0qfDit9DmfQ==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@ampproject/remapping": "^2.3.0",
+        "@bcoe/v8-coverage": "^0.2.3",
+        "debug": "^4.3.7",
+        "istanbul-lib-coverage": "^3.2.2",
+        "istanbul-lib-report": "^3.0.1",
+        "istanbul-lib-source-maps": "^5.0.6",
+        "istanbul-reports": "^3.1.7",
+        "magic-string": "^0.30.12",
+        "magicast": "^0.3.5",
+        "std-env": "^3.8.0",
+        "test-exclude": "^7.0.1",
+        "tinyrainbow": "^1.2.0"
+      },
+      "funding": {
+        "url": "https://opencollective.com/vitest"
+      },
+      "peerDependencies": {
+        "@vitest/browser": "2.1.9",
+        "vitest": "2.1.9"
+      },
+      "peerDependenciesMeta": {
+        "@vitest/browser": {
+          "optional": true
+        }
+      }
+    },
     "node_modules/@vitest/expect": {
       "version": "2.1.9",
       "resolved": "https://registry.npmjs.org/@vitest/expect/-/expect-2.1.9.tgz",
@@ -1289,7 +1492,6 @@
       "integrity": "sha512-NZyJarBfL7nWwIq+FDL6Zp/yHEhePMNnnJ0y3qfieCrmNvYct8uvtiV41UvlSe6apAfk0fY1FbWx+NwfmpvtTg==",
       "dev": true,
       "license": "MIT",
-      "peer": true,
       "bin": {
         "acorn": "bin/acorn"
       },
@@ -1574,6 +1776,20 @@
         "node": ">=6.0.0"
       }
     },
+    "node_modules/eastasianwidth": {
+      "version": "0.2.0",
+      "resolved": "https://registry.npmjs.org/eastasianwidth/-/eastasianwidth-0.2.0.tgz",
+      "integrity": "sha512-I88TYZWc9XiYHRQ4/3c5rjjfgkjhLyW2luGIheGERbNQ6OY7yTybanSpDXZa8y7VUP9YmDcYa+eyq4ca7iLqWA==",
+      "dev": true,
+      "license": "MIT"
+    },
+    "node_modules/emoji-regex": {
+      "version": "9.2.2",
+      "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-9.2.2.tgz",
+      "integrity": "sha512-L18DaJsXSUk2+42pv8mLs5jJT2hqFkFE4j21wOmgbUqsZ2hL72NsUU785g9RXgo3s0ZNgVl42TiHp3ZtOv/Vyg==",
+      "dev": true,
+      "license": "MIT"
+    },
     "node_modules/es-module-lexer": {
       "version": "1.7.0",
       "resolved": "https://registry.npmjs.org/es-module-lexer/-/es-module-lexer-1.7.0.tgz",
@@ -1640,7 +1856,6 @@
       "deprecated": "This version is no longer supported. Please see https://eslint.org/version-support for other options.",
       "dev": true,
       "license": "MIT",
-      "peer": true,
       "dependencies": {
         "@eslint-community/eslint-utils": "^4.2.0",
         "@eslint-community/regexpp": "^4.6.1",
@@ -1955,6 +2170,23 @@
       "dev": true,
       "license": "ISC"
     },
+    "node_modules/foreground-child": {
+      "version": "3.3.1",
+      "resolved": "https://registry.npmjs.org/foreground-child/-/foreground-child-3.3.1.tgz",
+      "integrity": "sha512-gIXjKqtFuWEgzFRJA9WCQeSJLZDjgJUOMCMzxtvFq/37KojM1BFGufqsCy0r4qSQmYLsZYMeyRqzIWOMup03sw==",
+      "dev": true,
+      "license": "ISC",
+      "dependencies": {
+        "cross-spawn": "^7.0.6",
+        "signal-exit": "^4.0.1"
+      },
+      "engines": {
+        "node": ">=14"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/isaacs"
+      }
+    },
     "node_modules/fs.realpath": {
       "version": "1.0.0",
       "resolved": "https://registry.npmjs.org/fs.realpath/-/fs.realpath-1.0.0.tgz",
@@ -2090,6 +2322,13 @@
         "node": ">=8"
       }
     },
+    "node_modules/html-escaper": {
+      "version": "2.0.2",
+      "resolved": "https://registry.npmjs.org/html-escaper/-/html-escaper-2.0.2.tgz",
+      "integrity": "sha512-H2iMtd0I4Mt5eYiapRdIDjp+XzelXQ0tFE4JS7YFwFevXXMmOp9myNrUvCg0D6ws8iqkRPBfKHgbwig1SmlLfg==",
+      "dev": true,
+      "license": "MIT"
+    },
     "node_modules/ignore": {
       "version": "5.3.2",
       "resolved": "https://registry.npmjs.org/ignore/-/ignore-5.3.2.tgz",
@@ -2156,6 +2395,16 @@
         "node": ">=0.10.0"
       }
     },
+    "node_modules/is-fullwidth-code-point": {
+      "version": "3.0.0",
+      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/is-fullwidth-code-point-3.0.0.tgz",
+      "integrity": "sha512-zymm5+u+sCsSWyD9qNaejV3DFvhCKclKdizYaJUuHA83RLjb7nSuGnddCHGv0hk+KY7BMAlsWeK4Ueg6EV6XQg==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=8"
+      }
+    },
     "node_modules/is-glob": {
       "version": "4.0.3",
       "resolved": "https://registry.npmjs.org/is-glob/-/is-glob-4.0.3.tgz",
@@ -2196,6 +2445,76 @@
       "dev": true,
       "license": "ISC"
     },
+    "node_modules/istanbul-lib-coverage": {
+      "version": "3.2.2",
+      "resolved": "https://registry.npmjs.org/istanbul-lib-coverage/-/istanbul-lib-coverage-3.2.2.tgz",
+      "integrity": "sha512-O8dpsF+r0WV/8MNRKfnmrtCWhuKjxrq2w+jpzBL5UZKTi2LeVWnWOmWRxFlesJONmc+wLAGvKQZEOanko0LFTg==",
+      "dev": true,
+      "license": "BSD-3-Clause",
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/istanbul-lib-report": {
+      "version": "3.0.1",
+      "resolved": "https://registry.npmjs.org/istanbul-lib-report/-/istanbul-lib-report-3.0.1.tgz",
+      "integrity": "sha512-GCfE1mtsHGOELCU8e/Z7YWzpmybrx/+dSTfLrvY8qRmaY6zXTKWn6WQIjaAFw069icm6GVMNkgu0NzI4iPZUNw==",
+      "dev": true,
+      "license": "BSD-3-Clause",
+      "dependencies": {
+        "istanbul-lib-coverage": "^3.0.0",
+        "make-dir": "^4.0.0",
+        "supports-color": "^7.1.0"
+      },
+      "engines": {
+        "node": ">=10"
+      }
+    },
+    "node_modules/istanbul-lib-source-maps": {
+      "version": "5.0.6",
+      "resolved": "https://registry.npmjs.org/istanbul-lib-source-maps/-/istanbul-lib-source-maps-5.0.6.tgz",
+      "integrity": "sha512-yg2d+Em4KizZC5niWhQaIomgf5WlL4vOOjZ5xGCmF8SnPE/mDWWXgvRExdcpCgh9lLRRa1/fSYp2ymmbJ1pI+A==",
+      "dev": true,
+      "license": "BSD-3-Clause",
+      "dependencies": {
+        "@jridgewell/trace-mapping": "^0.3.23",
+        "debug": "^4.1.1",
+        "istanbul-lib-coverage": "^3.0.0"
+      },
+      "engines": {
+        "node": ">=10"
+      }
+    },
+    "node_modules/istanbul-reports": {
+      "version": "3.2.0",
+      "resolved": "https://registry.npmjs.org/istanbul-reports/-/istanbul-reports-3.2.0.tgz",
+      "integrity": "sha512-HGYWWS/ehqTV3xN10i23tkPkpH46MLCIMFNCaaKNavAXTF1RkqxawEPtnjnGZ6XKSInBKkiOA5BKS+aZiY3AvA==",
+      "dev": true,
+      "license": "BSD-3-Clause",
+      "dependencies": {
+        "html-escaper": "^2.0.0",
+        "istanbul-lib-report": "^3.0.0"
+      },
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/jackspeak": {
+      "version": "3.4.3",
+      "resolved": "https://registry.npmjs.org/jackspeak/-/jackspeak-3.4.3.tgz",
+      "integrity": "sha512-OGlZQpz2yfahA/Rd1Y8Cd9SIEsqvXkLVoSw/cgwhnhFMDbsQFeZYoJJ7bIZBS9BcamUW96asq/npPWugM+RQBw==",
+      "dev": true,
+      "license": "BlueOak-1.0.0",
+      "dependencies": {
+        "@isaacs/cliui": "^8.0.2"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/isaacs"
+      },
+      "optionalDependencies": {
+        "@pkgjs/parseargs": "^0.11.0"
+      }
+    },
     "node_modules/js-yaml": {
       "version": "4.1.1",
       "resolved": "https://registry.npmjs.org/js-yaml/-/js-yaml-4.1.1.tgz",
@@ -2284,6 +2603,13 @@
       "dev": true,
       "license": "MIT"
     },
+    "node_modules/lru-cache": {
+      "version": "10.4.3",
+      "resolved": "https://registry.npmjs.org/lru-cache/-/lru-cache-10.4.3.tgz",
+      "integrity": "sha512-JNAzZcXrCt42VGLuYz0zfAzDfAvJWW6AfYlDBQyDV5DClI2m5sAmK+OIO7s59XfsRsWHp02jAJrRadPRGTt6SQ==",
+      "dev": true,
+      "license": "ISC"
+    },
     "node_modules/magic-string": {
       "version": "0.30.21",
       "resolved": "https://registry.npmjs.org/magic-string/-/magic-string-0.30.21.tgz",
@@ -2294,6 +2620,34 @@
         "@jridgewell/sourcemap-codec": "^1.5.5"
       }
     },
+    "node_modules/magicast": {
+      "version": "0.3.5",
+      "resolved": "https://registry.npmjs.org/magicast/-/magicast-0.3.5.tgz",
+      "integrity": "sha512-L0WhttDl+2BOsybvEOLK7fW3UA0OQ0IQ2d6Zl2x/a6vVRs3bAY0ECOSHHeL5jD+SbOpOCUEi0y1DgHEn9Qn1AQ==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@babel/parser": "^7.25.4",
+        "@babel/types": "^7.25.4",
+        "source-map-js": "^1.2.0"
+      }
+    },
+    "node_modules/make-dir": {
+      "version": "4.0.0",
+      "resolved": "https://registry.npmjs.org/make-dir/-/make-dir-4.0.0.tgz",
+      "integrity": "sha512-hXdUTZYIVOt1Ex//jAQi+wTZZpUpwBj/0QsOzqegb3rGMMeJiSEu5xLHnYfBrRV4RH2+OCSOO95Is/7x1WJ4bw==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "semver": "^7.5.3"
+      },
+      "engines": {
+        "node": ">=10"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/sindresorhus"
+      }
+    },
     "node_modules/merge2": {
       "version": "1.4.1",
       "resolved": "https://registry.npmjs.org/merge2/-/merge2-1.4.1.tgz",
@@ -2334,6 +2688,16 @@
         "url": "https://github.com/sponsors/isaacs"
       }
     },
+    "node_modules/minipass": {
+      "version": "7.1.2",
+      "resolved": "https://registry.npmjs.org/minipass/-/minipass-7.1.2.tgz",
+      "integrity": "sha512-qOOzS1cBTWYF4BH8fVePDBOO9iptMnGUEZwNc/cMWnTV2nVLZ7VoNWEPHkYczZA0pdoA7dl6e7FL659nX9S2aw==",
+      "dev": true,
+      "license": "ISC",
+      "engines": {
+        "node": ">=16 || 14 >=14.17"
+      }
+    },
     "node_modules/ms": {
       "version": "2.1.3",
       "resolved": "https://registry.npmjs.org/ms/-/ms-2.1.3.tgz",
@@ -2427,6 +2791,13 @@
         "url": "https://github.com/sponsors/sindresorhus"
       }
     },
+    "node_modules/package-json-from-dist": {
+      "version": "1.0.1",
+      "resolved": "https://registry.npmjs.org/package-json-from-dist/-/package-json-from-dist-1.0.1.tgz",
+      "integrity": "sha512-UEZIS3/by4OC8vL3P2dTXRETpebLI2NiI5vIrjaD/5UtrkFX/tNbwjTSRAGC/+7CAo2pIcBaRgWmcBBHcsaCIw==",
+      "dev": true,
+      "license": "BlueOak-1.0.0"
+    },
     "node_modules/parent-module": {
       "version": "1.0.1",
       "resolved": "https://registry.npmjs.org/parent-module/-/parent-module-1.0.1.tgz",
@@ -2470,6 +2841,23 @@
         "node": ">=8"
       }
     },
+    "node_modules/path-scurry": {
+      "version": "1.11.1",
+      "resolved": "https://registry.npmjs.org/path-scurry/-/path-scurry-1.11.1.tgz",
+      "integrity": "sha512-Xa4Nw17FS9ApQFJ9umLiJS4orGjm7ZzwUrwamcGQuHSzDyth9boKDaycYdDcZDuqYATXw4HFXgaqWTctW/v1HA==",
+      "dev": true,
+      "license": "BlueOak-1.0.0",
+      "dependencies": {
+        "lru-cache": "^10.2.0",
+        "minipass": "^5.0.0 || ^6.0.2 || ^7.0.0"
+      },
+      "engines": {
+        "node": ">=16 || 14 >=14.18"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/isaacs"
+      }
+    },
     "node_modules/path-type": {
       "version": "4.0.0",
       "resolved": "https://registry.npmjs.org/path-type/-/path-type-4.0.0.tgz",
@@ -2737,6 +3125,19 @@
       "dev": true,
       "license": "ISC"
     },
+    "node_modules/signal-exit": {
+      "version": "4.1.0",
+      "resolved": "https://registry.npmjs.org/signal-exit/-/signal-exit-4.1.0.tgz",
+      "integrity": "sha512-bzyZ1e88w9O1iNJbKnOlvYTrWPDl46O1bG0D3XInv+9tkPrxrN8jUUTiFlDkkmKWgn1M6CfIA13SuGqOa9Korw==",
+      "dev": true,
+      "license": "ISC",
+      "engines": {
+        "node": ">=14"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/isaacs"
+      }
+    },
     "node_modules/slash": {
       "version": "3.0.0",
       "resolved": "https://registry.npmjs.org/slash/-/slash-3.0.0.tgz",
@@ -2771,6 +3172,76 @@
       "dev": true,
       "license": "MIT"
     },
+    "node_modules/string-width": {
+      "version": "5.1.2",
+      "resolved": "https://registry.npmjs.org/string-width/-/string-width-5.1.2.tgz",
+      "integrity": "sha512-HnLOCR3vjcY8beoNLtcjZ5/nxn2afmME6lhrDrebokqMap+XbeW8n9TXpPDOqdGK5qcI3oT0GKTW6wC7EMiVqA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "eastasianwidth": "^0.2.0",
+        "emoji-regex": "^9.2.2",
+        "strip-ansi": "^7.0.1"
+      },
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/sindresorhus"
+      }
+    },
+    "node_modules/string-width-cjs": {
+      "name": "string-width",
+      "version": "4.2.3",
+      "resolved": "https://registry.npmjs.org/string-width/-/string-width-4.2.3.tgz",
+      "integrity": "sha512-wKyQRQpjJ0sIp62ErSZdGsjMJWsap5oRNihHhu6G7JVO/9jIB6UyevL+tXuOqrng8j/cxKTWyWUwvSTriiZz/g==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "emoji-regex": "^8.0.0",
+        "is-fullwidth-code-point": "^3.0.0",
+        "strip-ansi": "^6.0.1"
+      },
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/string-width-cjs/node_modules/emoji-regex": {
+      "version": "8.0.0",
+      "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-8.0.0.tgz",
+      "integrity": "sha512-MSjYzcWNOA0ewAHpz0MxpYFvwg6yjy1NG3xteoqz644VCo/RPgnr1/GGt+ic3iJTzQ8Eu3TdM14SawnVUmGE6A==",
+      "dev": true,
+      "license": "MIT"
+    },
+    "node_modules/string-width/node_modules/ansi-regex": {
+      "version": "6.2.2",
+      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-6.2.2.tgz",
+      "integrity": "sha512-Bq3SmSpyFHaWjPk8If9yc6svM8c56dB5BAtW4Qbw5jHTwwXXcTLoRMkpDJp6VL0XzlWaCHTXrkFURMYmD0sLqg==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/ansi-regex?sponsor=1"
+      }
+    },
+    "node_modules/string-width/node_modules/strip-ansi": {
+      "version": "7.1.2",
+      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-7.1.2.tgz",
+      "integrity": "sha512-gmBGslpoQJtgnMAvOVqGZpEz9dyoKTCzy2nfz/n8aIFhN/jCE/rCmcxabB6jOOHV+0WNnylOxaxBQPSvcWklhA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "ansi-regex": "^6.0.1"
+      },
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/strip-ansi?sponsor=1"
+      }
+    },
     "node_modules/strip-ansi": {
       "version": "6.0.1",
       "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-6.0.1.tgz",
@@ -2784,6 +3255,20 @@
         "node": ">=8"
       }
     },
+    "node_modules/strip-ansi-cjs": {
+      "name": "strip-ansi",
+      "version": "6.0.1",
+      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-6.0.1.tgz",
+      "integrity": "sha512-Y38VPSHcqkFrCpFnQ9vuSXmquuv5oXOKpGeT6aGrr3o3Gc9AlVa6JBfUSOCnbxGGZF+/0ooI7KrPuUSztUdU5A==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "ansi-regex": "^5.0.1"
+      },
+      "engines": {
+        "node": ">=8"
+      }
+    },
     "node_modules/strip-json-comments": {
       "version": "3.1.1",
       "resolved": "https://registry.npmjs.org/strip-json-comments/-/strip-json-comments-3.1.1.tgz",
@@ -2810,6 +3295,43 @@
         "node": ">=8"
       }
     },
+    "node_modules/test-exclude": {
+      "version": "7.0.1",
+      "resolved": "https://registry.npmjs.org/test-exclude/-/test-exclude-7.0.1.tgz",
+      "integrity": "sha512-pFYqmTw68LXVjeWJMST4+borgQP2AyMNbg1BpZh9LbyhUeNkeaPF9gzfPGUAnSMV3qPYdWUwDIjjCLiSDOl7vg==",
+      "dev": true,
+      "license": "ISC",
+      "dependencies": {
+        "@istanbuljs/schema": "^0.1.2",
+        "glob": "^10.4.1",
+        "minimatch": "^9.0.4"
+      },
+      "engines": {
+        "node": ">=18"
+      }
+    },
+    "node_modules/test-exclude/node_modules/glob": {
+      "version": "10.5.0",
+      "resolved": "https://registry.npmjs.org/glob/-/glob-10.5.0.tgz",
+      "integrity": "sha512-DfXN8DfhJ7NH3Oe7cFmu3NCu1wKbkReJ8TorzSAFbSKrlNaQSKfIzqYqVY8zlbs2NLBbWpRiU52GX2PbaBVNkg==",
+      "deprecated": "Old versions of glob are not supported, and contain widely publicized security vulnerabilities, which have been fixed in the current version. Please update. Support for old versions may be purchased (at exorbitant rates) by contacting i@izs.me",
+      "dev": true,
+      "license": "ISC",
+      "dependencies": {
+        "foreground-child": "^3.1.0",
+        "jackspeak": "^3.1.2",
+        "minimatch": "^9.0.4",
+        "minipass": "^7.1.2",
+        "package-json-from-dist": "^1.0.0",
+        "path-scurry": "^1.11.1"
+      },
+      "bin": {
+        "glob": "dist/esm/bin.mjs"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/isaacs"
+      }
+    },
     "node_modules/text-table": {
       "version": "0.2.0",
       "resolved": "https://registry.npmjs.org/text-table/-/text-table-0.2.0.tgz",
@@ -2919,7 +3441,6 @@
       "integrity": "sha512-jl1vZzPDinLr9eUt3J/t7V6FgNEw9QjvBPdysz9KfQDD41fQrC2Y4vKQdiaUpFT4bXlb1RHhLpp8wtm6M5TgSw==",
       "dev": true,
       "license": "Apache-2.0",
-      "peer": true,
       "bin": {
         "tsc": "bin/tsc",
         "tsserver": "bin/tsserver"
@@ -2951,7 +3472,6 @@
       "integrity": "sha512-o5a9xKjbtuhY6Bi5S3+HvbRERmouabWbyUcpXXUA1u+GNUKoROi9byOJ8M0nHbHYHkYICiMlqxkg1KkYmm25Sw==",
       "dev": true,
       "license": "MIT",
-      "peer": true,
       "dependencies": {
         "esbuild": "^0.21.3",
         "postcss": "^8.4.43",
@@ -3138,6 +3658,107 @@
         "node": ">=0.10.0"
       }
     },
+    "node_modules/wrap-ansi": {
+      "version": "8.1.0",
+      "resolved": "https://registry.npmjs.org/wrap-ansi/-/wrap-ansi-8.1.0.tgz",
+      "integrity": "sha512-si7QWI6zUMq56bESFvagtmzMdGOtoxfR+Sez11Mobfc7tm+VkUckk9bW2UeffTGVUbOksxmSw0AA2gs8g71NCQ==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "ansi-styles": "^6.1.0",
+        "string-width": "^5.0.1",
+        "strip-ansi": "^7.0.1"
+      },
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/wrap-ansi?sponsor=1"
+      }
+    },
+    "node_modules/wrap-ansi-cjs": {
+      "name": "wrap-ansi",
+      "version": "7.0.0",
+      "resolved": "https://registry.npmjs.org/wrap-ansi/-/wrap-ansi-7.0.0.tgz",
+      "integrity": "sha512-YVGIj2kamLSTxw6NsZjoBxfSwsn0ycdesmc4p+Q21c5zPuZ1pl+NfxVdxPtdHvmNVOQ6XSYG4AUtyt/Fi7D16Q==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "ansi-styles": "^4.0.0",
+        "string-width": "^4.1.0",
+        "strip-ansi": "^6.0.0"
+      },
+      "engines": {
+        "node": ">=10"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/wrap-ansi?sponsor=1"
+      }
+    },
+    "node_modules/wrap-ansi-cjs/node_modules/emoji-regex": {
+      "version": "8.0.0",
+      "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-8.0.0.tgz",
+      "integrity": "sha512-MSjYzcWNOA0ewAHpz0MxpYFvwg6yjy1NG3xteoqz644VCo/RPgnr1/GGt+ic3iJTzQ8Eu3TdM14SawnVUmGE6A==",
+      "dev": true,
+      "license": "MIT"
+    },
+    "node_modules/wrap-ansi-cjs/node_modules/string-width": {
+      "version": "4.2.3",
+      "resolved": "https://registry.npmjs.org/string-width/-/string-width-4.2.3.tgz",
+      "integrity": "sha512-wKyQRQpjJ0sIp62ErSZdGsjMJWsap5oRNihHhu6G7JVO/9jIB6UyevL+tXuOqrng8j/cxKTWyWUwvSTriiZz/g==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "emoji-regex": "^8.0.0",
+        "is-fullwidth-code-point": "^3.0.0",
+        "strip-ansi": "^6.0.1"
+      },
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/wrap-ansi/node_modules/ansi-regex": {
+      "version": "6.2.2",
+      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-6.2.2.tgz",
+      "integrity": "sha512-Bq3SmSpyFHaWjPk8If9yc6svM8c56dB5BAtW4Qbw5jHTwwXXcTLoRMkpDJp6VL0XzlWaCHTXrkFURMYmD0sLqg==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/ansi-regex?sponsor=1"
+      }
+    },
+    "node_modules/wrap-ansi/node_modules/ansi-styles": {
+      "version": "6.2.3",
+      "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-6.2.3.tgz",
+      "integrity": "sha512-4Dj6M28JB+oAH8kFkTLUo+a2jwOFkuqb3yucU0CANcRRUbxS0cP0nZYCGjcc3BNXwRIsUVmDGgzawme7zvJHvg==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/ansi-styles?sponsor=1"
+      }
+    },
+    "node_modules/wrap-ansi/node_modules/strip-ansi": {
+      "version": "7.1.2",
+      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-7.1.2.tgz",
+      "integrity": "sha512-gmBGslpoQJtgnMAvOVqGZpEz9dyoKTCzy2nfz/n8aIFhN/jCE/rCmcxabB6jOOHV+0WNnylOxaxBQPSvcWklhA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "ansi-regex": "^6.0.1"
+      },
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/strip-ansi?sponsor=1"
+      }
+    },
     "node_modules/wrappy": {
       "version": "1.0.2",
       "resolved": "https://registry.npmjs.org/wrappy/-/wrappy-1.0.2.tgz",
diff --git a/src/index.ts b/src/index.ts
new file mode 100644
index 0000000..6f6a035
--- /dev/null
+++ b/src/index.ts
@@ -0,0 +1,13 @@
+export { TaskQueue } from './task-queue.js';
+export type {
+  Task,
+  TaskStatus,
+  TaskOptions,
+  Schedule,
+  ShutdownOptions,
+  ShutdownSummary,
+  Middleware,
+  Handler,
+  ProgressCallback,
+  ShutdownCallback,
+} from './types.js';
diff --git a/src/task-queue.test.ts b/src/task-queue.test.ts
new file mode 100644
index 0000000..aa6a885
--- /dev/null
+++ b/src/task-queue.test.ts
@@ -0,0 +1,627 @@
+import { describe, it, expect, vi } from 'vitest';
+import { TaskQueue } from './task-queue.js';
+
+describe('Phase 1: Basic FIFO Queue', () => {
+  it('should add a task and return a task object', () => {
+    const tq = new TaskQueue();
+    const task = tq.addTask({ data: 'hello' });
+    expect(task).toBeDefined();
+    expect(task.id).toBeDefined();
+    expect(task.payload).toEqual({ data: 'hello' });
+    expect(task.status).toBe('pending');
+    expect(task.createdAt).toBeInstanceOf(Date);
+  });
+
+  it('should assign unique IDs', () => {
+    const tq = new TaskQueue();
+    const t1 = tq.addTask('a');
+    const t2 = tq.addTask('b');
+    expect(t1.id).not.toBe(t2.id);
+  });
+
+  it('should retrieve tasks in FIFO order', () => {
+    const tq = new TaskQueue();
+    tq.addTask('first');
+    tq.addTask('second');
+    tq.addTask('third');
+
+    const t1 = tq.getNextTask();
+    expect(t1?.payload).toBe('first');
+    expect(t1?.status).toBe('processing');
+
+    const t2 = tq.getNextTask();
+    expect(t2?.payload).toBe('second');
+
+    const t3 = tq.getNextTask();
+    expect(t3?.payload).toBe('third');
+  });
+
+  it('should return null when no tasks available', () => {
+    const tq = new TaskQueue();
+    expect(tq.getNextTask()).toBeNull();
+  });
+
+  it('should track pending count', () => {
+    const tq = new TaskQueue();
+    expect(tq.pendingCount()).toBe(0);
+    tq.addTask('a');
+    tq.addTask('b');
+    expect(tq.pendingCount()).toBe(2);
+    tq.getNextTask();
+    expect(tq.pendingCount()).toBe(1);
+  });
+
+  it('should transition task to processing on retrieval', () => {
+    const tq = new TaskQueue();
+    const task = tq.addTask('test');
+    expect(task.status).toBe('pending');
+    const retrieved = tq.getNextTask();
+    expect(retrieved?.id).toBe(task.id);
+    expect(retrieved?.status).toBe('processing');
+  });
+});
+
+describe('Phase 2: Named Queues', () => {
+  it('should support named queues', () => {
+    const tq = new TaskQueue();
+    tq.addTask('email', { queue: 'emails' });
+    tq.addTask('sms', { queue: 'notifications' });
+
+    expect(tq.getNextTask('emails')?.payload).toBe('email');
+    expect(tq.getNextTask('notifications')?.payload).toBe('sms');
+  });
+
+  it('should use default queue when none specified', () => {
+    const tq = new TaskQueue();
+    tq.addTask('default-task');
+    expect(tq.getNextTask()?.payload).toBe('default-task');
+  });
+
+  it('should list queue names', () => {
+    const tq = new TaskQueue();
+    tq.addTask('a', { queue: 'q1' });
+    tq.addTask('b', { queue: 'q2' });
+    const queues = tq.getQueues();
+    expect(queues).toContain('q1');
+    expect(queues).toContain('q2');
+  });
+
+  it('should return null for empty/non-existent queue', () => {
+    const tq = new TaskQueue();
+    expect(tq.getNextTask('nonexistent')).toBeNull();
+  });
+
+  it('should operate queues independently', () => {
+    const tq = new TaskQueue();
+    tq.addTask('a', { queue: 'q1' });
+    tq.addTask('b', { queue: 'q2' });
+    expect(tq.pendingCount('q1')).toBe(1);
+    expect(tq.pendingCount('q2')).toBe(1);
+    tq.getNextTask('q1');
+    expect(tq.pendingCount('q1')).toBe(0);
+    expect(tq.pendingCount('q2')).toBe(1);
+  });
+});
+
+describe('Phase 3: Priority', () => {
+  it('should return higher priority tasks first', () => {
+    const tq = new TaskQueue();
+    tq.addTask('low', { priority: 10 });
+    tq.addTask('high', { priority: 1 });
+    tq.addTask('medium', { priority: 5 });
+
+    expect(tq.getNextTask()?.payload).toBe('high');
+    expect(tq.getNextTask()?.payload).toBe('medium');
+    expect(tq.getNextTask()?.payload).toBe('low');
+  });
+
+  it('should default priority to 5', () => {
+    const tq = new TaskQueue();
+    const task = tq.addTask('test');
+    expect(task.priority).toBe(5);
+  });
+
+  it('should maintain FIFO for same priority', () => {
+    const tq = new TaskQueue();
+    tq.addTask('first', { priority: 5 });
+    tq.addTask('second', { priority: 5 });
+    tq.addTask('third', { priority: 5 });
+
+    expect(tq.getNextTask()?.payload).toBe('first');
+    expect(tq.getNextTask()?.payload).toBe('second');
+    expect(tq.getNextTask()?.payload).toBe('third');
+  });
+
+  it('should reject invalid priority', () => {
+    const tq = new TaskQueue();
+    expect(() => tq.addTask('test', { priority: 0 })).toThrow();
+    expect(() => tq.addTask('test', { priority: 11 })).toThrow();
+    expect(() => tq.addTask('test', { priority: 1.5 })).toThrow();
+  });
+
+  it('should expose priority on task', () => {
+    const tq = new TaskQueue();
+    const task = tq.addTask('test', { priority: 3 });
+    expect(task.priority).toBe(3);
+  });
+});
+
+describe('Phase 4: Delayed Tasks', () => {
+  it('should not return delayed tasks before their time', () => {
+    const tq = new TaskQueue();
+    tq.addTask('delayed', { delay: 10000 });
+    expect(tq.getNextTask()).toBeNull();
+  });
+
+  it('should return delayed tasks after their time', async () => {
+    const tq = new TaskQueue();
+    tq.addTask('delayed', { delay: 50 });
+    expect(tq.getNextTask()).toBeNull();
+    await new Promise(r => setTimeout(r, 60));
+    expect(tq.getNextTask()?.payload).toBe('delayed');
+  });
+
+  it('should support processAt', () => {
+    const tq = new TaskQueue();
+    const past = new Date(Date.now() - 1000);
+    tq.addTask('past', { processAt: past });
+    expect(tq.getNextTask()?.payload).toBe('past');
+  });
+
+  it('should indicate availableAt on task', () => {
+    const tq = new TaskQueue();
+    const task = tq.addTask('test', { delay: 5000 });
+    expect(task.availableAt.getTime()).toBeGreaterThan(Date.now());
+  });
+
+  it('should prefer non-delayed over not-yet-available delayed', () => {
+    const tq = new TaskQueue();
+    tq.addTask('delayed', { delay: 10000, priority: 1 });
+    tq.addTask('immediate', { priority: 5 });
+    expect(tq.getNextTask()?.payload).toBe('immediate');
+  });
+});
+
+describe('Phase 5: Retry with Backoff', () => {
+  it('should complete a task', () => {
+    const tq = new TaskQueue();
+    const task = tq.addTask('test');
+    tq.getNextTask();
+    tq.completeTask(task.id);
+    expect(task.status).toBe('completed');
+  });
+
+  it('should fail and retry a task', () => {
+    const tq = new TaskQueue();
+    const task = tq.addTask('test', { maxRetries: 2, backoffDelay: 100 });
+    tq.getNextTask();
+    tq.failTask(task.id, 'error');
+    expect(task.status).toBe('pending');
+    expect(task.failCount).toBe(1);
+    expect(task.availableAt.getTime()).toBeGreaterThan(Date.now());
+  });
+
+  it('should use exponential backoff', () => {
+    const tq = new TaskQueue();
+    const task = tq.addTask('test', { maxRetries: 3, backoffDelay: 1000 });
+
+    // First attempt fails
+    tq.getNextTask();
+    const beforeFail1 = Date.now();
+    tq.failTask(task.id);
+    expect(task.availableAt.getTime() - beforeFail1).toBeGreaterThanOrEqual(900); // ~1000ms
+
+    // Wait and retry
+    task.availableAt = new Date(Date.now() - 1);
+    tq.getNextTask();
+    const beforeFail2 = Date.now();
+    tq.failTask(task.id);
+    expect(task.availableAt.getTime() - beforeFail2).toBeGreaterThanOrEqual(1800); // ~2000ms
+  });
+
+  it('should track attempts', () => {
+    const tq = new TaskQueue();
+    const task = tq.addTask('test');
+    expect(task.attempts).toBe(0);
+    tq.getNextTask();
+    expect(task.attempts).toBe(1);
+  });
+
+  it('should permanently fail after max retries', () => {
+    const tq = new TaskQueue();
+    const task = tq.addTask('test', { maxRetries: 1, backoffDelay: 0 });
+
+    tq.getNextTask();
+    tq.failTask(task.id); // fail 1, retry
+    task.availableAt = new Date(Date.now() - 1);
+    tq.getNextTask();
+    tq.failTask(task.id); // fail 2, exhausted
+    expect(task.status).toBe('failed');
+  });
+});
+
+describe('Phase 6: Dead Letter Queue', () => {
+  it('should move to DLQ after retries exhausted', () => {
+    const tq = new TaskQueue();
+    const task = tq.addTask('test', { maxRetries: 0 });
+    tq.getNextTask();
+    tq.failTask(task.id);
+    expect(task.status).toBe('failed');
+    const dlq = tq.getDeadLetterTasks();
+    expect(dlq).toHaveLength(1);
+    expect(dlq[0].id).toBe(task.id);
+  });
+
+  it('should retry dead-lettered tasks', () => {
+    const tq = new TaskQueue();
+    const task = tq.addTask('test', { maxRetries: 0 });
+    tq.getNextTask();
+    tq.failTask(task.id);
+    expect(tq.getDeadLetterTasks()).toHaveLength(1);
+
+    tq.retryDeadLetterTask(task.id);
+    expect(task.status).toBe('pending');
+    expect(tq.getDeadLetterTasks()).toHaveLength(0);
+  });
+
+  it('should clear DLQ', () => {
+    const tq = new TaskQueue();
+    const t1 = tq.addTask('a', { maxRetries: 0 });
+    const t2 = tq.addTask('b', { maxRetries: 0 });
+    tq.getNextTask(); tq.failTask(t1.id);
+    tq.getNextTask(); tq.failTask(t2.id);
+    expect(tq.getDeadLetterTasks()).toHaveLength(2);
+    tq.clearDeadLetterQueue();
+    expect(tq.getDeadLetterTasks()).toHaveLength(0);
+  });
+
+  it('should retain error info in DLQ', () => {
+    const tq = new TaskQueue();
+    const task = tq.addTask('test', { maxRetries: 0 });
+    tq.getNextTask();
+    tq.failTask(task.id, 'something broke');
+    const dlq = tq.getDeadLetterTasks();
+    expect(dlq[0].error?.message).toBe('something broke');
+    expect(dlq[0].failCount).toBe(1);
+  });
+});
+
+describe('Phase 7: Task Dependencies', () => {
+  it('should block tasks with unresolved dependencies', () => {
+    const tq = new TaskQueue();
+    const t1 = tq.addTask('first');
+    const t2 = tq.addTask('second', { dependencies: [t1.id] });
+    expect(t2.status).toBe('blocked');
+    expect(tq.getNextTask()?.id).toBe(t1.id);
+    expect(tq.getNextTask()).toBeNull(); // t2 is blocked
+  });
+
+  it('should unblock when dependencies complete', () => {
+    const tq = new TaskQueue();
+    const t1 = tq.addTask('first');
+    const t2 = tq.addTask('second', { dependencies: [t1.id] });
+    tq.getNextTask();
+    tq.completeTask(t1.id);
+    expect(t2.status).toBe('pending');
+    expect(tq.getNextTask()?.id).toBe(t2.id);
+  });
+
+  it('should reject non-existent dependencies', () => {
+    const tq = new TaskQueue();
+    expect(() => tq.addTask('test', { dependencies: ['nonexistent'] })).toThrow();
+  });
+
+  it('should keep dependents blocked when dependency fails', () => {
+    const tq = new TaskQueue();
+    const t1 = tq.addTask('first', { maxRetries: 0 });
+    const t2 = tq.addTask('second', { dependencies: [t1.id] });
+    tq.getNextTask();
+    tq.failTask(t1.id);
+    expect(t2.status).toBe('blocked');
+  });
+
+  it('should provide dependency status', () => {
+    const tq = new TaskQueue();
+    const t1 = tq.addTask('first');
+    const t2 = tq.addTask('second');
+    const t3 = tq.addTask('third', { dependencies: [t1.id, t2.id] });
+
+    const status = tq.getDependencyStatus(t3.id);
+    expect(status).toHaveLength(2);
+    expect(status.every(s => !s.completed)).toBe(true);
+
+    tq.getNextTask();
+    tq.completeTask(t1.id);
+    const status2 = tq.getDependencyStatus(t3.id);
+    expect(status2.find(s => s.taskId === t1.id)?.completed).toBe(true);
+    expect(status2.find(s => s.taskId === t2.id)?.completed).toBe(false);
+  });
+});
+
+describe('Phase 8: Concurrency Control', () => {
+  it('should limit concurrent processing', () => {
+    const tq = new TaskQueue();
+    tq.setConcurrency('default', 2);
+    tq.addTask('a');
+    tq.addTask('b');
+    tq.addTask('c');
+
+    expect(tq.getNextTask()).not.toBeNull();
+    expect(tq.getNextTask()).not.toBeNull();
+    expect(tq.getNextTask()).toBeNull(); // limit reached
+  });
+
+  it('should free slot on complete', () => {
+    const tq = new TaskQueue();
+    tq.setConcurrency('default', 1);
+    const t1 = tq.addTask('a');
+    tq.addTask('b');
+
+    tq.getNextTask();
+    expect(tq.getNextTask()).toBeNull();
+    tq.completeTask(t1.id);
+    expect(tq.getNextTask()?.payload).toBe('b');
+  });
+
+  it('should report concurrency info', () => {
+    const tq = new TaskQueue();
+    tq.setConcurrency('default', 3);
+    tq.addTask('a');
+    tq.getNextTask();
+
+    const info = tq.getConcurrency('default');
+    expect(info.limit).toBe(3);
+    expect(info.active).toBe(1);
+  });
+
+  it('should default to unlimited', () => {
+    const tq = new TaskQueue();
+    const info = tq.getConcurrency('default');
+    expect(info.limit).toBeNull();
+  });
+});
+
+describe('Phase 9: Progress and Cancellation', () => {
+  it('should track progress', () => {
+    const tq = new TaskQueue();
+    const task = tq.addTask('test');
+    tq.getNextTask();
+    tq.updateProgress(task.id, 50, 'halfway');
+    expect(task.progress).toBe(50);
+    expect(task.progressMessage).toBe('halfway');
+
+    const progress = tq.getProgress(task.id);
+    expect(progress.percent).toBe(50);
+    expect(progress.message).toBe('halfway');
+  });
+
+  it('should notify progress listeners', () => {
+    const tq = new TaskQueue();
+    const task = tq.addTask('test');
+    tq.getNextTask();
+
+    const updates: number[] = [];
+    tq.onProgress(task.id, (p) => updates.push(p.percent));
+
+    tq.updateProgress(task.id, 25);
+    tq.updateProgress(task.id, 75);
+    expect(updates).toEqual([25, 75]);
+  });
+
+  it('should support unsubscribe', () => {
+    const tq = new TaskQueue();
+    const task = tq.addTask('test');
+    tq.getNextTask();
+
+    const updates: number[] = [];
+    const unsub = tq.onProgress(task.id, (p) => updates.push(p.percent));
+
+    tq.updateProgress(task.id, 25);
+    unsub();
+    tq.updateProgress(task.id, 75);
+    expect(updates).toEqual([25]);
+  });
+
+  it('should cancel pending task', () => {
+    const tq = new TaskQueue();
+    const task = tq.addTask('test');
+    tq.cancelTask(task.id);
+    expect(task.status).toBe('cancelled');
+    expect(tq.getNextTask()).toBeNull();
+  });
+
+  it('should cancel processing task', () => {
+    const tq = new TaskQueue();
+    const task = tq.addTask('test');
+    tq.getNextTask();
+    tq.cancelTask(task.id);
+    expect(task.status).toBe('cancelled');
+  });
+
+  it('should not retry cancelled tasks', () => {
+    const tq = new TaskQueue();
+    const task = tq.addTask('test', { maxRetries: 3 });
+    tq.getNextTask();
+    tq.cancelTask(task.id);
+    expect(task.status).toBe('cancelled');
+    // Can't fail a cancelled task
+    expect(() => tq.failTask(task.id)).toThrow();
+  });
+});
+
+describe('Phase 10: Recurring Tasks', () => {
+  it('should create and list schedules', () => {
+    const tq = new TaskQueue();
+    const id = tq.addSchedule('*/5 * * * *', 'default', { type: 'cleanup' });
+    expect(id).toBeDefined();
+    expect(tq.getSchedules()).toHaveLength(1);
+  });
+
+  it('should remove schedules', () => {
+    const tq = new TaskQueue();
+    const id = tq.addSchedule('*/5 * * * *', 'default', { type: 'cleanup' });
+    tq.removeSchedule(id);
+    expect(tq.getSchedules()).toHaveLength(0);
+  });
+
+  it('should enqueue tasks on tick when cron matches', () => {
+    const tq = new TaskQueue();
+    tq.addSchedule('*/5 * * * *', 'default', { type: 'cleanup' });
+
+    // Tick at a time that matches */5 (minute 0)
+    const matchTime = new Date('2024-01-01T00:00:00');
+    const tasks = tq.tick(matchTime);
+    expect(tasks).toHaveLength(1);
+    expect(tasks[0].payload).toEqual({ type: 'cleanup' });
+  });
+
+  it('should not double-fire in same minute', () => {
+    const tq = new TaskQueue();
+    tq.addSchedule('*/5 * * * *', 'default', 'test');
+
+    const time = new Date('2024-01-01T00:00:00');
+    tq.tick(time);
+    const tasks2 = tq.tick(time);
+    expect(tasks2).toHaveLength(0);
+  });
+
+  it('should not fire when cron does not match', () => {
+    const tq = new TaskQueue();
+    tq.addSchedule('0 0 * * *', 'default', 'midnight');
+
+    const nonMidnight = new Date('2024-01-01T12:30:00');
+    const tasks = tq.tick(nonMidnight);
+    expect(tasks).toHaveLength(0);
+  });
+});
+
+describe('Phase 11: Middleware Pipeline', () => {
+  it('should run middleware before handler', async () => {
+    const tq = new TaskQueue();
+    const order: string[] = [];
+
+    tq.use('default', async (_task, next) => {
+      order.push('mw1');
+      await next();
+    });
+    tq.setHandler('default', () => {
+      order.push('handler');
+    });
+
+    tq.addTask('test');
+    await tq.process();
+    expect(order).toEqual(['mw1', 'handler']);
+  });
+
+  it('should allow middleware to skip processing', async () => {
+    const tq = new TaskQueue();
+
+    tq.use('default', async () => {
+      // Don't call next
+    });
+    tq.setHandler('default', () => {
+      throw new Error('Should not be called');
+    });
+
+    tq.addTask('test');
+    const task = await tq.process();
+    expect(task?.status).toBe('completed');
+  });
+
+  it('should fail task if middleware throws', async () => {
+    const tq = new TaskQueue();
+    tq.use('default', async () => {
+      throw new Error('middleware error');
+    });
+
+    tq.addTask('test', { maxRetries: 0 });
+    const task = await tq.process();
+    expect(task?.status).toBe('failed');
+  });
+
+  it('should allow middleware to modify task', async () => {
+    const tq = new TaskQueue();
+    tq.use('default', async (task, next) => {
+      task.payload = { ...(task.payload as Record<string, unknown>), transformed: true };
+      await next();
+    });
+
+    let receivedPayload: unknown;
+    tq.setHandler('default', (task) => {
+      receivedPayload = task.payload;
+    });
+
+    tq.addTask({ data: 'original' });
+    await tq.process();
+    expect(receivedPayload).toEqual({ data: 'original', transformed: true });
+  });
+
+  it('should chain multiple middleware', async () => {
+    const tq = new TaskQueue();
+    const order: number[] = [];
+
+    tq.use('default', async (_task, next) => { order.push(1); await next(); });
+    tq.use('default', async (_task, next) => { order.push(2); await next(); });
+    tq.use('default', async (_task, next) => { order.push(3); await next(); });
+
+    tq.setHandler('default', () => { order.push(4); });
+
+    tq.addTask('test');
+    await tq.process();
+    expect(order).toEqual([1, 2, 3, 4]);
+  });
+});
+
+describe('Phase 12: Graceful Shutdown', () => {
+  it('should reject new tasks after shutdown', async () => {
+    const tq = new TaskQueue();
+    await tq.shutdown();
+    expect(() => tq.addTask('test')).toThrow();
+  });
+
+  it('should complete immediately if no tasks processing', async () => {
+    const tq = new TaskQueue();
+    const summary = await tq.shutdown();
+    expect(summary.completed).toBe(0);
+    expect(summary.forceCancelled).toBe(0);
+    expect(summary.duration).toBeGreaterThanOrEqual(0);
+  });
+
+  it('should wait for processing tasks', async () => {
+    const tq = new TaskQueue();
+    const task = tq.addTask('test');
+    tq.getNextTask();
+
+    const shutdownPromise = tq.shutdown({ timeout: 5000 });
+    // Complete the task
+    tq.completeTask(task.id);
+
+    const summary = await shutdownPromise;
+    expect(summary.completed).toBe(1);
+    expect(summary.forceCancelled).toBe(0);
+  });
+
+  it('should force-cancel on timeout', async () => {
+    const tq = new TaskQueue();
+    tq.addTask('test');
+    tq.getNextTask();
+
+    const summary = await tq.shutdown({ timeout: 50 });
+    expect(summary.forceCancelled).toBe(1);
+  });
+
+  it('should run shutdown callbacks', async () => {
+    const tq = new TaskQueue();
+    let called = false;
+    tq.onShutdown(() => { called = true; });
+    await tq.shutdown();
+    expect(called).toBe(true);
+  });
+
+  it('should be safe to call shutdown multiple times', async () => {
+    const tq = new TaskQueue();
+    const s1 = await tq.shutdown();
+    const s2 = await tq.shutdown();
+    expect(s1).toBe(s2);
+  });
+});
diff --git a/src/task-queue.ts b/src/task-queue.ts
new file mode 100644
index 0000000..a0dfdc2
--- /dev/null
+++ b/src/task-queue.ts
@@ -0,0 +1,613 @@
+import {
+  type Task,
+  type TaskOptions,
+  type Schedule,
+  type ShutdownOptions,
+  type ShutdownSummary,
+  type Middleware,
+  type Handler,
+  type ProgressCallback,
+  type ShutdownCallback,
+  generateId,
+} from './types.js';
+
+const DEFAULT_QUEUE = 'default';
+
+export class TaskQueue {
+  private tasks = new Map<string, Task>();
+  private taskOrder = new Map<string, number>();
+  private orderCounter = 0;
+  private queueNames = new Set<string>();
+  private dlqTasks = new Map<string, Task>();
+  private concurrencyLimits = new Map<string, number>();
+  private middlewareStacks = new Map<string, Middleware[]>();
+  private handlerMap = new Map<string, Handler>();
+  private scheduleMap = new Map<string, Schedule>();
+  private progressListeners = new Map<string, Set<ProgressCallback>>();
+  private _shutdownCallbacks: ShutdownCallback[] = [];
+  private _isShuttingDown = false;
+  private _shutdownPromise: Promise<ShutdownSummary> | null = null;
+  private _shutdownResolve?: (summary: ShutdownSummary) => void;
+  private _shutdownStartTime = 0;
+  private _shutdownProcessingIds = new Set<string>();
+  private _shutdownCompletedCount = 0;
+  private _shutdownTimer?: ReturnType<typeof setTimeout>;
+
+  // ===== Phase 1: Basic FIFO Queue =====
+
+  addTask<T = unknown>(payload: T, options?: TaskOptions): Task<T> {
+    if (this._isShuttingDown) {
+      throw new Error('Cannot add tasks: queue is shutting down');
+    }
+
+    const queueName = options?.queue ?? DEFAULT_QUEUE;
+    const priority = options?.priority ?? 5;
+
+    if (typeof priority !== 'number' || !Number.isInteger(priority) || priority < 1 || priority > 10) {
+      throw new Error(`Invalid priority: ${priority}. Must be an integer between 1 and 10.`);
+    }
+
+    let availableAt = new Date();
+    if (options?.delay != null && options.delay > 0) {
+      availableAt = new Date(Date.now() + options.delay);
+    } else if (options?.processAt) {
+      availableAt = new Date(options.processAt.getTime());
+    }
+
+    const dependencies = options?.dependencies ?? [];
+    for (const depId of dependencies) {
+      if (!this.tasks.has(depId)) {
+        throw new Error(`Dependency task '${depId}' does not exist`);
+      }
+    }
+
+    const id = generateId();
+
+    const task: Task<T> = {
+      id,
+      payload,
+      status: 'pending',
+      priority,
+      queue: queueName,
+      createdAt: new Date(),
+      availableAt,
+      attempts: 0,
+      maxRetries: options?.maxRetries ?? 3,
+      backoffDelay: options?.backoffDelay ?? 1000,
+      progress: 0,
+      progressMessage: undefined,
+      error: undefined,
+      failCount: 0,
+      dependencies: [...dependencies],
+    };
+
+    if (dependencies.length > 0) {
+      const allDepsCompleted = dependencies.every(depId => {
+        const dep = this.tasks.get(depId);
+        return dep && dep.status === 'completed';
+      });
+      if (!allDepsCompleted) {
+        task.status = 'blocked';
+      }
+    }
+
+    this.tasks.set(id, task as Task);
+    this.taskOrder.set(id, this.orderCounter++);
+
+    if (dependencies.length > 0) {
+      if (this.detectCycle(id, new Set())) {
+        this.tasks.delete(id);
+        this.taskOrder.delete(id);
+        throw new Error('Circular dependency detected');
+      }
+    }
+
+    this.queueNames.add(queueName);
+    return task;
+  }
+
+  getNextTask(queueName?: string): Task | null {
+    const queue = queueName ?? DEFAULT_QUEUE;
+
+    const limit = this.concurrencyLimits.get(queue);
+    if (limit != null) {
+      const active = this.countActive(queue);
+      if (active >= limit) {
+        return null;
+      }
+    }
+
+    const now = Date.now();
+    const eligible: Task[] = [];
+
+    for (const task of this.tasks.values()) {
+      if (task.queue !== queue) continue;
+      if (task.status !== 'pending') continue;
+      if (task.availableAt.getTime() > now) continue;
+      eligible.push(task);
+    }
+
+    if (eligible.length === 0) return null;
+
+    eligible.sort((a, b) => {
+      if (a.priority !== b.priority) return a.priority - b.priority;
+      if (a.availableAt.getTime() !== b.availableAt.getTime()) {
+        return a.availableAt.getTime() - b.availableAt.getTime();
+      }
+      return (this.taskOrder.get(a.id) ?? 0) - (this.taskOrder.get(b.id) ?? 0);
+    });
+
+    const task = eligible[0];
+    task.status = 'processing';
+    task.attempts++;
+    return task;
+  }
+
+  pendingCount(queueName?: string): number {
+    const queue = queueName ?? DEFAULT_QUEUE;
+    let count = 0;
+    for (const task of this.tasks.values()) {
+      if (task.queue === queue && task.status === 'pending') {
+        count++;
+      }
+    }
+    return count;
+  }
+
+  getTask(taskId: string): Task | undefined {
+    return this.tasks.get(taskId) ?? this.dlqTasks.get(taskId);
+  }
+
+  // ===== Phase 2: Named Queues =====
+
+  getQueues(): string[] {
+    return [...this.queueNames];
+  }
+
+  // ===== Phase 5: Complete and Fail =====
+
+  completeTask(taskId: string): Task {
+    const task = this.tasks.get(taskId);
+    if (!task) throw new Error(`Task '${taskId}' not found`);
+    if (task.status !== 'processing') {
+      throw new Error(`Task '${taskId}' is not in processing state`);
+    }
+
+    task.status = 'completed';
+    task.progress = 100;
+    this.unblockDependents(taskId);
+    this.onTaskFinished(taskId);
+    return task;
+  }
+
+  failTask(taskId: string, error?: Error | string): Task {
+    const task = this.tasks.get(taskId);
+    if (!task) throw new Error(`Task '${taskId}' not found`);
+    if (task.status !== 'processing') {
+      throw new Error(`Task '${taskId}' is not in processing state`);
+    }
+
+    const err = error instanceof Error ? error : new Error(error ?? 'Task failed');
+    task.error = err;
+    task.failCount++;
+
+    if (task.failCount <= task.maxRetries) {
+      const delay = task.backoffDelay * Math.pow(2, task.failCount - 1);
+      task.status = 'pending';
+      task.availableAt = new Date(Date.now() + delay);
+      task.progress = 0;
+      task.progressMessage = undefined;
+    } else {
+      task.status = 'failed';
+      this.moveToDLQ(task);
+    }
+
+    this.onTaskFinished(taskId);
+    return task;
+  }
+
+  // ===== Phase 6: Dead Letter Queue =====
+
+  private moveToDLQ(task: Task): void {
+    this.dlqTasks.set(task.id, task);
+  }
+
+  getDeadLetterTasks(queueName?: string): Task[] {
+    const queue = queueName ?? DEFAULT_QUEUE;
+    const result: Task[] = [];
+    for (const task of this.dlqTasks.values()) {
+      if (task.queue === queue) {
+        result.push(task);
+      }
+    }
+    return result;
+  }
+
+  retryDeadLetterTask(taskId: string): Task {
+    const task = this.dlqTasks.get(taskId);
+    if (!task) throw new Error(`Task '${taskId}' not found in dead letter queue`);
+
+    this.dlqTasks.delete(taskId);
+    task.status = 'pending';
+    task.failCount = 0;
+    task.attempts = 0;
+    task.error = undefined;
+    task.progress = 0;
+    task.progressMessage = undefined;
+    task.availableAt = new Date();
+    return task;
+  }
+
+  clearDeadLetterQueue(queueName?: string): void {
+    const queue = queueName ?? DEFAULT_QUEUE;
+    const toRemove: string[] = [];
+    for (const [id, task] of this.dlqTasks) {
+      if (task.queue === queue) {
+        toRemove.push(id);
+      }
+    }
+    for (const id of toRemove) {
+      this.dlqTasks.delete(id);
+    }
+  }
+
+  // ===== Phase 7: Task Dependencies =====
+
+  private detectCycle(taskId: string, visited: Set<string>): boolean {
+    if (visited.has(taskId)) return true;
+    visited.add(taskId);
+
+    const task = this.tasks.get(taskId);
+    if (!task) return false;
+
+    for (const depId of task.dependencies) {
+      if (this.detectCycle(depId, new Set(visited))) {
+        return true;
+      }
+    }
+    return false;
+  }
+
+  private unblockDependents(completedTaskId: string): void {
+    for (const task of this.tasks.values()) {
+      if (task.status !== 'blocked') continue;
+      if (!task.dependencies.includes(completedTaskId)) continue;
+
+      const allDone = task.dependencies.every(depId => {
+        const dep = this.tasks.get(depId);
+        return dep && dep.status === 'completed';
+      });
+
+      if (allDone) {
+        task.status = 'pending';
+      }
+    }
+  }
+
+  getDependencyStatus(taskId: string): { taskId: string; completed: boolean }[] {
+    const task = this.tasks.get(taskId);
+    if (!task) throw new Error(`Task '${taskId}' not found`);
+
+    return task.dependencies.map(depId => ({
+      taskId: depId,
+      completed: this.tasks.get(depId)?.status === 'completed' || false,
+    }));
+  }
+
+  // ===== Phase 8: Concurrency Control =====
+
+  setConcurrency(queueName: string, limit: number): void {
+    if (limit <= 0) {
+      this.concurrencyLimits.delete(queueName);
+    } else {
+      this.concurrencyLimits.set(queueName, limit);
+    }
+  }
+
+  getConcurrency(queueName?: string): { limit: number | null; active: number } {
+    const queue = queueName ?? DEFAULT_QUEUE;
+    return {
+      limit: this.concurrencyLimits.get(queue) ?? null,
+      active: this.countActive(queue),
+    };
+  }
+
+  private countActive(queueName: string): number {
+    let count = 0;
+    for (const task of this.tasks.values()) {
+      if (task.queue === queueName && task.status === 'processing') {
+        count++;
+      }
+    }
+    return count;
+  }
+
+  // ===== Phase 9: Progress and Cancellation =====
+
+  updateProgress(taskId: string, percent: number, message?: string): void {
+    const task = this.tasks.get(taskId);
+    if (!task) throw new Error(`Task '${taskId}' not found`);
+    if (task.status !== 'processing') {
+      throw new Error(`Task '${taskId}' is not in processing state`);
+    }
+    if (percent < 0 || percent > 100) {
+      throw new Error(`Invalid progress: ${percent}. Must be between 0 and 100.`);
+    }
+
+    task.progress = percent;
+    task.progressMessage = message;
+
+    const listeners = this.progressListeners.get(taskId);
+    if (listeners) {
+      for (const cb of listeners) {
+        try {
+          cb({ percent, message });
+        } catch (_e) {
+          // ignore listener errors
+        }
+      }
+    }
+  }
+
+  getProgress(taskId: string): { percent: number; message?: string } {
+    const task = this.tasks.get(taskId);
+    if (!task) throw new Error(`Task '${taskId}' not found`);
+    return { percent: task.progress, message: task.progressMessage };
+  }
+
+  onProgress(taskId: string, callback: ProgressCallback): () => void {
+    if (!this.progressListeners.has(taskId)) {
+      this.progressListeners.set(taskId, new Set());
+    }
+    this.progressListeners.get(taskId)!.add(callback);
+
+    return () => {
+      const listeners = this.progressListeners.get(taskId);
+      if (listeners) {
+        listeners.delete(callback);
+        if (listeners.size === 0) {
+          this.progressListeners.delete(taskId);
+        }
+      }
+    };
+  }
+
+  cancelTask(taskId: string): Task {
+    const task = this.tasks.get(taskId);
+    if (!task) throw new Error(`Task '${taskId}' not found`);
+    if (task.status !== 'pending' && task.status !== 'processing' && task.status !== 'blocked') {
+      throw new Error(`Task '${taskId}' cannot be cancelled (status: ${task.status})`);
+    }
+
+    const wasProcessing = task.status === 'processing';
+    task.status = 'cancelled';
+
+    if (wasProcessing) {
+      this.onTaskFinished(taskId);
+    }
+
+    return task;
+  }
+
+  // ===== Phase 10: Recurring Tasks =====
+
+  addSchedule(cron: string, queueName: string, payload: unknown): string {
+    this.validateCron(cron);
+    const id = generateId();
+    this.scheduleMap.set(id, {
+      id,
+      cron,
+      queue: queueName,
+      payload,
+      lastRun: null,
+    });
+    return id;
+  }
+
+  removeSchedule(scheduleId: string): boolean {
+    return this.scheduleMap.delete(scheduleId);
+  }
+
+  getSchedules(): Schedule[] {
+    return [...this.scheduleMap.values()];
+  }
+
+  tick(now?: Date): Task[] {
+    const currentTime = now ?? new Date();
+    const created: Task[] = [];
+
+    for (const schedule of this.scheduleMap.values()) {
+      if (this.shouldFire(schedule, currentTime)) {
+        try {
+          const task = this.addTask(schedule.payload, { queue: schedule.queue });
+          created.push(task);
+          schedule.lastRun = new Date(currentTime.getTime());
+        } catch (_e) {
+          // ignore errors (e.g., during shutdown)
+        }
+      }
+    }
+
+    return created;
+  }
+
+  private validateCron(cron: string): void {
+    const parts = cron.trim().split(/\s+/);
+    if (parts.length !== 5) {
+      throw new Error(`Invalid cron expression: '${cron}'`);
+    }
+  }
+
+  private shouldFire(schedule: Schedule, now: Date): boolean {
+    if (!this.cronMatches(schedule.cron, now)) return false;
+
+    if (schedule.lastRun) {
+      if (
+        schedule.lastRun.getMinutes() === now.getMinutes() &&
+        schedule.lastRun.getHours() === now.getHours() &&
+        schedule.lastRun.getDate() === now.getDate() &&
+        schedule.lastRun.getMonth() === now.getMonth() &&
+        schedule.lastRun.getFullYear() === now.getFullYear()
+      ) {
+        return false;
+      }
+    }
+
+    return true;
+  }
+
+  private cronMatches(cron: string, time: Date): boolean {
+    const parts = cron.trim().split(/\s+/);
+    const [minutePart, hourPart, dayPart, monthPart, weekdayPart] = parts;
+
+    if (!this.fieldMatches(minutePart, time.getMinutes())) return false;
+    if (!this.fieldMatches(hourPart, time.getHours())) return false;
+    if (!this.fieldMatches(dayPart, time.getDate())) return false;
+    if (!this.fieldMatches(monthPart, time.getMonth() + 1)) return false;
+    if (!this.fieldMatches(weekdayPart, time.getDay())) return false;
+
+    return true;
+  }
+
+  private fieldMatches(field: string, value: number): boolean {
+    if (field === '*') return true;
+    if (field.startsWith('*/')) {
+      const interval = parseInt(field.slice(2), 10);
+      return value % interval === 0;
+    }
+    return value === parseInt(field, 10);
+  }
+
+  // ===== Phase 11: Middleware Pipeline =====
+
+  use(queueName: string, middleware: Middleware): void {
+    if (!this.middlewareStacks.has(queueName)) {
+      this.middlewareStacks.set(queueName, []);
+    }
+    this.middlewareStacks.get(queueName)!.push(middleware);
+  }
+
+  setHandler(queueName: string, handler: Handler): void {
+    this.handlerMap.set(queueName, handler);
+  }
+
+  async process(queueName?: string): Promise<Task | null> {
+    const task = this.getNextTask(queueName);
+    if (!task) return null;
+
+    const queue = task.queue;
+    const middlewares = this.middlewareStacks.get(queue) ?? [];
+    const handler = this.handlerMap.get(queue);
+
+    let index = 0;
+    const executeChain = async (): Promise<void> => {
+      if (index < middlewares.length) {
+        const mw = middlewares[index++];
+        await mw(task, executeChain);
+      } else if (handler) {
+        await handler(task);
+      }
+    };
+
+    try {
+      await executeChain();
+      if (task.status === 'processing') {
+        this.completeTask(task.id);
+      }
+    } catch (error) {
+      if (task.status === 'processing') {
+        this.failTask(task.id, error instanceof Error ? error : new Error(String(error)));
+      }
+    }
+
+    return task;
+  }
+
+  // ===== Phase 12: Graceful Shutdown =====
+
+  onShutdown(callback: ShutdownCallback): void {
+    this._shutdownCallbacks.push(callback);
+  }
+
+  get isShuttingDown(): boolean {
+    return this._isShuttingDown;
+  }
+
+  async shutdown(options?: ShutdownOptions): Promise<ShutdownSummary> {
+    if (this._shutdownPromise) return this._shutdownPromise;
+
+    this._isShuttingDown = true;
+    this._shutdownStartTime = Date.now();
+    const timeout = options?.timeout ?? 30000;
+
+    for (const cb of this._shutdownCallbacks) {
+      try {
+        await cb();
+      } catch (_e) {
+        // ignore shutdown callback errors
+      }
+    }
+
+    const processingTasks: Task[] = [];
+    for (const task of this.tasks.values()) {
+      if (task.status === 'processing') {
+        processingTasks.push(task);
+      }
+    }
+
+    if (processingTasks.length === 0) {
+      const summary: ShutdownSummary = {
+        completed: 0,
+        forceCancelled: 0,
+        duration: Date.now() - this._shutdownStartTime,
+      };
+      this._shutdownPromise = Promise.resolve(summary);
+      return summary;
+    }
+
+    this._shutdownProcessingIds = new Set(processingTasks.map(t => t.id));
+    this._shutdownCompletedCount = 0;
+
+    this._shutdownPromise = new Promise<ShutdownSummary>((resolve) => {
+      this._shutdownResolve = resolve;
+
+      this._shutdownTimer = setTimeout(() => {
+        let forceCancelled = 0;
+        for (const id of this._shutdownProcessingIds) {
+          const task = this.tasks.get(id);
+          if (task && task.status === 'processing') {
+            task.status = 'cancelled';
+            forceCancelled++;
+          }
+        }
+        resolve({
+          completed: this._shutdownCompletedCount,
+          forceCancelled,
+          duration: Date.now() - this._shutdownStartTime,
+        });
+      }, timeout);
+    });
+
+    return this._shutdownPromise;
+  }
+
+  private onTaskFinished(taskId: string): void {
+    if (!this._isShuttingDown || !this._shutdownResolve) return;
+
+    if (this._shutdownProcessingIds.has(taskId)) {
+      this._shutdownProcessingIds.delete(taskId);
+      this._shutdownCompletedCount++;
+
+      if (this._shutdownProcessingIds.size === 0) {
+        if (this._shutdownTimer) {
+          clearTimeout(this._shutdownTimer);
+        }
+        this._shutdownResolve({
+          completed: this._shutdownCompletedCount,
+          forceCancelled: 0,
+          duration: Date.now() - this._shutdownStartTime,
+        });
+      }
+    }
+  }
+}
diff --git a/src/types.ts b/src/types.ts
new file mode 100644
index 0000000..cd51cf3
--- /dev/null
+++ b/src/types.ts
@@ -0,0 +1,60 @@
+import { randomUUID } from 'node:crypto';
+
+// ===== Core Types =====
+
+export type TaskStatus = 'pending' | 'processing' | 'completed' | 'failed' | 'cancelled' | 'blocked';
+
+export interface TaskOptions {
+  queue?: string;
+  priority?: number;
+  delay?: number;
+  processAt?: Date;
+  maxRetries?: number;
+  backoffDelay?: number;
+  dependencies?: string[];
+}
+
+export interface Task<T = unknown> {
+  id: string;
+  payload: T;
+  status: TaskStatus;
+  priority: number;
+  queue: string;
+  createdAt: Date;
+  availableAt: Date;
+  attempts: number;
+  maxRetries: number;
+  backoffDelay: number;
+  progress: number;
+  progressMessage?: string;
+  error?: Error;
+  failCount: number;
+  dependencies: string[];
+}
+
+export interface Schedule {
+  id: string;
+  cron: string;
+  queue: string;
+  payload: unknown;
+  lastRun: Date | null;
+}
+
+export interface ShutdownOptions {
+  timeout?: number;
+}
+
+export interface ShutdownSummary {
+  completed: number;
+  forceCancelled: number;
+  duration: number;
+}
+
+export type Middleware = (task: Task, next: () => Promise<void>) => Promise<void> | void;
+export type Handler = (task: Task) => Promise<void> | void;
+export type ProgressCallback = (progress: { percent: number; message?: string }) => void;
+export type ShutdownCallback = () => void | Promise<void>;
+
+export function generateId(): string {
+  return randomUUID();
+}
