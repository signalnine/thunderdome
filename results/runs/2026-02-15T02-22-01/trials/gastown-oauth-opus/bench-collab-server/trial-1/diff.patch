diff --git a/.thunderdome-metrics.json b/.thunderdome-metrics.json
new file mode 100644
index 0000000..a95ffc8
--- /dev/null
+++ b/.thunderdome-metrics.json
@@ -0,0 +1,169 @@
+{
+  "input_tokens": 293,
+  "output_tokens": 124248,
+  "cache_read_tokens": 8715756,
+  "cache_creation_tokens": 381619,
+  "turns": 223,
+  "tools_used": [
+    "Read",
+    "Glob",
+    "TodoWrite",
+    "Write",
+    "Bash",
+    "Edit",
+    "TaskOutput",
+    "Task",
+    "Grep",
+    "Task\" subagent_type=\"Explore"
+  ],
+  "duration_ms": 1674000,
+  "total_cost_usd": 10.196,
+  "gastown_meta": {
+    "strategy": "parallel",
+    "polecat_count": 4,
+    "roles": {
+      "mayor": {
+        "input_tokens": 3,
+        "output_tokens": 1374,
+        "cache_read_tokens": 7687,
+        "cache_creation_tokens": 1132,
+        "turns": 1,
+        "tools_used": [],
+        "duration_ms": 30647,
+        "total_cost_usd": 0.0452835
+      },
+      "polecat-0": {
+        "input_tokens": 21,
+        "output_tokens": 7250,
+        "cache_read_tokens": 423205,
+        "cache_creation_tokens": 14278,
+        "turns": 24,
+        "tools_used": [
+          "Read",
+          "Glob",
+          "TodoWrite",
+          "Write",
+          "Bash",
+          "Edit"
+        ],
+        "duration_ms": 134477,
+        "total_cost_usd": 0.49782199999999993
+      },
+      "polecat-1": {
+        "input_tokens": 69,
+        "output_tokens": 7664,
+        "cache_read_tokens": 486691,
+        "cache_creation_tokens": 13839,
+        "turns": 25,
+        "tools_used": [
+          "Read",
+          "Bash",
+          "Glob",
+          "TodoWrite",
+          "Write"
+        ],
+        "duration_ms": 142181,
+        "total_cost_usd": 0.53894225
+      },
+      "polecat-2": {
+        "input_tokens": 98,
+        "output_tokens": 45852,
+        "cache_read_tokens": 3179778,
+        "cache_creation_tokens": 98800,
+        "turns": 56,
+        "tools_used": [
+          "Read",
+          "Bash",
+          "Glob",
+          "TodoWrite",
+          "Write",
+          "Edit"
+        ],
+        "duration_ms": 880269,
+        "total_cost_usd": 3.392568999999999
+      },
+      "polecat-3": {
+        "input_tokens": 47,
+        "output_tokens": 27871,
+        "cache_read_tokens": 1694438,
+        "cache_creation_tokens": 58446,
+        "turns": 56,
+        "tools_used": [
+          "Read",
+          "Bash",
+          "TodoWrite",
+          "Write",
+          "TaskOutput",
+          "Edit"
+        ],
+        "duration_ms": 584423,
+        "total_cost_usd": 1.9371234999999993
+      },
+      "refinery-fixup": {
+        "input_tokens": 34,
+        "output_tokens": 28422,
+        "cache_read_tokens": 2564687,
+        "cache_creation_tokens": 91437,
+        "turns": 43,
+        "tools_used": [
+          "Task",
+          "Bash",
+          "Read",
+          "TodoWrite",
+          "Write",
+          "Edit"
+        ],
+        "duration_ms": 566990,
+        "total_cost_usd": 2.6784457999999995
+      },
+      "refinery-merge-1": {
+        "input_tokens": 7,
+        "output_tokens": 2074,
+        "cache_read_tokens": 104746,
+        "cache_creation_tokens": 31994,
+        "turns": 6,
+        "tools_used": [
+          "Read",
+          "Write",
+          "Grep",
+          "Bash"
+        ],
+        "duration_ms": 36101,
+        "total_cost_usd": 0.3058825
+      },
+      "refinery-merge-2": {
+        "input_tokens": 7,
+        "output_tokens": 1075,
+        "cache_read_tokens": 105907,
+        "cache_creation_tokens": 44459,
+        "turns": 6,
+        "tools_used": [
+          "Read",
+          "Task",
+          "Glob",
+          "Grep",
+          "Bash"
+        ],
+        "duration_ms": 60184,
+        "total_cost_usd": 0.4273865
+      },
+      "refinery-merge-3": {
+        "input_tokens": 7,
+        "output_tokens": 2666,
+        "cache_read_tokens": 148617,
+        "cache_creation_tokens": 27234,
+        "turns": 6,
+        "tools_used": [
+          "Task\" subagent_type=\"Explore",
+          "Task",
+          "Bash",
+          "Read",
+          "TodoWrite",
+          "Write"
+        ],
+        "duration_ms": 75123,
+        "total_cost_usd": 0.37272000000000005
+      }
+    }
+  }
+}
\ No newline at end of file
diff --git a/package-lock.json b/package-lock.json
index b36b372..6f03430 100644
--- a/package-lock.json
+++ b/package-lock.json
@@ -19,12 +19,84 @@
         "@types/ws": "^8.5.0",
         "@typescript-eslint/eslint-plugin": "^7.0.0",
         "@typescript-eslint/parser": "^7.0.0",
+        "@vitest/coverage-v8": "^2.0.0",
         "eslint": "^8.56.0",
         "supertest": "^7.0.0",
         "typescript": "^5.4.0",
         "vitest": "^2.0.0"
       }
     },
+    "node_modules/@ampproject/remapping": {
+      "version": "2.3.0",
+      "resolved": "https://registry.npmjs.org/@ampproject/remapping/-/remapping-2.3.0.tgz",
+      "integrity": "sha512-30iZtAPgz+LTIYoeivqYo853f02jBYSd5uGnGpkFV0M3xOt9aN73erkgYAmZU43x4VfqcnLxW9Kpg3R5LC4YYw==",
+      "dev": true,
+      "license": "Apache-2.0",
+      "dependencies": {
+        "@jridgewell/gen-mapping": "^0.3.5",
+        "@jridgewell/trace-mapping": "^0.3.24"
+      },
+      "engines": {
+        "node": ">=6.0.0"
+      }
+    },
+    "node_modules/@babel/helper-string-parser": {
+      "version": "7.27.1",
+      "resolved": "https://registry.npmjs.org/@babel/helper-string-parser/-/helper-string-parser-7.27.1.tgz",
+      "integrity": "sha512-qMlSxKbpRlAridDExk92nSobyDdpPijUq2DW6oDnUqd0iOGxmQjyqhMIihI9+zv4LPyZdRje2cavWPbCbWm3eA==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=6.9.0"
+      }
+    },
+    "node_modules/@babel/helper-validator-identifier": {
+      "version": "7.28.5",
+      "resolved": "https://registry.npmjs.org/@babel/helper-validator-identifier/-/helper-validator-identifier-7.28.5.tgz",
+      "integrity": "sha512-qSs4ifwzKJSV39ucNjsvc6WVHs6b7S03sOh2OcHF9UHfVPqWWALUsNUVzhSBiItjRZoLHx7nIarVjqKVusUZ1Q==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=6.9.0"
+      }
+    },
+    "node_modules/@babel/parser": {
+      "version": "7.29.0",
+      "resolved": "https://registry.npmjs.org/@babel/parser/-/parser-7.29.0.tgz",
+      "integrity": "sha512-IyDgFV5GeDUVX4YdF/3CPULtVGSXXMLh1xVIgdCgxApktqnQV0r7/8Nqthg+8YLGaAtdyIlo2qIdZrbCv4+7ww==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@babel/types": "^7.29.0"
+      },
+      "bin": {
+        "parser": "bin/babel-parser.js"
+      },
+      "engines": {
+        "node": ">=6.0.0"
+      }
+    },
+    "node_modules/@babel/types": {
+      "version": "7.29.0",
+      "resolved": "https://registry.npmjs.org/@babel/types/-/types-7.29.0.tgz",
+      "integrity": "sha512-LwdZHpScM4Qz8Xw2iKSzS+cfglZzJGvofQICy7W7v4caru4EaAmyUuO6BGrbyQ2mYV11W0U8j5mBhd14dd3B0A==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@babel/helper-string-parser": "^7.27.1",
+        "@babel/helper-validator-identifier": "^7.28.5"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      }
+    },
+    "node_modules/@bcoe/v8-coverage": {
+      "version": "0.2.3",
+      "resolved": "https://registry.npmjs.org/@bcoe/v8-coverage/-/v8-coverage-0.2.3.tgz",
+      "integrity": "sha512-0hYQ8SB4Db5zvZB4axdMHGwEaQjkZzFjQiN9LVYvIFB2nSUHW9tYpxWriPrWDASIxiaXax83REcLxuSdnGPZtw==",
+      "dev": true,
+      "license": "MIT"
+    },
     "node_modules/@esbuild/aix-ppc64": {
       "version": "0.21.5",
       "resolved": "https://registry.npmjs.org/@esbuild/aix-ppc64/-/aix-ppc64-0.21.5.tgz",
@@ -565,6 +637,84 @@
       "dev": true,
       "license": "BSD-3-Clause"
     },
+    "node_modules/@isaacs/cliui": {
+      "version": "8.0.2",
+      "resolved": "https://registry.npmjs.org/@isaacs/cliui/-/cliui-8.0.2.tgz",
+      "integrity": "sha512-O8jcjabXaleOG9DQ0+ARXWZBTfnP4WNAqzuiJK7ll44AmxGKv/J2M4TPjxjY3znBCfvBXFzucm1twdyFybFqEA==",
+      "dev": true,
+      "license": "ISC",
+      "dependencies": {
+        "string-width": "^5.1.2",
+        "string-width-cjs": "npm:string-width@^4.2.0",
+        "strip-ansi": "^7.0.1",
+        "strip-ansi-cjs": "npm:strip-ansi@^6.0.1",
+        "wrap-ansi": "^8.1.0",
+        "wrap-ansi-cjs": "npm:wrap-ansi@^7.0.0"
+      },
+      "engines": {
+        "node": ">=12"
+      }
+    },
+    "node_modules/@isaacs/cliui/node_modules/ansi-regex": {
+      "version": "6.2.2",
+      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-6.2.2.tgz",
+      "integrity": "sha512-Bq3SmSpyFHaWjPk8If9yc6svM8c56dB5BAtW4Qbw5jHTwwXXcTLoRMkpDJp6VL0XzlWaCHTXrkFURMYmD0sLqg==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/ansi-regex?sponsor=1"
+      }
+    },
+    "node_modules/@isaacs/cliui/node_modules/strip-ansi": {
+      "version": "7.1.2",
+      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-7.1.2.tgz",
+      "integrity": "sha512-gmBGslpoQJtgnMAvOVqGZpEz9dyoKTCzy2nfz/n8aIFhN/jCE/rCmcxabB6jOOHV+0WNnylOxaxBQPSvcWklhA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "ansi-regex": "^6.0.1"
+      },
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/strip-ansi?sponsor=1"
+      }
+    },
+    "node_modules/@istanbuljs/schema": {
+      "version": "0.1.3",
+      "resolved": "https://registry.npmjs.org/@istanbuljs/schema/-/schema-0.1.3.tgz",
+      "integrity": "sha512-ZXRY4jNvVgSVQ8DL3LTcakaAtXwTVUxE81hslsyD2AtoXW/wVob10HkOJ1X/pAlcI7D+2YoZKg5do8G/w6RYgA==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/@jridgewell/gen-mapping": {
+      "version": "0.3.13",
+      "resolved": "https://registry.npmjs.org/@jridgewell/gen-mapping/-/gen-mapping-0.3.13.tgz",
+      "integrity": "sha512-2kkt/7niJ6MgEPxF0bYdQ6etZaA+fQvDcLKckhy1yIQOzaoKjBBjSj63/aLVjYE3qhRt5dvM+uUyfCg6UKCBbA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@jridgewell/sourcemap-codec": "^1.5.0",
+        "@jridgewell/trace-mapping": "^0.3.24"
+      }
+    },
+    "node_modules/@jridgewell/resolve-uri": {
+      "version": "3.1.2",
+      "resolved": "https://registry.npmjs.org/@jridgewell/resolve-uri/-/resolve-uri-3.1.2.tgz",
+      "integrity": "sha512-bRISgCIjP20/tbWSPWMEi54QVPRZExkuD9lJL+UIxUKtwVJA8wW1Trb1jMs1RFXo1CBTNZ/5hpC9QvmKWdopKw==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=6.0.0"
+      }
+    },
     "node_modules/@jridgewell/sourcemap-codec": {
       "version": "1.5.5",
       "resolved": "https://registry.npmjs.org/@jridgewell/sourcemap-codec/-/sourcemap-codec-1.5.5.tgz",
@@ -572,6 +722,17 @@
       "dev": true,
       "license": "MIT"
     },
+    "node_modules/@jridgewell/trace-mapping": {
+      "version": "0.3.31",
+      "resolved": "https://registry.npmjs.org/@jridgewell/trace-mapping/-/trace-mapping-0.3.31.tgz",
+      "integrity": "sha512-zzNR+SdQSDJzc8joaeP8QQoCQr8NuYx2dIIytl1QeBEZHJ9uW6hebsrYgbz8hJwUQao3TWCMtmfV8Nu1twOLAw==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@jridgewell/resolve-uri": "^3.1.0",
+        "@jridgewell/sourcemap-codec": "^1.4.14"
+      }
+    },
     "node_modules/@noble/hashes": {
       "version": "1.8.0",
       "resolved": "https://registry.npmjs.org/@noble/hashes/-/hashes-1.8.0.tgz",
@@ -633,6 +794,17 @@
         "@noble/hashes": "^1.1.5"
       }
     },
+    "node_modules/@pkgjs/parseargs": {
+      "version": "0.11.0",
+      "resolved": "https://registry.npmjs.org/@pkgjs/parseargs/-/parseargs-0.11.0.tgz",
+      "integrity": "sha512-+1VkjdD0QBLPodGrJUeqarH8VAIvQODIbwh9XpP5Syisf7YoQgsJKPNFoqqLQlu+VQ/tVSshMR6loPMn8U+dPg==",
+      "dev": true,
+      "license": "MIT",
+      "optional": true,
+      "engines": {
+        "node": ">=14"
+      }
+    },
     "node_modules/@rollup/rollup-android-arm-eabi": {
       "version": "4.57.1",
       "resolved": "https://registry.npmjs.org/@rollup/rollup-android-arm-eabi/-/rollup-android-arm-eabi-4.57.1.tgz",
@@ -1081,7 +1253,6 @@
       "integrity": "sha512-m0jEgYlYz+mDJZ2+F4v8D1AyQb+QzsNqRuI7xg1VQX/KlKS0qT9r1Mo16yo5F/MtifXFgaofIFsdFMox2SxIbQ==",
       "dev": true,
       "license": "MIT",
-      "peer": true,
       "dependencies": {
         "undici-types": "~7.16.0"
       }
@@ -1207,7 +1378,6 @@
       "integrity": "sha512-4Z+L8I2OqhZV8qA132M4wNL30ypZGYOQVBfMgxDH/K5UX0PNqTu1c6za9ST5r9+tavvHiTWmBnKzpCJ/GlVFtg==",
       "dev": true,
       "license": "BSD-2-Clause",
-      "peer": true,
       "dependencies": {
         "@typescript-eslint/scope-manager": "7.18.0",
         "@typescript-eslint/types": "7.18.0",
@@ -1368,6 +1538,39 @@
       "dev": true,
       "license": "ISC"
     },
+    "node_modules/@vitest/coverage-v8": {
+      "version": "2.1.9",
+      "resolved": "https://registry.npmjs.org/@vitest/coverage-v8/-/coverage-v8-2.1.9.tgz",
+      "integrity": "sha512-Z2cOr0ksM00MpEfyVE8KXIYPEcBFxdbLSs56L8PO0QQMxt/6bDj45uQfxoc96v05KW3clk7vvgP0qfDit9DmfQ==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@ampproject/remapping": "^2.3.0",
+        "@bcoe/v8-coverage": "^0.2.3",
+        "debug": "^4.3.7",
+        "istanbul-lib-coverage": "^3.2.2",
+        "istanbul-lib-report": "^3.0.1",
+        "istanbul-lib-source-maps": "^5.0.6",
+        "istanbul-reports": "^3.1.7",
+        "magic-string": "^0.30.12",
+        "magicast": "^0.3.5",
+        "std-env": "^3.8.0",
+        "test-exclude": "^7.0.1",
+        "tinyrainbow": "^1.2.0"
+      },
+      "funding": {
+        "url": "https://opencollective.com/vitest"
+      },
+      "peerDependencies": {
+        "@vitest/browser": "2.1.9",
+        "vitest": "2.1.9"
+      },
+      "peerDependenciesMeta": {
+        "@vitest/browser": {
+          "optional": true
+        }
+      }
+    },
     "node_modules/@vitest/expect": {
       "version": "2.1.9",
       "resolved": "https://registry.npmjs.org/@vitest/expect/-/expect-2.1.9.tgz",
@@ -1500,7 +1703,6 @@
       "integrity": "sha512-NZyJarBfL7nWwIq+FDL6Zp/yHEhePMNnnJ0y3qfieCrmNvYct8uvtiV41UvlSe6apAfk0fY1FbWx+NwfmpvtTg==",
       "dev": true,
       "license": "MIT",
-      "peer": true,
       "bin": {
         "acorn": "bin/acorn"
       },
@@ -2116,12 +2318,26 @@
         "node": ">= 0.4"
       }
     },
+    "node_modules/eastasianwidth": {
+      "version": "0.2.0",
+      "resolved": "https://registry.npmjs.org/eastasianwidth/-/eastasianwidth-0.2.0.tgz",
+      "integrity": "sha512-I88TYZWc9XiYHRQ4/3c5rjjfgkjhLyW2luGIheGERbNQ6OY7yTybanSpDXZa8y7VUP9YmDcYa+eyq4ca7iLqWA==",
+      "dev": true,
+      "license": "MIT"
+    },
     "node_modules/ee-first": {
       "version": "1.1.1",
       "resolved": "https://registry.npmjs.org/ee-first/-/ee-first-1.1.1.tgz",
       "integrity": "sha512-WMwm9LhRUo+WUaRN+vRuETqG89IgZphVSNkdFgeb6sS/E4OrDIN7t48CAewSHXc6C8lefD8KKfr5vY61brQlow==",
       "license": "MIT"
     },
+    "node_modules/emoji-regex": {
+      "version": "9.2.2",
+      "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-9.2.2.tgz",
+      "integrity": "sha512-L18DaJsXSUk2+42pv8mLs5jJT2hqFkFE4j21wOmgbUqsZ2hL72NsUU785g9RXgo3s0ZNgVl42TiHp3ZtOv/Vyg==",
+      "dev": true,
+      "license": "MIT"
+    },
     "node_modules/encodeurl": {
       "version": "2.0.0",
       "resolved": "https://registry.npmjs.org/encodeurl/-/encodeurl-2.0.0.tgz",
@@ -2258,7 +2474,6 @@
       "deprecated": "This version is no longer supported. Please see https://eslint.org/version-support for other options.",
       "dev": true,
       "license": "MIT",
-      "peer": true,
       "dependencies": {
         "@eslint-community/eslint-utils": "^4.2.0",
         "@eslint-community/regexpp": "^4.6.1",
@@ -2698,6 +2913,23 @@
       "dev": true,
       "license": "ISC"
     },
+    "node_modules/foreground-child": {
+      "version": "3.3.1",
+      "resolved": "https://registry.npmjs.org/foreground-child/-/foreground-child-3.3.1.tgz",
+      "integrity": "sha512-gIXjKqtFuWEgzFRJA9WCQeSJLZDjgJUOMCMzxtvFq/37KojM1BFGufqsCy0r4qSQmYLsZYMeyRqzIWOMup03sw==",
+      "dev": true,
+      "license": "ISC",
+      "dependencies": {
+        "cross-spawn": "^7.0.6",
+        "signal-exit": "^4.0.1"
+      },
+      "engines": {
+        "node": ">=14"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/isaacs"
+      }
+    },
     "node_modules/form-data": {
       "version": "4.0.5",
       "resolved": "https://registry.npmjs.org/form-data/-/form-data-4.0.5.tgz",
@@ -2996,6 +3228,13 @@
         "node": ">= 0.4"
       }
     },
+    "node_modules/html-escaper": {
+      "version": "2.0.2",
+      "resolved": "https://registry.npmjs.org/html-escaper/-/html-escaper-2.0.2.tgz",
+      "integrity": "sha512-H2iMtd0I4Mt5eYiapRdIDjp+XzelXQ0tFE4JS7YFwFevXXMmOp9myNrUvCg0D6ws8iqkRPBfKHgbwig1SmlLfg==",
+      "dev": true,
+      "license": "MIT"
+    },
     "node_modules/http-errors": {
       "version": "2.0.1",
       "resolved": "https://registry.npmjs.org/http-errors/-/http-errors-2.0.1.tgz",
@@ -3128,6 +3367,16 @@
         "node": ">=0.10.0"
       }
     },
+    "node_modules/is-fullwidth-code-point": {
+      "version": "3.0.0",
+      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/is-fullwidth-code-point-3.0.0.tgz",
+      "integrity": "sha512-zymm5+u+sCsSWyD9qNaejV3DFvhCKclKdizYaJUuHA83RLjb7nSuGnddCHGv0hk+KY7BMAlsWeK4Ueg6EV6XQg==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=8"
+      }
+    },
     "node_modules/is-glob": {
       "version": "4.0.3",
       "resolved": "https://registry.npmjs.org/is-glob/-/is-glob-4.0.3.tgz",
@@ -3168,6 +3417,76 @@
       "dev": true,
       "license": "ISC"
     },
+    "node_modules/istanbul-lib-coverage": {
+      "version": "3.2.2",
+      "resolved": "https://registry.npmjs.org/istanbul-lib-coverage/-/istanbul-lib-coverage-3.2.2.tgz",
+      "integrity": "sha512-O8dpsF+r0WV/8MNRKfnmrtCWhuKjxrq2w+jpzBL5UZKTi2LeVWnWOmWRxFlesJONmc+wLAGvKQZEOanko0LFTg==",
+      "dev": true,
+      "license": "BSD-3-Clause",
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/istanbul-lib-report": {
+      "version": "3.0.1",
+      "resolved": "https://registry.npmjs.org/istanbul-lib-report/-/istanbul-lib-report-3.0.1.tgz",
+      "integrity": "sha512-GCfE1mtsHGOELCU8e/Z7YWzpmybrx/+dSTfLrvY8qRmaY6zXTKWn6WQIjaAFw069icm6GVMNkgu0NzI4iPZUNw==",
+      "dev": true,
+      "license": "BSD-3-Clause",
+      "dependencies": {
+        "istanbul-lib-coverage": "^3.0.0",
+        "make-dir": "^4.0.0",
+        "supports-color": "^7.1.0"
+      },
+      "engines": {
+        "node": ">=10"
+      }
+    },
+    "node_modules/istanbul-lib-source-maps": {
+      "version": "5.0.6",
+      "resolved": "https://registry.npmjs.org/istanbul-lib-source-maps/-/istanbul-lib-source-maps-5.0.6.tgz",
+      "integrity": "sha512-yg2d+Em4KizZC5niWhQaIomgf5WlL4vOOjZ5xGCmF8SnPE/mDWWXgvRExdcpCgh9lLRRa1/fSYp2ymmbJ1pI+A==",
+      "dev": true,
+      "license": "BSD-3-Clause",
+      "dependencies": {
+        "@jridgewell/trace-mapping": "^0.3.23",
+        "debug": "^4.1.1",
+        "istanbul-lib-coverage": "^3.0.0"
+      },
+      "engines": {
+        "node": ">=10"
+      }
+    },
+    "node_modules/istanbul-reports": {
+      "version": "3.2.0",
+      "resolved": "https://registry.npmjs.org/istanbul-reports/-/istanbul-reports-3.2.0.tgz",
+      "integrity": "sha512-HGYWWS/ehqTV3xN10i23tkPkpH46MLCIMFNCaaKNavAXTF1RkqxawEPtnjnGZ6XKSInBKkiOA5BKS+aZiY3AvA==",
+      "dev": true,
+      "license": "BSD-3-Clause",
+      "dependencies": {
+        "html-escaper": "^2.0.0",
+        "istanbul-lib-report": "^3.0.0"
+      },
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/jackspeak": {
+      "version": "3.4.3",
+      "resolved": "https://registry.npmjs.org/jackspeak/-/jackspeak-3.4.3.tgz",
+      "integrity": "sha512-OGlZQpz2yfahA/Rd1Y8Cd9SIEsqvXkLVoSw/cgwhnhFMDbsQFeZYoJJ7bIZBS9BcamUW96asq/npPWugM+RQBw==",
+      "dev": true,
+      "license": "BlueOak-1.0.0",
+      "dependencies": {
+        "@isaacs/cliui": "^8.0.2"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/isaacs"
+      },
+      "optionalDependencies": {
+        "@pkgjs/parseargs": "^0.11.0"
+      }
+    },
     "node_modules/js-yaml": {
       "version": "4.1.1",
       "resolved": "https://registry.npmjs.org/js-yaml/-/js-yaml-4.1.1.tgz",
@@ -3256,6 +3575,13 @@
       "dev": true,
       "license": "MIT"
     },
+    "node_modules/lru-cache": {
+      "version": "10.4.3",
+      "resolved": "https://registry.npmjs.org/lru-cache/-/lru-cache-10.4.3.tgz",
+      "integrity": "sha512-JNAzZcXrCt42VGLuYz0zfAzDfAvJWW6AfYlDBQyDV5DClI2m5sAmK+OIO7s59XfsRsWHp02jAJrRadPRGTt6SQ==",
+      "dev": true,
+      "license": "ISC"
+    },
     "node_modules/magic-string": {
       "version": "0.30.21",
       "resolved": "https://registry.npmjs.org/magic-string/-/magic-string-0.30.21.tgz",
@@ -3266,6 +3592,34 @@
         "@jridgewell/sourcemap-codec": "^1.5.5"
       }
     },
+    "node_modules/magicast": {
+      "version": "0.3.5",
+      "resolved": "https://registry.npmjs.org/magicast/-/magicast-0.3.5.tgz",
+      "integrity": "sha512-L0WhttDl+2BOsybvEOLK7fW3UA0OQ0IQ2d6Zl2x/a6vVRs3bAY0ECOSHHeL5jD+SbOpOCUEi0y1DgHEn9Qn1AQ==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@babel/parser": "^7.25.4",
+        "@babel/types": "^7.25.4",
+        "source-map-js": "^1.2.0"
+      }
+    },
+    "node_modules/make-dir": {
+      "version": "4.0.0",
+      "resolved": "https://registry.npmjs.org/make-dir/-/make-dir-4.0.0.tgz",
+      "integrity": "sha512-hXdUTZYIVOt1Ex//jAQi+wTZZpUpwBj/0QsOzqegb3rGMMeJiSEu5xLHnYfBrRV4RH2+OCSOO95Is/7x1WJ4bw==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "semver": "^7.5.3"
+      },
+      "engines": {
+        "node": ">=10"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/sindresorhus"
+      }
+    },
     "node_modules/math-intrinsics": {
       "version": "1.1.0",
       "resolved": "https://registry.npmjs.org/math-intrinsics/-/math-intrinsics-1.1.0.tgz",
@@ -3396,6 +3750,16 @@
         "url": "https://github.com/sponsors/ljharb"
       }
     },
+    "node_modules/minipass": {
+      "version": "7.1.2",
+      "resolved": "https://registry.npmjs.org/minipass/-/minipass-7.1.2.tgz",
+      "integrity": "sha512-qOOzS1cBTWYF4BH8fVePDBOO9iptMnGUEZwNc/cMWnTV2nVLZ7VoNWEPHkYczZA0pdoA7dl6e7FL659nX9S2aw==",
+      "dev": true,
+      "license": "ISC",
+      "engines": {
+        "node": ">=16 || 14 >=14.17"
+      }
+    },
     "node_modules/mkdirp-classic": {
       "version": "0.5.3",
       "resolved": "https://registry.npmjs.org/mkdirp-classic/-/mkdirp-classic-0.5.3.tgz",
@@ -3544,6 +3908,13 @@
         "url": "https://github.com/sponsors/sindresorhus"
       }
     },
+    "node_modules/package-json-from-dist": {
+      "version": "1.0.1",
+      "resolved": "https://registry.npmjs.org/package-json-from-dist/-/package-json-from-dist-1.0.1.tgz",
+      "integrity": "sha512-UEZIS3/by4OC8vL3P2dTXRETpebLI2NiI5vIrjaD/5UtrkFX/tNbwjTSRAGC/+7CAo2pIcBaRgWmcBBHcsaCIw==",
+      "dev": true,
+      "license": "BlueOak-1.0.0"
+    },
     "node_modules/parent-module": {
       "version": "1.0.1",
       "resolved": "https://registry.npmjs.org/parent-module/-/parent-module-1.0.1.tgz",
@@ -3596,6 +3967,23 @@
         "node": ">=8"
       }
     },
+    "node_modules/path-scurry": {
+      "version": "1.11.1",
+      "resolved": "https://registry.npmjs.org/path-scurry/-/path-scurry-1.11.1.tgz",
+      "integrity": "sha512-Xa4Nw17FS9ApQFJ9umLiJS4orGjm7ZzwUrwamcGQuHSzDyth9boKDaycYdDcZDuqYATXw4HFXgaqWTctW/v1HA==",
+      "dev": true,
+      "license": "BlueOak-1.0.0",
+      "dependencies": {
+        "lru-cache": "^10.2.0",
+        "minipass": "^5.0.0 || ^6.0.2 || ^7.0.0"
+      },
+      "engines": {
+        "node": ">=16 || 14 >=14.18"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/isaacs"
+      }
+    },
     "node_modules/path-to-regexp": {
       "version": "0.1.12",
       "resolved": "https://registry.npmjs.org/path-to-regexp/-/path-to-regexp-0.1.12.tgz",
@@ -4152,6 +4540,19 @@
       "dev": true,
       "license": "ISC"
     },
+    "node_modules/signal-exit": {
+      "version": "4.1.0",
+      "resolved": "https://registry.npmjs.org/signal-exit/-/signal-exit-4.1.0.tgz",
+      "integrity": "sha512-bzyZ1e88w9O1iNJbKnOlvYTrWPDl46O1bG0D3XInv+9tkPrxrN8jUUTiFlDkkmKWgn1M6CfIA13SuGqOa9Korw==",
+      "dev": true,
+      "license": "ISC",
+      "engines": {
+        "node": ">=14"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/isaacs"
+      }
+    },
     "node_modules/simple-concat": {
       "version": "1.0.1",
       "resolved": "https://registry.npmjs.org/simple-concat/-/simple-concat-1.0.1.tgz",
@@ -4249,6 +4650,76 @@
         "safe-buffer": "~5.2.0"
       }
     },
+    "node_modules/string-width": {
+      "version": "5.1.2",
+      "resolved": "https://registry.npmjs.org/string-width/-/string-width-5.1.2.tgz",
+      "integrity": "sha512-HnLOCR3vjcY8beoNLtcjZ5/nxn2afmME6lhrDrebokqMap+XbeW8n9TXpPDOqdGK5qcI3oT0GKTW6wC7EMiVqA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "eastasianwidth": "^0.2.0",
+        "emoji-regex": "^9.2.2",
+        "strip-ansi": "^7.0.1"
+      },
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/sindresorhus"
+      }
+    },
+    "node_modules/string-width-cjs": {
+      "name": "string-width",
+      "version": "4.2.3",
+      "resolved": "https://registry.npmjs.org/string-width/-/string-width-4.2.3.tgz",
+      "integrity": "sha512-wKyQRQpjJ0sIp62ErSZdGsjMJWsap5oRNihHhu6G7JVO/9jIB6UyevL+tXuOqrng8j/cxKTWyWUwvSTriiZz/g==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "emoji-regex": "^8.0.0",
+        "is-fullwidth-code-point": "^3.0.0",
+        "strip-ansi": "^6.0.1"
+      },
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/string-width-cjs/node_modules/emoji-regex": {
+      "version": "8.0.0",
+      "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-8.0.0.tgz",
+      "integrity": "sha512-MSjYzcWNOA0ewAHpz0MxpYFvwg6yjy1NG3xteoqz644VCo/RPgnr1/GGt+ic3iJTzQ8Eu3TdM14SawnVUmGE6A==",
+      "dev": true,
+      "license": "MIT"
+    },
+    "node_modules/string-width/node_modules/ansi-regex": {
+      "version": "6.2.2",
+      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-6.2.2.tgz",
+      "integrity": "sha512-Bq3SmSpyFHaWjPk8If9yc6svM8c56dB5BAtW4Qbw5jHTwwXXcTLoRMkpDJp6VL0XzlWaCHTXrkFURMYmD0sLqg==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/ansi-regex?sponsor=1"
+      }
+    },
+    "node_modules/string-width/node_modules/strip-ansi": {
+      "version": "7.1.2",
+      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-7.1.2.tgz",
+      "integrity": "sha512-gmBGslpoQJtgnMAvOVqGZpEz9dyoKTCzy2nfz/n8aIFhN/jCE/rCmcxabB6jOOHV+0WNnylOxaxBQPSvcWklhA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "ansi-regex": "^6.0.1"
+      },
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/strip-ansi?sponsor=1"
+      }
+    },
     "node_modules/strip-ansi": {
       "version": "6.0.1",
       "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-6.0.1.tgz",
@@ -4262,6 +4733,20 @@
         "node": ">=8"
       }
     },
+    "node_modules/strip-ansi-cjs": {
+      "name": "strip-ansi",
+      "version": "6.0.1",
+      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-6.0.1.tgz",
+      "integrity": "sha512-Y38VPSHcqkFrCpFnQ9vuSXmquuv5oXOKpGeT6aGrr3o3Gc9AlVa6JBfUSOCnbxGGZF+/0ooI7KrPuUSztUdU5A==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "ansi-regex": "^5.0.1"
+      },
+      "engines": {
+        "node": ">=8"
+      }
+    },
     "node_modules/strip-json-comments": {
       "version": "3.1.1",
       "resolved": "https://registry.npmjs.org/strip-json-comments/-/strip-json-comments-3.1.1.tgz",
@@ -4375,6 +4860,43 @@
         "node": ">=6"
       }
     },
+    "node_modules/test-exclude": {
+      "version": "7.0.1",
+      "resolved": "https://registry.npmjs.org/test-exclude/-/test-exclude-7.0.1.tgz",
+      "integrity": "sha512-pFYqmTw68LXVjeWJMST4+borgQP2AyMNbg1BpZh9LbyhUeNkeaPF9gzfPGUAnSMV3qPYdWUwDIjjCLiSDOl7vg==",
+      "dev": true,
+      "license": "ISC",
+      "dependencies": {
+        "@istanbuljs/schema": "^0.1.2",
+        "glob": "^10.4.1",
+        "minimatch": "^9.0.4"
+      },
+      "engines": {
+        "node": ">=18"
+      }
+    },
+    "node_modules/test-exclude/node_modules/glob": {
+      "version": "10.5.0",
+      "resolved": "https://registry.npmjs.org/glob/-/glob-10.5.0.tgz",
+      "integrity": "sha512-DfXN8DfhJ7NH3Oe7cFmu3NCu1wKbkReJ8TorzSAFbSKrlNaQSKfIzqYqVY8zlbs2NLBbWpRiU52GX2PbaBVNkg==",
+      "deprecated": "Old versions of glob are not supported, and contain widely publicized security vulnerabilities, which have been fixed in the current version. Please update. Support for old versions may be purchased (at exorbitant rates) by contacting i@izs.me",
+      "dev": true,
+      "license": "ISC",
+      "dependencies": {
+        "foreground-child": "^3.1.0",
+        "jackspeak": "^3.1.2",
+        "minimatch": "^9.0.4",
+        "minipass": "^7.1.2",
+        "package-json-from-dist": "^1.0.0",
+        "path-scurry": "^1.11.1"
+      },
+      "bin": {
+        "glob": "dist/esm/bin.mjs"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/isaacs"
+      }
+    },
     "node_modules/text-table": {
       "version": "0.2.0",
       "resolved": "https://registry.npmjs.org/text-table/-/text-table-0.2.0.tgz",
@@ -4518,7 +5040,6 @@
       "integrity": "sha512-jl1vZzPDinLr9eUt3J/t7V6FgNEw9QjvBPdysz9KfQDD41fQrC2Y4vKQdiaUpFT4bXlb1RHhLpp8wtm6M5TgSw==",
       "dev": true,
       "license": "Apache-2.0",
-      "peer": true,
       "bin": {
         "tsc": "bin/tsc",
         "tsserver": "bin/tsserver"
@@ -4769,6 +5290,107 @@
         "node": ">=0.10.0"
       }
     },
+    "node_modules/wrap-ansi": {
+      "version": "8.1.0",
+      "resolved": "https://registry.npmjs.org/wrap-ansi/-/wrap-ansi-8.1.0.tgz",
+      "integrity": "sha512-si7QWI6zUMq56bESFvagtmzMdGOtoxfR+Sez11Mobfc7tm+VkUckk9bW2UeffTGVUbOksxmSw0AA2gs8g71NCQ==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "ansi-styles": "^6.1.0",
+        "string-width": "^5.0.1",
+        "strip-ansi": "^7.0.1"
+      },
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/wrap-ansi?sponsor=1"
+      }
+    },
+    "node_modules/wrap-ansi-cjs": {
+      "name": "wrap-ansi",
+      "version": "7.0.0",
+      "resolved": "https://registry.npmjs.org/wrap-ansi/-/wrap-ansi-7.0.0.tgz",
+      "integrity": "sha512-YVGIj2kamLSTxw6NsZjoBxfSwsn0ycdesmc4p+Q21c5zPuZ1pl+NfxVdxPtdHvmNVOQ6XSYG4AUtyt/Fi7D16Q==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "ansi-styles": "^4.0.0",
+        "string-width": "^4.1.0",
+        "strip-ansi": "^6.0.0"
+      },
+      "engines": {
+        "node": ">=10"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/wrap-ansi?sponsor=1"
+      }
+    },
+    "node_modules/wrap-ansi-cjs/node_modules/emoji-regex": {
+      "version": "8.0.0",
+      "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-8.0.0.tgz",
+      "integrity": "sha512-MSjYzcWNOA0ewAHpz0MxpYFvwg6yjy1NG3xteoqz644VCo/RPgnr1/GGt+ic3iJTzQ8Eu3TdM14SawnVUmGE6A==",
+      "dev": true,
+      "license": "MIT"
+    },
+    "node_modules/wrap-ansi-cjs/node_modules/string-width": {
+      "version": "4.2.3",
+      "resolved": "https://registry.npmjs.org/string-width/-/string-width-4.2.3.tgz",
+      "integrity": "sha512-wKyQRQpjJ0sIp62ErSZdGsjMJWsap5oRNihHhu6G7JVO/9jIB6UyevL+tXuOqrng8j/cxKTWyWUwvSTriiZz/g==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "emoji-regex": "^8.0.0",
+        "is-fullwidth-code-point": "^3.0.0",
+        "strip-ansi": "^6.0.1"
+      },
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/wrap-ansi/node_modules/ansi-regex": {
+      "version": "6.2.2",
+      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-6.2.2.tgz",
+      "integrity": "sha512-Bq3SmSpyFHaWjPk8If9yc6svM8c56dB5BAtW4Qbw5jHTwwXXcTLoRMkpDJp6VL0XzlWaCHTXrkFURMYmD0sLqg==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/ansi-regex?sponsor=1"
+      }
+    },
+    "node_modules/wrap-ansi/node_modules/ansi-styles": {
+      "version": "6.2.3",
+      "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-6.2.3.tgz",
+      "integrity": "sha512-4Dj6M28JB+oAH8kFkTLUo+a2jwOFkuqb3yucU0CANcRRUbxS0cP0nZYCGjcc3BNXwRIsUVmDGgzawme7zvJHvg==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/ansi-styles?sponsor=1"
+      }
+    },
+    "node_modules/wrap-ansi/node_modules/strip-ansi": {
+      "version": "7.1.2",
+      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-7.1.2.tgz",
+      "integrity": "sha512-gmBGslpoQJtgnMAvOVqGZpEz9dyoKTCzy2nfz/n8aIFhN/jCE/rCmcxabB6jOOHV+0WNnylOxaxBQPSvcWklhA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "ansi-regex": "^6.0.1"
+      },
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/strip-ansi?sponsor=1"
+      }
+    },
     "node_modules/wrappy": {
       "version": "1.0.2",
       "resolved": "https://registry.npmjs.org/wrappy/-/wrappy-1.0.2.tgz",
diff --git a/src/__tests__/server.test.ts b/src/__tests__/server.test.ts
new file mode 100644
index 0000000..8678243
--- /dev/null
+++ b/src/__tests__/server.test.ts
@@ -0,0 +1,627 @@
+import { describe, it, expect, beforeEach, afterEach } from 'vitest';
+import request from 'supertest';
+import WebSocket from 'ws';
+import { createApp, type AppInstance } from '../server.js';
+import fs from 'fs';
+import path from 'path';
+import os from 'os';
+
+let server: AppInstance;
+let port: number;
+let baseUrl: string;
+
+/** Collect incoming messages into an array, returning a function to wait for the next one. */
+function createMessageCollector(ws: WebSocket) {
+  const messages: Record<string, unknown>[] = [];
+  let waitResolve: ((msg: Record<string, unknown>) => void) | null = null;
+
+  ws.on('message', (data) => {
+    const msg = JSON.parse(data.toString());
+    if (waitResolve) {
+      const resolve = waitResolve;
+      waitResolve = null;
+      resolve(msg);
+    } else {
+      messages.push(msg);
+    }
+  });
+
+  return {
+    next: (): Promise<Record<string, unknown>> => {
+      if (messages.length > 0) {
+        return Promise.resolve(messages.shift()!);
+      }
+      return new Promise((resolve, reject) => {
+        waitResolve = resolve;
+        setTimeout(() => {
+          waitResolve = null;
+          reject(new Error('Timeout waiting for message'));
+        }, 5000);
+      });
+    },
+    drain: () => { messages.length = 0; },
+  };
+}
+
+/** Connect to a document WebSocket and wait for the sync message. */
+async function connectAndSync(docId: string): Promise<{ ws: WebSocket; sync: Record<string, unknown>; messages: ReturnType<typeof createMessageCollector> }> {
+  const ws = new WebSocket(`ws://localhost:${port}/ws/documents/${docId}`);
+  const messages = createMessageCollector(ws);
+
+  await new Promise<void>((resolve, reject) => {
+    const timer = setTimeout(() => reject(new Error('Timeout waiting for WS open')), 5000);
+    ws.once('open', () => { clearTimeout(timer); resolve(); });
+    ws.once('error', (err) => { clearTimeout(timer); reject(err); });
+  });
+
+  const sync = await messages.next();
+  return { ws, sync, messages };
+}
+
+describe('Server', () => {
+  beforeEach(async () => {
+    server = createApp();
+    port = await server.start(0);
+    baseUrl = `http://localhost:${port}`;
+  });
+
+  afterEach(async () => {
+    await server.stop();
+  });
+
+  describe('Document CRUD via REST', () => {
+    it('should create a document', async () => {
+      const res = await request(baseUrl)
+        .post('/api/documents')
+        .send({ title: 'Test Doc', content: 'Hello World' })
+        .expect(201);
+
+      expect(res.body).toHaveProperty('id');
+      expect(res.body.title).toBe('Test Doc');
+      expect(res.body.content).toBe('Hello World');
+    });
+
+    it('should list documents', async () => {
+      await request(baseUrl).post('/api/documents').send({ title: 'Doc 1' }).expect(201);
+      await request(baseUrl).post('/api/documents').send({ title: 'Doc 2' }).expect(201);
+
+      const res = await request(baseUrl).get('/api/documents').expect(200);
+      expect(res.body).toHaveLength(2);
+    });
+
+    it('should get a single document', async () => {
+      const created = await request(baseUrl)
+        .post('/api/documents')
+        .send({ title: 'My Doc', content: 'content' })
+        .expect(201);
+
+      const res = await request(baseUrl)
+        .get(`/api/documents/${created.body.id}`)
+        .expect(200);
+
+      expect(res.body.title).toBe('My Doc');
+      expect(res.body.content).toBe('content');
+    });
+
+    it('should return 404 for nonexistent document', async () => {
+      await request(baseUrl)
+        .get('/api/documents/nonexistent-id')
+        .expect(404);
+    });
+
+    it('should update a document', async () => {
+      const created = await request(baseUrl)
+        .post('/api/documents')
+        .send({ title: 'Original', content: 'old' })
+        .expect(201);
+
+      const res = await request(baseUrl)
+        .put(`/api/documents/${created.body.id}`)
+        .send({ title: 'Updated', content: 'new' })
+        .expect(200);
+
+      expect(res.body.title).toBe('Updated');
+      expect(res.body.content).toBe('new');
+    });
+
+    it('should delete a document', async () => {
+      const created = await request(baseUrl)
+        .post('/api/documents')
+        .send({ title: 'To Delete' })
+        .expect(201);
+
+      await request(baseUrl)
+        .delete(`/api/documents/${created.body.id}`)
+        .expect(204);
+
+      await request(baseUrl)
+        .get(`/api/documents/${created.body.id}`)
+        .expect(404);
+    });
+
+    it('should return 400 for missing title on create', async () => {
+      await request(baseUrl)
+        .post('/api/documents')
+        .send({ content: 'no title' })
+        .expect(400);
+    });
+
+    it('should get document versions', async () => {
+      const created = await request(baseUrl)
+        .post('/api/documents')
+        .send({ title: 'Versioned Doc', content: 'initial' })
+        .expect(201);
+
+      const res = await request(baseUrl)
+        .get(`/api/documents/${created.body.id}/versions`)
+        .expect(200);
+
+      expect(res.body.length).toBeGreaterThanOrEqual(1);
+      expect(res.body[0].version).toBe(0);
+    });
+  });
+
+  describe('WebSocket connection and sync', () => {
+    it('should send sync message on connection', async () => {
+      const created = await request(baseUrl)
+        .post('/api/documents')
+        .send({ title: 'WS Doc', content: 'Hello' })
+        .expect(201);
+
+      const { ws, sync } = await connectAndSync(created.body.id);
+
+      expect(sync.type).toBe('sync');
+      expect(sync.content).toBe('Hello');
+      expect(sync.version).toBe(0);
+      expect(sync.documentId).toBe(created.body.id);
+
+      ws.close();
+    });
+
+    it('should reject connection to nonexistent document', async () => {
+      const ws = new WebSocket(`ws://localhost:${port}/ws/documents/nonexistent-id`);
+
+      await new Promise<void>((resolve) => {
+        ws.on('close', () => resolve());
+        ws.on('error', () => resolve());
+      });
+
+      expect(ws.readyState).not.toBe(WebSocket.OPEN);
+    });
+
+    it('should apply an insert operation', async () => {
+      const created = await request(baseUrl)
+        .post('/api/documents')
+        .send({ title: 'Edit Doc', content: 'Hello' })
+        .expect(201);
+
+      const { ws, sync, messages } = await connectAndSync(created.body.id);
+      expect(sync.type).toBe('sync');
+
+      ws.send(JSON.stringify({
+        type: 'operation',
+        operation: { type: 'insert', position: 5, text: ' World' },
+        version: 0,
+      }));
+
+      const ack = await messages.next();
+      expect(ack.type).toBe('ack');
+      expect(ack.version).toBe(1);
+
+      const res = await request(baseUrl)
+        .get(`/api/documents/${created.body.id}`)
+        .expect(200);
+
+      expect(res.body.content).toBe('Hello World');
+      ws.close();
+    });
+
+    it('should apply a delete operation', async () => {
+      const created = await request(baseUrl)
+        .post('/api/documents')
+        .send({ title: 'Del Doc', content: 'Hello World' })
+        .expect(201);
+
+      const { ws, messages } = await connectAndSync(created.body.id);
+
+      ws.send(JSON.stringify({
+        type: 'operation',
+        operation: { type: 'delete', position: 5, length: 6 },
+        version: 0,
+      }));
+
+      const ack = await messages.next();
+      expect(ack.type).toBe('ack');
+
+      const res = await request(baseUrl)
+        .get(`/api/documents/${created.body.id}`)
+        .expect(200);
+
+      expect(res.body.content).toBe('Hello');
+      ws.close();
+    });
+  });
+
+  describe('Two clients concurrent edits and convergence', () => {
+    it('should handle two clients making concurrent edits', async () => {
+      const created = await request(baseUrl)
+        .post('/api/documents')
+        .send({ title: 'Collab Doc', content: 'Hello' })
+        .expect(201);
+
+      const docId = created.body.id;
+
+      const c1 = await connectAndSync(docId);
+      expect(c1.sync.type).toBe('sync');
+
+      const c2 = await connectAndSync(docId);
+      expect(c2.sync.type).toBe('sync');
+
+      // Client 1: insert " World" at position 5 (based on version 0)
+      c1.ws.send(JSON.stringify({
+        type: 'operation',
+        operation: { type: 'insert', position: 5, text: ' World' },
+        version: 0,
+      }));
+
+      const ack1 = await c1.messages.next();
+      expect(ack1.type).toBe('ack');
+
+      // Client 2 receives the broadcast
+      const broadcast = await c2.messages.next();
+      expect(broadcast.type).toBe('operation');
+
+      // Client 2: insert "!" at position 5 (based on version 0, server now at version 1)
+      c2.ws.send(JSON.stringify({
+        type: 'operation',
+        operation: { type: 'insert', position: 5, text: '!' },
+        version: 0,
+      }));
+
+      const ack2 = await c2.messages.next();
+      expect(ack2.type).toBe('ack');
+
+      // Verify convergence via REST
+      const res = await request(baseUrl)
+        .get(`/api/documents/${docId}`)
+        .expect(200);
+
+      const content = res.body.content;
+      expect(content).toContain('Hello');
+      expect(content).toContain('World');
+      expect(content).toContain('!');
+
+      c1.ws.close();
+      c2.ws.close();
+    });
+
+    it('should converge when both clients insert at the same position', async () => {
+      const created = await request(baseUrl)
+        .post('/api/documents')
+        .send({ title: 'Same Pos', content: 'AB' })
+        .expect(201);
+
+      const docId = created.body.id;
+
+      const c1 = await connectAndSync(docId);
+      const c2 = await connectAndSync(docId);
+
+      // Client 1 inserts at position 1
+      c1.ws.send(JSON.stringify({
+        type: 'operation',
+        operation: { type: 'insert', position: 1, text: 'X' },
+        version: 0,
+      }));
+
+      const ack1 = await c1.messages.next();
+      expect(ack1.type).toBe('ack');
+      await c2.messages.next(); // broadcast
+
+      // Client 2 inserts at position 1 (based on version 0)
+      c2.ws.send(JSON.stringify({
+        type: 'operation',
+        operation: { type: 'insert', position: 1, text: 'Y' },
+        version: 0,
+      }));
+
+      const ack2 = await c2.messages.next();
+      expect(ack2.type).toBe('ack');
+
+      const res = await request(baseUrl)
+        .get(`/api/documents/${docId}`)
+        .expect(200);
+
+      expect(res.body.content).toContain('X');
+      expect(res.body.content).toContain('Y');
+      expect(res.body.content).toContain('A');
+      expect(res.body.content).toContain('B');
+
+      c1.ws.close();
+      c2.ws.close();
+    });
+  });
+
+  describe('Persistence across restart', () => {
+    it('should persist documents across server restart', async () => {
+      const tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), 'collab-test-'));
+      const dbPath = path.join(tmpDir, 'test.db');
+
+      const server1 = createApp(dbPath);
+      const port1 = await server1.start(0);
+
+      const created = await request(`http://localhost:${port1}`)
+        .post('/api/documents')
+        .send({ title: 'Persistent Doc', content: 'I persist!' })
+        .expect(201);
+
+      const docId = created.body.id;
+      await server1.stop();
+
+      const server2 = createApp(dbPath);
+      const port2 = await server2.start(0);
+
+      const res = await request(`http://localhost:${port2}`)
+        .get(`/api/documents/${docId}`)
+        .expect(200);
+
+      expect(res.body.title).toBe('Persistent Doc');
+      expect(res.body.content).toBe('I persist!');
+
+      await server2.stop();
+      fs.rmSync(tmpDir, { recursive: true, force: true });
+    });
+
+    it('should persist edits made via WebSocket across restart', async () => {
+      const tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), 'collab-test-'));
+      const dbPath = path.join(tmpDir, 'test.db');
+
+      const server1 = createApp(dbPath);
+      const port1 = await server1.start(0);
+
+      const created = await request(`http://localhost:${port1}`)
+        .post('/api/documents')
+        .send({ title: 'WS Persist', content: 'Hello' })
+        .expect(201);
+
+      const docId = created.body.id;
+
+      // Make edit via WebSocket â€” set up message listener BEFORE open
+      const ws = new WebSocket(`ws://localhost:${port1}/ws/documents/${docId}`);
+      const wsMessages = createMessageCollector(ws);
+
+      await new Promise<void>((resolve, reject) => {
+        const timer = setTimeout(() => reject(new Error('Timeout waiting for WS open')), 5000);
+        ws.once('open', () => { clearTimeout(timer); resolve(); });
+        ws.once('error', (err) => { clearTimeout(timer); reject(err); });
+      });
+
+      const sync = await wsMessages.next();
+      expect(sync.type).toBe('sync');
+
+      ws.send(JSON.stringify({
+        type: 'operation',
+        operation: { type: 'insert', position: 5, text: ' World' },
+        version: 0,
+      }));
+
+      const ack = await wsMessages.next();
+      expect(ack.type).toBe('ack');
+      ws.close();
+
+      await server1.stop();
+
+      const server2 = createApp(dbPath);
+      const port2 = await server2.start(0);
+
+      const res = await request(`http://localhost:${port2}`)
+        .get(`/api/documents/${docId}`)
+        .expect(200);
+
+      expect(res.body.content).toBe('Hello World');
+
+      await server2.stop();
+      fs.rmSync(tmpDir, { recursive: true, force: true });
+    });
+  });
+
+  describe('10 concurrent clients', () => {
+    it('should handle 10 concurrent clients without corruption', async () => {
+      const created = await request(baseUrl)
+        .post('/api/documents')
+        .send({ title: 'Concurrent Doc', content: '' })
+        .expect(201);
+
+      const docId = created.body.id;
+      const clients: Array<{ ws: WebSocket; messages: ReturnType<typeof createMessageCollector> }> = [];
+
+      // Connect 10 clients
+      for (let i = 0; i < 10; i++) {
+        const { ws, sync, messages } = await connectAndSync(docId);
+        expect(sync.type).toBe('sync');
+        clients.push({ ws, messages });
+      }
+
+      // Each client sends one insert operation sequentially
+      for (let i = 0; i < 10; i++) {
+        const { ws, messages } = clients[i];
+
+        const docState = await request(baseUrl)
+          .get(`/api/documents/${docId}`)
+          .expect(200);
+
+        const currentContent = docState.body.content;
+        const versionsRes = await request(baseUrl)
+          .get(`/api/documents/${docId}/versions`)
+          .expect(200);
+        const currentVersion = versionsRes.body.length - 1;
+
+        ws.send(JSON.stringify({
+          type: 'operation',
+          operation: { type: 'insert', position: currentContent.length, text: String(i) },
+          version: currentVersion,
+        }));
+
+        const ack = await messages.next();
+        expect(ack.type).toBe('ack');
+
+        // Drain broadcast messages from other clients
+        await new Promise(resolve => setTimeout(resolve, 50));
+        for (let j = 0; j < 10; j++) {
+          if (j !== i) {
+            clients[j].messages.drain();
+          }
+        }
+      }
+
+      // Verify the final document contains all 10 digits
+      const res = await request(baseUrl)
+        .get(`/api/documents/${docId}`)
+        .expect(200);
+
+      const content = res.body.content;
+      for (let i = 0; i < 10; i++) {
+        expect(content).toContain(String(i));
+      }
+      expect(content.length).toBe(10);
+
+      for (const { ws } of clients) {
+        ws.close();
+      }
+    });
+  });
+
+  describe('Malformed operations', () => {
+    it('should reject operation with missing type', async () => {
+      const created = await request(baseUrl)
+        .post('/api/documents')
+        .send({ title: 'Malformed', content: 'text' })
+        .expect(201);
+
+      const { ws, messages } = await connectAndSync(created.body.id);
+
+      ws.send(JSON.stringify({
+        type: 'operation',
+        operation: { position: 0, text: 'hello' },
+        version: 0,
+      }));
+
+      const errorMsg = await messages.next();
+      expect(errorMsg.type).toBe('error');
+
+      ws.close();
+    });
+
+    it('should reject operation with negative position', async () => {
+      const created = await request(baseUrl)
+        .post('/api/documents')
+        .send({ title: 'Negative', content: 'text' })
+        .expect(201);
+
+      const { ws, messages } = await connectAndSync(created.body.id);
+
+      ws.send(JSON.stringify({
+        type: 'operation',
+        operation: { type: 'insert', position: -1, text: 'hello' },
+        version: 0,
+      }));
+
+      const errorMsg = await messages.next();
+      expect(errorMsg.type).toBe('error');
+
+      ws.close();
+    });
+
+    it('should reject operation with missing version', async () => {
+      const created = await request(baseUrl)
+        .post('/api/documents')
+        .send({ title: 'No Version', content: 'text' })
+        .expect(201);
+
+      const { ws, messages } = await connectAndSync(created.body.id);
+
+      ws.send(JSON.stringify({
+        type: 'operation',
+        operation: { type: 'insert', position: 0, text: 'hello' },
+      }));
+
+      const errorMsg = await messages.next();
+      expect(errorMsg.type).toBe('error');
+
+      ws.close();
+    });
+
+    it('should reject invalid JSON', async () => {
+      const created = await request(baseUrl)
+        .post('/api/documents')
+        .send({ title: 'Bad JSON', content: 'text' })
+        .expect(201);
+
+      const { ws, messages } = await connectAndSync(created.body.id);
+
+      ws.send('not valid json {{{');
+
+      const errorMsg = await messages.next();
+      expect(errorMsg.type).toBe('error');
+
+      ws.close();
+    });
+
+    it('should reject unknown message type', async () => {
+      const created = await request(baseUrl)
+        .post('/api/documents')
+        .send({ title: 'Unknown', content: 'text' })
+        .expect(201);
+
+      const { ws, messages } = await connectAndSync(created.body.id);
+
+      ws.send(JSON.stringify({
+        type: 'unknown_type',
+      }));
+
+      const errorMsg = await messages.next();
+      expect(errorMsg.type).toBe('error');
+
+      ws.close();
+    });
+
+    it('should reject delete with out-of-bounds range', async () => {
+      const created = await request(baseUrl)
+        .post('/api/documents')
+        .send({ title: 'OOB Delete', content: 'hi' })
+        .expect(201);
+
+      const { ws, messages } = await connectAndSync(created.body.id);
+
+      ws.send(JSON.stringify({
+        type: 'operation',
+        operation: { type: 'delete', position: 0, length: 100 },
+        version: 0,
+      }));
+
+      const errorMsg = await messages.next();
+      expect(errorMsg.type).toBe('error');
+
+      ws.close();
+    });
+
+    it('should reject insert with empty text', async () => {
+      const created = await request(baseUrl)
+        .post('/api/documents')
+        .send({ title: 'Empty Insert', content: 'text' })
+        .expect(201);
+
+      const { ws, messages } = await connectAndSync(created.body.id);
+
+      ws.send(JSON.stringify({
+        type: 'operation',
+        operation: { type: 'insert', position: 0, text: '' },
+        version: 0,
+      }));
+
+      const errorMsg = await messages.next();
+      expect(errorMsg.type).toBe('error');
+
+      ws.close();
+    });
+  });
+});
diff --git a/src/collaboration.ts b/src/collaboration.ts
new file mode 100644
index 0000000..29cf5ca
--- /dev/null
+++ b/src/collaboration.ts
@@ -0,0 +1,611 @@
+import { WebSocketServer, WebSocket } from 'ws';
+import type { Server as HttpServer } from 'http';
+import type { Database } from './database.js';
+import { applyOperation as otApplyOperation, transformOp, validateOperation, type Operation as OtOperation } from './ot.js';
+import type BetterSqlite3 from 'better-sqlite3';
+
+// â”€â”€ Operation types (used by CollaborationManager / collaboration.test.ts) â”€â”€
+
+export interface InsertOperation {
+  type: 'insert';
+  position: number;
+  text: string;
+}
+
+export interface DeleteOperation {
+  type: 'delete';
+  position: number;
+  count: number;
+}
+
+export type Operation = InsertOperation | DeleteOperation;
+
+export interface ClientMessage {
+  type: 'operation';
+  operation: Operation;
+  baseVersion: number;
+  clientId?: string;
+}
+
+export interface SyncMessage {
+  type: 'sync';
+  content: string;
+  version: number;
+  documentId: number | string;
+}
+
+export interface BroadcastMessage {
+  type: 'operation';
+  operation: Operation;
+  version: number;
+  clientId?: string;
+}
+
+export interface ErrorMessage {
+  type: 'error';
+  message: string;
+}
+
+export interface AckMessage {
+  type: 'ack';
+  version: number;
+}
+
+export type OutgoingMessage = SyncMessage | BroadcastMessage | ErrorMessage | AckMessage;
+
+// â”€â”€ OT Transform (for collaboration.test.ts) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
+
+export function transformOT(
+  op1: Operation,
+  op2: Operation,
+): [Operation[], Operation[]] {
+  if (op1.type === 'insert' && op2.type === 'insert') {
+    return xformII(op1, op2);
+  }
+  if (op1.type === 'delete' && op2.type === 'delete') {
+    return xformDD(op1, op2);
+  }
+  if (op1.type === 'insert' && op2.type === 'delete') {
+    return xformID(op1, op2);
+  }
+  // delete, insert â€” swap and flip result
+  const [b, a] = xformID(op2 as InsertOperation, op1 as DeleteOperation);
+  return [a, b];
+}
+
+function xformII(a: InsertOperation, b: InsertOperation): [InsertOperation[], InsertOperation[]] {
+  if (a.position < b.position || (a.position === b.position)) {
+    return [
+      [{ ...a }],
+      [{ ...b, position: b.position + a.text.length }],
+    ];
+  }
+  return [
+    [{ ...a, position: a.position + b.text.length }],
+    [{ ...b }],
+  ];
+}
+
+function xformDD(a: DeleteOperation, b: DeleteOperation): [DeleteOperation[], DeleteOperation[]] {
+  const as = a.position, ae = as + a.count;
+  const bs = b.position, be = bs + b.count;
+
+  // No overlap
+  if (ae <= bs) {
+    return [[{ ...a }], [{ type: 'delete', position: bs - a.count, count: b.count }]];
+  }
+  if (be <= as) {
+    return [[{ type: 'delete', position: as - b.count, count: a.count }], [{ ...b }]];
+  }
+
+  // Overlap
+  const aParts: DeleteOperation[] = [];
+  const bParts: DeleteOperation[] = [];
+
+  if (as < bs) {
+    aParts.push({ type: 'delete', position: as, count: bs - as });
+  }
+  if (ae > be) {
+    aParts.push({ type: 'delete', position: (ae > be ? be : ae) - b.count, count: ae - be });
+  }
+  if (bs < as) {
+    bParts.push({ type: 'delete', position: bs, count: as - bs });
+  }
+  if (be > ae) {
+    bParts.push({ type: 'delete', position: (be > ae ? ae : be) - a.count, count: be - ae });
+  }
+
+  if (aParts.length === 0) aParts.push({ type: 'delete', position: Math.min(as, bs), count: 0 });
+  if (bParts.length === 0) bParts.push({ type: 'delete', position: Math.min(as, bs), count: 0 });
+
+  return [aParts, bParts];
+}
+
+function xformID(
+  ins: InsertOperation,
+  del: DeleteOperation,
+): [InsertOperation[], DeleteOperation[]] {
+  const ds = del.position;
+  const de = ds + del.count;
+
+  if (ins.position <= ds) {
+    return [
+      [{ ...ins }],
+      [{ type: 'delete', position: ds + ins.text.length, count: del.count }],
+    ];
+  }
+  if (ins.position >= de) {
+    return [
+      [{ type: 'insert', position: ins.position - del.count, text: ins.text }],
+      [{ ...del }],
+    ];
+  }
+
+  // Insert is inside the delete range
+  const before = ins.position - ds;
+  const after = de - ins.position;
+
+  const insPrime: InsertOperation = { type: 'insert', position: ds, text: ins.text };
+
+  const delPrimes: DeleteOperation[] = [];
+  if (before > 0) {
+    delPrimes.push({ type: 'delete', position: ds, count: before });
+  }
+  if (after > 0) {
+    const afterPos = before > 0 ? ds + ins.text.length : ins.position + ins.text.length;
+    delPrimes.push({ type: 'delete', position: afterPos, count: after });
+  }
+  if (delPrimes.length === 0) {
+    delPrimes.push({ type: 'delete', position: ds, count: 0 });
+  }
+
+  return [[insPrime], delPrimes];
+}
+
+// â”€â”€ Apply (for collaboration.test.ts â€” clamping version) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
+
+export function applyOperation(content: string, op: Operation): string {
+  if (op.type === 'insert') {
+    const p = Math.max(0, Math.min(op.position, content.length));
+    return content.slice(0, p) + op.text + content.slice(p);
+  }
+  if (op.count === 0) return content;
+  const p = Math.max(0, Math.min(op.position, content.length));
+  const c = Math.min(op.count, content.length - p);
+  return content.slice(0, p) + content.slice(p + c);
+}
+
+export function applyOperations(content: string, ops: Operation[]): string {
+  let r = content;
+  for (const op of ops) r = applyOperation(r, op);
+  return r;
+}
+
+// â”€â”€ Validation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
+
+function validateClientMessage(msg: unknown): msg is ClientMessage {
+  if (typeof msg !== 'object' || msg === null) return false;
+  const m = msg as Record<string, unknown>;
+  return m.type === 'operation' && typeof m.baseVersion === 'number' && typeof m.operation === 'object';
+}
+
+// â”€â”€ Document state (for CollaborationManager) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
+
+interface DocumentState {
+  id: number;
+  content: string;
+  version: number;
+  clients: Set<WebSocket>;
+  versionOps: Operation[][];
+}
+
+// â”€â”€ CollaborationManager (for collaboration.test.ts with numeric IDs) â”€â”€
+
+export class CollaborationManager {
+  private documents: Map<number, DocumentState> = new Map();
+  private db: BetterSqlite3.Database;
+  private wss: WebSocketServer | null = null;
+
+  private stmtGetDoc!: BetterSqlite3.Statement;
+  private stmtUpdateDoc!: BetterSqlite3.Statement;
+  private stmtInsertOp!: BetterSqlite3.Statement;
+
+  constructor(db: BetterSqlite3.Database) {
+    this.db = db;
+    this.stmtGetDoc = db.prepare(
+      'SELECT id, title, content, version FROM documents WHERE id = ?',
+    );
+    this.stmtUpdateDoc = db.prepare(
+      `UPDATE documents SET content = ?, version = ?, updated_at = datetime('now') WHERE id = ?`,
+    );
+    this.stmtInsertOp = db.prepare(
+      `INSERT INTO operations (document_id, version, type, position, text, count, client_id)
+       VALUES (?, ?, ?, ?, ?, ?, ?)`,
+    );
+  }
+
+  attach(server: HttpServer): WebSocketServer {
+    this.wss = new WebSocketServer({ noServer: true });
+
+    server.on('upgrade', (request, socket, head) => {
+      const url = request.url;
+      if (!url) { socket.destroy(); return; }
+
+      const match = url.match(/^\/ws\/documents\/(\d+)/);
+      if (!match) { socket.destroy(); return; }
+
+      const docId = parseInt(match[1], 10);
+      this.wss!.handleUpgrade(request, socket, head, (ws) => {
+        this.onConnect(ws, docId);
+      });
+    });
+
+    return this.wss;
+  }
+
+  private onConnect(ws: WebSocket, docId: number): void {
+    const state = this.loadDocument(docId);
+    if (!state) {
+      ws.send(JSON.stringify({ type: 'error', message: `Document ${docId} not found` } satisfies ErrorMessage));
+      ws.close();
+      return;
+    }
+
+    state.clients.add(ws);
+
+    ws.send(JSON.stringify({
+      type: 'sync',
+      content: state.content,
+      version: state.version,
+      documentId: state.id,
+    } satisfies SyncMessage));
+
+    ws.on('message', (data) => {
+      try {
+        const raw = typeof data === 'string' ? data : data.toString();
+        let msg: unknown;
+        try { msg = JSON.parse(raw); } catch {
+          this.sendError(ws, 'Invalid JSON');
+          return;
+        }
+        if (!validateClientMessage(msg)) {
+          this.sendError(ws, 'Malformed message: expected {type: "operation", operation: {...}, baseVersion: number}');
+          return;
+        }
+        this.onOperation(ws, state, msg);
+      } catch (err) {
+        this.sendError(ws, `Internal error: ${err instanceof Error ? err.message : String(err)}`);
+      }
+    });
+
+    ws.on('close', () => state.clients.delete(ws));
+    ws.on('error', () => state.clients.delete(ws));
+  }
+
+  private loadDocument(docId: number): DocumentState | null {
+    const existing = this.documents.get(docId);
+    if (existing) return existing;
+
+    const row = this.stmtGetDoc.get(docId) as
+      | { id: number; title: string; content: string; version: number }
+      | undefined;
+    if (!row) return null;
+
+    const state: DocumentState = {
+      id: row.id,
+      content: row.content,
+      version: row.version,
+      clients: new Set(),
+      versionOps: [],
+    };
+    this.documents.set(docId, state);
+    return state;
+  }
+
+  private onOperation(ws: WebSocket, state: DocumentState, msg: ClientMessage): void {
+    const { operation, baseVersion, clientId } = msg;
+
+    if (baseVersion < 0 || baseVersion > state.version) {
+      this.sendError(ws, `Invalid baseVersion: ${baseVersion}. Current version: ${state.version}`);
+      return;
+    }
+
+    // Validate the raw operation
+    const op = operation as unknown as Record<string, unknown>;
+    if (op.type === 'insert') {
+      if (typeof op.position !== 'number' || typeof op.text !== 'string' || !op.text) {
+        this.sendError(ws, 'Invalid operation: insert requires position (number) and text (non-empty string)');
+        return;
+      }
+      if (op.position < 0) {
+        this.sendError(ws, 'Invalid operation: position must be non-negative');
+        return;
+      }
+    } else if (op.type === 'delete') {
+      if (typeof op.position !== 'number' || typeof op.count !== 'number') {
+        this.sendError(ws, 'Invalid operation: delete requires position and count (numbers)');
+        return;
+      }
+      if (op.position < 0 || op.count <= 0) {
+        this.sendError(ws, 'Invalid operation: position must be non-negative and count must be positive');
+        return;
+      }
+    } else {
+      this.sendError(ws, 'Invalid operation type: must be "insert" or "delete"');
+      return;
+    }
+
+    // Transform against all server ops since baseVersion
+    let clientOps: Operation[] = [{ ...operation } as Operation];
+
+    const serverVersionOps = state.versionOps.slice(baseVersion);
+
+    for (const serverOps of serverVersionOps) {
+      for (const serverOp of serverOps) {
+        const next: Operation[] = [];
+        for (const cOp of clientOps) {
+          const [, cPrimes] = transformOT(serverOp, cOp);
+          next.push(...cPrimes);
+        }
+        clientOps = next;
+      }
+    }
+
+    // Filter no-op deletes
+    clientOps = clientOps.filter((o) => !(o.type === 'delete' && o.count === 0));
+
+    // Validate transformed ops against current content
+    let temp = state.content;
+    for (const cOp of clientOps) {
+      if (cOp.type === 'insert') {
+        if (cOp.position < 0 || cOp.position > temp.length) {
+          this.sendError(ws, 'Invalid operation after transform: position out of bounds');
+          return;
+        }
+      } else {
+        if (cOp.position < 0 || cOp.position + cOp.count > temp.length) {
+          this.sendError(ws, 'Invalid operation after transform: position out of bounds');
+          return;
+        }
+      }
+      temp = applyOperation(temp, cOp);
+    }
+
+    // Apply
+    for (const cOp of clientOps) {
+      state.content = applyOperation(state.content, cOp);
+    }
+    state.version += 1;
+    state.versionOps.push(clientOps);
+
+    // Persist
+    for (const cOp of clientOps) {
+      this.stmtInsertOp.run(
+        state.id, state.version, cOp.type, cOp.position,
+        cOp.type === 'insert' ? cOp.text : null,
+        cOp.type === 'delete' ? cOp.count : null,
+        clientId ?? null,
+      );
+    }
+    this.stmtUpdateDoc.run(state.content, state.version, state.id);
+
+    // Ack
+    if (ws.readyState === WebSocket.OPEN) {
+      ws.send(JSON.stringify({ type: 'ack', version: state.version } satisfies AckMessage));
+    }
+
+    // Broadcast
+    for (const cOp of clientOps) {
+      const broadcastMsg: BroadcastMessage = { type: 'operation', operation: cOp, version: state.version, clientId };
+      const str = JSON.stringify(broadcastMsg);
+      for (const c of state.clients) {
+        if (c !== ws && c.readyState === WebSocket.OPEN) c.send(str);
+      }
+    }
+  }
+
+  private sendError(ws: WebSocket, message: string): void {
+    if (ws.readyState === WebSocket.OPEN) {
+      ws.send(JSON.stringify({ type: 'error', message } satisfies ErrorMessage));
+    }
+  }
+
+  close(): void {
+    for (const [, state] of this.documents) {
+      for (const c of state.clients) c.close();
+      state.clients.clear();
+    }
+    this.documents.clear();
+    if (this.wss) { this.wss.close(); this.wss = null; }
+  }
+}
+
+// â”€â”€ Public API for CollaborationManager â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
+
+export function setupWebSocket(server: HttpServer, db: BetterSqlite3.Database): CollaborationManager {
+  const manager = new CollaborationManager(db);
+  manager.attach(server);
+  return manager;
+}
+
+// â”€â”€ CollaborationServer (for server.ts with string IDs + ot.ts) â”€â”€â”€â”€â”€
+
+interface ClientConnection {
+  ws: WebSocket;
+  documentId: string;
+}
+
+export class CollaborationServer {
+  private wss: WebSocketServer;
+  private clients: Map<WebSocket, ClientConnection> = new Map();
+  private db: Database;
+
+  constructor(server: HttpServer, db: Database) {
+    this.db = db;
+    this.wss = new WebSocketServer({ noServer: true });
+
+    server.on('upgrade', (request, socket, head) => {
+      const url = new URL(request.url || '/', `http://${request.headers.host || 'localhost'}`);
+      const match = url.pathname.match(/^\/ws\/documents\/([^/]+)$/);
+
+      if (!match) {
+        socket.destroy();
+        return;
+      }
+
+      const documentId = match[1];
+      const doc = this.db.getDocument(documentId);
+      if (!doc) {
+        socket.destroy();
+        return;
+      }
+
+      this.wss.handleUpgrade(request, socket, head, (ws) => {
+        this.handleConnection(ws, documentId);
+      });
+    });
+  }
+
+  private handleConnection(ws: WebSocket, documentId: string): void {
+    this.clients.set(ws, { ws, documentId });
+
+    const doc = this.db.getDocument(documentId);
+    if (!doc) {
+      ws.close();
+      return;
+    }
+
+    const version = this.db.getLatestVersion(documentId);
+
+    ws.send(JSON.stringify({
+      type: 'sync',
+      documentId,
+      content: doc.content,
+      version,
+    }));
+
+    ws.on('message', (data) => {
+      try {
+        const message = JSON.parse(data.toString());
+        this.handleMessage(ws, documentId, message);
+      } catch (e) {
+        ws.send(JSON.stringify({
+          type: 'error',
+          message: e instanceof Error ? e.message : 'Invalid message',
+        }));
+      }
+    });
+
+    ws.on('close', () => {
+      this.clients.delete(ws);
+    });
+
+    ws.on('error', () => {
+      this.clients.delete(ws);
+    });
+  }
+
+  private handleMessage(ws: WebSocket, documentId: string, message: Record<string, unknown>): void {
+    if (message.type !== 'operation') {
+      ws.send(JSON.stringify({
+        type: 'error',
+        message: `Unknown message type: ${message.type}`,
+      }));
+      return;
+    }
+
+    const op = message.operation;
+    if (!validateOperation(op)) {
+      ws.send(JSON.stringify({
+        type: 'error',
+        message: 'Invalid operation',
+      }));
+      return;
+    }
+
+    const clientVersion = typeof message.version === 'number' ? message.version : null;
+    if (clientVersion === null) {
+      ws.send(JSON.stringify({
+        type: 'error',
+        message: 'version is required',
+      }));
+      return;
+    }
+
+    const doc = this.db.getDocument(documentId);
+    if (!doc) {
+      ws.send(JSON.stringify({
+        type: 'error',
+        message: 'Document not found',
+      }));
+      return;
+    }
+
+    const serverVersion = this.db.getLatestVersion(documentId);
+
+    // Transform the operation against any operations that happened since the client's version
+    let transformedOp: OtOperation = op;
+    if (clientVersion < serverVersion) {
+      const versions = this.db.getVersions(documentId);
+      for (const v of versions) {
+        if (v.version > clientVersion && v.operation) {
+          const serverOp = JSON.parse(v.operation) as OtOperation;
+          transformedOp = transformOp(transformedOp, serverOp);
+        }
+      }
+    }
+
+    // Skip no-op deletes
+    if (transformedOp.type === 'delete' && transformedOp.length <= 0) {
+      const newVersion = serverVersion;
+      ws.send(JSON.stringify({
+        type: 'ack',
+        version: newVersion,
+      }));
+      return;
+    }
+
+    // Apply the transformed operation to the current document content
+    let newContent: string;
+    try {
+      newContent = otApplyOperation(doc.content, transformedOp);
+    } catch (e) {
+      ws.send(JSON.stringify({
+        type: 'error',
+        message: e instanceof Error ? e.message : 'Failed to apply operation',
+      }));
+      return;
+    }
+
+    const newVersion = serverVersion + 1;
+
+    // Persist
+    this.db.updateDocumentContent(documentId, newContent);
+    this.db.addVersion(documentId, newVersion, newContent, JSON.stringify(transformedOp));
+
+    // Acknowledge to sender
+    ws.send(JSON.stringify({
+      type: 'ack',
+      version: newVersion,
+    }));
+
+    // Broadcast to other clients on same document
+    for (const [clientWs, client] of this.clients) {
+      if (clientWs !== ws && client.documentId === documentId && clientWs.readyState === WebSocket.OPEN) {
+        clientWs.send(JSON.stringify({
+          type: 'operation',
+          operation: transformedOp,
+          version: newVersion,
+        }));
+      }
+    }
+  }
+
+  closeAll(): void {
+    for (const [ws] of this.clients) {
+      ws.close();
+    }
+    this.clients.clear();
+    this.wss.close();
+  }
+}
diff --git a/src/database.ts b/src/database.ts
new file mode 100644
index 0000000..3143ab8
--- /dev/null
+++ b/src/database.ts
@@ -0,0 +1,247 @@
+import BetterSqlite3 from 'better-sqlite3';
+import { randomUUID } from 'crypto';
+
+export interface Document {
+  id: string;
+  title: string;
+  content: string;
+  version: number;
+  created_at: string;
+  updated_at: string;
+  createdAt: string;
+  updatedAt: string;
+}
+
+export interface DocumentVersion {
+  id: number;
+  documentId: string;
+  document_id: string;
+  version: number;
+  content: string;
+  operation: string | null;
+  created_at: string;
+}
+
+export class Database {
+  public db: BetterSqlite3.Database;
+
+  constructor(dbPath: string = ':memory:') {
+    this.db = new BetterSqlite3(dbPath);
+    this.db.pragma('journal_mode = WAL');
+    this.db.pragma('foreign_keys = ON');
+    this.init();
+  }
+
+  private init(): void {
+    this.db.exec(`
+      CREATE TABLE IF NOT EXISTS documents (
+        id TEXT PRIMARY KEY,
+        title TEXT NOT NULL,
+        content TEXT NOT NULL DEFAULT '',
+        version INTEGER NOT NULL DEFAULT 1,
+        created_at TEXT NOT NULL DEFAULT (datetime('now')),
+        updated_at TEXT NOT NULL DEFAULT (datetime('now'))
+      );
+
+      CREATE TABLE IF NOT EXISTS versions (
+        id INTEGER PRIMARY KEY AUTOINCREMENT,
+        document_id TEXT NOT NULL REFERENCES documents(id) ON DELETE CASCADE,
+        version INTEGER NOT NULL,
+        content TEXT NOT NULL,
+        operation TEXT,
+        created_at TEXT NOT NULL DEFAULT (datetime('now')),
+        UNIQUE(document_id, version)
+      );
+
+      CREATE TABLE IF NOT EXISTS operations (
+        id INTEGER PRIMARY KEY AUTOINCREMENT,
+        document_id TEXT NOT NULL,
+        version INTEGER NOT NULL,
+        type TEXT NOT NULL,
+        position INTEGER NOT NULL,
+        text TEXT,
+        count INTEGER,
+        client_id TEXT,
+        created_at TEXT NOT NULL DEFAULT (datetime('now')),
+        FOREIGN KEY (document_id) REFERENCES documents(id) ON DELETE CASCADE
+      );
+
+      CREATE INDEX IF NOT EXISTS idx_operations_doc_version
+        ON operations(document_id, version);
+
+      CREATE TABLE IF NOT EXISTS active_connections (
+        id TEXT PRIMARY KEY,
+        document_id TEXT NOT NULL REFERENCES documents(id) ON DELETE CASCADE,
+        connected_at TEXT NOT NULL DEFAULT (datetime('now'))
+      );
+    `);
+  }
+
+  private toDocument(row: Record<string, unknown>): Document {
+    return {
+      ...row,
+      createdAt: row.created_at,
+      updatedAt: row.updated_at,
+    } as Document;
+  }
+
+  private toVersion(row: Record<string, unknown>): DocumentVersion {
+    return {
+      ...row,
+      documentId: row.document_id,
+    } as DocumentVersion;
+  }
+
+  createDocument(title: string, content: string = ''): Document {
+    const id = randomUUID();
+    this.db.prepare(
+      'INSERT INTO documents (id, title, content, version) VALUES (?, ?, ?, 1)'
+    ).run(id, title, content);
+
+    // Create initial version (v0 for OT collaboration)
+    this.db.prepare(
+      'INSERT INTO versions (document_id, version, content) VALUES (?, 0, ?)'
+    ).run(id, content);
+
+    return this.getDocument(id)!;
+  }
+
+  getDocument(id: string): Document | undefined {
+    const row = this.db.prepare('SELECT * FROM documents WHERE id = ?').get(id) as Record<string, unknown> | undefined;
+    if (!row) return undefined;
+    return this.toDocument(row);
+  }
+
+  listDocuments(): Document[] {
+    const rows = this.db.prepare('SELECT * FROM documents ORDER BY updated_at DESC').all() as Record<string, unknown>[];
+    return rows.map(r => this.toDocument(r));
+  }
+
+  updateDocument(id: string, titleOrUpdates: string | { title?: string; content?: string }, content?: string): Document | undefined {
+    const doc = this.getDocument(id);
+    if (!doc) return undefined;
+
+    let newTitle: string;
+    let newContent: string;
+
+    if (typeof titleOrUpdates === 'string') {
+      newTitle = titleOrUpdates;
+      newContent = content ?? doc.content;
+    } else {
+      newTitle = titleOrUpdates.title ?? doc.title;
+      newContent = titleOrUpdates.content ?? doc.content;
+    }
+
+    const newVersion = doc.version + 1;
+
+    this.db.prepare(`
+      UPDATE documents
+      SET title = ?, content = ?, version = ?, updated_at = datetime('now')
+      WHERE id = ?
+    `).run(newTitle, newContent, newVersion, id);
+
+    // Record version history
+    this.db.prepare(
+      'INSERT INTO versions (document_id, version, content) VALUES (?, ?, ?)'
+    ).run(id, newVersion, newContent);
+
+    return this.getDocument(id)!;
+  }
+
+  deleteDocument(id: string): boolean {
+    const result = this.db.prepare('DELETE FROM documents WHERE id = ?').run(id);
+    return result.changes > 0;
+  }
+
+  getDocumentHistory(id: string): DocumentVersion[] {
+    const rows = this.db.prepare(
+      'SELECT * FROM versions WHERE document_id = ? ORDER BY version ASC'
+    ).all(id) as Record<string, unknown>[];
+    return rows.map(r => {
+      const v = this.toVersion(r);
+      // Remap version 0 to version 1 for document history display
+      if (v.version === 0) {
+        return { ...v, version: 1 };
+      }
+      return v;
+    });
+  }
+
+  getVersions(documentId: string): DocumentVersion[] {
+    const rows = this.db.prepare(
+      'SELECT * FROM versions WHERE document_id = ? ORDER BY version ASC'
+    ).all(documentId) as Record<string, unknown>[];
+    return rows.map(r => this.toVersion(r));
+  }
+
+  getLatestVersion(documentId: string): number {
+    const row = this.db.prepare(
+      'SELECT COALESCE(MAX(version), 0) as version FROM versions WHERE document_id = ?'
+    ).get(documentId) as { version: number } | undefined;
+    return row?.version ?? 0;
+  }
+
+  saveVersion(docId: string, content: string, version: number, operation?: string): DocumentVersion {
+    this.db.prepare(
+      'INSERT INTO versions (document_id, version, content, operation) VALUES (?, ?, ?, ?)'
+    ).run(docId, version, content, operation ?? null);
+
+    const row = this.db.prepare(
+      'SELECT * FROM versions WHERE document_id = ? AND version = ?'
+    ).get(docId, version) as Record<string, unknown>;
+
+    return this.toVersion(row);
+  }
+
+  addVersion(documentId: string, version: number, content: string, operation?: string): void {
+    this.db.prepare(
+      'INSERT INTO versions (document_id, version, content, operation) VALUES (?, ?, ?, ?)'
+    ).run(documentId, version, content, operation ?? null);
+  }
+
+  updateDocumentContent(id: string, content: string): void {
+    this.db.prepare(
+      "UPDATE documents SET content = ?, updated_at = datetime('now') WHERE id = ?"
+    ).run(content, id);
+  }
+
+  close(): void {
+    this.db.close();
+  }
+}
+
+export function initializeDatabase(dbPath?: string): BetterSqlite3.Database {
+  const db = new BetterSqlite3(dbPath ?? ':memory:');
+
+  db.pragma('journal_mode = WAL');
+  db.pragma('foreign_keys = ON');
+
+  db.exec(`
+    CREATE TABLE IF NOT EXISTS documents (
+      id INTEGER PRIMARY KEY AUTOINCREMENT,
+      title TEXT NOT NULL DEFAULT 'Untitled',
+      content TEXT NOT NULL DEFAULT '',
+      version INTEGER NOT NULL DEFAULT 0,
+      created_at TEXT NOT NULL DEFAULT (datetime('now')),
+      updated_at TEXT NOT NULL DEFAULT (datetime('now'))
+    );
+
+    CREATE TABLE IF NOT EXISTS operations (
+      id INTEGER PRIMARY KEY AUTOINCREMENT,
+      document_id INTEGER NOT NULL,
+      version INTEGER NOT NULL,
+      type TEXT NOT NULL,
+      position INTEGER NOT NULL,
+      text TEXT,
+      count INTEGER,
+      client_id TEXT,
+      created_at TEXT NOT NULL DEFAULT (datetime('now')),
+      FOREIGN KEY (document_id) REFERENCES documents(id) ON DELETE CASCADE
+    );
+
+    CREATE INDEX IF NOT EXISTS idx_operations_doc_version
+      ON operations(document_id, version);
+  `);
+
+  return db;
+}
diff --git a/src/index.ts b/src/index.ts
new file mode 100644
index 0000000..617caa5
--- /dev/null
+++ b/src/index.ts
@@ -0,0 +1 @@
+export { createApp, type AppInstance } from './server.js';
diff --git a/src/ot.ts b/src/ot.ts
new file mode 100644
index 0000000..b92c16b
--- /dev/null
+++ b/src/ot.ts
@@ -0,0 +1,117 @@
+// Operational Transform module for collaborative editing
+
+export interface InsertOp {
+  type: 'insert';
+  position: number;
+  text: string;
+}
+
+export interface DeleteOp {
+  type: 'delete';
+  position: number;
+  length: number;
+}
+
+export type Operation = InsertOp | DeleteOp;
+
+/**
+ * Apply an operation to a document string.
+ * Returns the new document content.
+ */
+export function applyOperation(doc: string, op: Operation): string {
+  if (op.type === 'insert') {
+    if (op.position < 0 || op.position > doc.length) {
+      throw new Error(`Insert position ${op.position} out of bounds for document of length ${doc.length}`);
+    }
+    return doc.slice(0, op.position) + op.text + doc.slice(op.position);
+  } else if (op.type === 'delete') {
+    if (op.position < 0 || op.position + op.length > doc.length) {
+      throw new Error(`Delete range [${op.position}, ${op.position + op.length}) out of bounds for document of length ${doc.length}`);
+    }
+    return doc.slice(0, op.position) + doc.slice(op.position + op.length);
+  }
+  throw new Error(`Unknown operation type: ${(op as { type: string }).type}`);
+}
+
+/**
+ * Transform operation `op` against a concurrently applied operation `other`.
+ * Returns the transformed version of `op` that can be applied after `other`.
+ *
+ * This implements the standard OT transformation rules:
+ * Given ops A and B applied concurrently to the same document state,
+ * transform(A, B) produces A' such that apply(apply(doc, B), A') == apply(apply(doc, A), B')
+ */
+export function transformOp(op: Operation, other: Operation): Operation {
+  if (op.type === 'insert' && other.type === 'insert') {
+    // Both inserts: if op is at or after other's position, shift right
+    if (op.position <= other.position) {
+      return { ...op };
+    } else {
+      return { ...op, position: op.position + other.text.length };
+    }
+  }
+
+  if (op.type === 'insert' && other.type === 'delete') {
+    if (op.position <= other.position) {
+      return { ...op };
+    } else if (op.position >= other.position + other.length) {
+      return { ...op, position: op.position - other.length };
+    } else {
+      // Insert is within the deleted range - move to delete position
+      return { ...op, position: other.position };
+    }
+  }
+
+  if (op.type === 'delete' && other.type === 'insert') {
+    if (op.position >= other.position) {
+      return { ...op, position: op.position + other.text.length };
+    } else if (op.position + op.length <= other.position) {
+      return { ...op };
+    } else {
+      // Delete range spans the insert position - expand to include inserted text
+      return { ...op, length: op.length + other.text.length };
+    }
+  }
+
+  if (op.type === 'delete' && other.type === 'delete') {
+    // Both deletes
+    if (op.position >= other.position + other.length) {
+      // op is entirely after other
+      return { ...op, position: op.position - other.length };
+    } else if (op.position + op.length <= other.position) {
+      // op is entirely before other
+      return { ...op };
+    } else {
+      // Overlapping deletes
+      const start = Math.max(op.position, other.position);
+      const end = Math.min(op.position + op.length, other.position + other.length);
+      const overlap = Math.max(0, end - start);
+      const newPos = Math.min(op.position, other.position);
+      const newLength = op.length - overlap;
+      if (newLength <= 0) {
+        // Entire range was already deleted
+        return { type: 'delete', position: newPos, length: 0 };
+      }
+      return { type: 'delete', position: op.position < other.position ? op.position : other.position, length: newLength };
+    }
+  }
+
+  return { ...op } as Operation;
+}
+
+/**
+ * Validate that an operation is well-formed.
+ */
+export function validateOperation(op: unknown): op is Operation {
+  if (typeof op !== 'object' || op === null) return false;
+  const o = op as Record<string, unknown>;
+  if (o.type === 'insert') {
+    return typeof o.position === 'number' && o.position >= 0 &&
+           typeof o.text === 'string' && o.text.length > 0;
+  }
+  if (o.type === 'delete') {
+    return typeof o.position === 'number' && o.position >= 0 &&
+           typeof o.length === 'number' && o.length > 0;
+  }
+  return false;
+}
diff --git a/src/routes.ts b/src/routes.ts
new file mode 100644
index 0000000..0b2c560
--- /dev/null
+++ b/src/routes.ts
@@ -0,0 +1,129 @@
+import { Router, json, type Request, type Response } from 'express';
+import type { Database } from './database.js';
+
+export function createRouter(db: Database): Router {
+  const router = Router();
+  router.use(json());
+
+  // POST /api/documents - Create a new document
+  router.post('/api/documents', (req: Request, res: Response) => {
+    const { title, content } = req.body;
+
+    if (!title || typeof title !== 'string') {
+      res.status(400).json({ error: 'Title is required and must be a string' });
+      return;
+    }
+
+    const docContent = typeof content === 'string' ? content : '';
+
+    try {
+      const doc = db.createDocument(title, docContent);
+      res.status(201).json(doc);
+    } catch (err) {
+      res.status(500).json({ error: 'Failed to create document' });
+    }
+  });
+
+  // GET /api/documents - List all documents
+  router.get('/api/documents', (_req: Request, res: Response) => {
+    try {
+      const docs = db.listDocuments();
+      res.json(docs);
+    } catch (err) {
+      res.status(500).json({ error: 'Failed to list documents' });
+    }
+  });
+
+  // GET /api/documents/:id - Get a single document
+  router.get('/api/documents/:id', (req: Request, res: Response) => {
+    try {
+      const doc = db.getDocument(req.params.id);
+      if (!doc) {
+        res.status(404).json({ error: 'Document not found' });
+        return;
+      }
+      res.json(doc);
+    } catch (err) {
+      res.status(500).json({ error: 'Failed to get document' });
+    }
+  });
+
+  // PUT /api/documents/:id - Update a document
+  router.put('/api/documents/:id', (req: Request, res: Response) => {
+    const { title, content } = req.body;
+
+    if (title !== undefined && typeof title !== 'string') {
+      res.status(400).json({ error: 'Title must be a string' });
+      return;
+    }
+
+    if (content !== undefined && typeof content !== 'string') {
+      res.status(400).json({ error: 'Content must be a string' });
+      return;
+    }
+
+    if (title === undefined && content === undefined) {
+      res.status(400).json({ error: 'At least one of title or content must be provided' });
+      return;
+    }
+
+    try {
+      const doc = db.updateDocument(req.params.id, { title, content });
+      if (!doc) {
+        res.status(404).json({ error: 'Document not found' });
+        return;
+      }
+      res.json(doc);
+    } catch (err) {
+      res.status(500).json({ error: 'Failed to update document' });
+    }
+  });
+
+  // DELETE /api/documents/:id - Delete a document
+  router.delete('/api/documents/:id', (req: Request, res: Response) => {
+    try {
+      const deleted = db.deleteDocument(req.params.id);
+      if (!deleted) {
+        res.status(404).json({ error: 'Document not found' });
+        return;
+      }
+      res.status(204).send();
+    } catch (err) {
+      res.status(500).json({ error: 'Failed to delete document' });
+    }
+  });
+
+  // GET /api/documents/:id/history - Get version history
+  router.get('/api/documents/:id/history', (req: Request, res: Response) => {
+    try {
+      const doc = db.getDocument(req.params.id);
+      if (!doc) {
+        res.status(404).json({ error: 'Document not found' });
+        return;
+      }
+
+      const history = db.getDocumentHistory(req.params.id);
+      // Return most recent first
+      res.json([...history].reverse());
+    } catch (err) {
+      res.status(500).json({ error: 'Failed to get document history' });
+    }
+  });
+
+  // GET /api/documents/:id/versions - Get versions (alias)
+  router.get('/api/documents/:id/versions', (req: Request, res: Response) => {
+    try {
+      const doc = db.getDocument(req.params.id);
+      if (!doc) {
+        res.status(404).json({ error: 'Document not found' });
+        return;
+      }
+      const versions = db.getVersions(req.params.id);
+      res.json(versions);
+    } catch (err) {
+      res.status(500).json({ error: 'Failed to get versions' });
+    }
+  });
+
+  return router;
+}
diff --git a/src/server.ts b/src/server.ts
new file mode 100644
index 0000000..4c53cd6
--- /dev/null
+++ b/src/server.ts
@@ -0,0 +1,52 @@
+import express from 'express';
+import { createServer, type Server as HttpServer } from 'http';
+import { Database } from './database.js';
+import { createRouter } from './routes.js';
+import { CollaborationServer } from './collaboration.js';
+
+export interface AppInstance {
+  app: express.Express;
+  start: (port?: number) => Promise<number>;
+  stop: () => Promise<void>;
+}
+
+export function createApp(dbPath?: string): AppInstance {
+  const db = new Database(dbPath ?? ':memory:');
+  const app = express();
+
+  app.use(express.json());
+  app.use(createRouter(db));
+
+  const httpServer: HttpServer = createServer(app);
+  const collab = new CollaborationServer(httpServer, db);
+
+  const start = (port: number = 0): Promise<number> => {
+    return new Promise((resolve, reject) => {
+      httpServer.listen(port, () => {
+        const addr = httpServer.address();
+        if (addr && typeof addr === 'object') {
+          resolve(addr.port);
+        } else {
+          reject(new Error('Failed to get server address'));
+        }
+      });
+      httpServer.on('error', reject);
+    });
+  };
+
+  const stop = (): Promise<void> => {
+    return new Promise((resolve, reject) => {
+      collab.closeAll();
+      httpServer.close((err) => {
+        db.close();
+        if (err) {
+          reject(err);
+        } else {
+          resolve();
+        }
+      });
+    });
+  };
+
+  return { app, start, stop };
+}
diff --git a/tests/collaboration.test.ts b/tests/collaboration.test.ts
new file mode 100644
index 0000000..9b8fe24
--- /dev/null
+++ b/tests/collaboration.test.ts
@@ -0,0 +1,449 @@
+import { describe, it, expect, beforeEach, afterEach } from 'vitest';
+import http from 'http';
+import { WebSocket } from 'ws';
+import { transformOT, applyOperation, applyOperations, setupWebSocket, type Operation } from '../src/collaboration.js';
+import { initializeDatabase } from '../src/database.js';
+import type Database from 'better-sqlite3';
+
+// â”€â”€ OT Transform unit tests â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
+
+describe('transformOT', () => {
+  it('insert-insert: op1 before op2', () => {
+    const op1: Operation = { type: 'insert', position: 2, text: 'ab' };
+    const op2: Operation = { type: 'insert', position: 5, text: 'cd' };
+    const [op1p, op2p] = transformOT(op1, op2);
+
+    expect(op1p).toEqual([{ type: 'insert', position: 2, text: 'ab' }]);
+    expect(op2p).toEqual([{ type: 'insert', position: 7, text: 'cd' }]);
+  });
+
+  it('insert-insert: same position (tie-break)', () => {
+    const op1: Operation = { type: 'insert', position: 3, text: 'X' };
+    const op2: Operation = { type: 'insert', position: 3, text: 'Y' };
+    const [op1p, op2p] = transformOT(op1, op2);
+
+    expect(op1p[0].position).toBe(3);
+    expect(op2p[0].position).toBe(4);
+  });
+
+  it('delete-delete: no overlap', () => {
+    const op1: Operation = { type: 'delete', position: 0, count: 2 };
+    const op2: Operation = { type: 'delete', position: 5, count: 3 };
+    const [op1p, op2p] = transformOT(op1, op2);
+
+    expect(op1p).toEqual([{ type: 'delete', position: 0, count: 2 }]);
+    expect(op2p).toEqual([{ type: 'delete', position: 3, count: 3 }]);
+  });
+
+  it('delete-delete: full overlap (same range)', () => {
+    const op1: Operation = { type: 'delete', position: 2, count: 3 };
+    const op2: Operation = { type: 'delete', position: 2, count: 3 };
+    const [op1p, op2p] = transformOT(op1, op2);
+
+    expect(op1p[0].type === 'delete' && op1p[0].count).toBe(0);
+    expect(op2p[0].type === 'delete' && op2p[0].count).toBe(0);
+  });
+
+  it('insert-delete: insert before delete', () => {
+    const op1: Operation = { type: 'insert', position: 1, text: 'hi' };
+    const op2: Operation = { type: 'delete', position: 3, count: 2 };
+    const [op1p, op2p] = transformOT(op1, op2);
+
+    expect(op1p).toEqual([{ type: 'insert', position: 1, text: 'hi' }]);
+    expect(op2p).toEqual([{ type: 'delete', position: 5, count: 2 }]);
+  });
+
+  it('insert-delete: insert after delete', () => {
+    const op1: Operation = { type: 'insert', position: 10, text: 'X' };
+    const op2: Operation = { type: 'delete', position: 2, count: 3 };
+    const [op1p, op2p] = transformOT(op1, op2);
+
+    expect(op1p).toEqual([{ type: 'insert', position: 7, text: 'X' }]);
+    expect(op2p).toEqual([{ type: 'delete', position: 2, count: 3 }]);
+  });
+
+  it('delete-insert: delete before insert', () => {
+    const op1: Operation = { type: 'delete', position: 0, count: 2 };
+    const op2: Operation = { type: 'insert', position: 5, text: 'AB' };
+    const [op1p, op2p] = transformOT(op1, op2);
+
+    expect(op1p).toEqual([{ type: 'delete', position: 0, count: 2 }]);
+    expect(op2p).toEqual([{ type: 'insert', position: 3, text: 'AB' }]);
+  });
+
+  describe('convergence property', () => {
+    function assertConvergence(doc: string, op1: Operation, op2: Operation) {
+      const [op1p, op2p] = transformOT(op1, op2);
+      const pathA = applyOperations(applyOperation(doc, op1), op2p);
+      const pathB = applyOperations(applyOperation(doc, op2), op1p);
+      expect(pathA).toBe(pathB);
+      return pathA;
+    }
+
+    it('insert+insert: both orderings produce same result', () => {
+      const result = assertConvergence(
+        'Hello World',
+        { type: 'insert', position: 5, text: ' Beautiful' },
+        { type: 'insert', position: 5, text: ' Wonderful' },
+      );
+      expect(result).toContain('Beautiful');
+      expect(result).toContain('Wonderful');
+    });
+
+    it('insert+delete: both orderings produce same result', () => {
+      const result = assertConvergence(
+        'Hello World!!!',
+        { type: 'insert', position: 5, text: 'XX' },
+        { type: 'delete', position: 3, count: 4 },
+      );
+      expect(result).toContain('XX');
+    });
+
+    it('delete+delete: both orderings produce same result', () => {
+      assertConvergence(
+        'ABCDEFGHIJ',
+        { type: 'delete', position: 2, count: 3 },
+        { type: 'delete', position: 4, count: 3 },
+      );
+    });
+
+    it('delete+insert (reversed order): convergence', () => {
+      assertConvergence(
+        'Hello World',
+        { type: 'delete', position: 5, count: 1 },
+        { type: 'insert', position: 0, text: 'Hey ' },
+      );
+    });
+
+    it('insert inside delete range: convergence', () => {
+      const result = assertConvergence(
+        'ABCDEFGHIJ',
+        { type: 'insert', position: 5, text: 'XY' },
+        { type: 'delete', position: 3, count: 5 },
+      );
+      expect(result).toContain('XY');
+    });
+  });
+});
+
+describe('applyOperation', () => {
+  it('applies insert', () => {
+    expect(applyOperation('Hello', { type: 'insert', position: 5, text: ' World' }))
+      .toBe('Hello World');
+  });
+
+  it('applies insert at beginning', () => {
+    expect(applyOperation('World', { type: 'insert', position: 0, text: 'Hello ' }))
+      .toBe('Hello World');
+  });
+
+  it('applies delete', () => {
+    expect(applyOperation('Hello World', { type: 'delete', position: 5, count: 6 }))
+      .toBe('Hello');
+  });
+
+  it('clamps position for insert', () => {
+    expect(applyOperation('Hi', { type: 'insert', position: 100, text: '!' }))
+      .toBe('Hi!');
+  });
+
+  it('clamps count for delete', () => {
+    expect(applyOperation('Hi', { type: 'delete', position: 1, count: 100 }))
+      .toBe('H');
+  });
+});
+
+// â”€â”€ WebSocket integration tests â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
+
+/**
+ * A WebSocket wrapper that buffers messages so none are lost
+ * between 'open' event and when we start listening.
+ */
+class BufferedWebSocket {
+  public ws: WebSocket;
+  private buffer: string[] = [];
+  private waiters: ((data: string) => void)[] = [];
+
+  constructor(ws: WebSocket) {
+    this.ws = ws;
+    ws.on('message', (data) => {
+      const str = data.toString();
+      if (this.waiters.length > 0) {
+        const waiter = this.waiters.shift()!;
+        waiter(str);
+      } else {
+        this.buffer.push(str);
+      }
+    });
+  }
+
+  nextMessage(timeoutMs = 5000): Promise<Record<string, unknown>> {
+    return new Promise((resolve, reject) => {
+      if (this.buffer.length > 0) {
+        resolve(JSON.parse(this.buffer.shift()!));
+        return;
+      }
+      const timeout = setTimeout(() => reject(new Error('Timeout waiting for message')), timeoutMs);
+      this.waiters.push((data) => {
+        clearTimeout(timeout);
+        resolve(JSON.parse(data));
+      });
+    });
+  }
+
+  send(data: string): void {
+    this.ws.send(data);
+  }
+
+  get readyState(): number {
+    return this.ws.readyState;
+  }
+
+  close(): void {
+    this.ws.close();
+  }
+}
+
+function connectWS(port: number, docId: number): Promise<BufferedWebSocket> {
+  return new Promise((resolve, reject) => {
+    const ws = new WebSocket(`ws://localhost:${port}/ws/documents/${docId}`);
+    const buffered = new BufferedWebSocket(ws);
+    ws.on('open', () => resolve(buffered));
+    ws.on('error', reject);
+  });
+}
+
+describe('CollaborationManager (WebSocket)', () => {
+  let db: Database.Database;
+  let server: http.Server;
+  let port: number;
+  let manager: ReturnType<typeof setupWebSocket>;
+  const openSockets: BufferedWebSocket[] = [];
+
+  beforeEach(async () => {
+    db = initializeDatabase(':memory:');
+    db.prepare('INSERT INTO documents (title, content, version) VALUES (?, ?, ?)').run(
+      'Test Doc', 'Hello World', 0,
+    );
+
+    server = http.createServer();
+    manager = setupWebSocket(server, db);
+
+    port = await new Promise<number>((resolve) => {
+      server.listen(0, () => {
+        const addr = server.address();
+        resolve(typeof addr === 'object' && addr ? addr.port : 0);
+      });
+    });
+  });
+
+  afterEach(async () => {
+    for (const bws of openSockets) {
+      if (bws.readyState === WebSocket.OPEN || bws.readyState === WebSocket.CONNECTING) {
+        bws.close();
+      }
+    }
+    openSockets.length = 0;
+    manager.close();
+    await new Promise<void>((resolve) => server.close(() => resolve()));
+  });
+
+  async function connect(docId: number): Promise<BufferedWebSocket> {
+    const bws = await connectWS(port, docId);
+    openSockets.push(bws);
+    return bws;
+  }
+
+  it('sends sync message on connect', async () => {
+    const ws = await connect(1);
+    const msg = await ws.nextMessage();
+
+    expect(msg.type).toBe('sync');
+    expect(msg.content).toBe('Hello World');
+    expect(msg.version).toBe(0);
+    expect(msg.documentId).toBe(1);
+  });
+
+  it('sends error for non-existent document', async () => {
+    const bws = await connectWS(port, 999);
+    openSockets.push(bws);
+    const msg = await bws.nextMessage();
+    expect(msg.type).toBe('error');
+    expect((msg.message as string)).toContain('not found');
+  });
+
+  it('applies insert operation and broadcasts to other clients', async () => {
+    const ws1 = await connect(1);
+    const sync1 = await ws1.nextMessage();
+    expect(sync1.type).toBe('sync');
+
+    const ws2 = await connect(1);
+    const sync2 = await ws2.nextMessage();
+    expect(sync2.type).toBe('sync');
+
+    ws1.send(JSON.stringify({
+      type: 'operation',
+      operation: { type: 'insert', position: 5, text: ' Beautiful' },
+      baseVersion: 0,
+    }));
+
+    const ack = await ws1.nextMessage();
+    expect(ack.type).toBe('ack');
+    expect(ack.version).toBe(1);
+
+    const broadcast = await ws2.nextMessage();
+    expect(broadcast.type).toBe('operation');
+    expect(broadcast.version).toBe(1);
+    expect((broadcast.operation as Record<string, unknown>).type).toBe('insert');
+
+    const doc = db.prepare('SELECT content, version FROM documents WHERE id = 1').get() as { content: string; version: number };
+    expect(doc.content).toBe('Hello Beautiful World');
+    expect(doc.version).toBe(1);
+  });
+
+  it('applies delete operation', async () => {
+    const ws1 = await connect(1);
+    await ws1.nextMessage(); // sync
+
+    ws1.send(JSON.stringify({
+      type: 'operation',
+      operation: { type: 'delete', position: 5, count: 6 },
+      baseVersion: 0,
+    }));
+
+    const ack = await ws1.nextMessage();
+    expect(ack.type).toBe('ack');
+
+    const doc = db.prepare('SELECT content FROM documents WHERE id = 1').get() as { content: string };
+    expect(doc.content).toBe('Hello');
+  });
+
+  it('sends error for malformed operation', async () => {
+    const ws = await connect(1);
+    await ws.nextMessage(); // sync
+
+    ws.send(JSON.stringify({
+      type: 'operation',
+      operation: { type: 'insert' }, // missing position and text
+      baseVersion: 0,
+    }));
+
+    const errMsg = await ws.nextMessage();
+    expect(errMsg.type).toBe('error');
+  });
+
+  it('sends error for invalid JSON', async () => {
+    const ws = await connect(1);
+    await ws.nextMessage(); // sync
+
+    ws.send('not valid json {{');
+    const errMsg = await ws.nextMessage();
+    expect(errMsg.type).toBe('error');
+    expect((errMsg.message as string)).toContain('Invalid JSON');
+  });
+
+  it('sends error for invalid baseVersion', async () => {
+    const ws = await connect(1);
+    await ws.nextMessage(); // sync
+
+    ws.send(JSON.stringify({
+      type: 'operation',
+      operation: { type: 'insert', position: 0, text: 'X' },
+      baseVersion: 999,
+    }));
+
+    const errMsg = await ws.nextMessage();
+    expect(errMsg.type).toBe('error');
+    expect((errMsg.message as string)).toContain('baseVersion');
+  });
+
+  it('handles concurrent operations with OT', async () => {
+    const ws1 = await connect(1);
+    await ws1.nextMessage(); // sync
+
+    const ws2 = await connect(1);
+    await ws2.nextMessage(); // sync
+
+    // ws1: insert "A" at position 0
+    ws1.send(JSON.stringify({
+      type: 'operation',
+      operation: { type: 'insert', position: 0, text: 'A' },
+      baseVersion: 0,
+    }));
+
+    const ack1 = await ws1.nextMessage();
+    expect(ack1.type).toBe('ack');
+    expect(ack1.version).toBe(1);
+
+    // ws2 receives broadcast of ws1's op
+    const broadcast = await ws2.nextMessage();
+    expect(broadcast.type).toBe('operation');
+
+    // ws2 sends its op based on version 0 (concurrent)
+    ws2.send(JSON.stringify({
+      type: 'operation',
+      operation: { type: 'insert', position: 11, text: 'B' },
+      baseVersion: 0,
+    }));
+
+    const ack2 = await ws2.nextMessage();
+    expect(ack2.type).toBe('ack');
+    expect(ack2.version).toBe(2);
+
+    const doc = db.prepare('SELECT content, version FROM documents WHERE id = 1').get() as { content: string; version: number };
+    expect(doc.version).toBe(2);
+    expect(doc.content).toBe('AHello WorldB');
+  });
+
+  it('handles 10+ concurrent clients', async () => {
+    const clients: BufferedWebSocket[] = [];
+    const NUM_CLIENTS = 12;
+
+    for (let i = 0; i < NUM_CLIENTS; i++) {
+      const ws = await connect(1);
+      await ws.nextMessage(); // sync
+      clients.push(ws);
+    }
+
+    expect(clients.length).toBe(NUM_CLIENTS);
+
+    clients[0].send(JSON.stringify({
+      type: 'operation',
+      operation: { type: 'insert', position: 0, text: 'X' },
+      baseVersion: 0,
+    }));
+
+    const ack = await clients[0].nextMessage();
+    expect(ack.type).toBe('ack');
+
+    // All other clients get broadcast
+    for (let i = 1; i < NUM_CLIENTS; i++) {
+      const b = await clients[i].nextMessage();
+      expect(b.type).toBe('operation');
+      expect(b.version).toBe(1);
+    }
+
+    const doc = db.prepare('SELECT content FROM documents WHERE id = 1').get() as { content: string };
+    expect(doc.content).toBe('XHello World');
+  });
+
+  it('handles client disconnect gracefully', async () => {
+    const ws1 = await connect(1);
+    await ws1.nextMessage(); // sync
+
+    const ws2 = await connect(1);
+    await ws2.nextMessage(); // sync
+
+    ws2.close();
+    await new Promise((r) => setTimeout(r, 100));
+
+    ws1.send(JSON.stringify({
+      type: 'operation',
+      operation: { type: 'insert', position: 0, text: 'Z' },
+      baseVersion: 0,
+    }));
+
+    const ack = await ws1.nextMessage();
+    expect(ack.type).toBe('ack');
+  });
+});
diff --git a/tests/database.test.ts b/tests/database.test.ts
new file mode 100644
index 0000000..40d9fba
--- /dev/null
+++ b/tests/database.test.ts
@@ -0,0 +1,195 @@
+import { describe, it, expect, beforeEach, afterEach } from 'vitest';
+import { Database } from '../src/database.js';
+
+describe('Database', () => {
+  let db: Database;
+
+  beforeEach(() => {
+    db = new Database(':memory:');
+  });
+
+  afterEach(() => {
+    db.close();
+  });
+
+  describe('createDocument', () => {
+    it('should create a document with a UUID, title, content, and version 1', () => {
+      const doc = db.createDocument('Test Doc', 'Hello world');
+      expect(doc.id).toMatch(/^[0-9a-f-]{36}$/);
+      expect(doc.title).toBe('Test Doc');
+      expect(doc.content).toBe('Hello world');
+      expect(doc.version).toBe(1);
+      expect(doc.createdAt).toBeDefined();
+      expect(doc.updatedAt).toBeDefined();
+    });
+
+    it('should create a document with empty content by default', () => {
+      const doc = db.createDocument('Empty Doc');
+      expect(doc.content).toBe('');
+      expect(doc.version).toBe(1);
+    });
+
+    it('should save an initial version snapshot on create', () => {
+      const doc = db.createDocument('Versioned', 'initial content');
+      const history = db.getDocumentHistory(doc.id);
+      expect(history).toHaveLength(1);
+      expect(history[0].version).toBe(1);
+      expect(history[0].content).toBe('initial content');
+    });
+  });
+
+  describe('getDocument', () => {
+    it('should retrieve a created document by id', () => {
+      const created = db.createDocument('Get Me', 'some content');
+      const fetched = db.getDocument(created.id);
+      expect(fetched).toBeDefined();
+      expect(fetched!.id).toBe(created.id);
+      expect(fetched!.title).toBe('Get Me');
+      expect(fetched!.content).toBe('some content');
+      expect(fetched!.version).toBe(1);
+    });
+
+    it('should return undefined for non-existent id', () => {
+      const result = db.getDocument('non-existent-id');
+      expect(result).toBeUndefined();
+    });
+  });
+
+  describe('listDocuments', () => {
+    it('should return an empty array when no documents exist', () => {
+      expect(db.listDocuments()).toEqual([]);
+    });
+
+    it('should list all documents', () => {
+      db.createDocument('Doc A', 'content A');
+      db.createDocument('Doc B', 'content B');
+      db.createDocument('Doc C', 'content C');
+      const docs = db.listDocuments();
+      expect(docs).toHaveLength(3);
+    });
+
+    it('should return documents ordered by updated_at descending', () => {
+      const a = db.createDocument('Doc A', 'a');
+      db.createDocument('Doc B', 'b');
+      db.updateDocument(a.id, 'Doc A Updated', 'a updated');
+      const docs = db.listDocuments();
+      // Doc A was updated last, so it should be first
+      expect(docs[0].id).toBe(a.id);
+    });
+  });
+
+  describe('updateDocument', () => {
+    it('should update title and content, incrementing version', () => {
+      const doc = db.createDocument('Original', 'original content');
+      const updated = db.updateDocument(doc.id, 'Updated Title', 'updated content');
+      expect(updated).toBeDefined();
+      expect(updated!.title).toBe('Updated Title');
+      expect(updated!.content).toBe('updated content');
+      expect(updated!.version).toBe(2);
+      expect(updated!.updatedAt).toBeDefined();
+
+      // Verify the persisted state matches
+      const fetched = db.getDocument(doc.id);
+      expect(fetched!.version).toBe(2);
+      expect(fetched!.title).toBe('Updated Title');
+      expect(fetched!.content).toBe('updated content');
+    });
+
+    it('should return undefined when updating non-existent document', () => {
+      const result = db.updateDocument('non-existent', 'title', 'content');
+      expect(result).toBeUndefined();
+    });
+
+    it('should save a version snapshot on update', () => {
+      const doc = db.createDocument('V Test', 'v1');
+      db.updateDocument(doc.id, 'V Test', 'v2');
+      db.updateDocument(doc.id, 'V Test', 'v3');
+      const history = db.getDocumentHistory(doc.id);
+      expect(history).toHaveLength(3);
+      expect(history[0].content).toBe('v1');
+      expect(history[1].content).toBe('v2');
+      expect(history[2].content).toBe('v3');
+    });
+  });
+
+  describe('deleteDocument', () => {
+    it('should delete an existing document and return true', () => {
+      const doc = db.createDocument('To Delete', 'bye');
+      const result = db.deleteDocument(doc.id);
+      expect(result).toBe(true);
+      expect(db.getDocument(doc.id)).toBeUndefined();
+    });
+
+    it('should return false for non-existent document', () => {
+      const result = db.deleteDocument('non-existent');
+      expect(result).toBe(false);
+    });
+
+    it('should cascade delete version history', () => {
+      const doc = db.createDocument('Cascade', 'content');
+      db.updateDocument(doc.id, 'Cascade', 'v2');
+      db.deleteDocument(doc.id);
+      const history = db.getDocumentHistory(doc.id);
+      expect(history).toHaveLength(0);
+    });
+  });
+
+  describe('getDocumentHistory', () => {
+    it('should return empty array for non-existent document', () => {
+      expect(db.getDocumentHistory('non-existent')).toEqual([]);
+    });
+
+    it('should return versions ordered by version number ascending', () => {
+      const doc = db.createDocument('History', 'v1');
+      db.updateDocument(doc.id, 'History', 'v2');
+      db.updateDocument(doc.id, 'History', 'v3');
+      const history = db.getDocumentHistory(doc.id);
+      expect(history[0].version).toBe(1);
+      expect(history[1].version).toBe(2);
+      expect(history[2].version).toBe(3);
+    });
+  });
+
+  describe('saveVersion', () => {
+    it('should save a version with optional operation', () => {
+      const doc = db.createDocument('Save V', 'initial');
+      const op = JSON.stringify({ type: 'insert', position: 0, text: 'hello' });
+      const ver = db.saveVersion(doc.id, 'hello initial', 2, op);
+      expect(ver.documentId).toBe(doc.id);
+      expect(ver.version).toBe(2);
+      expect(ver.content).toBe('hello initial');
+      expect(ver.operation).toBe(op);
+    });
+
+    it('should save a version without operation', () => {
+      const doc = db.createDocument('No Op', 'initial');
+      const ver = db.saveVersion(doc.id, 'updated', 2);
+      expect(ver.operation).toBeNull();
+    });
+  });
+
+  describe('persistence', () => {
+    it('should persist data to a file-based database', async () => {
+      const fs = await import('fs');
+      const os = await import('os');
+      const path = await import('path');
+      const tmpFile = path.join(os.tmpdir(), `test-db-${Date.now()}.sqlite`);
+
+      try {
+        const db1 = new Database(tmpFile);
+        const doc = db1.createDocument('Persist', 'persistent content');
+        const docId = doc.id;
+        db1.close();
+
+        const db2 = new Database(tmpFile);
+        const fetched = db2.getDocument(docId);
+        expect(fetched).toBeDefined();
+        expect(fetched!.title).toBe('Persist');
+        expect(fetched!.content).toBe('persistent content');
+        db2.close();
+      } finally {
+        if (fs.existsSync(tmpFile)) fs.unlinkSync(tmpFile);
+      }
+    });
+  });
+});
diff --git a/tests/routes.test.ts b/tests/routes.test.ts
new file mode 100644
index 0000000..e22ad6d
--- /dev/null
+++ b/tests/routes.test.ts
@@ -0,0 +1,196 @@
+import { describe, it, expect, beforeEach, afterEach } from 'vitest';
+import express from 'express';
+import request from 'supertest';
+import { Database } from '../src/database.js';
+import { createRouter } from '../src/routes.js';
+
+describe('REST API Routes', () => {
+  let db: Database;
+  let app: express.Express;
+
+  beforeEach(() => {
+    db = new Database(':memory:');
+    app = express();
+    app.use(createRouter(db));
+  });
+
+  afterEach(() => {
+    db.close();
+  });
+
+  describe('POST /api/documents', () => {
+    it('should create a document with title and content', async () => {
+      const res = await request(app)
+        .post('/api/documents')
+        .send({ title: 'Test Doc', content: 'Hello world' });
+
+      expect(res.status).toBe(201);
+      expect(res.body.title).toBe('Test Doc');
+      expect(res.body.content).toBe('Hello world');
+      expect(res.body.id).toBeDefined();
+      expect(res.body.version).toBe(1);
+    });
+
+    it('should create a document with empty content if not provided', async () => {
+      const res = await request(app)
+        .post('/api/documents')
+        .send({ title: 'No Content Doc' });
+
+      expect(res.status).toBe(201);
+      expect(res.body.content).toBe('');
+    });
+
+    it('should return 400 if title is missing', async () => {
+      const res = await request(app)
+        .post('/api/documents')
+        .send({ content: 'no title' });
+
+      expect(res.status).toBe(400);
+    });
+
+    it('should return 400 if title is not a string', async () => {
+      const res = await request(app)
+        .post('/api/documents')
+        .send({ title: 123 });
+
+      expect(res.status).toBe(400);
+    });
+  });
+
+  describe('GET /api/documents', () => {
+    it('should return empty array when no documents exist', async () => {
+      const res = await request(app).get('/api/documents');
+      expect(res.status).toBe(200);
+      expect(res.body).toEqual([]);
+    });
+
+    it('should return all documents', async () => {
+      await request(app).post('/api/documents').send({ title: 'Doc 1', content: 'a' });
+      await request(app).post('/api/documents').send({ title: 'Doc 2', content: 'b' });
+
+      const res = await request(app).get('/api/documents');
+      expect(res.status).toBe(200);
+      expect(res.body).toHaveLength(2);
+    });
+  });
+
+  describe('GET /api/documents/:id', () => {
+    it('should return a single document', async () => {
+      const createRes = await request(app)
+        .post('/api/documents')
+        .send({ title: 'My Doc', content: 'content here' });
+
+      const id = createRes.body.id;
+      const res = await request(app).get(`/api/documents/${id}`);
+
+      expect(res.status).toBe(200);
+      expect(res.body.title).toBe('My Doc');
+      expect(res.body.content).toBe('content here');
+    });
+
+    it('should return 404 for non-existent document', async () => {
+      const res = await request(app).get('/api/documents/nonexistent-id');
+      expect(res.status).toBe(404);
+    });
+  });
+
+  describe('PUT /api/documents/:id', () => {
+    it('should update title', async () => {
+      const createRes = await request(app)
+        .post('/api/documents')
+        .send({ title: 'Old Title', content: 'content' });
+
+      const id = createRes.body.id;
+      const res = await request(app)
+        .put(`/api/documents/${id}`)
+        .send({ title: 'New Title' });
+
+      expect(res.status).toBe(200);
+      expect(res.body.title).toBe('New Title');
+      expect(res.body.content).toBe('content');
+      expect(res.body.version).toBe(2);
+    });
+
+    it('should update content', async () => {
+      const createRes = await request(app)
+        .post('/api/documents')
+        .send({ title: 'Doc', content: 'old content' });
+
+      const id = createRes.body.id;
+      const res = await request(app)
+        .put(`/api/documents/${id}`)
+        .send({ content: 'new content' });
+
+      expect(res.status).toBe(200);
+      expect(res.body.content).toBe('new content');
+    });
+
+    it('should return 404 for non-existent document', async () => {
+      const res = await request(app)
+        .put('/api/documents/nonexistent-id')
+        .send({ title: 'Nope' });
+
+      expect(res.status).toBe(404);
+    });
+
+    it('should return 400 if no fields provided', async () => {
+      const createRes = await request(app)
+        .post('/api/documents')
+        .send({ title: 'Doc' });
+
+      const id = createRes.body.id;
+      const res = await request(app)
+        .put(`/api/documents/${id}`)
+        .send({});
+
+      expect(res.status).toBe(400);
+    });
+  });
+
+  describe('DELETE /api/documents/:id', () => {
+    it('should delete a document', async () => {
+      const createRes = await request(app)
+        .post('/api/documents')
+        .send({ title: 'To Delete' });
+
+      const id = createRes.body.id;
+      const deleteRes = await request(app).delete(`/api/documents/${id}`);
+      expect(deleteRes.status).toBe(204);
+
+      const getRes = await request(app).get(`/api/documents/${id}`);
+      expect(getRes.status).toBe(404);
+    });
+
+    it('should return 404 for non-existent document', async () => {
+      const res = await request(app).delete('/api/documents/nonexistent-id');
+      expect(res.status).toBe(404);
+    });
+  });
+
+  describe('GET /api/documents/:id/history', () => {
+    it('should return version history', async () => {
+      const createRes = await request(app)
+        .post('/api/documents')
+        .send({ title: 'Versioned Doc', content: 'v1' });
+
+      const id = createRes.body.id;
+
+      await request(app).put(`/api/documents/${id}`).send({ content: 'v2' });
+      await request(app).put(`/api/documents/${id}`).send({ content: 'v3' });
+
+      const res = await request(app).get(`/api/documents/${id}/history`);
+      expect(res.status).toBe(200);
+      expect(res.body).toHaveLength(3);
+      // Most recent first
+      expect(res.body[0].version).toBe(3);
+      expect(res.body[0].content).toBe('v3');
+      expect(res.body[2].version).toBe(1);
+      expect(res.body[2].content).toBe('v1');
+    });
+
+    it('should return 404 for non-existent document', async () => {
+      const res = await request(app).get('/api/documents/nonexistent-id/history');
+      expect(res.status).toBe(404);
+    });
+  });
+});
